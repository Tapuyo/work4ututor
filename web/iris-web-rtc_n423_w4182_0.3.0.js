!function (e, t) { if ("object" == typeof exports && "object" == typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else { var n = t(); for (var i in n) ("object" == typeof exports ? exports : e)[i] = n[i] } }(self, (function () {
    return function () {
        var e = {
            5957: function (e, t, n) {
                e.exports = function () {
                    "use strict"; function e(e, t) { return t.forEach((function (t) { t && "string" != typeof t && !Array.isArray(t) && Object.keys(t).forEach((function (n) { if ("default" !== n && !(n in e)) { var i = Object.getOwnPropertyDescriptor(t, n); Object.defineProperty(e, n, i.get ? i : { enumerable: !0, get: function () { return t[n] } }) } })) })), Object.freeze(e) } var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== n.g ? n.g : "undefined" != typeof self ? self : {}, i = function (e) { try { return !!e() } catch (e) { return !0 } }, r = !i((function () { var e = function () { }.bind(); return "function" != typeof e || e.hasOwnProperty("prototype") })), o = r, s = Function.prototype, a = s.bind, c = s.call, E = o && a.bind(c, c), _ = o ? function (e) { return e && E(e) } : function (e) { return e && function () { return c.apply(e, arguments) } }, d = _({}.isPrototypeOf), u = function (e) { return e && e.Math == Math && e }, l = u("object" == typeof globalThis && globalThis) || u("object" == typeof window && window) || u("object" == typeof self && self) || u("object" == typeof t && t) || function () { return this }() || Function("return this")(), R = r, h = Function.prototype, p = h.apply, T = h.call, O = "object" == typeof Reflect && Reflect.apply || (R ? T.bind(p) : function () { return T.apply(p, arguments) }), C = function (e) { return "function" == typeof e }, A = {}, S = !i((function () { return 7 != Object.defineProperty({}, 1, { get: function () { return 7 } })[1] })), g = r, m = Function.prototype.call, I = g ? m.bind(m) : function () { return m.apply(m, arguments) }, f = {}, P = {}.propertyIsEnumerable, N = Object.getOwnPropertyDescriptor, D = N && !P.call({ 1: 2 }, 1); f.f = D ? function (e) { var t = N(this, e); return !!t && t.enumerable } : P; var v, y, L = function (e, t) { return { enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t } }, w = _, b = w({}.toString), U = w("".slice), M = function (e) { return U(b(e), 8, -1) }, k = _, V = i, x = M, F = l.Object, Y = k("".split), B = V((function () { return !F("z").propertyIsEnumerable(0) })) ? function (e) { return "String" == x(e) ? Y(e, "") : F(e) } : F, G = l.TypeError, j = function (e) { if (null == e) throw G("Can't call method on " + e); return e }, H = B, W = j, K = function (e) { return H(W(e)) }, J = C, X = function (e) { return "object" == typeof e ? null !== e : J(e) }, q = {}, Q = q, z = l, Z = C, $ = function (e) { return Z(e) ? e : void 0 }, ee = function (e, t) { return arguments.length < 2 ? $(Q[e]) || $(z[e]) : Q[e] && Q[e][t] || z[e] && z[e][t] }, te = ee("navigator", "userAgent") || "", ne = l, ie = te, re = ne.process, oe = ne.Deno, se = re && re.versions || oe && oe.version, ae = se && se.v8; ae && (y = (v = ae.split("."))[0] > 0 && v[0] < 4 ? 1 : +(v[0] + v[1])), !y && ie && (!(v = ie.match(/Edge\/(\d+)/)) || v[1] >= 74) && (v = ie.match(/Chrome\/(\d+)/)) && (y = +v[1]); var ce = y, Ee = ce, _e = i, de = !!Object.getOwnPropertySymbols && !_e((function () { var e = Symbol(); return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Ee && Ee < 41 })), ue = de && !Symbol.sham && "symbol" == typeof Symbol.iterator, le = ee, Re = C, he = d, pe = ue, Te = l.Object, Oe = pe ? function (e) { return "symbol" == typeof e } : function (e) { var t = le("Symbol"); return Re(t) && he(t.prototype, Te(e)) }, Ce = l.String, Ae = function (e) { try { return Ce(e) } catch (e) { return "Object" } }, Se = C, ge = Ae, me = l.TypeError, Ie = function (e) { if (Se(e)) return e; throw me(ge(e) + " is not a function") }, fe = Ie, Pe = function (e, t) { var n = e[t]; return null == n ? void 0 : fe(n) }, Ne = I, De = C, ve = X, ye = l.TypeError, Le = { exports: {} }, we = l, be = Object.defineProperty, Ue = function (e, t) { try { be(we, e, { value: t, configurable: !0, writable: !0 }) } catch (i) { we[e] = t } return t }, Me = "__core-js_shared__", ke = l[Me] || Ue(Me, {}), Ve = ke; (Le.exports = function (e, t) { return Ve[e] || (Ve[e] = void 0 !== t ? t : {}) })("versions", []).push({ version: "3.20.3", mode: "pure", copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE", source: "https://github.com/zloirock/core-js" }); var xe = j, Fe = l.Object, Ye = function (e) { return Fe(xe(e)) }, Be = Ye, Ge = _({}.hasOwnProperty), je = Object.hasOwn || function (e, t) { return Ge(Be(e), t) }, He = _, We = 0, Ke = Math.random(), Je = He(1..toString), Xe = function (e) { return "Symbol(" + (void 0 === e ? "" : e) + ")_" + Je(++We + Ke, 36) }, qe = l, Qe = Le.exports, ze = je, Ze = Xe, $e = de, et = ue, tt = Qe("wks"), nt = qe.Symbol, it = nt && nt.for, rt = et ? nt : nt && nt.withoutSetter || Ze, ot = function (e) { if (!ze(tt, e) || !$e && "string" != typeof tt[e]) { var t = "Symbol." + e; $e && ze(nt, e) ? tt[e] = nt[e] : tt[e] = et && it ? it(t) : rt(t) } return tt[e] }, st = I, at = X, ct = Oe, Et = Pe, _t = function (e, t) { var n, i; if ("string" === t && De(n = e.toString) && !ve(i = Ne(n, e))) return i; if (De(n = e.valueOf) && !ve(i = Ne(n, e))) return i; if ("string" !== t && De(n = e.toString) && !ve(i = Ne(n, e))) return i; throw ye("Can't convert object to primitive value") }, dt = ot, ut = l.TypeError, lt = dt("toPrimitive"), Rt = function (e, t) { if (!at(e) || ct(e)) return e; var n, i = Et(e, lt); if (i) { if (void 0 === t && (t = "default"), n = st(i, e, t), !at(n) || ct(n)) return n; throw ut("Can't convert object to primitive value") } return void 0 === t && (t = "number"), _t(e, t) }, ht = Oe, pt = function (e) { var t = Rt(e, "string"); return ht(t) ? t : t + "" }, Tt = X, Ot = l.document, Ct = Tt(Ot) && Tt(Ot.createElement), At = function (e) { return Ct ? Ot.createElement(e) : {} }, St = At, gt = !S && !i((function () { return 7 != Object.defineProperty(St("div"), "a", { get: function () { return 7 } }).a })), mt = S, It = I, ft = f, Pt = L, Nt = K, Dt = pt, vt = je, yt = gt, Lt = Object.getOwnPropertyDescriptor; A.f = mt ? Lt : function (e, t) { if (e = Nt(e), t = Dt(t), yt) try { return Lt(e, t) } catch (e) { } if (vt(e, t)) return Pt(!It(ft.f, e, t), e[t]) }; var wt = i, bt = C, Ut = /#|\.prototype\./, Mt = function (e, t) { var n = Vt[kt(e)]; return n == Ft || n != xt && (bt(t) ? wt(t) : !!t) }, kt = Mt.normalize = function (e) { return String(e).replace(Ut, ".").toLowerCase() }, Vt = Mt.data = {}, xt = Mt.NATIVE = "N", Ft = Mt.POLYFILL = "P", Yt = Mt, Bt = Ie, Gt = r, jt = _(_.bind), Ht = function (e, t) { return Bt(e), void 0 === t ? e : Gt ? jt(e, t) : function () { return e.apply(t, arguments) } }, Wt = {}, Kt = S && i((function () { return 42 != Object.defineProperty((function () { }), "prototype", { value: 42, writable: !1 }).prototype })), Jt = l, Xt = X, qt = Jt.String, Qt = Jt.TypeError, zt = function (e) { if (Xt(e)) return e; throw Qt(qt(e) + " is not an object") }, Zt = S, $t = gt, en = Kt, tn = zt, nn = pt, rn = l.TypeError, on = Object.defineProperty, sn = Object.getOwnPropertyDescriptor, an = "enumerable", cn = "configurable", En = "writable"; Wt.f = Zt ? en ? function (e, t, n) { if (tn(e), t = nn(t), tn(n), "function" == typeof e && "prototype" === t && "value" in n && En in n && !n.writable) { var i = sn(e, t); i && i.writable && (e[t] = n.value, n = { configurable: cn in n ? n.configurable : i.configurable, enumerable: an in n ? n.enumerable : i.enumerable, writable: !1 }) } return on(e, t, n) } : on : function (e, t, n) { if (tn(e), t = nn(t), tn(n), $t) try { return on(e, t, n) } catch (e) { } if ("get" in n || "set" in n) throw rn("Accessors not supported"); return "value" in n && (e[t] = n.value), e }; var _n = Wt, dn = L, un = S ? function (e, t, n) { return _n.f(e, t, dn(1, n)) } : function (e, t, n) { return e[t] = n, e }, ln = l, Rn = O, hn = _, pn = C, Tn = A.f, On = Yt, Cn = q, An = Ht, Sn = un, gn = je, mn = function (e) { var t = function (n, i, r) { if (this instanceof t) { switch (arguments.length) { case 0: return new e; case 1: return new e(n); case 2: return new e(n, i) }return new e(n, i, r) } return Rn(e, this, arguments) }; return t.prototype = e.prototype, t }, In = function (e, t) { var n, i, r, o, s, a, c, E, _ = e.target, d = e.global, u = e.stat, l = e.proto, R = d ? ln : u ? ln[_] : (ln[_] || {}).prototype, h = d ? Cn : Cn[_] || Sn(Cn, _, {})[_], p = h.prototype; for (r in t) n = !On(d ? r : _ + (u ? "." : "#") + r, e.forced) && R && gn(R, r), s = h[r], n && (a = e.noTargetGet ? (E = Tn(R, r)) && E.value : R[r]), o = n && a ? a : t[r], n && typeof s == typeof o || (c = e.bind && n ? An(o, ln) : e.wrap && n ? mn(o) : l && pn(o) ? hn(o) : o, (e.sham || o && o.sham || s && s.sham) && Sn(c, "sham", !0), Sn(h, r, c), l && (gn(Cn, i = _ + "Prototype") || Sn(Cn, i, {}), Sn(Cn[i], r, o), e.real && p && !p[r] && Sn(p, r, o))) }, fn = Math.ceil, Pn = Math.floor, Nn = function (e) { var t = +e; return t != t || 0 === t ? 0 : (t > 0 ? Pn : fn)(t) }, Dn = Nn, vn = Math.min, yn = function (e) { return e > 0 ? vn(Dn(e), 9007199254740991) : 0 }, Ln = function (e) { return yn(e.length) }, wn = Ie, bn = Ye, Un = B, Mn = Ln, kn = l.TypeError, Vn = function (e) { return function (t, n, i, r) { wn(n); var o = bn(t), s = Un(o), a = Mn(o), c = e ? a - 1 : 0, E = e ? -1 : 1; if (i < 2) for (; ;) { if (c in s) { r = s[c], c += E; break } if (c += E, e ? c < 0 : a <= c) throw kn("Reduce of empty array with no initial value") } for (; e ? c >= 0 : a > c; c += E)c in s && (r = n(r, s[c], c, o)); return r } }, xn = { left: Vn(!1), right: Vn(!0) }, Fn = i, Yn = function (e, t) { var n = [][e]; return !!n && Fn((function () { n.call(null, t || function () { throw 1 }, 1) })) }, Bn = "process" == M(l.process), Gn = xn.left, jn = ce, Hn = Bn; In({ target: "Array", proto: !0, forced: !Yn("reduce") || !Hn && jn > 79 && jn < 83 }, { reduce: function (e) { var t = arguments.length; return Gn(this, e, t, t > 1 ? arguments[1] : void 0) } }); var Wn = q, Kn = function (e) { return Wn[e + "Prototype"] }, Jn = Kn("Array").reduce, Xn = d, qn = Jn, Qn = Array.prototype, zn = function (e) { var t = e.reduce; return e === Qn || Xn(Qn, e) && t === Qn.reduce ? qn : t }, Zn = zn; let $n = !0, ei = !0; function ti(e, t, n) { const i = e.match(t); return i && i.length >= n && parseInt(i[n], 10) } function ni(e, t, n) { if (!e.RTCPeerConnection) return; const i = e.RTCPeerConnection.prototype, r = i.addEventListener; i.addEventListener = function (e, i) { if (e !== t) return r.apply(this, arguments); const o = e => { const t = n(e); t && (i.handleEvent ? i.handleEvent(t) : i(t)) }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(i, o), r.apply(this, [e, o]) }; const o = i.removeEventListener; i.removeEventListener = function (e, n) { if (e !== t || !this._eventMap || !this._eventMap[t]) return o.apply(this, arguments); if (!this._eventMap[t].has(n)) return o.apply(this, arguments); const i = this._eventMap[t].get(n); return this._eventMap[t].delete(n), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o.apply(this, [e, i]) }, Object.defineProperty(i, "on" + t, { get() { return this["_on" + t] }, set(e) { this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e) }, enumerable: !0, configurable: !0 }) } function ii(e) { return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : ($n = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") } function ri(e) { return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (ei = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) } function oi() { if ("object" == typeof window) { if ($n) return; "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments) } } function si(e, t) { ei && console.warn(e + " is deprecated, please use " + t + " instead.") } function ai(e) { const t = { browser: null, version: null }; if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t; const { navigator: n } = e; if (n.mozGetUserMedia) t.browser = "firefox", t.version = ti(n.userAgent, /Firefox\/(\d+)\./, 1); else if (n.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection) t.browser = "chrome", t.version = ti(n.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else { if (!e.RTCPeerConnection || !n.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t; t.browser = "safari", t.version = ti(n.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype } return t } function ci(e) { return "[object Object]" === Object.prototype.toString.call(e) } function Ei(e) { var t; return ci(e) ? Zn(t = Object.keys(e)).call(t, (function (t, n) { const i = ci(e[n]), r = i ? Ei(e[n]) : e[n], o = i && !Object.keys(r).length; return void 0 === r || o ? t : Object.assign(t, { [n]: r }) }), {}) : e } function _i(e, t, n) { const i = n ? "outbound-rtp" : "inbound-rtp", r = new Map; if (null === t) return r; const o = []; return e.forEach((e => { "track" === e.type && e.trackIdentifier === t.id && o.push(e) })), o.forEach((t => { e.forEach((n => { n.type === i && n.trackId === t.id && function e(t, n, i) { n && !i.has(n.id) && (i.set(n.id, n), Object.keys(n).forEach((r => { r.endsWith("Id") ? e(t, t.get(n[r]), i) : r.endsWith("Ids") && n[r].forEach((n => { e(t, t.get(n), i) })) }))) }(e, n, r) })) })), r } var di = Le.exports, ui = Xe, li = di("keys"), Ri = function (e) { return li[e] || (li[e] = ui(e)) }, hi = !i((function () { function e() { } return e.prototype.constructor = null, Object.getPrototypeOf(new e) !== e.prototype })), pi = l, Ti = je, Oi = C, Ci = Ye, Ai = hi, Si = Ri("IE_PROTO"), gi = pi.Object, mi = gi.prototype, Ii = Ai ? gi.getPrototypeOf : function (e) { var t = Ci(e); if (Ti(t, Si)) return t[Si]; var n = t.constructor; return Oi(n) && t instanceof n ? n.prototype : t instanceof gi ? mi : null }, fi = l, Pi = C, Ni = fi.String, Di = fi.TypeError, vi = _, yi = zt, Li = function (e) { if ("object" == typeof e || Pi(e)) return e; throw Di("Can't set " + Ni(e) + " as a prototype") }, wi = Object.setPrototypeOf || ("__proto__" in {} ? function () { var e, t = !1, n = {}; try { (e = vi(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n, []), t = n instanceof Array } catch (e) { } return function (n, i) { return yi(n), Li(i), t ? e(n, i) : n.__proto__ = i, n } }() : void 0), bi = {}, Ui = Nn, Mi = Math.max, ki = Math.min, Vi = function (e, t) { var n = Ui(e); return n < 0 ? Mi(n + t, 0) : ki(n, t) }, xi = K, Fi = Vi, Yi = Ln, Bi = function (e) { return function (t, n, i) { var r, o = xi(t), s = Yi(o), a = Fi(i, s); if (e && n != n) { for (; s > a;)if ((r = o[a++]) != r) return !0 } else for (; s > a; a++)if ((e || a in o) && o[a] === n) return e || a || 0; return !e && -1 } }, Gi = { includes: Bi(!0), indexOf: Bi(!1) }, ji = {}, Hi = je, Wi = K, Ki = Gi.indexOf, Ji = ji, Xi = _([].push), qi = function (e, t) { var n, i = Wi(e), r = 0, o = []; for (n in i) !Hi(Ji, n) && Hi(i, n) && Xi(o, n); for (; t.length > r;)Hi(i, n = t[r++]) && (~Ki(o, n) || Xi(o, n)); return o }, Qi = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], zi = qi, Zi = Qi.concat("length", "prototype"); bi.f = Object.getOwnPropertyNames || function (e) { return zi(e, Zi) }; var $i = {}; $i.f = Object.getOwnPropertySymbols; var er = ee, tr = bi, nr = $i, ir = zt, rr = _([].concat), or = er("Reflect", "ownKeys") || function (e) { var t = tr.f(ir(e)), n = nr.f; return n ? rr(t, n(e)) : t }, sr = je, ar = or, cr = A, Er = Wt, _r = {}, dr = qi, ur = Qi, lr = Object.keys || function (e) { return dr(e, ur) }, Rr = S, hr = Kt, pr = Wt, Tr = zt, Or = K, Cr = lr; _r.f = Rr && !hr ? Object.defineProperties : function (e, t) { Tr(e); for (var n, i = Or(t), r = Cr(t), o = r.length, s = 0; o > s;)pr.f(e, n = r[s++], i[n]); return e }; var Ar, Sr = ee("document", "documentElement"), gr = zt, mr = _r, Ir = Qi, fr = ji, Pr = Sr, Nr = At, Dr = Ri("IE_PROTO"), vr = function () { }, yr = function (e) { return "<script>" + e + "<\/script>" }, Lr = function (e) { e.write(yr("")), e.close(); var t = e.parentWindow.Object; return e = null, t }, wr = function () { try { Ar = new ActiveXObject("htmlfile") } catch (e) { } var e, t; wr = "undefined" != typeof document ? document.domain && Ar ? Lr(Ar) : ((t = Nr("iframe")).style.display = "none", Pr.appendChild(t), t.src = String("javascript:"), (e = t.contentWindow.document).open(), e.write(yr("document.F=Object")), e.close(), e.F) : Lr(Ar); for (var n = Ir.length; n--;)delete wr.prototype[Ir[n]]; return wr() }; fr[Dr] = !0; var br = Object.create || function (e, t) { var n; return null !== e ? (vr.prototype = gr(e), n = new vr, vr.prototype = null, n[Dr] = e) : n = wr(), void 0 === t ? n : mr.f(n, t) }, Ur = _("".replace), Mr = String(Error("zxcasd").stack), kr = /\n\s*at [^:]*:[^\n]*/, Vr = kr.test(Mr), xr = X, Fr = un, Yr = {}, Br = Yr, Gr = ot("iterator"), jr = Array.prototype, Hr = {}; Hr[ot("toStringTag")] = "z"; var Wr = "[object z]" === String(Hr), Kr = l, Jr = Wr, Xr = C, qr = M, Qr = ot("toStringTag"), zr = Kr.Object, Zr = "Arguments" == qr(function () { return arguments }()), $r = Jr ? qr : function (e) { var t, n, i; return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function (e, t) { try { return e[t] } catch (e) { } }(t = zr(e), Qr)) ? n : Zr ? qr(t) : "Object" == (i = qr(t)) && Xr(t.callee) ? "Arguments" : i }, eo = $r, to = Pe, no = Yr, io = ot("iterator"), ro = function (e) { if (null != e) return to(e, io) || to(e, "@@iterator") || no[eo(e)] }, oo = I, so = Ie, ao = zt, co = Ae, Eo = ro, _o = l.TypeError, uo = I, lo = zt, Ro = Pe, ho = Ht, po = I, To = zt, Oo = Ae, Co = function (e) { return void 0 !== e && (Br.Array === e || jr[Gr] === e) }, Ao = Ln, So = d, go = function (e, t) { var n = arguments.length < 2 ? Eo(e) : t; if (so(n)) return ao(oo(n, e)); throw _o(co(e) + " is not iterable") }, mo = ro, Io = function (e, t, n) { var i, r; lo(e); try { if (!(i = Ro(e, "return"))) { if ("throw" === t) throw n; return n } i = uo(i, e) } catch (e) { r = !0, i = e } if ("throw" === t) throw n; if (r) throw i; return lo(i), n }, fo = l.TypeError, Po = function (e, t) { this.stopped = e, this.result = t }, No = Po.prototype, Do = function (e, t, n) { var i, r, o, s, a, c, E, _ = n && n.that, d = !(!n || !n.AS_ENTRIES), u = !(!n || !n.IS_ITERATOR), l = !(!n || !n.INTERRUPTED), R = ho(t, _), h = function (e) { return i && Io(i, "normal", e), new Po(!0, e) }, p = function (e) { return d ? (To(e), l ? R(e[0], e[1], h) : R(e[0], e[1])) : l ? R(e, h) : R(e) }; if (u) i = e; else { if (!(r = mo(e))) throw fo(Oo(e) + " is not iterable"); if (Co(r)) { for (o = 0, s = Ao(e); s > o; o++)if ((a = p(e[o])) && So(No, a)) return a; return new Po(!1) } i = go(e, r) } for (c = i.next; !(E = po(c, i)).done;) { try { a = p(E.value) } catch (e) { Io(i, "throw", e) } if ("object" == typeof a && a && So(No, a)) return a } return new Po(!1) }, vo = $r, yo = l.String, Lo = function (e) { if ("Symbol" === vo(e)) throw TypeError("Cannot convert a Symbol value to a string"); return yo(e) }, wo = Lo, bo = L, Uo = !i((function () { var e = Error("a"); return !("stack" in e) || (Object.defineProperty(e, "stack", bo(1, 7)), 7 !== e.stack) })), Mo = In, ko = l, Vo = d, xo = Ii, Fo = wi, Yo = function (e, t, n) { for (var i = ar(t), r = Er.f, o = cr.f, s = 0; s < i.length; s++) { var a = i[s]; sr(e, a) || n && sr(n, a) || r(e, a, o(t, a)) } }, Bo = br, Go = un, jo = L, Ho = function (e, t) { if (Vr && "string" == typeof e) for (; t--;)e = Ur(e, kr, ""); return e }, Wo = function (e, t) { xr(t) && "cause" in t && Fr(e, "cause", t.cause) }, Ko = Do, Jo = function (e, t) { return void 0 === e ? arguments.length < 2 ? "" : t : wo(e) }, Xo = Uo, qo = ot("toStringTag"), Qo = ko.Error, zo = [].push, Zo = function (e, t) { var n, i = arguments.length > 2 ? arguments[2] : void 0, r = Vo($o, this); Fo ? n = Fo(new Qo, r ? xo(this) : $o) : (n = r ? this : Bo($o), Go(n, qo, "Error")), void 0 !== t && Go(n, "message", Jo(t)), Xo && Go(n, "stack", Ho(n.stack, 1)), Wo(n, i); var o = []; return Ko(e, zo, { that: o }), Go(n, "errors", o), n }; Fo ? Fo(Zo, Qo) : Yo(Zo, Qo, { name: !0 }); var $o = Zo.prototype = Bo(Qo.prototype, { constructor: jo(1, Zo), message: jo(1, ""), name: jo(1, "AggregateError") }); Mo({ global: !0 }, { AggregateError: Zo }); var es = C, ts = ke, ns = _(Function.toString); es(ts.inspectSource) || (ts.inspectSource = function (e) { return ns(e) }); var is, rs, os, ss = ts.inspectSource, as = C, cs = ss, Es = l.WeakMap, _s = as(Es) && /native code/.test(cs(Es)), ds = l, us = _, ls = X, Rs = un, hs = je, ps = ke, Ts = Ri, Os = ji, Cs = "Object already initialized", As = ds.TypeError, Ss = ds.WeakMap; if (_s || ps.state) { var gs = ps.state || (ps.state = new Ss), ms = us(gs.get), Is = us(gs.has), fs = us(gs.set); is = function (e, t) { if (Is(gs, e)) throw new As(Cs); return t.facade = e, fs(gs, e, t), t }, rs = function (e) { return ms(gs, e) || {} }, os = function (e) { return Is(gs, e) } } else { var Ps = Ts("state"); Os[Ps] = !0, is = function (e, t) { if (hs(e, Ps)) throw new As(Cs); return t.facade = e, Rs(e, Ps, t), t }, rs = function (e) { return hs(e, Ps) ? e[Ps] : {} }, os = function (e) { return hs(e, Ps) } } var Ns, Ds, vs, ys = { set: is, get: rs, has: os, enforce: function (e) { return os(e) ? rs(e) : is(e, {}) }, getterFor: function (e) { return function (t) { var n; if (!ls(t) || (n = rs(t)).type !== e) throw As("Incompatible receiver, " + e + " required"); return n } } }, Ls = S, ws = je, bs = Function.prototype, Us = Ls && Object.getOwnPropertyDescriptor, Ms = ws(bs, "name"), ks = { EXISTS: Ms, PROPER: Ms && "something" === function () { }.name, CONFIGURABLE: Ms && (!Ls || Ls && Us(bs, "name").configurable) }, Vs = un, xs = function (e, t, n, i) { i && i.enumerable ? e[t] = n : Vs(e, t, n) }, Fs = i, Ys = C, Bs = br, Gs = Ii, js = xs, Hs = ot("iterator"), Ws = !1;[].keys && ("next" in (vs = [].keys()) ? (Ds = Gs(Gs(vs))) !== Object.prototype && (Ns = Ds) : Ws = !0); var Ks = null == Ns || Fs((function () { var e = {}; return Ns[Hs].call(e) !== e })); Ys((Ns = Ks ? {} : Bs(Ns))[Hs]) || js(Ns, Hs, (function () { return this })); var Js = { IteratorPrototype: Ns, BUGGY_SAFARI_ITERATORS: Ws }, Xs = $r, qs = Wr ? {}.toString : function () { return "[object " + Xs(this) + "]" }, Qs = Wr, zs = Wt.f, Zs = un, $s = je, ea = qs, ta = ot("toStringTag"), na = function (e, t, n, i) { if (e) { var r = n ? e : e.prototype; $s(r, ta) || zs(r, ta, { configurable: !0, value: t }), i && !Qs && Zs(r, "toString", ea) } }, ia = Js.IteratorPrototype, ra = br, oa = L, sa = na, aa = Yr, ca = function () { return this }, Ea = In, _a = I, da = function (e, t, n, i) { var r = t + " Iterator"; return e.prototype = ra(ia, { next: oa(+!i, n) }), sa(e, r, !1, !0), aa[r] = ca, e }, ua = Ii, la = na, Ra = xs, ha = Yr, pa = ks.PROPER, Ta = Js.BUGGY_SAFARI_ITERATORS, Oa = ot("iterator"), Ca = "keys", Aa = "values", Sa = "entries", ga = function () { return this }, ma = function (e, t, n, i, r, o, s) { da(n, t, i); var a, c, E, _ = function (e) { if (e === r && h) return h; if (!Ta && e in l) return l[e]; switch (e) { case Ca: case Aa: case Sa: return function () { return new n(this, e) } }return function () { return new n(this) } }, d = t + " Iterator", u = !1, l = e.prototype, R = l[Oa] || l["@@iterator"] || r && l[r], h = !Ta && R || _(r), p = "Array" == t && l.entries || R; if (p && (a = ua(p.call(new e))) !== Object.prototype && a.next && (la(a, d, !0, !0), ha[d] = ga), pa && r == Aa && R && R.name !== Aa && (u = !0, h = function () { return _a(R, this) }), r) if (c = { values: _(Aa), keys: o ? h : _(Ca), entries: _(Sa) }, s) for (E in c) (Ta || u || !(E in l)) && Ra(l, E, c[E]); else Ea({ target: t, proto: !0, forced: Ta || u }, c); return s && l[Oa] !== h && Ra(l, Oa, h, { name: r }), ha[t] = h, c }, Ia = K, fa = Yr, Pa = ys; Wt.f; var Na = ma, Da = "Array Iterator", va = Pa.set, ya = Pa.getterFor(Da); Na(Array, "Array", (function (e, t) { va(this, { type: Da, target: Ia(e), index: 0, kind: t }) }), (function () { var e = ya(this), t = e.target, n = e.kind, i = e.index++; return !t || i >= t.length ? (e.target = void 0, { value: void 0, done: !0 }) : "keys" == n ? { value: i, done: !1 } : "values" == n ? { value: t[i], done: !1 } : { value: [i, t[i]], done: !1 } }), "values"), fa.Arguments = fa.Array; var La = l.Promise, wa = xs, ba = ee, Ua = Wt, Ma = S, ka = ot("species"), Va = d, xa = l.TypeError, Fa = ot("iterator"), Ya = !1; try { var Ba = 0, Ga = { next: function () { return { done: !!Ba++ } }, return: function () { Ya = !0 } }; Ga[Fa] = function () { return this }, Array.from(Ga, (function () { throw 2 })) } catch (e) { } var ja = _, Ha = i, Wa = C, Ka = $r, Ja = ss, Xa = function () { }, qa = [], Qa = ee("Reflect", "construct"), za = /^\s*(?:class|function)\b/, Za = ja(za.exec), $a = !za.exec(Xa), ec = function (e) { if (!Wa(e)) return !1; try { return Qa(Xa, qa, e), !0 } catch (e) { return !1 } }, tc = function (e) { if (!Wa(e)) return !1; switch (Ka(e)) { case "AsyncFunction": case "GeneratorFunction": case "AsyncGeneratorFunction": return !1 }try { return $a || !!Za(za, Ja(e)) } catch (e) { return !0 } }; tc.sham = !0; var nc, ic, rc, oc, sc = !Qa || Ha((function () { var e; return ec(ec.call) || !ec(Object) || !ec((function () { e = !0 })) || e })) ? tc : ec, ac = sc, cc = Ae, Ec = l.TypeError, _c = zt, dc = function (e) { if (ac(e)) return e; throw Ec(cc(e) + " is not a constructor") }, uc = ot("species"), lc = function (e, t) { var n, i = _c(e).constructor; return void 0 === i || null == (n = _c(i)[uc]) ? t : dc(n) }, Rc = _([].slice), hc = /(?:ipad|iphone|ipod).*applewebkit/i.test(te), pc = l, Tc = O, Oc = Ht, Cc = C, Ac = je, Sc = i, gc = Sr, mc = Rc, Ic = At, fc = hc, Pc = Bn, Nc = pc.setImmediate, Dc = pc.clearImmediate, vc = pc.process, yc = pc.Dispatch, Lc = pc.Function, wc = pc.MessageChannel, bc = pc.String, Uc = 0, Mc = {}, kc = "onreadystatechange"; try { nc = pc.location } catch (e) { } var Vc = function (e) { if (Ac(Mc, e)) { var t = Mc[e]; delete Mc[e], t() } }, xc = function (e) { return function () { Vc(e) } }, Fc = function (e) { Vc(e.data) }, Yc = function (e) { pc.postMessage(bc(e), nc.protocol + "//" + nc.host) }; Nc && Dc || (Nc = function (e) { var t = mc(arguments, 1); return Mc[++Uc] = function () { Tc(Cc(e) ? e : Lc(e), void 0, t) }, ic(Uc), Uc }, Dc = function (e) { delete Mc[e] }, Pc ? ic = function (e) { vc.nextTick(xc(e)) } : yc && yc.now ? ic = function (e) { yc.now(xc(e)) } : wc && !fc ? (oc = (rc = new wc).port2, rc.port1.onmessage = Fc, ic = Oc(oc.postMessage, oc)) : pc.addEventListener && Cc(pc.postMessage) && !pc.importScripts && nc && "file:" !== nc.protocol && !Sc(Yc) ? (ic = Yc, pc.addEventListener("message", Fc, !1)) : ic = kc in Ic("script") ? function (e) { gc.appendChild(Ic("script")).onreadystatechange = function () { gc.removeChild(this), Vc(e) } } : function (e) { setTimeout(xc(e), 0) }); var Bc, Gc, jc, Hc, Wc, Kc, Jc, Xc, qc = { set: Nc, clear: Dc }, Qc = l, zc = /ipad|iphone|ipod/i.test(te) && void 0 !== Qc.Pebble, Zc = /web0s(?!.*chrome)/i.test(te), $c = l, eE = Ht, tE = A.f, nE = qc.set, iE = hc, rE = zc, oE = Zc, sE = Bn, aE = $c.MutationObserver || $c.WebKitMutationObserver, cE = $c.document, EE = $c.process, _E = $c.Promise, dE = tE($c, "queueMicrotask"), uE = dE && dE.value; uE || (Bc = function () { var e, t; for (sE && (e = EE.domain) && e.exit(); Gc;) { t = Gc.fn, Gc = Gc.next; try { t() } catch (e) { throw Gc ? Hc() : jc = void 0, e } } jc = void 0, e && e.enter() }, iE || sE || oE || !aE || !cE ? !rE && _E && _E.resolve ? ((Jc = _E.resolve(void 0)).constructor = _E, Xc = eE(Jc.then, Jc), Hc = function () { Xc(Bc) }) : sE ? Hc = function () { EE.nextTick(Bc) } : (nE = eE(nE, $c), Hc = function () { nE(Bc) }) : (Wc = !0, Kc = cE.createTextNode(""), new aE(Bc).observe(Kc, { characterData: !0 }), Hc = function () { Kc.data = Wc = !Wc })); var lE = uE || function (e) { var t = { fn: e, next: void 0 }; jc && (jc.next = t), Gc || (Gc = t, Hc()), jc = t }, RE = {}, hE = Ie, pE = function (e) { var t, n; this.promise = new e((function (e, i) { if (void 0 !== t || void 0 !== n) throw TypeError("Bad Promise constructor"); t = e, n = i })), this.resolve = hE(t), this.reject = hE(n) }; RE.f = function (e) { return new pE(e) }; var TE = zt, OE = X, CE = RE, AE = function (e, t) { if (TE(e), OE(t) && t.constructor === e) return t; var n = CE.f(e); return (0, n.resolve)(t), n.promise }, SE = l, gE = function (e) { try { return { error: !1, value: e() } } catch (e) { return { error: !0, value: e } } }, mE = function () { this.head = null, this.tail = null }; mE.prototype = { add: function (e) { var t = { item: e, next: null }; this.head ? this.tail.next = t : this.head = t, this.tail = t }, get: function () { var e = this.head; if (e) return this.head = e.next, this.tail === e && (this.tail = null), e.item } }; var IE, fE, PE, NE = "object" == typeof window, DE = In, vE = l, yE = ee, LE = I, wE = La, bE = function (e, t, n) { for (var i in t) n && n.unsafe && e[i] ? e[i] = t[i] : wa(e, i, t[i], n); return e }, UE = na, ME = function (e) { var t = ba(e), n = Ua.f; Ma && t && !t[ka] && n(t, ka, { configurable: !0, get: function () { return this } }) }, kE = Ie, VE = C, xE = X, FE = function (e, t) { if (Va(t, e)) return e; throw xa("Incorrect invocation") }, YE = ss, BE = Do, GE = function (e, t) { if (!t && !Ya) return !1; var n = !1; try { var i = {}; i[Fa] = function () { return { next: function () { return { done: n = !0 } } } }, e(i) } catch (e) { } return n }, jE = lc, HE = qc.set, WE = lE, KE = AE, JE = function (e, t) { var n = SE.console; n && n.error && (1 == arguments.length ? n.error(e) : n.error(e, t)) }, XE = RE, qE = gE, QE = mE, zE = ys, ZE = Yt, $E = NE, e_ = Bn, t_ = ce, n_ = ot("species"), i_ = "Promise", r_ = zE.getterFor(i_), o_ = zE.set, s_ = zE.getterFor(i_), a_ = wE && wE.prototype, c_ = wE, E_ = a_, __ = vE.TypeError, d_ = vE.document, u_ = vE.process, l_ = XE.f, R_ = l_, h_ = !!(d_ && d_.createEvent && vE.dispatchEvent), p_ = VE(vE.PromiseRejectionEvent), T_ = "unhandledrejection", O_ = ZE(i_, (function () { var e = YE(c_), t = e !== String(c_); if (!t && 66 === t_) return !0; if (!E_.finally) return !0; if (t_ >= 51 && /native code/.test(e)) return !1; var n = new c_((function (e) { e(1) })), i = function (e) { e((function () { }), (function () { })) }; return (n.constructor = {})[n_] = i, !(n.then((function () { })) instanceof i) || !t && $E && !p_ })), C_ = O_ || !GE((function (e) { c_.all(e).catch((function () { })) })), A_ = function (e) { var t; return !(!xE(e) || !VE(t = e.then)) && t }, S_ = function (e, t) { var n, i, r, o = t.value, s = 1 == t.state, a = s ? e.ok : e.fail, c = e.resolve, E = e.reject, _ = e.domain; try { a ? (s || (2 === t.rejection && P_(t), t.rejection = 1), !0 === a ? n = o : (_ && _.enter(), n = a(o), _ && (_.exit(), r = !0)), n === e.promise ? E(__("Promise-chain cycle")) : (i = A_(n)) ? LE(i, n, c, E) : c(n)) : E(o) } catch (e) { _ && !r && _.exit(), E(e) } }, g_ = function (e, t) { e.notified || (e.notified = !0, WE((function () { for (var n, i = e.reactions; n = i.get();)S_(n, e); e.notified = !1, t && !e.rejection && I_(e) }))) }, m_ = function (e, t, n) { var i, r; h_ ? ((i = d_.createEvent("Event")).promise = t, i.reason = n, i.initEvent(e, !1, !0), vE.dispatchEvent(i)) : i = { promise: t, reason: n }, !p_ && (r = vE["on" + e]) ? r(i) : e === T_ && JE("Unhandled promise rejection", n) }, I_ = function (e) { LE(HE, vE, (function () { var t, n = e.facade, i = e.value; if (f_(e) && (t = qE((function () { e_ ? u_.emit("unhandledRejection", i, n) : m_(T_, n, i) })), e.rejection = e_ || f_(e) ? 2 : 1, t.error)) throw t.value })) }, f_ = function (e) { return 1 !== e.rejection && !e.parent }, P_ = function (e) { LE(HE, vE, (function () { var t = e.facade; e_ ? u_.emit("rejectionHandled", t) : m_("rejectionhandled", t, e.value) })) }, N_ = function (e, t, n) { return function (i) { e(t, i, n) } }, D_ = function (e, t, n) { e.done || (e.done = !0, n && (e = n), e.value = t, e.state = 2, g_(e, !0)) }, v_ = function (e, t, n) { if (!e.done) { e.done = !0, n && (e = n); try { if (e.facade === t) throw __("Promise can't be resolved itself"); var i = A_(t); i ? WE((function () { var n = { done: !1 }; try { LE(i, t, N_(v_, n, e), N_(D_, n, e)) } catch (t) { D_(n, t, e) } })) : (e.value = t, e.state = 1, g_(e, !1)) } catch (t) { D_({ done: !1 }, t, e) } } }; O_ && (E_ = (c_ = function (e) { FE(this, E_), kE(e), LE(IE, this); var t = r_(this); try { e(N_(v_, t), N_(D_, t)) } catch (e) { D_(t, e) } }).prototype, (IE = function (e) { o_(this, { type: i_, done: !1, notified: !1, parent: !1, reactions: new QE, rejection: !1, state: 0, value: void 0 }) }).prototype = bE(E_, { then: function (e, t) { var n = s_(this), i = l_(jE(this, c_)); return n.parent = !0, i.ok = !VE(e) || e, i.fail = VE(t) && t, i.domain = e_ ? u_.domain : void 0, 0 == n.state ? n.reactions.add(i) : WE((function () { S_(i, n) })), i.promise }, catch: function (e) { return this.then(void 0, e) } }), fE = function () { var e = new IE, t = r_(e); this.promise = e, this.resolve = N_(v_, t), this.reject = N_(D_, t) }, XE.f = l_ = function (e) { return e === c_ || e === PE ? new fE(e) : R_(e) }), DE({ global: !0, wrap: !0, forced: O_ }, { Promise: c_ }), UE(c_, i_, !1, !0), ME(i_), PE = yE(i_), DE({ target: i_, stat: !0, forced: O_ }, { reject: function (e) { var t = l_(this); return LE(t.reject, void 0, e), t.promise } }), DE({ target: i_, stat: !0, forced: !0 }, { resolve: function (e) { return KE(this === PE ? c_ : this, e) } }), DE({ target: i_, stat: !0, forced: C_ }, { all: function (e) { var t = this, n = l_(t), i = n.resolve, r = n.reject, o = qE((function () { var n = kE(t.resolve), o = [], s = 0, a = 1; BE(e, (function (e) { var c = s++, E = !1; a++, LE(n, t, e).then((function (e) { E || (E = !0, o[c] = e, --a || i(o)) }), r) })), --a || i(o) })); return o.error && r(o.value), n.promise }, race: function (e) { var t = this, n = l_(t), i = n.reject, r = qE((function () { var r = kE(t.resolve); BE(e, (function (e) { LE(r, t, e).then(n.resolve, i) })) })); return r.error && i(r.value), n.promise } }); var y_ = I, L_ = Ie, w_ = RE, b_ = gE, U_ = Do; In({ target: "Promise", stat: !0 }, { allSettled: function (e) { var t = this, n = w_.f(t), i = n.resolve, r = n.reject, o = b_((function () { var n = L_(t.resolve), r = [], o = 0, s = 1; U_(e, (function (e) { var a = o++, c = !1; s++, y_(n, t, e).then((function (e) { c || (c = !0, r[a] = { status: "fulfilled", value: e }, --s || i(r)) }), (function (e) { c || (c = !0, r[a] = { status: "rejected", reason: e }, --s || i(r)) })) })), --s || i(r) })); return o.error && r(o.value), n.promise } }); var M_ = Ie, k_ = ee, V_ = I, x_ = RE, F_ = gE, Y_ = Do, B_ = "No one promise resolved"; In({ target: "Promise", stat: !0 }, { any: function (e) { var t = this, n = k_("AggregateError"), i = x_.f(t), r = i.resolve, o = i.reject, s = F_((function () { var i = M_(t.resolve), s = [], a = 0, c = 1, E = !1; Y_(e, (function (e) { var _ = a++, d = !1; c++, V_(i, t, e).then((function (e) { d || E || (E = !0, r(e)) }), (function (e) { d || E || (d = !0, s[_] = e, --c || o(new n(s, B_))) })) })), --c || o(new n(s, B_)) })); return s.error && o(s.value), i.promise } }); var G_ = La, j_ = ee, H_ = C, W_ = lc, K_ = AE; In({ target: "Promise", proto: !0, real: !0, forced: !!G_ && i((function () { G_.prototype.finally.call({ then: function () { } }, (function () { })) })) }, { finally: function (e) { var t = W_(this, j_("Promise")), n = H_(e); return this.then(n ? function (n) { return K_(t, e()).then((function () { return n })) } : e, n ? function (n) { return K_(t, e()).then((function () { throw n })) } : e) } }); var J_ = _, X_ = Nn, q_ = Lo, Q_ = j, z_ = J_("".charAt), Z_ = J_("".charCodeAt), $_ = J_("".slice), ed = function (e) { return function (t, n) { var i, r, o = q_(Q_(t)), s = X_(n), a = o.length; return s < 0 || s >= a ? e ? "" : void 0 : (i = Z_(o, s)) < 55296 || i > 56319 || s + 1 === a || (r = Z_(o, s + 1)) < 56320 || r > 57343 ? e ? z_(o, s) : i : e ? $_(o, s, s + 2) : r - 56320 + (i - 55296 << 10) + 65536 } }, td = (ed(!1), ed(!0)), nd = Lo, id = ys, rd = ma, od = "String Iterator", sd = id.set, ad = id.getterFor(od); rd(String, "String", (function (e) { sd(this, { type: od, string: nd(e), index: 0 }) }), (function () { var e, t = ad(this), n = t.string, i = t.index; return i >= n.length ? { value: void 0, done: !0 } : (e = td(n, i), t.index += e.length, { value: e, done: !1 }) })); var cd = q.Promise, Ed = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, _d = l, dd = $r, ud = un, ld = Yr, Rd = ot("toStringTag"); for (var hd in Ed) { var pd = _d[hd], Td = pd && pd.prototype; Td && dd(Td) !== Rd && ud(Td, Rd, hd), ld[hd] = ld.Array } var Od = cd, Cd = Od; const Ad = oi; function Sd(e, t) { const n = e && e.navigator; if (!n.mediaDevices) return; const i = function (e) { if ("object" != typeof e || e.mandatory || e.optional) return e; const t = {}; return Object.keys(e).forEach((n => { if ("require" === n || "advanced" === n || "mediaSource" === n) return; const i = "object" == typeof e[n] ? e[n] : { ideal: e[n] }; void 0 !== i.exact && "number" == typeof i.exact && (i.min = i.max = i.exact); const r = function (e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t }; if (void 0 !== i.ideal) { t.optional = t.optional || []; let e = {}; "number" == typeof i.ideal ? (e[r("min", n)] = i.ideal, t.optional.push(e), e = {}, e[r("max", n)] = i.ideal, t.optional.push(e)) : (e[r("", n)] = i.ideal, t.optional.push(e)) } void 0 !== i.exact && "number" != typeof i.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[r("", n)] = i.exact) : ["min", "max"].forEach((e => { void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[r(e, n)] = i[e]) })) })), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t }, r = function (e, r) { if (t.version >= 61) return r(e); if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) { const t = function (e, t, n) { t in e && !(n in e) && (e[n] = e[t], delete e[t]) }; t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = i(e.audio) } if (e && "object" == typeof e.video) { let o = e.video.facingMode; o = o && ("object" == typeof o ? o : { ideal: o }); const s = t.version < 66; if (o && ("user" === o.exact || "environment" === o.exact || "user" === o.ideal || "environment" === o.ideal) && (!n.mediaDevices.getSupportedConstraints || !n.mediaDevices.getSupportedConstraints().facingMode || s)) { let t; if (delete e.video.facingMode, "environment" === o.exact || "environment" === o.ideal ? t = ["back", "rear"] : "user" !== o.exact && "user" !== o.ideal || (t = ["front"]), t) return n.mediaDevices.enumerateDevices().then((n => { let s = (n = n.filter((e => "videoinput" === e.kind))).find((e => t.some((t => e.label.toLowerCase().includes(t))))); return !s && n.length && t.includes("back") && (s = n[n.length - 1]), s && (e.video.deviceId = o.exact ? { exact: s.deviceId } : { ideal: s.deviceId }), e.video = i(e.video), Ad("chrome: " + JSON.stringify(e)), r(e) })) } e.video = i(e.video) } return Ad("chrome: " + JSON.stringify(e)), r(e) }, o = function (e) { return t.version >= 64 ? e : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e.name] || e.name, message: e.message, constraint: e.constraint || e.constraintName, toString() { return this.name + (this.message && ": ") + this.message } } }; if (n.getUserMedia = function (e, t, i) { r(e, (e => { n.webkitGetUserMedia(e, t, (e => { i && i(o(e)) })) })) }.bind(n), n.mediaDevices.getUserMedia) { const e = n.mediaDevices.getUserMedia.bind(n.mediaDevices); n.mediaDevices.getUserMedia = function (t) { return r(t, (t => e(t).then((e => { if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach((e => { e.stop() })), new DOMException("", "NotFoundError"); return e }), (e => Cd.reject(o(e)))))) } } } function gd(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream } function md(e) { if ("object" == typeof e && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get() { return this._ontrack }, set(e) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e) }, enumerable: !0, configurable: !0 }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { return this._ontrackpoly || (this._ontrackpoly = t => { t.stream.addEventListener("addtrack", (n => { let i; i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === n.track.id)) : { track: n.track }; const r = new Event("track"); r.track = n.track, r.receiver = i, r.transceiver = { receiver: i }, r.streams = [t.stream], this.dispatchEvent(r) })), t.stream.getTracks().forEach((n => { let i; i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === n.id)) : { track: n }; const r = new Event("track"); r.track = n, r.receiver = i, r.transceiver = { receiver: i }, r.streams = [t.stream], this.dispatchEvent(r) })) }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments) } } else ni(e, "track", (e => (e.transceiver || Object.defineProperty(e, "transceiver", { value: { receiver: e.receiver } }), e))) } function Id(e) { if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) { const t = function (e, t) { return { track: t, get dtmf() { return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf }, _pc: e } }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; const n = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, i) { let r = n.apply(this, arguments); return r || (r = t(this, e), this._senders.push(r)), r }; const i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { i.apply(this, arguments); const t = this._senders.indexOf(e); -1 !== t && this._senders.splice(t, 1) } } const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach((e => { this._senders.push(t(this, e)) })) }; const i = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { this._senders = this._senders || [], i.apply(this, [e]), e.getTracks().forEach((e => { const t = this._senders.find((t => t.track === e)); t && this._senders.splice(this._senders.indexOf(t), 1) })) } } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { const e = t.apply(this, []); return e.forEach((e => e._pc = this)), e }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } } function fd(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [e, n, i] = arguments; if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments); if (0 === t.length && (0 === arguments.length || "function" != typeof e)) return t.apply(this, []); const r = function (e) { const t = {}; return e.result().forEach((e => { const n = { id: e.id, timestamp: e.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e.type] || e.type }; e.names().forEach((t => { n[t] = e.stat(t) })), t[n.id] = n })), t }, o = function (e) { return new Map(Object.keys(e).map((t => [t, e[t]]))) }; if (arguments.length >= 2) { const i = function (e) { n(o(r(e))) }; return t.apply(this, [i, e]) } return new Cd(((e, n) => { t.apply(this, [function (t) { e(o(r(t))) }, n]) })).then(n, i) } } function Pd(e) { if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return; if (!("getStats" in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const e = t.apply(this, []); return e.forEach((e => e._pc = this)), e }); const n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { const e = n.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { const e = this; return this._pc.getStats().then((t => _i(t, e.track, !0))) } } if (!("getStats" in e.RTCRtpReceiver.prototype)) { const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const e = t.apply(this, []); return e.forEach((e => e._pc = this)), e }), ni(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function () { const e = this; return this._pc.getStats().then((t => _i(t, e.track, !1))) } } if (!("getStats" in e.RTCRtpSender.prototype) || !("getStats" in e.RTCRtpReceiver.prototype)) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { const e = arguments[0]; let t, n, i; return this.getSenders().forEach((n => { n.track === e && (t ? i = !0 : t = n) })), this.getReceivers().forEach((t => (t.track === e && (n ? i = !0 : n = t), t.track === e))), i || t && n ? Cd.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t ? t.getStats() : n ? n.getStats() : Cd.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return t.apply(this, arguments) } } function Nd(e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e => this._shimmedLocalStreams[e][0])) }; const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, n) { if (!n) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; const i = t.apply(this, arguments); return this._shimmedLocalStreams[n.id] ? -1 === this._shimmedLocalStreams[n.id].indexOf(i) && this._shimmedLocalStreams[n.id].push(i) : this._shimmedLocalStreams[n.id] = [n, i], i }; const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach((e => { if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError") })); const t = this.getSenders(); n.apply(this, arguments); const i = this.getSenders().filter((e => -1 === t.indexOf(e))); this._shimmedLocalStreams[e.id] = [e].concat(i) }; const i = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], i.apply(this, arguments) }; const r = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach((t => { const n = this._shimmedLocalStreams[t].indexOf(e); -1 !== n && this._shimmedLocalStreams[t].splice(n, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t] })), r.apply(this, arguments) } } function Dd(e, t) { if (!e.RTCPeerConnection) return; if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return Nd(e); const n = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { const e = n.apply(this); return this._reverseStreams = this._reverseStreams || {}, e.map((e => this._reverseStreams[e.id])) }; const i = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (t) { if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach((e => { if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError") })), !this._reverseStreams[t.id]) { const n = new e.MediaStream(t.getTracks()); this._streams[t.id] = n, this._reverseStreams[n.id] = t, t = n } i.apply(this, [t]) }; const r = e.RTCPeerConnection.prototype.removeStream; function o(e, t) { let n = t.sdp; return Object.keys(e._reverseStreams || []).forEach((t => { const i = e._reverseStreams[t], r = e._streams[i.id]; n = n.replace(new RegExp(r.id, "g"), i.id) })), new RTCSessionDescription({ type: t.type, sdp: n }) } function s(e, t) { let n = t.sdp; return Object.keys(e._reverseStreams || []).forEach((t => { const i = e._reverseStreams[t], r = e._streams[i.id]; n = n.replace(new RegExp(i.id, "g"), r.id) })), new RTCSessionDescription({ type: t.type, sdp: n }) } e.RTCPeerConnection.prototype.removeStream = function (e) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id] }, e.RTCPeerConnection.prototype.addTrack = function (t, n) { if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); const i = [].slice.call(arguments, 1); if (1 !== i.length || !i[0].getTracks().find((e => e === t))) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); const r = this.getSenders().find((e => e.track === t)); if (r) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; const o = this._streams[n.id]; if (o) o.addTrack(t), Cd.resolve().then((() => { this.dispatchEvent(new Event("negotiationneeded")) })); else { const i = new e.MediaStream([t]); this._streams[n.id] = i, this._reverseStreams[i.id] = n, this.addStream(i) } return this.getSenders().find((e => e.track === t)) }, ["createOffer", "createAnswer"].forEach((function (t) { const n = e.RTCPeerConnection.prototype[t], i = { [t]() { const e = arguments; return arguments.length && "function" == typeof arguments[0] ? n.apply(this, [t => { const n = o(this, t); e[0].apply(null, [n]) }, t => { e[1] && e[1].apply(null, t) }, arguments[2]]) : n.apply(this, arguments).then((e => o(this, e))) } }; e.RTCPeerConnection.prototype[t] = i[t] })); const a = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return arguments.length && arguments[0].type ? (arguments[0] = s(this, arguments[0]), a.apply(this, arguments)) : a.apply(this, arguments) }; const c = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get() { const e = c.get.apply(this); return "" === e.type ? e : o(this, e) } }), e.RTCPeerConnection.prototype.removeTrack = function (e) { if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); let t; this._streams = this._streams || {}, Object.keys(this._streams).forEach((n => { this._streams[n].getTracks().find((t => e.track === t)) && (t = this._streams[n]) })), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function vd(e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function (t) { const n = e.RTCPeerConnection.prototype[t], i = { [t]() { return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } }; e.RTCPeerConnection.prototype[t] = i[t] })) } function yd(e, t) { ni(e, "negotiationneeded", (e => { const n = e.target; if (!(t.version < 72 || n.getConfiguration && "plan-b" === n.getConfiguration().sdpSemantics) || "stable" === n.signalingState) return e })) } var Ld = Object.freeze({ __proto__: null, shimMediaStream: gd, shimOnTrack: md, shimGetSendersWithDtmf: Id, shimGetStats: fd, shimSenderReceiverGetStats: Pd, shimAddTrackRemoveTrackWithNative: Nd, shimAddTrackRemoveTrack: Dd, shimPeerConnection: vd, fixNegotiationNeeded: yd, shimGetUserMedia: Sd, shimGetDisplayMedia: function (e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function (n) { return t(n).then((t => { const i = n.video && n.video.width, r = n.video && n.video.height, o = n.video && n.video.frameRate; return n.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t, maxFrameRate: o || 3 } }, i && (n.video.mandatory.maxWidth = i), r && (n.video.mandatory.maxHeight = r), e.navigator.mediaDevices.getUserMedia(n) })) } : console.error("shimGetDisplayMedia: getSourceId argument is not a function")) } }); function wd(e, t) { const n = e && e.navigator, i = e && e.MediaStreamTrack; if (n.getUserMedia = function (e, t, i) { si("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), n.mediaDevices.getUserMedia(e).then(t, i) }, !(t.version > 55 && "autoGainControl" in n.mediaDevices.getSupportedConstraints())) { const e = function (e, t, n) { t in e && !(n in e) && (e[n] = e[t], delete e[t]) }, t = n.mediaDevices.getUserMedia.bind(n.mediaDevices); if (n.mediaDevices.getUserMedia = function (n) { return "object" == typeof n && "object" == typeof n.audio && (n = JSON.parse(JSON.stringify(n)), e(n.audio, "autoGainControl", "mozAutoGainControl"), e(n.audio, "noiseSuppression", "mozNoiseSuppression")), t(n) }, i && i.prototype.getSettings) { const t = i.prototype.getSettings; i.prototype.getSettings = function () { const n = t.apply(this, arguments); return e(n, "mozAutoGainControl", "autoGainControl"), e(n, "mozNoiseSuppression", "noiseSuppression"), n } } if (i && i.prototype.applyConstraints) { const t = i.prototype.applyConstraints; i.prototype.applyConstraints = function (n) { return "audio" === this.kind && "object" == typeof n && (n = JSON.parse(JSON.stringify(n)), e(n, "autoGainControl", "mozAutoGainControl"), e(n, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [n]) } } } } function bd(e) { "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function Ud(e, t) { if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return; !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function (t) { const n = e.RTCPeerConnection.prototype[t], i = { [t]() { return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } }; e.RTCPeerConnection.prototype[t] = i[t] })); const n = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, i = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [e, r, o] = arguments; return i.apply(this, [e || null]).then((e => { if (t.version < 53 && !r) try { e.forEach((e => { e.type = n[e.type] || e.type })) } catch (t) { if ("TypeError" !== t.name) throw t; e.forEach(((t, i) => { e.set(i, Object.assign({}, t, { type: n[t.type] || t.type })) })) } return e })).then(r, o) } } function Md(e) { if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return; if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return; const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const e = t.apply(this, []); return e.forEach((e => e._pc = this)), e }); const n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { const e = n.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Cd.resolve(new Map) } } function kd(e) { if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return; if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return; const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const e = t.apply(this, []); return e.forEach((e => e._pc = this)), e }), ni(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } function Vd(e) { e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function (e) { si("removeStream", "removeTrack"), this.getSenders().forEach((t => { t.track && e.getTracks().includes(t.track) && this.removeTrack(t) })) }) } function xd(e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel) } function Fd(e) { if ("object" != typeof e || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; let e = arguments[1] && arguments[1].sendEncodings; void 0 === e && (e = []), e = [...e]; const n = e.length > 0; n && e.forEach((e => { if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0") })); const i = t.apply(this, arguments); if (n) { const { sender: t } = i, n = t.getParameters(); (!("encodings" in n) || 1 === n.encodings.length && 0 === Object.keys(n.encodings[0]).length) && (n.encodings = e, t.sendEncodings = e, this.setParametersPromises.push(t.setParameters(n).then((() => { delete t.sendEncodings })).catch((() => { delete t.sendEncodings })))) } return i }) } function Yd(e) { if ("object" != typeof e || !e.RTCRtpSender) return; const t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { const e = t.apply(this, arguments); return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e }) } function Bd(e) { if ("object" != typeof e || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Cd.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => { this.setParametersPromises = [] })) : t.apply(this, arguments) } } function Gd(e) { if ("object" != typeof e || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Cd.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => { this.setParametersPromises = [] })) : t.apply(this, arguments) } } var jd = Object.freeze({ __proto__: null, shimOnTrack: bd, shimPeerConnection: Ud, shimSenderGetStats: Md, shimReceiverGetStats: kd, shimRemoveStream: Vd, shimRTCDataChannel: xd, shimAddTransceiver: Fd, shimGetParameters: Yd, shimCreateOffer: Bd, shimCreateAnswer: Gd, shimGetUserMedia: wd, shimGetDisplayMedia: function (e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function (n) { if (!n || !n.video) { const e = new DOMException("getDisplayMedia without video constraints is undefined"); return e.name = "NotFoundError", e.code = 8, Cd.reject(e) } return !0 === n.video ? n.video = { mediaSource: t } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n) }) } }); function Hd(e) { if ("object" == typeof e && e.RTCPeerConnection) { if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in e.RTCPeerConnection.prototype)) { const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (e) { this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach((n => t.call(this, n, e))), e.getVideoTracks().forEach((n => t.call(this, n, e))) }, e.RTCPeerConnection.prototype.addTrack = function (e) { for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++)i[r - 1] = arguments[r]; return i && i.forEach((e => { this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e] })), t.apply(this, arguments) } } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) { this._localStreams || (this._localStreams = []); const t = this._localStreams.indexOf(e); if (-1 === t) return; this._localStreams.splice(t, 1); const n = e.getTracks(); this.getSenders().forEach((e => { n.includes(e.track) && this.removeTrack(e) })) }) } } function Wd(e) { if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get() { return this._onaddstream }, set(e) { this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = e => { e.streams.forEach((e => { if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return; this._remoteStreams.push(e); const t = new Event("addstream"); t.stream = e, this.dispatchEvent(t) })) }) } }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const e = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (t) { t.streams.forEach((t => { if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return; e._remoteStreams.push(t); const n = new Event("addstream"); n.stream = t, e.dispatchEvent(n) })) }), t.apply(e, arguments) } } } function Kd(e) { if ("object" != typeof e || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype, n = t.createOffer, i = t.createAnswer, r = t.setLocalDescription, o = t.setRemoteDescription, s = t.addIceCandidate; t.createOffer = function (e, t) { const i = arguments.length >= 2 ? arguments[2] : arguments[0], r = n.apply(this, [i]); return t ? (r.then(e, t), Cd.resolve()) : r }, t.createAnswer = function (e, t) { const n = arguments.length >= 2 ? arguments[2] : arguments[0], r = i.apply(this, [n]); return t ? (r.then(e, t), Cd.resolve()) : r }; let a = function (e, t, n) { const i = r.apply(this, [e]); return n ? (i.then(t, n), Cd.resolve()) : i }; t.setLocalDescription = a, a = function (e, t, n) { const i = o.apply(this, [e]); return n ? (i.then(t, n), Cd.resolve()) : i }, t.setRemoteDescription = a, a = function (e, t, n) { const i = s.apply(this, [e]); return n ? (i.then(t, n), Cd.resolve()) : i }, t.addIceCandidate = a } function Jd(e) { const t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { const e = t.mediaDevices, n = e.getUserMedia.bind(e); t.mediaDevices.getUserMedia = e => n(Xd(e)) } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, n, i) { t.mediaDevices.getUserMedia(e).then(n, i) }.bind(t)) } function Xd(e) { return e && void 0 !== e.video ? Object.assign({}, e, { video: Ei(e.video) }) : e } function qd(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection; e.RTCPeerConnection = function (e, n) { if (e && e.iceServers) { const t = []; for (let n = 0; n < e.iceServers.length; n++) { let i = e.iceServers[n]; !i.hasOwnProperty("urls") && i.hasOwnProperty("url") ? (si("RTCIceServer.url", "RTCIceServer.urls"), i = JSON.parse(JSON.stringify(i)), i.urls = i.url, delete i.url, t.push(i)) : t.push(e.iceServers[n]) } e.iceServers = t } return new t(e, n) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get: () => t.generateCertificate }) } function Qd(e) { "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function zd(e) { const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (e) { if (e) { void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio); const t = this.getTransceivers().find((e => "audio" === e.receiver.track.kind)); !1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo); const n = this.getTransceivers().find((e => "video" === e.receiver.track.kind)); !1 === e.offerToReceiveVideo && n ? "sendrecv" === n.direction ? n.setDirection ? n.setDirection("sendonly") : n.direction = "sendonly" : "recvonly" === n.direction && (n.setDirection ? n.setDirection("inactive") : n.direction = "inactive") : !0 !== e.offerToReceiveVideo || n || this.addTransceiver("video", { direction: "recvonly" }) } return t.apply(this, arguments) } } function Zd(e) { "object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext) } var $d = Object.freeze({ __proto__: null, shimLocalStreamsAPI: Hd, shimRemoteStreamsAPI: Wd, shimCallbacksAPI: Kd, shimGetUserMedia: Jd, shimConstraints: Xd, shimRTCIceServerUrls: qd, shimTrackEventTransceiver: Qd, shimCreateOfferLegacy: zd, shimAudioContext: Zd }), eu = "\t\n\v\f\r Â áš€â€€â€â€‚â€ƒâ€„â€…â€†â€‡â€ˆâ€‰â€Šâ€¯âŸã€€\u2028\u2029\ufeff", tu = j, nu = Lo, iu = _("".replace), ru = "[\t\n\v\f\r Â áš€â€€â€â€‚â€ƒâ€„â€…â€†â€‡â€ˆâ€‰â€Šâ€¯âŸã€€\u2028\u2029\ufeff]", ou = RegExp("^" + ru + ru + "*"), su = RegExp(ru + ru + "*$"), au = function (e) { return function (t) { var n = nu(tu(t)); return 1 & e && (n = iu(n, ou, "")), 2 & e && (n = iu(n, su, "")), n } }, cu = { start: au(1), end: au(2), trim: au(3) }, Eu = ks.PROPER, _u = i, du = eu, uu = cu.trim; In({ target: "String", proto: !0, forced: function (e) { return _u((function () { return !!du[e]() || "â€‹Â…á Ž" !== "â€‹Â…á Ž"[e]() || Eu && du[e].name !== e })) }("trim") }, { trim: function () { return uu(this) } }); var lu = Kn("String").trim, Ru = d, hu = lu, pu = String.prototype, Tu = function (e) { var t = e.trim; return "string" == typeof e || e === pu || Ru(pu, e) && t === pu.trim ? hu : t }, Ou = { exports: {} }; !function (e) { const t = { generateIdentifier: function () { return Math.random().toString(36).substr(2, 10) } }; t.localCName = t.generateIdentifier(), t.splitLines = function (e) { return Tu(e).call(e).split("\n").map((e => Tu(e).call(e))) }, t.splitSections = function (e) { return e.split("\nm=").map(((e, t) => { var n; return Tu(n = t > 0 ? "m=" + e : e).call(n) + "\r\n" })) }, t.getDescription = function (e) { const n = t.splitSections(e); return n && n[0] }, t.getMediaSections = function (e) { const n = t.splitSections(e); return n.shift(), n }, t.matchPrefix = function (e, n) { return t.splitLines(e).filter((e => 0 === e.indexOf(n))) }, t.parseCandidate = function (e) { let t; t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" "); const n = { foundation: t[0], component: { 1: "rtp", 2: "rtcp" }[t[1]] || t[1], protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], address: t[4], port: parseInt(t[5], 10), type: t[7] }; for (let i = 8; i < t.length; i += 2)switch (t[i]) { case "raddr": n.relatedAddress = t[i + 1]; break; case "rport": n.relatedPort = parseInt(t[i + 1], 10); break; case "tcptype": n.tcpType = t[i + 1]; break; case "ufrag": n.ufrag = t[i + 1], n.usernameFragment = t[i + 1]; break; default: void 0 === n[t[i]] && (n[t[i]] = t[i + 1]) }return n }, t.writeCandidate = function (e) { const t = []; t.push(e.foundation); const n = e.component; "rtp" === n ? t.push(1) : "rtcp" === n ? t.push(2) : t.push(n), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port); const i = e.type; return t.push("typ"), t.push(i), "host" !== i && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ") }, t.parseIceOptions = function (e) { return e.substr(14).split(" ") }, t.parseRtpMap = function (e) { let t = e.substr(9).split(" "); const n = { payloadType: parseInt(t.shift(), 10) }; return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.channels = 3 === t.length ? parseInt(t[2], 10) : 1, n.numChannels = n.channels, n }, t.writeRtpMap = function (e) { let t = e.payloadType; void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType); const n = e.channels || e.numChannels || 1; return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== n ? "/" + n : "") + "\r\n" }, t.parseExtmap = function (e) { const t = e.substr(9).split(" "); return { id: parseInt(t[0], 10), direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv", uri: t[1] } }, t.writeExtmap = function (e) { return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n" }, t.parseFmtp = function (e) { const t = {}; let n; const i = e.substr(e.indexOf(" ") + 1).split(";"); for (let s = 0; s < i.length; s++) { var r, o; n = Tu(r = i[s]).call(r).split("="), t[Tu(o = n[0]).call(o)] = n[1] } return t }, t.writeFmtp = function (e) { let t = "", n = e.payloadType; if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) { const i = []; Object.keys(e.parameters).forEach((t => { void 0 !== e.parameters[t] ? i.push(t + "=" + e.parameters[t]) : i.push(t) })), t += "a=fmtp:" + n + " " + i.join(";") + "\r\n" } return t }, t.parseRtcpFb = function (e) { const t = e.substr(e.indexOf(" ") + 1).split(" "); return { type: t.shift(), parameter: t.join(" ") } }, t.writeRtcpFb = function (e) { let t = "", n = e.payloadType; return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((e => { t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n" })), t }, t.parseSsrcMedia = function (e) { const t = e.indexOf(" "), n = { ssrc: parseInt(e.substr(7, t - 7), 10) }, i = e.indexOf(":", t); return i > -1 ? (n.attribute = e.substr(t + 1, i - t - 1), n.value = e.substr(i + 1)) : n.attribute = e.substr(t + 1), n }, t.parseSsrcGroup = function (e) { const t = e.substr(13).split(" "); return { semantics: t.shift(), ssrcs: t.map((e => parseInt(e, 10))) } }, t.getMid = function (e) { const n = t.matchPrefix(e, "a=mid:")[0]; if (n) return n.substr(6) }, t.parseFingerprint = function (e) { const t = e.substr(14).split(" "); return { algorithm: t[0].toLowerCase(), value: t[1].toUpperCase() } }, t.getDtlsParameters = function (e, n) { return { role: "auto", fingerprints: t.matchPrefix(e + n, "a=fingerprint:").map(t.parseFingerprint) } }, t.writeDtlsParameters = function (e, t) { let n = "a=setup:" + t + "\r\n"; return e.fingerprints.forEach((e => { n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n" })), n }, t.parseCryptoLine = function (e) { const t = e.substr(9).split(" "); return { tag: parseInt(t[0], 10), cryptoSuite: t[1], keyParams: t[2], sessionParams: t.slice(3) } }, t.writeCryptoLine = function (e) { return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n" }, t.parseCryptoKeyParams = function (e) { if (0 !== e.indexOf("inline:")) return null; const t = e.substr(7).split("|"); return { keyMethod: "inline", keySalt: t[0], lifeTime: t[1], mkiValue: t[2] ? t[2].split(":")[0] : void 0, mkiLength: t[2] ? t[2].split(":")[1] : void 0 } }, t.writeCryptoKeyParams = function (e) { return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "") }, t.getCryptoParameters = function (e, n) { return t.matchPrefix(e + n, "a=crypto:").map(t.parseCryptoLine) }, t.getIceParameters = function (e, n) { const i = t.matchPrefix(e + n, "a=ice-ufrag:")[0], r = t.matchPrefix(e + n, "a=ice-pwd:")[0]; return i && r ? { usernameFragment: i.substr(12), password: r.substr(10) } : null }, t.writeIceParameters = function (e) { let t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n"; return e.iceLite && (t += "a=ice-lite\r\n"), t }, t.parseRtpParameters = function (e) { const n = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, i = t.splitLines(e)[0].split(" "); for (let r = 3; r < i.length; r++) { const o = i[r], s = t.matchPrefix(e, "a=rtpmap:" + o + " ")[0]; if (s) { const i = t.parseRtpMap(s), r = t.matchPrefix(e, "a=fmtp:" + o + " "); switch (i.parameters = r.length ? t.parseFmtp(r[0]) : {}, i.rtcpFeedback = t.matchPrefix(e, "a=rtcp-fb:" + o + " ").map(t.parseRtcpFb), n.codecs.push(i), i.name.toUpperCase()) { case "RED": case "ULPFEC": n.fecMechanisms.push(i.name.toUpperCase()) } } } return t.matchPrefix(e, "a=extmap:").forEach((e => { n.headerExtensions.push(t.parseExtmap(e)) })), n }, t.writeRtpDescription = function (e, n) { let i = ""; i += "m=" + e + " ", i += n.codecs.length > 0 ? "9" : "0", i += " UDP/TLS/RTP/SAVPF ", i += n.codecs.map((e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType)).join(" ") + "\r\n", i += "c=IN IP4 0.0.0.0\r\n", i += "a=rtcp:9 IN IP4 0.0.0.0\r\n", n.codecs.forEach((e => { i += t.writeRtpMap(e), i += t.writeFmtp(e), i += t.writeRtcpFb(e) })); let r = 0; return n.codecs.forEach((e => { e.maxptime > r && (r = e.maxptime) })), r > 0 && (i += "a=maxptime:" + r + "\r\n"), n.headerExtensions && n.headerExtensions.forEach((e => { i += t.writeExtmap(e) })), i }, t.parseRtpEncodingParameters = function (e) { const n = [], i = t.parseRtpParameters(e), r = -1 !== i.fecMechanisms.indexOf("RED"), o = -1 !== i.fecMechanisms.indexOf("ULPFEC"), s = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute)), a = s.length > 0 && s[0].ssrc; let c; const E = t.matchPrefix(e, "a=ssrc-group:FID").map((e => e.substr(17).split(" ").map((e => parseInt(e, 10))))); E.length > 0 && E[0].length > 1 && E[0][0] === a && (c = E[0][1]), i.codecs.forEach((e => { if ("RTX" === e.name.toUpperCase() && e.parameters.apt) { let t = { ssrc: a, codecPayloadType: parseInt(e.parameters.apt, 10) }; a && c && (t.rtx = { ssrc: c }), n.push(t), r && (t = JSON.parse(JSON.stringify(t)), t.fec = { ssrc: a, mechanism: o ? "red+ulpfec" : "red" }, n.push(t)) } })), 0 === n.length && a && n.push({ ssrc: a }); let _ = t.matchPrefix(e, "b="); return _.length && (_ = 0 === _[0].indexOf("b=TIAS:") ? parseInt(_[0].substr(7), 10) : 0 === _[0].indexOf("b=AS:") ? 1e3 * parseInt(_[0].substr(5), 10) * .95 - 16e3 : void 0, n.forEach((e => { e.maxBitrate = _ }))), n }, t.parseRtcpParameters = function (e) { const n = {}, i = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute))[0]; i && (n.cname = i.value, n.ssrc = i.ssrc); const r = t.matchPrefix(e, "a=rtcp-rsize"); n.reducedSize = r.length > 0, n.compound = 0 === r.length; const o = t.matchPrefix(e, "a=rtcp-mux"); return n.mux = o.length > 0, n }, t.writeRtcpParameters = function (e) { let t = ""; return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t }, t.parseMsid = function (e) { let n; const i = t.matchPrefix(e, "a=msid:"); if (1 === i.length) return n = i[0].substr(7).split(" "), { stream: n[0], track: n[1] }; const r = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "msid" === e.attribute)); return r.length > 0 ? (n = r[0].value.split(" "), { stream: n[0], track: n[1] }) : void 0 }, t.parseSctpDescription = function (e) { const n = t.parseMLine(e), i = t.matchPrefix(e, "a=max-message-size:"); let r; i.length > 0 && (r = parseInt(i[0].substr(19), 10)), isNaN(r) && (r = 65536); const o = t.matchPrefix(e, "a=sctp-port:"); if (o.length > 0) return { port: parseInt(o[0].substr(12), 10), protocol: n.fmt, maxMessageSize: r }; const s = t.matchPrefix(e, "a=sctpmap:"); if (s.length > 0) { const e = s[0].substr(10).split(" "); return { port: parseInt(e[0], 10), protocol: e[1], maxMessageSize: r } } }, t.writeSctpDescription = function (e, t) { let n = []; return n = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && n.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), n.join("") }, t.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, t.writeSessionBoilerplate = function (e, n, i) { let r; const o = void 0 !== n ? n : 2; return r = e || t.generateSessionId(), "v=0\r\no=" + (i || "thisisadapterortc") + " " + r + " " + o + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n" }, t.getDirection = function (e, n) { const i = t.splitLines(e); for (let t = 0; t < i.length; t++)switch (i[t]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return i[t].substr(2) }return n ? t.getDirection(n) : "sendrecv" }, t.getKind = function (e) { return t.splitLines(e)[0].split(" ")[0].substr(2) }, t.isRejected = function (e) { return "0" === e.split(" ", 2)[1] }, t.parseMLine = function (e) { const n = t.splitLines(e)[0].substr(2).split(" "); return { kind: n[0], port: parseInt(n[1], 10), protocol: n[2], fmt: n.slice(3).join(" ") } }, t.parseOLine = function (e) { const n = t.matchPrefix(e, "o=")[0].substr(2).split(" "); return { username: n[0], sessionId: n[1], sessionVersion: parseInt(n[2], 10), netType: n[3], addressType: n[4], address: n[5] } }, t.isValidSDP = function (e) { if ("string" != typeof e || 0 === e.length) return !1; const n = t.splitLines(e); for (let t = 0; t < n.length; t++)if (n[t].length < 2 || "=" !== n[t].charAt(1)) return !1; return !0 }, e.exports = t }(Ou); var Cu = Ou.exports, Au = Object.freeze(e({ __proto__: null, default: Cu }, [Ou.exports])); function Su(e) { if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return; const t = e.RTCIceCandidate; e.RTCIceCandidate = function (e) { if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) { const n = new t(e), i = Cu.parseCandidate(e.candidate), r = Object.assign(n, i); return r.toJSON = function () { return { candidate: r.candidate, sdpMid: r.sdpMid, sdpMLineIndex: r.sdpMLineIndex, usernameFragment: r.usernameFragment } }, r } return new t(e) }, e.RTCIceCandidate.prototype = t.prototype, ni(e, "icecandidate", (t => (t.candidate && Object.defineProperty(t, "candidate", { value: new e.RTCIceCandidate(t.candidate), writable: "false" }), t))) } function gu(e) { !e.RTCIceCandidate || e.RTCIceCandidate && "relayProtocol" in e.RTCIceCandidate.prototype || ni(e, "icecandidate", (e => { if (e.candidate) { const t = Cu.parseCandidate(e.candidate.candidate); "relay" === t.type && (e.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t.priority >> 24]) } return e })) } function mu(e, t) { if (!e.RTCPeerConnection) return; "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get() { return void 0 === this._sctp ? null : this._sctp } }); const n = function (e) { if (!e || !e.sdp) return !1; const t = Cu.splitSections(e.sdp); return t.shift(), t.some((e => { const t = Cu.parseMLine(e); return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP") })) }, i = function (e) { const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (null === t || t.length < 2) return -1; const n = parseInt(t[1], 10); return n != n ? -1 : n }, r = function (e) { let n = 65536; return "firefox" === t.browser && (n = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), n }, o = function (e, n) { let i = 65536; "firefox" === t.browser && 57 === t.version && (i = 65535); const r = Cu.matchPrefix(e.sdp, "a=max-message-size:"); return r.length > 0 ? i = parseInt(r[0].substr(19), 10) : "firefox" === t.browser && -1 !== n && (i = 2147483637), i }, s = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, "chrome" === t.browser && t.version >= 76) { const { sdpSemantics: e } = this.getConfiguration(); "plan-b" === e && Object.defineProperty(this, "sctp", { get() { return void 0 === this._sctp ? null : this._sctp }, enumerable: !0, configurable: !0 }) } if (n(arguments[0])) { const e = i(arguments[0]), t = r(e), n = o(arguments[0], e); let s; s = 0 === t && 0 === n ? Number.POSITIVE_INFINITY : 0 === t || 0 === n ? Math.max(t, n) : Math.min(t, n); const a = {}; Object.defineProperty(a, "maxMessageSize", { get: () => s }), this._sctp = a } return s.apply(this, arguments) } } function Iu(e) { if (!e.RTCPeerConnection || !("createDataChannel" in e.RTCPeerConnection.prototype)) return; function t(e, t) { const n = e.send; e.send = function () { const i = arguments[0], r = i.length || i.size || i.byteLength; if ("open" === e.readyState && t.sctp && r > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)"); return n.apply(e, arguments) } } const n = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { const e = n.apply(this, arguments); return t(e, this), e }, ni(e, "datachannel", (e => (t(e.channel, e.target), e))) } function fu(e) { if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return; const t = e.RTCPeerConnection.prototype; Object.defineProperty(t, "connectionState", { get() { return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, "onconnectionstatechange", { get() { return this._onconnectionstatechange || null }, set(e) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach((e => { const n = t[e]; t[e] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => { const t = e.target; if (t._lastConnectionState !== t.connectionState) { t._lastConnectionState = t.connectionState; const n = new Event("connectionstatechange", e); t.dispatchEvent(n) } return e }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments) } })) } function Pu(e, t) { if (!e.RTCPeerConnection) return; if ("chrome" === t.browser && t.version >= 71) return; if ("safari" === t.browser && t.version >= 605) return; const n = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (t) { if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) { const n = t.sdp.split("\n").filter((e => "a=extmap-allow-mixed" !== Tu(e).call(e))).join("\n"); e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: t.type, sdp: n }) : t.sdp = n } return n.apply(this, arguments) } } function Nu(e, t) { if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return; const n = e.RTCPeerConnection.prototype.addIceCandidate; n && 0 !== n.length && (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Cd.resolve() : n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Cd.resolve()) }) } function Du(e, t) { if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return; const n = e.RTCPeerConnection.prototype.setLocalDescription; n && 0 !== n.length && (e.RTCPeerConnection.prototype.setLocalDescription = function () { let e = arguments[0] || {}; if ("object" != typeof e || e.type && e.sdp) return n.apply(this, arguments); if (e = { type: e.type, sdp: e.sdp }, !e.type) switch (this.signalingState) { case "stable": case "have-local-offer": case "have-remote-pranswer": e.type = "offer"; break; default: e.type = "answer" }return e.sdp || "offer" !== e.type && "answer" !== e.type ? n.apply(this, [e]) : ("offer" === e.type ? this.createOffer : this.createAnswer).apply(this).then((e => n.apply(this, [e]))) }) } var vu = Object.freeze({ __proto__: null, shimRTCIceCandidate: Su, shimRTCIceCandidateRelayProtocol: gu, shimMaxMessageSize: mu, shimSendThrowTypeError: Iu, shimConnectionState: fu, removeExtmapAllowMixed: Pu, shimAddIceCandidateNullOrEmpty: Nu, shimParameterlessSetLocalDescription: Du }); let yu, Lu; !function () { let { window: e } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: !0, shimFirefox: !0, shimSafari: !0 }; const n = oi, i = ai(e), r = { browserDetails: i, commonShim: vu, extractVersion: ti, disableLog: ii, disableWarnings: ri, sdp: Au }; switch (i.browser) { case "chrome": if (!Ld || !vd || !t.shimChrome) return n("Chrome shim is not included in this adapter release."), r; if (null === i.version) return n("Chrome shim can not determine version, not shimming."), r; n("adapter.js shimming chrome."), r.browserShim = Ld, Nu(e, i), Du(e), Sd(e, i), gd(e), vd(e, i), md(e), Dd(e, i), Id(e), fd(e), Pd(e), yd(e, i), Su(e), gu(e), fu(e), mu(e, i), Iu(e), Pu(e, i); break; case "firefox": if (!jd || !Ud || !t.shimFirefox) return n("Firefox shim is not included in this adapter release."), r; n("adapter.js shimming firefox."), r.browserShim = jd, Nu(e, i), Du(e), wd(e, i), Ud(e, i), bd(e), Vd(e), Md(e), kd(e), xd(e), Fd(e), Yd(e), Bd(e), Gd(e), Su(e), fu(e), mu(e, i), Iu(e); break; case "safari": if (!$d || !t.shimSafari) return n("Safari shim is not included in this adapter release."), r; n("adapter.js shimming safari."), r.browserShim = $d, Nu(e, i), Du(e), qd(e), zd(e), Kd(e), Hd(e), Wd(e), Qd(e), Jd(e), Zd(e), Su(e), gu(e), mu(e, i), Iu(e), Pu(e, i); break; default: n("Unsupported browser!") } }({ window: "undefined" == typeof window ? void 0 : window }), function (e) { e.WIN_10 = "Windows 10", e.WIN_81 = "Windows 8.1", e.WIN_8 = "Windows 8", e.WIN_7 = "Windows 7", e.WIN_VISTA = "Windows Vista", e.WIN_SERVER_2003 = "Windows Server 2003", e.WIN_XP = "Windows XP", e.WIN_2000 = "Windows 2000", e.ANDROID = "Android", e.HARMONY_OS = "HarmonyOS", e.OPEN_BSD = "Open BSD", e.SUN_OS = "Sun OS", e.LINUX = "Linux", e.IOS = "iOS", e.MAC_OS = "Mac OS", e.QNX = "QNX", e.UNIX = "UNIX", e.BEOS = "BeOS", e.OS_2 = "OS/2", e.SEARCH_BOT = "Search Bot" }(yu || (yu = {})), function (e) { e.CHROME = "Chrome", e.SAFARI = "Safari", e.EDGE = "Edge", e.FIREFOX = "Firefox", e.OPERA = "OPR", e.QQ = "QQBrowser", e.WECHAT = "MicroMessenger" }(Lu || (Lu = {})); var wu = { exports: {} }; !function (e, n) { !function (t, i) { var r = "function", o = "undefined", s = "object", a = "string", c = "major", E = "model", _ = "name", d = "type", u = "vendor", l = "version", R = "architecture", h = "console", p = "mobile", T = "tablet", O = "smarttv", C = "wearable", A = "embedded", S = "Amazon", g = "Apple", m = "ASUS", I = "BlackBerry", f = "Google", P = "Huawei", N = "LG", D = "Microsoft", v = "Motorola", y = "Samsung", L = "Sharp", w = "Sony", b = "Xiaomi", U = "Zebra", M = "Facebook", k = "Chromium OS", V = "Mac OS", x = function (e) { for (var t = {}, n = 0; n < e.length; n++)t[e[n].toUpperCase()] = e[n]; return t }, F = function (e, t) { return typeof e === a && -1 !== Y(t).indexOf(Y(e)) }, Y = function (e) { return e.toLowerCase() }, B = function (e, t) { if (typeof e === a) return e = e.replace(/^\s\s*/, ""), typeof t === o ? e : e.substring(0, 350) }, G = function (e, t) { for (var n, o, a, c, E, _, d = 0; d < t.length && !E;) { var u = t[d], l = t[d + 1]; for (n = o = 0; n < u.length && !E && u[n];)if (E = u[n++].exec(e)) for (a = 0; a < l.length; a++)_ = E[++o], typeof (c = l[a]) === s && c.length > 0 ? 2 === c.length ? typeof c[1] == r ? this[c[0]] = c[1].call(this, _) : this[c[0]] = c[1] : 3 === c.length ? typeof c[1] !== r || c[1].exec && c[1].test ? this[c[0]] = _ ? _.replace(c[1], c[2]) : i : this[c[0]] = _ ? c[1].call(this, _, c[2]) : i : 4 === c.length && (this[c[0]] = _ ? c[3].call(this, _.replace(c[1], c[2])) : i) : this[c] = _ || i; d += 2 } }, j = function (e, t) { for (var n in t) if (typeof t[n] === s && t[n].length > 0) { for (var r = 0; r < t[n].length; r++)if (F(t[n][r], e)) return "?" === n ? i : n } else if (F(t[n], e)) return "?" === n ? i : n; return e }, H = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, W = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [l, [_, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [l, [_, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [_, l], [/opios[\/ ]+([\w\.]+)/i], [l, [_, "Opera Mini"]], [/\bopr\/([\w\.]+)/i], [l, [_, "Opera"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [_, l], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [l, [_, "UCBrowser"]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [l, [_, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [l, [_, "WeChat"]], [/konqueror\/([\w\.]+)/i], [l, [_, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [l, [_, "IE"]], [/yabrowser\/([\w\.]+)/i], [l, [_, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[_, /(.+)/, "$1 Secure Browser"], l], [/\bfocus\/([\w\.]+)/i], [l, [_, "Firefox Focus"]], [/\bopt\/([\w\.]+)/i], [l, [_, "Opera Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [l, [_, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [l, [_, "Dolphin"]], [/coast\/([\w\.]+)/i], [l, [_, "Opera Coast"]], [/miuibrowser\/([\w\.]+)/i], [l, [_, "MIUI Browser"]], [/fxios\/([-\w\.]+)/i], [l, [_, "Firefox"]], [/\bqihu|(qi?ho?o?|360)browser/i], [[_, "360 Browser"]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[_, /(.+)/, "$1 Browser"], l], [/(comodo_dragon)\/([\w\.]+)/i], [[_, /_/g, " "], l], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [_, l], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [_], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[_, M], l], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [_, l], [/\bgsa\/([\w\.]+) .*safari\//i], [l, [_, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [l, [_, "Chrome Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[_, "Chrome WebView"], l], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [l, [_, "Android Browser"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [_, l], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [l, [_, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [l, _], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [_, [l, j, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [_, l], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[_, "Netscape"], l], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [l, [_, "Firefox Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [_, l], [/(cobalt)\/([\w\.]+)/i], [_, [l, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[R, "amd64"]], [/(ia32(?=;))/i], [[R, Y]], [/((?:i[346]|x)86)[;\)]/i], [[R, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[R, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[R, "armhf"]], [/windows (ce|mobile); ppc;/i], [[R, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[R, /ower/, "", Y]], [/(sun4\w)[;\)]/i], [[R, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[R, Y]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [E, [u, y], [d, T]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [E, [u, y], [d, p]], [/\((ip(?:hone|od)[\w ]*);/i], [E, [u, g], [d, p]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [E, [u, g], [d, T]], [/(macintosh);/i], [E, [u, g]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [E, [u, L], [d, p]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [E, [u, P], [d, T]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [E, [u, P], [d, p]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[E, /_/g, " "], [u, b], [d, p]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[E, /_/g, " "], [u, b], [d, T]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [E, [u, "OPPO"], [d, p]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [E, [u, "Vivo"], [d, p]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [E, [u, "Realme"], [d, p]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [E, [u, v], [d, p]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [E, [u, v], [d, T]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [E, [u, N], [d, T]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [E, [u, N], [d, p]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [E, [u, "Lenovo"], [d, T]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[E, /_/g, " "], [u, "Nokia"], [d, p]], [/(pixel c)\b/i], [E, [u, f], [d, T]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [E, [u, f], [d, p]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [E, [u, w], [d, p]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[E, "Xperia Tablet"], [u, w], [d, T]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [E, [u, "OnePlus"], [d, p]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [E, [u, S], [d, T]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[E, /(.+)/g, "Fire Phone $1"], [u, S], [d, p]], [/(playbook);[-\w\),; ]+(rim)/i], [E, u, [d, T]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [E, [u, I], [d, p]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [E, [u, m], [d, T]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [E, [u, m], [d, p]], [/(nexus 9)/i], [E, [u, "HTC"], [d, T]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [u, [E, /_/g, " "], [d, p]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [E, [u, "Acer"], [d, T]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [E, [u, "Meizu"], [d, p]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [u, E, [d, p]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [u, E, [d, T]], [/(surface duo)/i], [E, [u, D], [d, T]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [E, [u, "Fairphone"], [d, p]], [/(u304aa)/i], [E, [u, "AT&T"], [d, p]], [/\bsie-(\w*)/i], [E, [u, "Siemens"], [d, p]], [/\b(rct\w+) b/i], [E, [u, "RCA"], [d, T]], [/\b(venue[\d ]{2,7}) b/i], [E, [u, "Dell"], [d, T]], [/\b(q(?:mv|ta)\w+) b/i], [E, [u, "Verizon"], [d, T]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [E, [u, "Barnes & Noble"], [d, T]], [/\b(tm\d{3}\w+) b/i], [E, [u, "NuVision"], [d, T]], [/\b(k88) b/i], [E, [u, "ZTE"], [d, T]], [/\b(nx\d{3}j) b/i], [E, [u, "ZTE"], [d, p]], [/\b(gen\d{3}) b.+49h/i], [E, [u, "Swiss"], [d, p]], [/\b(zur\d{3}) b/i], [E, [u, "Swiss"], [d, T]], [/\b((zeki)?tb.*\b) b/i], [E, [u, "Zeki"], [d, T]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[u, "Dragon Touch"], E, [d, T]], [/\b(ns-?\w{0,9}) b/i], [E, [u, "Insignia"], [d, T]], [/\b((nxa|next)-?\w{0,9}) b/i], [E, [u, "NextBook"], [d, T]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[u, "Voice"], E, [d, p]], [/\b(lvtel\-)?(v1[12]) b/i], [[u, "LvTel"], E, [d, p]], [/\b(ph-1) /i], [E, [u, "Essential"], [d, p]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [E, [u, "Envizen"], [d, T]], [/\b(trio[-\w\. ]+) b/i], [E, [u, "MachSpeed"], [d, T]], [/\btu_(1491) b/i], [E, [u, "Rotor"], [d, T]], [/(shield[\w ]+) b/i], [E, [u, "Nvidia"], [d, T]], [/(sprint) (\w+)/i], [u, E, [d, p]], [/(kin\.[onetw]{3})/i], [[E, /\./g, " "], [u, D], [d, p]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [E, [u, U], [d, T]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [E, [u, U], [d, p]], [/smart-tv.+(samsung)/i], [u, [d, O]], [/hbbtv.+maple;(\d+)/i], [[E, /^/, "SmartTV"], [u, y], [d, O]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[u, N], [d, O]], [/(apple) ?tv/i], [u, [E, "Apple TV"], [d, O]], [/crkey/i], [[E, "Chromecast"], [u, f], [d, O]], [/droid.+aft(\w)( bui|\))/i], [E, [u, S], [d, O]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [E, [u, L], [d, O]], [/(bravia[\w ]+)( bui|\))/i], [E, [u, w], [d, O]], [/(mitv-\w{5}) bui/i], [E, [u, b], [d, O]], [/Hbbtv.*(technisat) (.*);/i], [u, E, [d, O]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[u, B], [E, B], [d, O]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[d, O]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [u, E, [d, h]], [/droid.+; (shield) bui/i], [E, [u, "Nvidia"], [d, h]], [/(playstation [345portablevi]+)/i], [E, [u, w], [d, h]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [E, [u, D], [d, h]], [/((pebble))app/i], [u, E, [d, C]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [E, [u, g], [d, C]], [/droid.+; (glass) \d/i], [E, [u, f], [d, C]], [/droid.+; (wt63?0{2,3})\)/i], [E, [u, U], [d, C]], [/(quest( 2| pro)?)/i], [E, [u, M], [d, C]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [u, [d, A]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [E, [d, p]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [E, [d, T]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[d, T]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[d, p]], [/(android[-\w\. ]{0,9});.+buil/i], [E, [u, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [l, [_, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [l, [_, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [_, l], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [l, _]], os: [[/microsoft (windows) (vista|xp)/i], [_, l], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [_, [l, j, H]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[_, "Windows"], [l, j, H]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[l, /_/g, "."], [_, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[_, V], [l, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [l, _], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [_, l], [/\(bb(10);/i], [l, [_, I]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [l, [_, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [l, [_, "Firefox OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [l, [_, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [l, [_, "watchOS"]], [/crkey\/([\d\.]+)/i], [l, [_, "Chromecast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[_, k], l], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [_, l], [/(sunos) ?([\w\.\d]*)/i], [[_, "Solaris"], l], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [_, l]] }, K = function (e, n) { if (typeof e === s && (n = e, e = i), !(this instanceof K)) return new K(e, n).getResult(); var c = typeof t !== o && t.navigator ? t.navigator : i, E = e || (c && c.userAgent ? c.userAgent : ""), _ = c && c.userAgentData ? c.userAgentData : i, d = n ? function (e, t) { var n = {}; for (var i in e) t[i] && t[i].length % 2 == 0 ? n[i] = t[i].concat(e[i]) : n[i] = e[i]; return n }(W, n) : W; return this.getBrowser = function () { var e = {}; return e.name = i, e.version = i, G.call(e, E, d.browser), e.major = function (e) { return typeof e === a ? e.replace(/[^\d\.]/g, "").split(".")[0] : i }(e.version), c && c.brave && typeof c.brave.isBrave == r && (e.name = "Brave"), e }, this.getCPU = function () { var e = {}; return e.architecture = i, G.call(e, E, d.cpu), e }, this.getDevice = function () { var e = {}; return e.vendor = i, e.model = i, e.type = i, G.call(e, E, d.device), !e.type && _ && _.mobile && (e.type = p), "Macintosh" == e.model && c && typeof c.standalone !== o && c.maxTouchPoints && c.maxTouchPoints > 2 && (e.model = "iPad", e.type = T), e }, this.getEngine = function () { var e = {}; return e.name = i, e.version = i, G.call(e, E, d.engine), e }, this.getOS = function () { var e = {}; return e.name = i, e.version = i, G.call(e, E, d.os), !e.name && _ && "Unknown" != _.platform && (e.name = _.platform.replace(/chrome os/i, k).replace(/macos/i, V)), e }, this.getResult = function () { return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() } }, this.getUA = function () { return E }, this.setUA = function (e) { return E = typeof e === a && e.length > 350 ? B(e, 350) : e, this }, this.setUA(E), this }; K.VERSION = "0.7.34", K.BROWSER = x([_, l, c]), K.CPU = x([R]), K.DEVICE = x([E, u, d, h, p, O, T, C, A]), K.ENGINE = K.OS = x([_, l]), e.exports && (n = e.exports = K), n.UAParser = K; var J = typeof t !== o && (t.jQuery || t.Zepto); if (J && !J.ua) { var X = new K; J.ua = X.getResult(), J.ua.get = function () { return X.getUA() }, J.ua.set = function (e) { X.setUA(e); var t = X.getResult(); for (var n in t) J.ua[n] = t[n] } } }("object" == typeof window ? window : t) }(wu, wu.exports); const bu = new (0, wu.exports); let Uu, Mu, ku = bu.getResult(), Vu = null; function xu(e) { if (!Vu) { e && bu.setUA(e), ku = bu.getResult(); const t = function (e) { if ("Blink" === e.engine.name && "WeChat" !== e.browser.name) return Lu.CHROME; switch (e.browser.name) { case "Chrome Headless": case "Chrome": case "Chromium": return Lu.CHROME; case "Safari": case "Mobile Safari": return Lu.SAFARI; case "Edge": return Lu.EDGE; case "Firefox": return Lu.FIREFOX; case "QQBrowser": return Lu.QQ; case "Opera": return Lu.OPERA; case "WeChat": return Lu.WECHAT; default: return e.browser.name || "" } }(ku), n = function (e) { let t; return t = "Blink" === e.engine.name ? e.engine.version || "" : e.browser.version || "", t.split(".")[0] }(ku), i = function (e) { return "Windows" === e.os.name ? e.os.version ? e.os.name + " " + e.os.version : e.os.name : e.os.name || "" }(ku), r = ku.os.version; if (!(t && n && i && r)) return { name: t, version: n, os: i, osVersion: r }; Vu = { name: t, version: n, os: i, osVersion: r } } return Vu } function Fu() { return xu().os } function Yu() { const e = xu(); return "".concat(e.os, " ").concat(e.osVersion) } function Bu() { const e = xu(); return !!("WebKit" === ku.engine.name && e.os === yu.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e.name !== Lu.SAFARI || Ju() && e.name !== Lu.SAFARI) } function Gu() { const e = xu(); if (Bu()) { if (e.os === yu.MAC_OS) return !0; if (e.os === yu.IOS) { const e = ku.os.version && ku.os.version.split("."); if (e && 14 === Number(e[0]) && e[1] && Number(e[1]) >= 3) return !0; if (e && Number(e[0]) > 14) return !0 } } return !1 } function ju() { return "WebKit" === ku.engine.name } function Hu() { return xu().name === Lu.CHROME } function Wu() { return xu().name === Lu.SAFARI } function Ku() { return xu().name === Lu.FIREFOX } function Ju() { return xu().os === yu.IOS } function Xu(e) { const t = xu(); return !(t.name !== Lu.CHROME || !t.osVersion) && Number(t.version) >= e } function qu(e) { const t = xu(); return !(t.name !== Lu.EDGE || !t.osVersion) && Number(t.version) >= e } function Qu(e) { const t = xu(); return !(t.name !== Lu.OPERA || !t.osVersion) && Number(t.version) >= e } function zu() { const e = xu(); return !(e.name !== Lu.CHROME || !e.osVersion) && Number(e.version) <= 90 } function Zu() { const e = xu(); if (e.os !== yu.IOS || !e.osVersion) return !1; const t = e.osVersion.split("."); return Number(t[0]) < 14 || 14 === Number(t[0]) && Number(t[1]) <= 6 } function $u() { const e = xu(); if (e.os !== yu.IOS || !e.osVersion) return !1; const t = e.osVersion.split("."); return 15 === Number(t[0]) } function el() { const e = xu(); if (e.os !== yu.IOS || !e.osVersion) return !1; const t = e.osVersion.split("."); return 16 === Number(t[0]) } function tl() { const e = xu(); if (e.os !== yu.IOS || !e.osVersion) return !1; const t = e.osVersion.split("."); return 15 === Number(t[0]) && Number(t[1]) >= 1 } function nl() { return Wu() && navigator.maxTouchPoints > 0 } function il() { return xu().name === Lu.WECHAT } function rl() { return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35 } function ol() { const e = xu(); return e.name !== Lu.EDGE && e.name !== Lu.SAFARI && !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i) } function sl() { return Fu() === yu.ANDROID } function al() { const e = xu(); return sl() && (e.name === Lu.CHROME || e.name === Lu.WECHAT || /chrome|chromium/i.test(navigator.userAgent)) } !function (e) { e.L1T1 = "L1T1", e.L1T2 = "L1T2", e.L1T3 = "L1T3", e.L2T1_KEY = "L2T1_KEY", e.L2T2_KEY = "L2T2_KEY", e.L2T3_KEY = "L2T3_KEY", e.L3T1_KEY = "L3T1_KEY", e.L3T2_KEY = "L3T2_KEY", e.L3T3_KEY = "L3T3_KEY" }(Uu || (Uu = {})), function (e) { e.CERTIFICATE = "certificate", e.CODEC = "codec", e.CANDIDATE_PAIR = "candidate-pair", e.LOCAL_CANDIDATE = "local-candidate", e.REMOTE_CANDIDATE = "remote-candidate", e.INBOUND = "inbound-rtp", e.TRACK = "track", e.OUTBOUND = "outbound-rtp", e.PC = "peer-connection", e.REMOTE_INBOUND = "remote-inbound-rtp", e.REMOTE_OUTBOUND = "remote-outbound-rtp", e.TRANSPORT = "transport", e.CSRC = "csrc", e.DATA_CHANNEL = "data-channel", e.STREAM = "stream", e.SENDER = "sender", e.RECEIVER = "receiver" }(Mu || (Mu = {})); var cl = { exports: {} }, El = In, _l = S, dl = Wt.f; El({ target: "Object", stat: !0, forced: Object.defineProperty !== dl, sham: !_l }, { defineProperty: dl }); var ul = q.Object, ll = cl.exports = function (e, t, n) { return ul.defineProperty(e, t, n) }; ul.defineProperty.sham && (ll.sham = !0); var Rl = cl.exports; function hl(e, t, n) { return t in e ? Rl(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } var pl, Tl = { exports: {} }, Ol = function (e, t) { return function () { for (var n = new Array(arguments.length), i = 0; i < n.length; i++)n[i] = arguments[i]; return e.apply(t, n) } }, Cl = Ol, Al = Object.prototype.toString, Sl = (pl = Object.create(null), function (e) { var t = Al.call(e); return pl[t] || (pl[t] = t.slice(8, -1).toLowerCase()) }); function gl(e) { return e = e.toLowerCase(), function (t) { return Sl(t) === e } } function ml(e) { return Array.isArray(e) } function Il(e) { return void 0 === e } var fl = gl("ArrayBuffer"); function Pl(e) { return null !== e && "object" == typeof e } function Nl(e) { if ("object" !== Sl(e)) return !1; var t = Object.getPrototypeOf(e); return null === t || t === Object.prototype } var Dl = gl("Date"), vl = gl("File"), yl = gl("Blob"), Ll = gl("FileList"); function wl(e) { return "[object Function]" === Al.call(e) } var bl = gl("URLSearchParams"); function Ul(e, t) { if (null != e) if ("object" != typeof e && (e = [e]), ml(e)) for (var n = 0, i = e.length; n < i; n++)t.call(null, e[n], n, e); else for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.call(null, e[r], r, e) } var Ml, kl = (Ml = "undefined" != typeof Uint8Array && Object.getPrototypeOf(Uint8Array), function (e) { return Ml && e instanceof Ml }), Vl = { isArray: ml, isArrayBuffer: fl, isBuffer: function (e) { return null !== e && !Il(e) && null !== e.constructor && !Il(e.constructor) && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e) }, isFormData: function (e) { var t = "[object FormData]"; return e && ("function" == typeof FormData && e instanceof FormData || Al.call(e) === t || wl(e.toString) && e.toString() === t) }, isArrayBufferView: function (e) { return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && fl(e.buffer) }, isString: function (e) { return "string" == typeof e }, isNumber: function (e) { return "number" == typeof e }, isObject: Pl, isPlainObject: Nl, isUndefined: Il, isDate: Dl, isFile: vl, isBlob: yl, isFunction: wl, isStream: function (e) { return Pl(e) && wl(e.pipe) }, isURLSearchParams: bl, isStandardBrowserEnv: function () { return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && "undefined" != typeof window && "undefined" != typeof document }, forEach: Ul, merge: function e() { var t = {}; function n(n, i) { Nl(t[i]) && Nl(n) ? t[i] = e(t[i], n) : Nl(n) ? t[i] = e({}, n) : ml(n) ? t[i] = n.slice() : t[i] = n } for (var i = 0, r = arguments.length; i < r; i++)Ul(arguments[i], n); return t }, extend: function (e, t, n) { return Ul(t, (function (t, i) { e[i] = n && "function" == typeof t ? Cl(t, n) : t })), e }, trim: function (e) { return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "") }, stripBOM: function (e) { return 65279 === e.charCodeAt(0) && (e = e.slice(1)), e }, inherits: function (e, t, n, i) { e.prototype = Object.create(t.prototype, i), e.prototype.constructor = e, n && Object.assign(e.prototype, n) }, toFlatObject: function (e, t, n) { var i, r, o, s = {}; t = t || {}; do { for (r = (i = Object.getOwnPropertyNames(e)).length; r-- > 0;)s[o = i[r]] || (t[o] = e[o], s[o] = !0); e = Object.getPrototypeOf(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, kindOf: Sl, kindOfTest: gl, endsWith: function (e, t, n) { e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length; var i = e.indexOf(t, n); return -1 !== i && i === n }, toArray: function (e) { if (!e) return null; var t = e.length; if (Il(t)) return null; for (var n = new Array(t); t-- > 0;)n[t] = e[t]; return n }, isTypedArray: kl, isFileList: Ll }, xl = Vl; function Fl(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } var Yl = function (e, t, n) { if (!t) return e; var i; if (n) i = n(t); else if (xl.isURLSearchParams(t)) i = t.toString(); else { var r = []; xl.forEach(t, (function (e, t) { null != e && (xl.isArray(e) ? t += "[]" : e = [e], xl.forEach(e, (function (e) { xl.isDate(e) ? e = e.toISOString() : xl.isObject(e) && (e = JSON.stringify(e)), r.push(Fl(t) + "=" + Fl(e)) }))) })), i = r.join("&") } if (i) { var o = e.indexOf("#"); -1 !== o && (e = e.slice(0, o)), e += (-1 === e.indexOf("?") ? "?" : "&") + i } return e }, Bl = Vl; function Gl() { this.handlers = [] } Gl.prototype.use = function (e, t, n) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!n && n.synchronous, runWhen: n ? n.runWhen : null }), this.handlers.length - 1 }, Gl.prototype.eject = function (e) { this.handlers[e] && (this.handlers[e] = null) }, Gl.prototype.forEach = function (e) { Bl.forEach(this.handlers, (function (t) { null !== t && e(t) })) }; var jl = Gl, Hl = Vl, Wl = Vl; function Kl(e, t, n, i, r) { Error.call(this), this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), i && (this.request = i), r && (this.response = r) } Wl.inherits(Kl, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null } } }); var Jl = Kl.prototype, Xl = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach((function (e) { Xl[e] = { value: e } })), Object.defineProperties(Kl, Xl), Object.defineProperty(Jl, "isAxiosError", { value: !0 }), Kl.from = function (e, t, n, i, r, o) { var s = Object.create(Jl); return Wl.toFlatObject(e, s, (function (e) { return e !== Error.prototype })), Kl.call(s, e.message, t, n, i, r), s.name = e.name, o && Object.assign(s, o), s }; var ql = Kl, Ql = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, zl = Vl, Zl = function (e, t) { t = t || new FormData; var n = []; function i(e) { return null === e ? "" : zl.isDate(e) ? e.toISOString() : zl.isArrayBuffer(e) || zl.isTypedArray(e) ? "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e } return function e(r, o) { if (zl.isPlainObject(r) || zl.isArray(r)) { if (-1 !== n.indexOf(r)) throw Error("Circular reference detected in " + o); n.push(r), zl.forEach(r, (function (n, r) { if (!zl.isUndefined(n)) { var s, a = o ? o + "." + r : r; if (n && !o && "object" == typeof n) if (zl.endsWith(r, "{}")) n = JSON.stringify(n); else if (zl.endsWith(r, "[]") && (s = zl.toArray(n))) return void s.forEach((function (e) { !zl.isUndefined(e) && t.append(a, i(e)) })); e(n, a) } })), n.pop() } else t.append(o, i(r)) }(e), t }, $l = ql, eR = Vl, tR = eR.isStandardBrowserEnv() ? { write: function (e, t, n, i, r, o) { var s = []; s.push(e + "=" + encodeURIComponent(t)), eR.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), eR.isString(i) && s.push("path=" + i), eR.isString(r) && s.push("domain=" + r), !0 === o && s.push("secure"), document.cookie = s.join("; ") }, read: function (e) { var t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove: function (e) { this.write(e, "", Date.now() - 864e5) } } : { write: function () { }, read: function () { return null }, remove: function () { } }, nR = function (e) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) }, iR = function (e, t) { return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e }, rR = function (e, t) { return e && !nR(t) ? iR(e, t) : t }, oR = Vl, sR = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"], aR = Vl, cR = aR.isStandardBrowserEnv() ? function () { var e, t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a"); function i(e) { var i = e; return t && (n.setAttribute("href", i), i = n.href), n.setAttribute("href", i), { href: n.href, protocol: n.protocol ? n.protocol.replace(/:$/, "") : "", host: n.host, search: n.search ? n.search.replace(/^\?/, "") : "", hash: n.hash ? n.hash.replace(/^#/, "") : "", hostname: n.hostname, port: n.port, pathname: "/" === n.pathname.charAt(0) ? n.pathname : "/" + n.pathname } } return e = i(window.location.href), function (t) { var n = aR.isString(t) ? i(t) : t; return n.protocol === e.protocol && n.host === e.host } }() : function () { return !0 }, ER = ql; function _R(e) { ER.call(this, null == e ? "canceled" : e, ER.ERR_CANCELED), this.name = "CanceledError" } Vl.inherits(_R, ER, { __CANCEL__: !0 }); var dR = _R, uR = Vl, lR = function (e, t, n) { var i = n.config.validateStatus; n.status && i && !i(n.status) ? t(new $l("Request failed with status code " + n.status, [$l.ERR_BAD_REQUEST, $l.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) : e(n) }, RR = tR, hR = Yl, pR = rR, TR = function (e) { var t, n, i, r = {}; return e ? (oR.forEach(e.split("\n"), (function (e) { if (i = e.indexOf(":"), t = oR.trim(e.substr(0, i)).toLowerCase(), n = oR.trim(e.substr(i + 1)), t) { if (r[t] && sR.indexOf(t) >= 0) return; r[t] = "set-cookie" === t ? (r[t] ? r[t] : []).concat([n]) : r[t] ? r[t] + ", " + n : n } })), r) : r }, OR = cR, CR = Ql, AR = ql, SR = dR, gR = function (e) { var t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" }, mR = function (e) { return new Promise((function (t, n) { var i, r = e.data, o = e.headers, s = e.responseType; function a() { e.cancelToken && e.cancelToken.unsubscribe(i), e.signal && e.signal.removeEventListener("abort", i) } uR.isFormData(r) && uR.isStandardBrowserEnv() && delete o["Content-Type"]; var c = new XMLHttpRequest; if (e.auth) { var E = e.auth.username || "", _ = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : ""; o.Authorization = "Basic " + btoa(E + ":" + _) } var d = pR(e.baseURL, e.url); function u() { if (c) { var i = "getAllResponseHeaders" in c ? TR(c.getAllResponseHeaders()) : null, r = { data: s && "text" !== s && "json" !== s ? c.response : c.responseText, status: c.status, statusText: c.statusText, headers: i, config: e, request: c }; lR((function (e) { t(e), a() }), (function (e) { n(e), a() }), r), c = null } } if (c.open(e.method.toUpperCase(), hR(d, e.params, e.paramsSerializer), !0), c.timeout = e.timeout, "onloadend" in c ? c.onloadend = u : c.onreadystatechange = function () { c && 4 === c.readyState && (0 !== c.status || c.responseURL && 0 === c.responseURL.indexOf("file:")) && setTimeout(u) }, c.onabort = function () { c && (n(new AR("Request aborted", AR.ECONNABORTED, e, c)), c = null) }, c.onerror = function () { n(new AR("Network Error", AR.ERR_NETWORK, e, c, c)), c = null }, c.ontimeout = function () { var t = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded", i = e.transitional || CR; e.timeoutErrorMessage && (t = e.timeoutErrorMessage), n(new AR(t, i.clarifyTimeoutError ? AR.ETIMEDOUT : AR.ECONNABORTED, e, c)), c = null }, uR.isStandardBrowserEnv()) { var l = (e.withCredentials || OR(d)) && e.xsrfCookieName ? RR.read(e.xsrfCookieName) : void 0; l && (o[e.xsrfHeaderName] = l) } "setRequestHeader" in c && uR.forEach(o, (function (e, t) { void 0 === r && "content-type" === t.toLowerCase() ? delete o[t] : c.setRequestHeader(t, e) })), uR.isUndefined(e.withCredentials) || (c.withCredentials = !!e.withCredentials), s && "json" !== s && (c.responseType = e.responseType), "function" == typeof e.onDownloadProgress && c.addEventListener("progress", e.onDownloadProgress), "function" == typeof e.onUploadProgress && c.upload && c.upload.addEventListener("progress", e.onUploadProgress), (e.cancelToken || e.signal) && (i = function (e) { c && (n(!e || e && e.type ? new SR : e), c.abort(), c = null) }, e.cancelToken && e.cancelToken.subscribe(i), e.signal && (e.signal.aborted ? i() : e.signal.addEventListener("abort", i))), r || (r = null); var R = gR(d); R && -1 === ["http", "https", "file"].indexOf(R) ? n(new AR("Unsupported protocol " + R + ":", AR.ERR_BAD_REQUEST, e)) : c.send(r) })) }, IR = Vl, fR = function (e, t) { Hl.forEach(e, (function (n, i) { i !== t && i.toUpperCase() === t.toUpperCase() && (e[t] = n, delete e[i]) })) }, PR = ql, NR = Zl, DR = { "Content-Type": "application/x-www-form-urlencoded" }; function vR(e, t) { !IR.isUndefined(e) && IR.isUndefined(e["Content-Type"]) && (e["Content-Type"] = t) } var yR, LR = { transitional: Ql, adapter: (("undefined" != typeof XMLHttpRequest || "undefined" != typeof process && "[object process]" === Object.prototype.toString.call(process)) && (yR = mR), yR), transformRequest: [function (e, t) { if (fR(t, "Accept"), fR(t, "Content-Type"), IR.isFormData(e) || IR.isArrayBuffer(e) || IR.isBuffer(e) || IR.isStream(e) || IR.isFile(e) || IR.isBlob(e)) return e; if (IR.isArrayBufferView(e)) return e.buffer; if (IR.isURLSearchParams(e)) return vR(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString(); var n, i = IR.isObject(e), r = t && t["Content-Type"]; if ((n = IR.isFileList(e)) || i && "multipart/form-data" === r) { var o = this.env && this.env.FormData; return NR(n ? { "files[]": e } : e, o && new o) } return i || "application/json" === r ? (vR(t, "application/json"), function (e, t, n) { if (IR.isString(e)) try { return (t || JSON.parse)(e), IR.trim(e) } catch (e) { if ("SyntaxError" !== e.name) throw e } return (n || JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { var t = this.transitional || LR.transitional, n = t && t.silentJSONParsing, i = t && t.forcedJSONParsing, r = !n && "json" === this.responseType; if (r || i && IR.isString(e) && e.length) try { return JSON.parse(e) } catch (e) { if (r) { if ("SyntaxError" === e.name) throw PR.from(e, PR.ERR_BAD_RESPONSE, this, null, this.response); throw e } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: null }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*" } } }; IR.forEach(["delete", "get", "head"], (function (e) { LR.headers[e] = {} })), IR.forEach(["post", "put", "patch"], (function (e) { LR.headers[e] = IR.merge(DR) })); var wR = LR, bR = Vl, UR = wR, MR = function (e) { return !(!e || !e.__CANCEL__) }, kR = Vl, VR = function (e, t, n) { var i = this || UR; return bR.forEach(n, (function (n) { e = n.call(i, e, t) })), e }, xR = MR, FR = wR, YR = dR; function BR(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new YR } var GR = Vl, jR = function (e, t) { t = t || {}; var n = {}; function i(e, t) { return GR.isPlainObject(e) && GR.isPlainObject(t) ? GR.merge(e, t) : GR.isPlainObject(t) ? GR.merge({}, t) : GR.isArray(t) ? t.slice() : t } function r(n) { return GR.isUndefined(t[n]) ? GR.isUndefined(e[n]) ? void 0 : i(void 0, e[n]) : i(e[n], t[n]) } function o(e) { if (!GR.isUndefined(t[e])) return i(void 0, t[e]) } function s(n) { return GR.isUndefined(t[n]) ? GR.isUndefined(e[n]) ? void 0 : i(void 0, e[n]) : i(void 0, t[n]) } function a(n) { return n in t ? i(e[n], t[n]) : n in e ? i(void 0, e[n]) : void 0 } var c = { url: o, method: o, data: o, baseURL: s, transformRequest: s, transformResponse: s, paramsSerializer: s, timeout: s, timeoutMessage: s, withCredentials: s, adapter: s, responseType: s, xsrfCookieName: s, xsrfHeaderName: s, onUploadProgress: s, onDownloadProgress: s, decompress: s, maxContentLength: s, maxBodyLength: s, beforeRedirect: s, transport: s, httpAgent: s, httpsAgent: s, cancelToken: s, socketPath: s, responseEncoding: s, validateStatus: a }; return GR.forEach(Object.keys(e).concat(Object.keys(t)), (function (e) { var t = c[e] || r, i = t(e); GR.isUndefined(i) && t !== a || (n[e] = i) })), n }, HR = "0.27.2", WR = HR, KR = ql, JR = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((function (e, t) { JR[e] = function (n) { return typeof n === e || "a" + (t < 1 ? "n " : " ") + e } })); var XR = {}; JR.transitional = function (e, t, n) { function i(e, t) { return "[Axios v" + WR + "] Transitional option '" + e + "'" + t + (n ? ". " + n : "") } return function (n, r, o) { if (!1 === e) throw new KR(i(r, " has been removed" + (t ? " in " + t : "")), KR.ERR_DEPRECATED); return t && !XR[r] && (XR[r] = !0, console.warn(i(r, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(n, r, o) } }; var qR = Vl, QR = Yl, zR = jl, ZR = function (e) { return BR(e), e.headers = e.headers || {}, e.data = VR.call(e, e.data, e.headers, e.transformRequest), e.headers = kR.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers), kR.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (function (t) { delete e.headers[t] })), (e.adapter || FR.adapter)(e).then((function (t) { return BR(e), t.data = VR.call(e, t.data, t.headers, e.transformResponse), t }), (function (t) { return xR(t) || (BR(e), t && t.response && (t.response.data = VR.call(e, t.response.data, t.response.headers, e.transformResponse))), Promise.reject(t) })) }, $R = jR, eh = rR, th = { assertOptions: function (e, t, n) { if ("object" != typeof e) throw new KR("options must be an object", KR.ERR_BAD_OPTION_VALUE); for (var i = Object.keys(e), r = i.length; r-- > 0;) { var o = i[r], s = t[o]; if (s) { var a = e[o], c = void 0 === a || s(a, o, e); if (!0 !== c) throw new KR("option " + o + " must be " + c, KR.ERR_BAD_OPTION_VALUE) } else if (!0 !== n) throw new KR("Unknown option " + o, KR.ERR_BAD_OPTION) } }, validators: JR }, nh = th.validators; function ih(e) { this.defaults = e, this.interceptors = { request: new zR, response: new zR } } ih.prototype.request = function (e, t) { "string" == typeof e ? (t = t || {}).url = e : t = e || {}, (t = $R(this.defaults, t)).method ? t.method = t.method.toLowerCase() : this.defaults.method ? t.method = this.defaults.method.toLowerCase() : t.method = "get"; var n = t.transitional; void 0 !== n && th.assertOptions(n, { silentJSONParsing: nh.transitional(nh.boolean), forcedJSONParsing: nh.transitional(nh.boolean), clarifyTimeoutError: nh.transitional(nh.boolean) }, !1); var i = [], r = !0; this.interceptors.request.forEach((function (e) { "function" == typeof e.runWhen && !1 === e.runWhen(t) || (r = r && e.synchronous, i.unshift(e.fulfilled, e.rejected)) })); var o, s = []; if (this.interceptors.response.forEach((function (e) { s.push(e.fulfilled, e.rejected) })), !r) { var a = [ZR, void 0]; for (Array.prototype.unshift.apply(a, i), a = a.concat(s), o = Promise.resolve(t); a.length;)o = o.then(a.shift(), a.shift()); return o } for (var c = t; i.length;) { var E = i.shift(), _ = i.shift(); try { c = E(c) } catch (e) { _(e); break } } try { o = ZR(c) } catch (e) { return Promise.reject(e) } for (; s.length;)o = o.then(s.shift(), s.shift()); return o }, ih.prototype.getUri = function (e) { e = $R(this.defaults, e); var t = eh(e.baseURL, e.url); return QR(t, e.params, e.paramsSerializer) }, qR.forEach(["delete", "get", "head", "options"], (function (e) { ih.prototype[e] = function (t, n) { return this.request($R(n || {}, { method: e, url: t, data: (n || {}).data })) } })), qR.forEach(["post", "put", "patch"], (function (e) { function t(t) { return function (n, i, r) { return this.request($R(r || {}, { method: e, headers: t ? { "Content-Type": "multipart/form-data" } : {}, url: n, data: i })) } } ih.prototype[e] = t(), ih.prototype[e + "Form"] = t(!0) })); var rh = ih, oh = dR; function sh(e) { if ("function" != typeof e) throw new TypeError("executor must be a function."); var t; this.promise = new Promise((function (e) { t = e })); var n = this; this.promise.then((function (e) { if (n._listeners) { var t, i = n._listeners.length; for (t = 0; t < i; t++)n._listeners[t](e); n._listeners = null } })), this.promise.then = function (e) { var t, i = new Promise((function (e) { n.subscribe(e), t = e })).then(e); return i.cancel = function () { n.unsubscribe(t) }, i }, e((function (e) { n.reason || (n.reason = new oh(e), t(n.reason)) })) } sh.prototype.throwIfRequested = function () { if (this.reason) throw this.reason }, sh.prototype.subscribe = function (e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] }, sh.prototype.unsubscribe = function (e) { if (this._listeners) { var t = this._listeners.indexOf(e); -1 !== t && this._listeners.splice(t, 1) } }, sh.source = function () { var e; return { token: new sh((function (t) { e = t })), cancel: e } }; var ah = sh, ch = Vl, Eh = Vl, _h = Ol, dh = rh, uh = jR, lh = function e(t) { var n = new dh(t), i = _h(dh.prototype.request, n); return Eh.extend(i, dh.prototype, n), Eh.extend(i, n), i.create = function (n) { return e(uh(t, n)) }, i }(wR); lh.Axios = dh, lh.CanceledError = dR, lh.CancelToken = ah, lh.isCancel = MR, lh.VERSION = HR, lh.toFormData = Zl, lh.AxiosError = ql, lh.Cancel = lh.CanceledError, lh.all = function (e) { return Promise.all(e) }, lh.spread = function (e) { return function (t) { return e.apply(null, t) } }, lh.isAxiosError = function (e) { return ch.isObject(e) && !0 === e.isAxiosError }, Tl.exports = lh, Tl.exports.default = lh; var Rh = Tl.exports; class hh { constructor(e) { hl(this, "logger", void 0), hl(this, "prefixLists", []), this.logger = e } debug() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this.logger.debug(...this.prefixLists, ...t) } info() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this.logger.info(...this.prefixLists, ...t) } warning() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this.logger.warning(...this.prefixLists, ...t) } error() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this.logger.error(...this.prefixLists, ...t) } prefix(e) { return this.prefixLists.push(e), this } popPrefix() { return this.prefixLists.pop(), this } } class ph { constructor() { hl(this, "_events", {}), hl(this, "addListener", this.on) } getListeners(e) { return this._events[e] ? this._events[e].map((e => e.listener)) : [] } on(e, t) { this._events[e] || (this._events[e] = []); const n = this._events[e]; -1 === this._indexOfListener(n, t) && n.push({ listener: t, once: !1 }) } once(e, t) { this._events[e] || (this._events[e] = []); const n = this._events[e]; -1 === this._indexOfListener(n, t) && n.push({ listener: t, once: !0 }) } off(e, t) { if (!this._events[e]) return; const n = this._events[e], i = this._indexOfListener(n, t); -1 !== i && n.splice(i, 1), 0 === this._events[e].length && delete this._events[e] } removeAllListeners(e) { e ? delete this._events[e] : this._events = {} } emit(e) { this._events[e] || (this._events[e] = []); const t = this._events[e].map((e => e)); for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++)i[r - 1] = arguments[r]; for (let o = 0; o < t.length; o += 1) { const n = t[o]; n.once && this.off(e, n.listener), n.listener.apply(this, i || []) } } safeEmit(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i];[...this._events[e] || []].forEach((t => { t.once && this.off(e, t.listener); try { t.listener.apply(this, n) } catch (t) { Dh.error("safeEmit event:".concat(e, " error ").concat(null == t ? void 0 : t.toString())) } })) } _indexOfListener(e, t) { let n = e.length; for (; n--;)if (e[n].listener === t) return n; return -1 } } const Th = new class extends ph { reportLogUploadError(e) { this.emit("REPORT_LOG_UPLOAD", e) } }; let Oh; !function (e) { e.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e.TIMEOUT = "TIMEOUT", e.INVALID_PARAMS = "INVALID_PARAMS", e.NOT_READABLE = "NOT_READABLE", e.NOT_SUPPORTED = "NOT_SUPPORTED", e.INVALID_OPERATION = "INVALID_OPERATION", e.OPERATION_ABORTED = "OPERATION_ABORTED", e.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e.NETWORK_ERROR = "NETWORK_ERROR", e.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e.PERMISSION_DENIED = "PERMISSION_DENIED", e.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e.UID_CONFLICT = "UID_CONFLICT", e.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e.INVALID_TRACK = "INVALID_TRACK", e.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e.ICE_FAILED = "ICE_FAILED", e.PC_CLOSED = "PC_CLOSED", e.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e.WS_ABORT = "WS_ABORT", e.WS_DISCONNECT = "WS_DISCONNECT", e.WS_ERR = "WS_ERR", e.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e.INVALID_PLUGIN = "INVALID_PLUGIN", e.DISCONNECT_P2P = "DISCONNECT_P2P", e.INIT_WEBSOCKET_TIMEOUT = "INIT_WEBSOCKET_TIMEOUT", e.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", e.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", e.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED" }(Oh || (Oh = {})); class Ch extends Error { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", n = arguments.length > 2 ? arguments[2] : void 0; super(t), hl(this, "code", void 0), hl(this, "message", void 0), hl(this, "data", void 0), hl(this, "name", "AgoraRTCException"), this.code = e, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t), this.data = n } toString() { return this.data ? "data: ".concat(JSON.stringify(this.data), "\n").concat(this.stack) : "".concat(this.stack) } print() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error"; return "error" === e && Dh.error(this.toString()), "warning" === e && Dh.warning(this.toString()), this } throw() { throw this.print(), this } } const Ah = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 }; function Sh(e, t) { const n = Math.floor(t.timeout * Math.pow(t.timeoutFactor, e)); return Math.min(t.maxRetryTimeout, n) } function gh(e, t, n, i) { const r = Object.assign({}, Ah, i); let o = r.timeout; const s = async () => { await function (e) { return new Cd((t => { window.setTimeout(t, e) })) }(o), o *= r.timeoutFactor, o = Math.min(r.maxRetryTimeout, o) }; let a = !1; const c = new Cd((async (i, o) => { t = t || (() => !1), n = n || (() => !0); for (let c = 0; c < r.maxRetryCount; c += 1) { if (a) return o(new Ch(Oh.OPERATION_ABORTED)); try { const n = await e(); if (!t(n, c)) return i(n); if (c + 1 === r.maxRetryCount) return i(n); await s() } catch (e) { if (!n(e, c)) return o(e); if (c + 1 === r.maxRetryCount) return o(e); await s() } } })); return c.cancel = () => a = !0, c } function mh() { const e = new Date; return e.toTimeString().split(" ")[0] + ":" + e.getMilliseconds() } function Ih() { const e = new Date, t = /((\d+:){2}\d+)/.exec((new Date).toUTCString()); return t ? (null == t ? void 0 : t[0]) + ":" + e.getUTCMilliseconds() : e.toTimeString().split(" ")[0] + ":" + e.getMilliseconds() } const fh = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 }, Ph = Date.now(), Nh = e => { for (const t in fh) if (Object.prototype.hasOwnProperty.call(fh, t) && fh[t] === e) return t; return "DEFAULT" }, Dh = new class { constructor() { hl(this, "proxyServerURL", void 0), hl(this, "logLevel", fh.DEBUG), hl(this, "uploadState", "collecting"), hl(this, "uploadLogWaitingList", []), hl(this, "uploadLogUploadingList", []), hl(this, "uploadErrorCount", 0), hl(this, "currentLogID", 0), hl(this, "url", void 0), hl(this, "extLog", ((e, t) => { this.appendLogToWaitingList(e, ...t) })) } debug() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; const i = [fh.DEBUG].concat(t); this.log.apply(this, i) } info() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; const i = [fh.INFO].concat(t); this.log.apply(this, i) } warning() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; const i = [fh.WARNING].concat(t); this.log.apply(this, i) } error() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; const i = [fh.ERROR].concat(t); this.log.apply(this, i) } upload() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; const i = [fh.DEBUG].concat(t); this.uploadLog.apply(this, i) } setLogLevel(e) { e = Math.min(Math.max(0, e), 4), this.logLevel = e } enableLogUpload() { Gh("UPLOAD_LOG", !0) } disableLogUpload() { Gh("UPLOAD_LOG", !1), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [] } setProxyServer(e) { this.proxyServerURL = e } prefix(e) { return new hh(this).prefix(e) } log() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; if (Date.now() - Ph < 100) return void setTimeout((() => { this.log(...t) }), Date.now() - Ph); const i = Math.max(0, Math.min(4, t[0])); if (t[0] = mh() + " Agora-SDK [".concat(Nh(i), "]:"), this.appendLogToWaitingList(i, ...t), i < this.logLevel) return; const r = mh() + " %cAgora-SDK [".concat(Nh(i), "]:"); let o = []; if (!jh("USE_NEW_LOG")) switch (i) { case fh.DEBUG: o = [r, "color: #64B5F6;"].concat(t.slice(1)), console.log.apply(console, o); break; case fh.INFO: o = [r, "color: #1E88E5; font-weight: bold;"].concat(t.slice(1)), console.log.apply(console, o); break; case fh.WARNING: o = [r, "color: #FB8C00; font-weight: bold;"].concat(t.slice(1)), console.warn.apply(console, o); break; case fh.ERROR: o = [r, "color: #B00020; font-weight: bold;"].concat(t.slice(1)), console.error.apply(console, o) } } uploadLog() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; if (Date.now() - Ph < 100) return void setTimeout((() => { this.uploadLog(...t) }), Date.now() - Ph); const i = Math.max(0, Math.min(4, t[0])); t[0] = mh() + " Agora-SDK [".concat(Nh(i), "]:"), this.appendLogToWaitingList(i, ...t) } appendLogToWaitingList(e) { if (!jh("UPLOAD_LOG")) return; for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; Array.isArray(n[0]) ? n[0][0] = Ih() + " Agora-SDK [".concat(Nh(e), "]:") : n[0] = Ih() + " Agora-SDK [".concat(Nh(e), "]:"); let r = ""; n.forEach((e => { "object" == typeof e && (e = JSON.stringify(e)), r += "".concat(e, " ") })), this.uploadLogWaitingList.push({ payload_str: r, log_level: e, log_item_id: this.currentLogID++ }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval() } startUpload() { this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval() } async uploadLogs() { const e = this.uploadLogUploadingList, t = { sdk_version: yh, process_id: jh("PROCESS_ID"), payload: JSON.stringify(e) }; return gh((async () => { const e = await Rh.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(jh("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(jh("LOG_UPLOAD_SERVER"), "/upload/v1")), t, { responseType: "text" }); if ("OK" !== e.data) { const t = new Error("unexpected upload log response"); throw t.response = e, t } }), (() => (this.uploadLogUploadingList = [], !1)), (e => (e.response ? Th.reportLogUploadError({ status: e.response.status, data: e.response.data, headers: e.response.headers, message: e.message }) : e.request ? Th.reportLogUploadError({ status: e.request.status, message: e.message }) : Th.reportLogUploadError({ status: -1, message: e.message }), !0)), { timeout: jh("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: jh("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") }) } uploadLogInterval() { 0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, jh("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then((() => { this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout((() => this.uploadLogInterval()), jh("UPLOAD_LOG_INTERVAL")) })).catch((e => { this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout((() => this.uploadLogInterval()), jh("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout((() => this.uploadLogInterval()), jh("UPLOAD_LOG_RETRY_INTERVAL_V1")) }))) } }, vh = "v4.18.2-0-g8d83af1d-dirty(7/11/2023, 7:07:15 PM)", yh = function (e) { if (e.match(/[0-9]+\.[0-9]+\.[0-9]+$/)) return e; const t = e.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/); if (t && t[1] && t[2]) { const e = t[1], n = t[2]; return "".concat(e, ".").concat(n) } const n = e.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/); if (n && n[1] && n[2]) { const e = n[1], t = n[2]; return "".concat(e, ".").concat(100 * (Number(t) + 1)) } return "4.0.0.999" }("4.18.2"), Lh = function () { try { return !0 === JSON.parse("true") } catch (e) { return !0 } }(), wh = ["CHINA", "GLOBAL"], bh = function () { const e = "us".concat("erna", "me"), t = "pa".concat("sswo", "rd"), n = ["t", "s", "t"]; n.splice(1, 0, "e"); const i = n.join(""), r = []; for (let a = 0; a < 6; a++)r.push("1"); const o = r.join(""), s = {}; return s[e] = i, s[t] = o, Object.assign(s, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: !1 }) }(); window.DEFAULT_TURN_CONFIG = bh; const Uh = { "90p": Jh(160, 90), "90p_1": Jh(160, 90), "120p": Jh(160, 120, 15, 30, 65), "120p_1": Jh(160, 120, 15, 30, 65), "120p_3": Jh(120, 120, 15, 30, 50), "120p_4": Jh(212, 120), "180p": Jh(320, 180, 15, 30, 140), "180p_1": Jh(320, 180, 15, 30, 140), "180p_3": Jh(180, 180, 15, 30, 100), "180p_4": Jh(240, 180, 15, 30, 120), "240p": Jh(320, 240, 15, 40, 200), "240p_1": Jh(320, 240, 15, 40, 200), "240p_3": Jh(240, 240, 15, 40, 140), "240p_4": Jh(424, 240, 15, 40, 220), "360p": Jh(640, 360, 15, 80, 400), "360p_1": Jh(640, 360, 15, 80, 400), "360p_3": Jh(360, 360, 15, 80, 260), "360p_4": Jh(640, 360, 30, 80, 600), "360p_6": Jh(360, 360, 30, 80, 400), "360p_7": Jh(480, 360, 15, 80, 320), "360p_8": Jh(480, 360, 30, 80, 490), "360p_9": Jh(640, 360, 15, 80, 800), "360p_10": Jh(640, 360, 24, 80, 800), "360p_11": Jh(640, 360, 24, 80, 1e3), "480p": Jh(640, 480, 15, 100, 500), "480p_1": Jh(640, 480, 15, 100, 500), "480p_2": Jh(640, 480, 30, 100, 1e3), "480p_3": Jh(480, 480, 15, 100, 400), "480p_4": Jh(640, 480, 30, 100, 750), "480p_6": Jh(480, 480, 30, 100, 600), "480p_8": Jh(848, 480, 15, 100, 610), "480p_9": Jh(848, 480, 30, 100, 930), "480p_10": Jh(640, 480, 10, 100, 400), "720p": Jh(1280, 720, 15, 120, 1130), "720p_1": Jh(1280, 720, 15, 120, 1130), "720p_2": Jh(1280, 720, 30, 120, 2e3), "720p_3": Jh(1280, 720, 30, 120, 1710), "720p_5": Jh(960, 720, 15, 120, 910), "720p_6": Jh(960, 720, 30, 120, 1380), "1080p": Jh(1920, 1080, 15, 120, 2080), "1080p_1": Jh(1920, 1080, 15, 120, 2080), "1080p_2": Jh(1920, 1080, 30, 120, 3e3), "1080p_3": Jh(1920, 1080, 30, 120, 3150), "1080p_5": Jh(1920, 1080, 60, 120, 4780), "1440p": Jh(2560, 1440, 30, 120, 4850), "1440p_1": Jh(2560, 1440, 30, 120, 4850), "1440p_2": Jh(2560, 1440, 60, 120, 7350), "4k": Jh(3840, 2160, 30, 120, 8910), "4k_1": Jh(3840, 2160, 30, 120, 8910), "4k_3": Jh(3840, 2160, 60, 120, 13500) }, Mh = { "480p": Xh(640, 480, 5), "480p_1": Xh(640, 480, 5), "480p_2": Xh(640, 480, 30), "480p_3": Xh(640, 480, 15), "720p": Xh(1280, 720, 5), "720p_1": Xh(1280, 720, 5), "720p_2": Xh(1280, 720, 30), "720p_3": Xh(1280, 720, 15), "1080p": Xh(1920, 1080, 5), "1080p_1": Xh(1920, 1080, 5), "1080p_2": Xh(1920, 1080, 30), "1080p_3": Xh(1920, 1080, 15) }, kh = { "1SL1TL": qh(1, 1), "3SL3TL": qh(3, 3), "2SL3TL": qh(2, 3) }; function Vh(e) { return e || (e = "480p_1"), "string" == typeof e ? Object.assign({}, Uh[e]) : e } function xh(e) { return "string" == typeof e ? Object.assign({}, Mh[e]) : e } function Fh(e) { return "string" == typeof e ? Object.assign({}, kh[e]) : e } const Yh = { speech_low_quality: Kh(16e3, !1), speech_standard: Kh(32e3, !1, 18), music_standard: Kh(48e3, !1), standard_stereo: Kh(48e3, !0, 56), high_quality: Kh(48e3, !1, 128), high_quality_stereo: Kh(48e3, !0, 192) }; function Bh(e) { return "string" == typeof e ? Object.assign({}, Yh[e]) : e } function Gh(e, t, n) { Object.keys(Hh).includes(e) && (!n && Object.keys(Wh).includes(e) || (Hh[e] = t)) } function jh(e) { return Hh[e] } const Hh = { PROCESS_ID: "", ENCRYPT_AES: !0, AREAS: wh, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", ENABLE_EVENT_REPORT: !0, GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: !0, UPLOAD_LOG: !1, NOT_REPORT_EVENT: [], SUBSCRIBE_TWCC: !1, PUBLISH_TWCC: !1, PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: !0, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: !1, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: !1, TURN_ENABLE_TCP: !0, TURN_ENABLE_UDP: !0, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], WORKER_DOMAIN: "edge.agora.io", TURN_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: !0, CHROME_FORCE_PLAN_B: !1, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: !1, STATS_UPDATE_INTERVAL: 250, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: !0, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: !0, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: !1, SIMULCAST: !1, PRELOAD_MEDIA_COUNT: 0, USE_PUB_RTX: !1, USE_SUB_RTX: !1, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, ENUMERATE_DEVICES_INTERVAL: !1, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: !1, CLOSE_AFB_FOR_LOCAL_AP: !0, JOIN_WITH_FALLBACK_SIGNAL_PROXY: !0, JOIN_WITH_FALLBACK_MEDIA_PROXY: !0, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: !1, JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION: 2e3, USE_TURN_SERVER_OF_GATEWAY: !1, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: !1, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: !0, SDP_LOGGING: !1, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: !1, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: !0, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: {}, ADJUST_3A_FROM_PLUGINS: !0, RAISE_H264_BASELINE_PRIORITY: !0, FILTER_SEND_H264_BASELINE: !1, ENABLE_PUBLISHED_USER_LIST: !0, MAX_SUBSCRIPTION: 50, X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: !1, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: .9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: !1, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: !1, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: !0, FILTER_AUDIO_FEC: !1, CHROME_DUAL_STREAM_USE_ENCODING: !0, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: !0, ICE_RESTART_INTERVAL: 1e4, NEW_ICE_RESTART: !1, ENABLE_USER_LICENSE_CHECK: !0, SIGNAL_CHANNEL: 0, TRANSMITTER_INITIAL_RTT: 30, TRANSMITTER_INITIAL_RTO: 30, TRANSMITTER_MAX_BATCH_ACK_COUNT: 2, TRANSMITTER_MAX_RTO: 500, DATACHANNEL_COMPRESS: !1, FINGERPRINT: null, DC_JOIN_WITH_FAILBACK: 5e3, ENABLE_VIDEO_FRAME_CALLBACK: !0, VIDEO_FREEZE_DURATION: 500, SPATIALIZER_PARAMETERS: {}, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, DISABLE_WEBAUDIO: !1, CHANNEL_MEDIA_RELAY_SERVERS: void 0, KEEP_LAST_FRAME: !0, FORWARD_P2P_CREATION: !0, SYNC_GROUP: !0, BLOCK_LOCAL_CLIENT: !1, AP_AREA: !0, SVC: [], ENABLE_ENCODED_TRANSFORM: !1, IMAGE_MODERATION_WORKER_HOST: "edge.agora.io", IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3, SHOW_IMAGE_MODERATION_WORKER_MESSAGE: !1, IMAGE_MODERATION_QUALITY_RATIO: .9, IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: !0, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: !1, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: !0, googTrackId: !0 } }, Wh = {}; function Kh(e, t, n) { return { sampleRate: e, stereo: t, bitrate: n } } function Jh(e, t, n, i, r) { return { width: e, height: t, frameRate: n, bitrateMin: i, bitrateMax: r } } function Xh(e, t, n, i, r) { return { width: { max: e }, height: { max: t }, frameRate: n, bitrateMin: i, bitrateMax: r } } function qh(e, t) { return { numSpatialLayers: e, numTemporalLayers: t } } Lh || (Hh.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], Hh.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], Hh.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], Hh.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], Hh.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], Hh.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], Hh.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", Hh.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", Hh.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", Hh.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", Hh.AREAS = ["NORTH_AMERICA", "OVERSEA"]); const Qh = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]], zh = [], Zh = []; function $h(e, t) { return !!t && zh.some((n => n.uid === e && n.channelName === t)) } var ep = pt, tp = Wt, np = L, ip = function (e, t, n) { var i = ep(t); i in e ? tp.f(e, i, np(0, n)) : e[i] = n }, rp = Vi, op = Ln, sp = ip, ap = l.Array, cp = Math.max, Ep = function (e, t, n) { for (var i = op(e), r = rp(t, i), o = rp(void 0 === n ? i : n, i), s = ap(cp(o - r, 0)), a = 0; r < o; r++, a++)sp(s, a, e[r]); return s.length = a, s }, _p = Ep, dp = Math.floor, up = function (e, t) { var n = e.length, i = dp(n / 2); return n < 8 ? lp(e, t) : Rp(e, up(_p(e, 0, i), t), up(_p(e, i), t), t) }, lp = function (e, t) { for (var n, i, r = e.length, o = 1; o < r;) { for (i = o, n = e[o]; i && t(e[i - 1], n) > 0;)e[i] = e[--i]; i !== o++ && (e[i] = n) } return e }, Rp = function (e, t, n, i) { for (var r = t.length, o = n.length, s = 0, a = 0; s < r || a < o;)e[s + a] = s < r && a < o ? i(t[s], n[a]) <= 0 ? t[s++] : n[a++] : s < r ? t[s++] : n[a++]; return e }, hp = up, pp = te.match(/firefox\/(\d+)/i), Tp = !!pp && +pp[1], Op = /MSIE|Trident/.test(te), Cp = te.match(/AppleWebKit\/(\d+)\./), Ap = !!Cp && +Cp[1], Sp = In, gp = _, mp = Ie, Ip = Ye, fp = Ln, Pp = Lo, Np = i, Dp = hp, vp = Yn, yp = Tp, Lp = Op, wp = ce, bp = Ap, Up = [], Mp = gp(Up.sort), kp = gp(Up.push), Vp = Np((function () { Up.sort(void 0) })), xp = Np((function () { Up.sort(null) })), Fp = vp("sort"), Yp = !Np((function () { if (wp) return wp < 70; if (!(yp && yp > 3)) { if (Lp) return !0; if (bp) return bp < 603; var e, t, n, i, r = ""; for (e = 65; e < 76; e++) { switch (t = String.fromCharCode(e), e) { case 66: case 69: case 70: case 72: n = 3; break; case 68: case 71: n = 4; break; default: n = 2 }for (i = 0; i < 47; i++)Up.push({ k: t + i, v: n }) } for (Up.sort((function (e, t) { return t.v - e.v })), i = 0; i < Up.length; i++)t = Up[i].k.charAt(0), r.charAt(r.length - 1) !== t && (r += t); return "DGBEFHACIJK" !== r } })); Sp({ target: "Array", proto: !0, forced: Vp || !xp || !Fp || !Yp }, { sort: function (e) { void 0 !== e && mp(e); var t = Ip(this); if (Yp) return void 0 === e ? Mp(t) : Mp(t, e); var n, i, r = [], o = fp(t); for (i = 0; i < o; i++)i in t && kp(r, t[i]); for (Dp(r, function (e) { return function (t, n) { return void 0 === n ? -1 : void 0 === t ? 1 : void 0 !== e ? +e(t, n) || 0 : Pp(t) > Pp(n) ? 1 : -1 } }(e)), n = r.length, i = 0; i < n;)t[i] = r[i++]; for (; i < o;)delete t[i++]; return t } }); var Bp = Kn("Array").sort, Gp = d, jp = Bp, Hp = Array.prototype, Wp = function (e) { var t = e.sort; return e === Hp || Gp(Hp, e) && t === Hp.sort ? jp : t }; function Kp(e, t) { if ("boolean" != typeof e) throw new Ch(Oh.INVALID_PARAMS, "Invalid ".concat(t, ": The value is of the boolean type.")) } function Jp(e, t, n) { if (!n.includes(e)) throw new Ch(Oh.INVALID_PARAMS, "".concat(t, " can only be set as ").concat(JSON.stringify(n))) } function Xp(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4; if (e < n || e > i || (!(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]) && !nT(e)) throw new Ch(Oh.INVALID_PARAMS, "invalid ".concat(t, ": the value range is [").concat(n, ", ").concat(i, "]. integer only")) } function qp(e, t) { if ("number" != typeof e) { if (!(e.min || e.max || e.ideal || e.exact)) throw new Ch(Oh.INVALID_PARAMS, "".concat(t, " is not a valid ConstrainLong")); void 0 !== e.min && Xp(e.min, "".concat(t, ".min"), 0, 1 / 0), void 0 !== e.max && Xp(e.max, "".concat(t, ".max"), 1, 1 / 0), void 0 !== e.exact && Xp(e.exact, "".concat(t, ".exact"), 1, 1 / 0), void 0 !== e.ideal && Xp(e.ideal, "".concat(t, ".ideal"), 1, 1 / 0) } else Xp(e, t, 1, 1 / 0) } function Qp(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255, r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]; if (null == e) throw new Ch(Oh.INVALID_PARAMS, "".concat(t || "param", " cannot be empty")); if (!tT(e, n, i, r)) throw new Ch(Oh.INVALID_PARAMS, "Invalid ".concat(t || "string param", ": Length of the string: [").concat(n, ",").concat(i, "].").concat(r ? " ASCII characters only." : "")) } function zp(e, t) { if (!Array.isArray(e)) throw new Ch(Oh.INVALID_PARAMS, "".concat(t, " should be an array")) } function Zp(e) { if ("string" != typeof e || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e)) throw Dh.error("Invalid Channel Name ".concat(e)), new Ch(Oh.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,") } function $p(e) { if (!("number" == typeof (t = e) && Math.floor(t) === t && 0 <= t && t <= 4294967295 || tT(e, 1, 255))) throw Dh.error("Invalid UID ".concat(e, " ").concat(typeof e)), new Ch(Oh.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]"); var t; "string" == typeof e && Dh.warning("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.") } function eT(e) { return null == e } function tT(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255, i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; return "string" == typeof e && e.length <= n && e.length >= t && (!i || iT(e)) } function nT(e) { return "number" == typeof e && e % 1 == 0 } function iT(e) { if ("string" != typeof e) return !1; for (let t = 0; t < e.length; t += 1) { const n = e.charCodeAt(t); if (n < 0 || n > 255) return !1 } return !0 } let rT, oT, sT; !function (e) { e.FREE = "free", e.UPLOADING = "uploading" }(rT || (rT = {})), function (e) { e[e.MISC = 0] = "MISC", e[e.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e[e.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e[e.WEB_EVENT = 3] = "WEB_EVENT", e[e.INTERNAL_API = 4] = "INTERNAL_API", e[e.WEB_API = 5] = "WEB_API", e[e.PUBLIC_API = 6] = "PUBLIC_API" }(oT || (oT = {})), function (e) { e.NONE = "none", e.INIT = "init", e.CANPLAY = "canplay", e.PLAYING = "playing", e.PAUSED = "paused", e.SUSPEND = "suspend", e.STALLED = "stalled", e.WAITING = "waiting", e.ERROR = "error", e.DESTROYED = "destroyed", e.ABORT = "abort", e.ENDED = "ended", e.EMPTIED = "emptied", e.LOADEDDATA = "loadeddata" }(sT || (sT = {})); const aT = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 }; function cT(e) { return Qp(e.reportId, "params.reportId", 0, 100, !1), Qp(e.category, "params.category", 0, 100, !1), Qp(e.event, "params.event", 0, 100, !1), Qp(e.label, "params.label", 0, 100, !1), Xp(e.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, !1), !0 } const ET = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 }; let _T, dT, uT, lT, RT, hT, pT, TT, OT, CT, AT, ST, gT, mT, IT, fT, PT, NT, DT, vT, yT, LT, wT, bT; function UT(e) { return Xp(e.timeout, "config.timeout", 0, 1e5), Xp(e.timeoutFactor, "config.timeoutFactor", 0, 100, !1), Xp(e.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), Xp(e.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), !0 } function MT(e) { return Jp(e.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]), Jp(e.mode, "config.mode", ["rtc", "live"]), void 0 !== e.audioCodec && Jp(e.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e.proxyServer && Qp(e.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e.turnServer && VT(e.turnServer), void 0 !== e.httpRetryConfig && UT(e.httpRetryConfig), void 0 !== e.websocketRetryConfig && UT(e.websocketRetryConfig), !0 } function kT(e) { if (!Array.isArray(e) || e.length < 1) return !1; try { e.forEach((e => { if (!e.urls) throw Error() })) } catch (e) { return !1 } return !0 } function VT(e) { return Qp(e.turnServerURL, "turnServerURL"), Qp(e.username, "username"), Qp(e.password, "password"), e.udpport && Xp(e.udpport, "udpport", 1, 99999, !0), e.forceturn && Kp(e.forceturn, "forceturn"), e.security && Kp(e.security, "security"), e.tcpport && Xp(e.tcpport, "tcpport", 1, 99999, !0), !0 } function xT(e) { return void 0 !== e.level && Jp(e.level, "level", [1, 2, 3]), !0 } !function (e) { e.PUBLISH = "publish", e.SUBSCRIBE = "subscribe", e.WS_COMPRESSOR_INIT = "ws_compressor_init", e.SESSION_INIT = "session_init", e.JOIN_CHOOSE_SERVER = "join_choose_server", e.REQ_USER_ACCOUNT = "req_user_account", e.JOIN_GATEWAY = "join_gateway", e.REJOIN_GATEWAY = "rejoin_gateway", e.STREAM_SWITCH = "stream_switch", e.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e.FIRST_VIDEO_RECEIVED = "first_video_received", e.FIRST_AUDIO_RECEIVED = "first_audio_received", e.FIRST_VIDEO_DECODE = "first_video_decode", e.FIRST_AUDIO_DECODE = "first_audio_decode", e.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e.ON_UPDATE_STREAM = "on_update_stream", e.ON_REMOVE_STREAM = "on_remove_stream", e.USER_ANALYTICS = "req_user_analytics", e.PC_STATS = "pc_stats" }(_T || (_T = {})), function (e) { e.SESSION = "io.agora.pb.Wrtc.Session", e.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e.PUBLISH = "io.agora.pb.Wrtc.Publish", e.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed", e.PC_STATS = "io.agora.pb.Wrtc.PCStats" }(dT || (dT = {})), function (e) { e[e.WORKER_EVENT = 156] = "WORKER_EVENT", e[e.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT" }(uT || (uT = {})), function (e) { e[e.SESSION = 26] = "SESSION", e[e.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e[e.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e[e.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e[e.PUBLISH = 30] = "PUBLISH", e[e.SUBSCRIBE = 29] = "SUBSCRIBE", e[e.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e[e.STREAM_SWITCH = 32] = "STREAM_SWITCH", e[e.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e[e.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e[e.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e[e.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e[e.API_INVOKE = 41] = "API_INVOKE", e[e.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e[e.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e[e.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e[e.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e[e.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e[e.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e[e.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e[e.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e[e.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e[e.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e[e.WORKER_EVENT = 156] = "WORKER_EVENT", e[e.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e[e.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e[e.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e[e.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e[e.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED" }(lT || (lT = {})), function (e) { e.CREATE_CLIENT = "createClient", e.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e.SET_AREA = "setArea", e.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e.START_PROXY_SERVER = "Client.startProxyServer", e.STOP_PROXY_SERVER = "Client.stopProxyServer", e.SET_PROXY_SERVER = "Client.setProxyServer", e.SET_TURN_SERVER = "Client.setTurnServer", e.SET_CLIENT_ROLE = "Client.setClientRole", e.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e.ENABLE_DUAL_STREAM = "Client.enableDualStream", e.DISABLE_DUAL_STREAM = "Client.disableDualStream", e.JOIN = "Client.join", e.LEAVE = "Client.leave", e.PUBLISH = "Client.publish", e.UNPUBLISH = "Client.unpublish", e.SUBSCRIBE = "Client.subscribe", e.MASS_SUBSCRIBE = "Client.massSubscribe", e.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e.UNSUBSCRIBE = "Client.unsubscribe", e.RENEW_TOKEN = "Client.renewToken", e.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e.DATACHANNEL_FAILBACK = "Client._datachannelFailback", e.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e.START_LIVE_STREAMING = "Client.startLiveStreaming", e.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e.ADD_INJECT_STREAM_URL = "Client.addInjectStreamUrl", e.REMOVE_INJECT_STREAM_URL = "Client.removeInjectStreamUrl", e.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e.SET_CONFIG_DISTRIBUTE = "_configDistribute", e.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e.STREAM_TYPE_CHANGE = "streamTypeChange", e.CONNECTION_STATE_CHANGE = "connectionStateChange", e.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage", e.IMAGE_MODERATION_UPLOAD = "imageModerationUpload" }(RT || (RT = {})), function (e) { e.TRACER = "tracer" }(hT || (hT = {})), function (e) { e.IDLE = "IDLE", e.INITING = "INITING", e.INITEND = "INITEND" }(pT || (pT = {})), function (e) { e.STATE_CHANGE = "state_change", e.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged" }(TT || (TT = {})), function (e) { e[e.ACCESS_POINT = 101] = "ACCESS_POINT", e[e.UNILBS = 201] = "UNILBS", e[e.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR" }(OT || (OT = {})), function (e) { e[e.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e[e.IIIEGAL_UID = 2] = "IIIEGAL_UID", e[e.INTERNAL_ERROR = 3] = "INTERNAL_ERROR" }(CT || (CT = {})), function (e) { e[e.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e[e.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e[e.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e[e.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e[e.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e[e.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e[e.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e[e.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e[e.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e[e.USER_OVERLOAD = 16] = "USER_OVERLOAD", e[e.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e[e.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND" }(AT || (AT = {})), function (e) { e[e.NO_FLAG_SET = 100] = "NO_FLAG_SET", e[e.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e[e.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e[e.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e[e.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e[e.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e[e.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e[e.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e[e.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e[e.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e[e.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e[e.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e[e.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e[e.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e[e.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e[e.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e[e.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e[e.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e[e.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV" }(ST || (ST = {})), function (e) { e[e.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e[e.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e[e.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e[e.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e[e.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e[e.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e[e.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e[e.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e[e.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e[e.K_UID_BANNED = 14] = "K_UID_BANNED", e[e.K_IP_BANNED = 15] = "K_IP_BANNED", e[e.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e[e.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e[e.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e[e.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e[e.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e[e.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e[e.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e[e.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e[e.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e[e.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e[e.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e[e.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e[e.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e[e.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e[e.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e[e.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e[e.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e[e.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e[e.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e[e.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e[e.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e[e.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e[e.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e[e.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e[e.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e[e.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e[e.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e[e.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e[e.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e[e.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e[e.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e[e.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e[e.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e[e.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e[e.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e[e.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e[e.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e[e.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e[e.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e[e.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e[e.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e[e.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e[e.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e[e.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e[e.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e[e.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e[e.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e[e.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e[e.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e[e.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e[e.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e[e.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY" }(gT || (gT = {})), function (e) { e[e.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e[e.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e[e.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY" }(mT || (mT = {})), function (e) { e.LEAVE = "LEAVE", e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.UID_BANNED = "UID_BANNED", e.IP_BANNED = "IP_BANNED", e.CHANNEL_BANNED = "CHANNEL_BANNED", e.FALLBACK = "FALLBACK", e.LICENSE_MISSING = "LICENSE_MISSING", e.LICENSE_EXPIRED = "LICENSE_EXPIRED", e.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e.LICENSE_ILLEGAL = "LICENSE_ILLEGAL" }(IT || (IT = {})), function (e) { e.CONNECTION_STATE_CHANGE = "connection-state-change", e.MEDIA_RECONNECT_START = "media-reconnect-start", e.MEDIA_RECONNECT_END = "media-reconnect-end", e.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e.USER_JOINED = "user-joined", e.USER_LEAVED = "user-left", e.USER_PUBLISHED = "user-published", e.USER_UNPUBLISHED = "user-unpublished", e.USER_INFO_UPDATED = "user-info-updated", e.CLIENT_BANNED = "client-banned", e.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e.VOLUME_INDICATOR = "volume-indicator", e.CRYPT_ERROR = "crypt-error", e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e.NETWORK_QUALITY = "network-quality", e.STREAM_TYPE_CHANGED = "stream-type-changed", e.STREAM_FALLBACK = "stream-fallback", e.RECEIVE_METADATA = "receive-metadata", e.STREAM_MESSAGE = "stream-message", e.LIVE_STREAMING_ERROR = "live-streaming-error", e.LIVE_STREAMING_WARNING = "live-streaming-warning", e.INJECT_STREAM_STATUS = "stream-inject-status", e.EXCEPTION = "exception", e.ERROR = "error", e.P2P_LOST = "p2p_lost", e.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e.PUBLISHED_USER_LIST = "published-user-list", e.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e.CONTENT_INSPECT_ERROR = "content-inspect-error", e.CONTENT_INSPECT_RESULT = "content-inspect-result", e.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = "image-moderation-connection-state-change" }(fT || (fT = {})), function (e) { e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.MULTI_IP = "MULTI_IP", e.TIMEOUT = "TIMEOUT", e.OFFLINE = "OFFLINE", e.LEAVE = "LEAVE", e.P2P_FAILED = "P2P_FAILED", e.FALLBACK = "FALLBACK" }(PT || (PT = {})), function (e) { e.CONNECTING = "connecting", e.CONNECTED = "connected", e.RECONNECTING = "reconnecting", e.CLOSED = "closed" }(NT || (NT = {})), function (e) { e.WS_CONNECTED = "ws_connected", e.WS_RECONNECTING = "ws_reconnecting", e.WS_CLOSED = "ws_closed", e.WS_RECONNECT_WAITTING_FINISH = "ws_reconnect_waitting_finish", e.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e.ON_BINARY_DATA = "on_binary_data", e.REQUEST_RECOVER = "request_recover", e.REQUEST_JOIN_INFO = "request_join_info", e.REQUEST_REJOIN_INFO = "req_rejoin_info", e.IS_P2P_DISCONNECTED = "is_p2p_dis", e.DISCONNECT_P2P = "dis_p2p", e.ABORT_P2P_EXECUTION = "abort_p2p_execution", e.NEED_RENEW_SESSION = "need-sid", e.REPORT_JOIN_GATEWAY = "report_join_gateway", e.REQUEST_TIMEOUT = "request_timeout", e.REQUEST_SUCCESS = "request_success", e.JOIN_RESPONSE = "join_response", e.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e.DATACHANNEL_CONNECTING = "datachannel_connecting", e.DATACHANNEL_FAILBACK = "datachannel_failback" }(DT || (DT = {})), function (e) { e.PING = "ping", e.PING_BACK = "ping_back", e.JOIN = "join_v3", e.REJOIN = "rejoin_v3", e.LEAVE = "leave", e.SET_CLIENT_ROLE = "set_client_role", e.PUBLISH = "publish", e.UNPUBLISH = "unpublish", e.SUBSCRIBE = "subscribe", e.SUBSCRIBE_STREAMS = "subscribe_streams", e.UNSUBSCRIBE = "unsubscribe", e.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e.SUBSCRIBE_CHANGE = "subscribe_change", e.TRAFFIC_STATS = "traffic_stats", e.RENEW_TOKEN = "renew_token", e.SWITCH_VIDEO_STREAM = "switch_video_stream", e.DEFAULT_VIDEO_STREAM = "default_video_stream", e.SET_FALLBACK_OPTION = "set_fallback_option", e.GATEWAY_INFO = "gateway_info", e.CONTROL = "control", e.SEND_METADATA = "send_metadata", e.DATA_STREAM = "data_stream", e.PICK_SVC_LAYER = "pick_svc_layer", e.RESTART_ICE = "restart_ice", e.CONNECT_PC = "connect_pc", e.SET_VIDEO_PROFILE = "set_video_profile", e.SET_PARAMETER = "set_parameter" }(vT || (vT = {})), function (e) { e.PUBLISH_STATS = "publish_stats", e.PUBLISH_RELATED_STATS = "publish_related_stats", e.SUBSCRIBE_STATS = "subscribe_stats", e.SUBSCRIBE_RELATED_STATS = "subscribe_related_stats", e.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e.DENOISER_STATS = "denoiser_stats", e.TRANSPORT_STATS = "transport_stats", e.EXTENSION_USAGE_STATS = "extension_usage_stats" }(yT || (yT = {})), function (e) { e.ON_USER_ONLINE = "on_user_online", e.ON_USER_OFFLINE = "on_user_offline", e.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e.ON_PUBLISH_STREAM = "on_publish_stream", e.ON_UPLINK_STATS = "on_uplink_stats", e.ON_P2P_LOST = "on_p2p_lost", e.ON_REMOVE_STREAM = "on_remove_stream", e.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e.ON_USER_BANNED = "on_user_banned", e.ON_USER_LICENSE_BANNED = "on_user_license_banned", e.ON_NOTIFICATION = "on_notification", e.ON_CRYPT_ERROR = "on_crypt_error", e.MUTE_AUDIO = "mute_audio", e.MUTE_VIDEO = "mute_video", e.UNMUTE_AUDIO = "unmute_audio", e.UNMUTE_VIDEO = "unmute_video", e.ON_P2P_OK = "on_p2p_ok", e.RECEIVE_METADATA = "receive_metadata", e.ON_DATA_STREAM = "on_data_stream", e.ENABLE_LOCAL_VIDEO = "enable_local_video", e.DISABLE_LOCAL_VIDEO = "disable_local_video", e.ENABLE_LOCAL_AUDIO = "enable_local_audio", e.DISABLE_LOCAL_AUDIO = "disable_local_audio", e.ON_PUBLISHED_USER_LIST = "on_published_user_list" }(LT || (LT = {})), function (e) { e.CONNECTION_STATE_CHANGE = "CONNECTION_STATE_CHANGE", e.NEED_ANSWER = "NEED_ANSWER", e.NEED_RENEGOTIATE = "NEED_RENEGOTIATE", e.P2P_LOST = "P2P_LOST", e.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e.NEED_UNPUB = "NEED_UNPUB", e.NEED_UNSUB = "NEED_UNSUB", e.NEED_UPLOAD = "NEED_UPLOAD", e.NEED_CONTROL = "NEED_CONTROL", e.START_RECONNECT = "START_RECONNECT", e.END_RECONNECT = "END_RECONNECT", e.NEED_SIGNAL_RTT = "NEED_SIGNAL_RTT" }(wT || (wT = {})), function (e) { e.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e.ON_AUDIO_BUFFER = "on_audio_buffer", e.UPDATE_SOURCE = "update_source" }(bT || (bT = {})); const FT = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, currentPacketLossRate: 0 }, YT = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 }, BT = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }, GT = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }, jT = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }; let HT, WT, KT; !function (e) { e.CONNECTED = "websocket:connected", e.RECONNECTING = "websocket:reconnecting", e.WILL_RECONNECT = "websocket:will_reconnect", e.CLOSED = "websocket:closed", e.FAILED = "websocket:failed", e.ON_MESSAGE = "websocket:on_message", e.REQUEST_NEW_URLS = "websocket:request_new_urls", e.RECONNECT_WAITTING_FINISH = "websocket:reconnect_waitting_finish", e.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire" }(HT || (HT = {})), function (e) { e.TRANSCODE = "mix_streaming", e.RAW = "raw_streaming", e.INJECT = "inject_streaming" }(WT || (WT = {})), function (e) { e[e.INJECT_STREAM_STATUS_START_SUCCESS = 0] = "INJECT_STREAM_STATUS_START_SUCCESS", e[e.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = "INJECT_STREAM_STATUS_START_ALREADY_EXISTS", e[e.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = "INJECT_STREAM_STATUS_START_UNAUTHORIZED", e[e.INJECT_STREAM_STATUS_START_TIMEOUT = 3] = "INJECT_STREAM_STATUS_START_TIMEOUT", e[e.INJECT_STREAM_STATUS_START_FAILED = 4] = "INJECT_STREAM_STATUS_START_FAILED", e[e.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = "INJECT_STREAM_STATUS_STOP_SUCCESS", e[e.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = "INJECT_STREAM_STATUS_STOP_NOT_FOUND", e[e.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = "INJECT_STREAM_STATUS_STOP_UNAUTHORIZED", e[e.INJECT_STREAM_STATUS_STOP_TIMEOUT = 8] = "INJECT_STREAM_STATUS_STOP_TIMEOUT", e[e.INJECT_STREAM_STATUS_STOP_FAILED = 9] = "INJECT_STREAM_STATUS_STOP_FAILED", e[e.INJECT_STREAM_STATUS_BROKEN = 10] = "INJECT_STREAM_STATUS_BROKEN" }(KT || (KT = {})); const JT = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 }, XT = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 }; function qT(e, t) { Qp(e.url, "".concat(t, ".url"), 1, 1e3, !1), eT(e.x) || Xp(e.x, "".concat(t, ".x"), 0, 1e4), eT(e.y) || Xp(e.y, "".concat(t, ".y"), 0, 1e4), eT(e.width) || Xp(e.width, "".concat(t, ".width"), 0, 1e4), eT(e.height) || Xp(e.height, "".concat(t, ".height"), 0, 1e4), eT(e.zOrder) || Xp(e.zOrder, "".concat(t, ".zOrder"), 0, 255), eT(e.alpha) || Xp(e.alpha, "".concat(t, ".alpha"), 0, 1, !1) } const QT = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: !1, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" }, zT = { audioBitrate: 48, audioChannels: 2, audioVolume: 100, audioSampleRate: 48e3, height: 0, width: 0, videoBitrate: 400, videoFramerate: 15, videoGop: 30 }; let ZT, $T, eO, tO, nO, iO, rO, oO, sO, aO, cO, EO, _O, dO, uO, lO, RO, hO, pO, TO, OO; function CO(e) { if (!e.channelName) throw new Ch(Oh.INVALID_PARAMS, "invalid channelName in info"); if ("number" != typeof e.uid) throw new Ch(Oh.INVALID_PARAMS, "invalid uid in info, uid must be a number"); return e.token && Qp(e.token, "info.token", 1, 2047), $p(e.uid), Zp(e.channelName), !0 } function AO(e) { return Jp(e, "mediaSource", ["screen", "window", "application"]), !0 } !function (e) { e.WARNING = "@live_uap-warning", e.ERROR = "@line_uap-error", e.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e.INJECT_STREAM_STATUS = "@live_uap-inject-status", e.WORKER_STATUS = "@live_uap-worker-status", e.REQUEST_NEW_ADDRESS = "@live_uap-request-address" }(ZT || (ZT = {})), function (e) { e.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager" }($T || ($T = {})), function (e) { e[e.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e[e.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e[e.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e[e.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e[e.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e[e.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e[e.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e[e.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e[e.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e[e.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e[e.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e[e.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e[e.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e[e.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e[e.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e[e.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e[e.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e[e.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN" }(eO || (eO = {})), function (e) { e.CONNECT_FAILED = "connect failed", e.CONNECT_TIMEOUT = "connect timeout", e.WS_DISCONNECTED = "websocket disconnected", e.REQUEST_TIMEOUT = "request timeout", e.REQUEST_FAILED = "request failed", e.WAIT_STATUS_TIMEOUT = "wait status timeout", e.WAIT_STATUS_ERROR = "wait status error", e.BAD_STATE = "bad state", e.WS_ABORT = "ws abort", e.AP_REQUEST_TIMEOUT = "AP request timeout", e.AP_JSON_PARSE_ERROR = "AP json parse error", e.AP_REQUEST_ERROR = "AP request error", e.AP_REQUEST_ABORT = "AP request abort" }(tO || (tO = {})), function (e) { e[e.SetSdkProfile = 0] = "SetSdkProfile", e[e.SetSourceChannel = 1] = "SetSourceChannel", e[e.SetSourceUserId = 2] = "SetSourceUserId", e[e.SetDestChannel = 3] = "SetDestChannel", e[e.StartPacketTransfer = 4] = "StartPacketTransfer", e[e.StopPacketTransfer = 5] = "StopPacketTransfer", e[e.UpdateDestChannel = 6] = "UpdateDestChannel", e[e.Reconnect = 7] = "Reconnect", e[e.SetVideoProfile = 8] = "SetVideoProfile" }(nO || (nO = {})), function (e) { e.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e.NETWORK_CONNECTED = "NETWORK_CONNECTED", e.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE" }(iO || (iO = {})), function (e) { e.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE" }(rO || (rO = {})), function (e) { e.RELAY_OK = "RELAY_OK", e.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED" }(oO || (oO = {})), function (e) { e.High = "high", e.Low = "low", e.Audio = "audio", e.Screen = "screen", e.ScreenLow = "screen_low" }(sO || (sO = {})), function (e) { e.DISCONNECT = "disconnect", e.CONNECTION_STATE_CHANGE = "connection-state-change", e.NETWORK_QUALITY = "network-quality", e.STREAM_TYPE_CHANGE = "stream-type-change", e.IS_P2P_DISCONNECTED = "is-p2p-dis", e.DISCONNECT_P2P = "dis-p2p", e.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e.NEED_RENEW_SESSION = "need-sid", e.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e.JOIN_RESPONSE = "join-response", e.REQUEST_DC_CONNECTION_PARAMS = "request-dc-connection-params", e.RESET_CONNECTION_EVENTS = "reset-connection-events", e.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e.DATACHANNEL_FAILBACK = "datachannel_failback", e.RESET_SIGNAL = "reset-signal" }(aO || (aO = {})), function (e) { e[e.Nothing = 0] = "Nothing", e[e.Audio = 1] = "Audio", e[e.LwoVideo = 2] = "LwoVideo", e[e.Video = 4] = "Video", e[e.Data = 8] = "Data" }(cO || (cO = {})), function (e) { e[e.websocket = 0] = "websocket", e[e.datachannel = 1] = "datachannel" }(EO || (EO = {})), function (e) { e.NEED_RENEGOTIATE = "@need_renegotiate", e.NEED_REPLACE_TRACK = "@need_replace_track", e.NEED_CLOSE = "@need_close", e.NEED_ENABLE_TRACK = "@need_enable_track", e.NEED_DISABLE_TRACK = "@need_disable_track", e.NEED_SESSION_ID = "@need_sid", e.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e.GET_STATS = "@get_stats", e.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e.NEED_MUTE_TRACK = "@need_mute_track", e.NEED_UNMUTE_TRACK = "@need_unmute_track" }(_O || (_O = {})), function (e) { e.SCREEN_TRACK = "screen_track", e.CUSTOM_TRACK = "custome_track", e.LOW_STREAM = "low_stream" }(dO || (dO = {})), function (e) { e[e.HIGH_STREAM = 0] = "HIGH_STREAM", e[e.LOW_STREAM = 1] = "LOW_STREAM" }(uO || (uO = {})), function (e) { e[e.HIGH_STREAM = 0] = "HIGH_STREAM", e[e.LOW_STREAM = 1] = "LOW_STREAM" }(lO || (lO = {})), function (e) { e[e.DISABLE = 0] = "DISABLE", e[e.LOW_STREAM = 1] = "LOW_STREAM", e[e.AUDIO_ONLY = 2] = "AUDIO_ONLY" }(RO || (RO = {})), function (e) { e.TRANSCEIVER_UPDATED = "transceiver-updated" }(hO || (hO = {})), function (e) { e.SOURCE_STATE_CHANGE = "source-state-change", e.TRACK_ENDED = "track-ended", e.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e.CLOSED = "closed" }(pO || (pO = {})), function (e) { e.FIRST_FRAME_DECODED = "first-frame-decoded", e.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status" }(TO || (TO = {})), function (e) { e.CHINA = "CHINA", e.ASIA = "ASIA", e.NORTH_AMERICA = "NORTH_AMERICA", e.EUROPE = "EUROPE", e.JAPAN = "JAPAN", e.INDIA = "INDIA", e.KOREA = "KOREA", e.HKMC = "HKMC", e.US = "US", e.OCEANIA = "OCEANIA", e.SOUTH_AMERICA = "SOUTH_AMERICA", e.AFRICA = "AFRICA", e.OVERSEA = "OVERSEA", e.GLOBAL = "GLOBAL", e.EXTENSIONS = "EXTENSIONS" }(OO || (OO = {})); const SO = [OO.AFRICA, OO.ASIA, OO.CHINA, OO.EUROPE, OO.GLOBAL, OO.INDIA, OO.JAPAN, OO.NORTH_AMERICA, OO.OCEANIA, OO.OVERSEA, OO.SOUTH_AMERICA]; let gO; !function (e) { e.CHINA = "CN", e.ASIA = "AS", e.NORTH_AMERICA = "NA", e.EUROPE = "EU", e.JAPAN = "JP", e.INDIA = "IN", e.KOREA = "KR", e.HKMC = "HK", e.US = "US", e.OCEANIA = "OC", e.SOUTH_AMERICA = "SA", e.AFRICA = "AF", e.OVERSEA = "OVERSEA", e.GLOBAL = "GLOBAL", e.EXTENSIONS = "GLOBAL" }(gO || (gO = {})); const mO = { CHINA: {}, ASIA: { CODE: gO.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: gO.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: gO.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: gO.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "\tuap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: gO.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: gO.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: gO.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: gO.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: gO.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: gO.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: gO.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: gO.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: gO.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, EXTENSIONS: {} }; let IO, fO, PO, NO, DO, vO, yO, LO, wO, bO, UO, MO, kO, VO, xO, FO, YO, BO, GO, jO, HO, WO; Lh && (mO.CHINA = { CODE: gO.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] }), function (e) { e.UPDATE_BITRATE_LIMIT = "update_bitrate_limit" }(IO || (IO = {})); class KO extends ph { constructor(e, t) { super(), hl(this, "onICEConnectionStateChange", void 0), hl(this, "onConnectionStateChange", void 0), hl(this, "onDTLSTransportStateChange", void 0), hl(this, "onDTLSTransportError", void 0), hl(this, "onICETransportStateChange", void 0), hl(this, "onFirstAudioReceived", void 0), hl(this, "onFirstVideoReceived", void 0), hl(this, "onFirstAudioDecoded", void 0), hl(this, "onFirstVideoDecoded", void 0), hl(this, "onFirstVideoDecodedTimeout", void 0), hl(this, "onSelectedLocalCandidateChanged", void 0), hl(this, "onSelectedRemoteCandidateChanged", void 0), hl(this, "establishPromise", void 0) } } !function (e) { e.SEND = "sendonly", e.RECV = "recvonly", e.SENDRECV = "sendrecv", e.INACTIVE = "inactive" }(fO || (fO = {})), function (e) { e.VIDEO = "video", e.AUDIO = "audio" }(PO || (PO = {})), function (e) { e[e.UDP = 0] = "UDP", e[e.TCP = 1] = "TCP", e[e.RELAY = 2] = "RELAY" }(NO || (NO = {})), function (e) { e[e.FIRST_CONNECTION = 0] = "FIRST_CONNECTION", e[e.TCP_RESTART = 1] = "TCP_RESTART", e[e.RELAY_RESTART = 2] = "RELAY_RESTART", e[e.OLD_FIRST_CONNECTION = 10] = "OLD_FIRST_CONNECTION", e[e.OLD_RESTART = 11] = "OLD_RESTART", e[e.DISCONNECTED_OR_FAILED = 20] = "DISCONNECTED_OR_FAILED" }(DO || (DO = {})), function (e) { e.LocalVideoTrack = "videoTrack", e.LocalAudioTrack = "audioTrack", e.LocalVideoLowTrack = "videoLowTrack" }(vO || (vO = {})), function (e) { e.New = "new", e.Connected = "connected", e.Reconnecting = "reconnecting", e.Disconnected = "disconnected" }(yO || (yO = {})), function (e) { e.StateChange = "stateChange", e.IceConnectionStateChange = "iceConnectionStateChange", e.RequestMuteLocal = "requestMuteLocal", e.RequestUnmuteLocal = "requestUnmuteLocal", e.RequestRePublish = "requestRePublish", e.RequestReSubscribe = "requestReSubscribe", e.RequestUploadStats = "requestUploadStats", e.MediaReconnectStart = "MediaReconnectStart", e.MediaReconnectEnd = "MediaReconnectEnd", e.NeedSignalRTT = "NeedSignalRTT", e.RequestRestartICE = "RequestRestartIce", e.PeerConnectionStateChange = "PeerConnectionStateChange", e.RequestReconnect = "RequestReconnect", e.RequestReconnectPC = "RequestReconnectPC", e.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e.P2PLost = "P2PLost", e.UpdateVideoEncoder = "UpdateVideoEncoder", e.ConnectionTypeChange = "ConnectionTypeChange", e.RequestLowStreamParameter = "RequestLowStreamParameter", e.QueryClientConnectionState = "QueryClientConnectionState" }(LO || (LO = {})), function (e) { e.ONLINE = "ONLINE", e.OFFLINE = "OFFLINE" }(wO || (wO = {})), function (e) { e.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e.ONLINE = "ONLINE", e.OFFLINE = "OFFLINE" }(bO || (bO = {})), function (e) { e.ON_TRACK = "on_track", e.ON_NODE = "on_node" }(UO || (UO = {})), function (e) { e.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e.REQUEST_CONSTRAINTS = "request_constraints" }(MO || (MO = {})), function (e) { e.CONNECTING = "CONNECTING", e.RECONNECTING = "RECONNECTING", e.CONNECTED = "CONNECTED", e.CLOSED = "CLOSED" }(kO || (kO = {})), function (e) { e[e.CONNECT_AP = 0] = "CONNECT_AP", e[e.AP_CONNECTED = 1] = "AP_CONNECTED", e[e.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e[e.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e[e.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e[e.CONNECT_WORKER = 5] = "CONNECT_WORKER", e[e.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e[e.CLOSED = 7] = "CLOSED" }(VO || (VO = {})), function (e) { e.CONNECTION_STATE_CHANGE = "connection-state-change", e.STATE_CHANGE = "state-change", e.INSPECT_RESULT = "inspect-result", e.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e.REQUEST_NEW_WORKER_URL = "request-new-worker-url" }(xO || (xO = {})), function (e) { e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.MULTI_IP = "MULTI_IP", e.TIMEOUT = "TIMEOUT", e.OFFLINE = "OFFLINE", e.LEAVE = "LEAVE", e.P2P_FAILED = "P2P_FAILED", e.FALLBACK = "FALLBACK" }(FO || (FO = {})), function (e) { e.CONNECTED = "transmitter:connected", e.RECONNECTING = "transmitter:reconnecting", e.WILL_RECONNECT = "transmitter:will_reconnect", e.CLOSED = "transmitter:closed", e.FAILED = "transmitter:failed", e.ON_MESSAGE = "transmitter:on_message", e.REQUEST_NEW_URLS = "transmitter:request_new_urls", e.RECONNECT_WAITTING_FINISH = "transmitter:reconnect_waitting_finish", e.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e.FAILBACK = "transmitter:failback" }(YO || (YO = {})), function (e) { e.CAMERA_CHANGED = "camera-changed", e.MICROPHONE_CHANGED = "microphone-changed", e.PLAYBACK_DEVICE_CHANGED = "playback-device-changed", e.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed", e.AUTOPLAY_FAILED = "autoplay-failed", e.SECURITY_POLICY_VIOLATION = "security-policy-violation" }(BO || (BO = {})), function (e) { e[e.APP_TYPE_INVALID_VALUE = -1] = "APP_TYPE_INVALID_VALUE", e[e.APP_TYPE_NATIVE = 0] = "APP_TYPE_NATIVE", e[e.APP_TYPE_NATIVE_COCOS = 1] = "APP_TYPE_NATIVE_COCOS", e[e.APP_TYPE_NATIVE_UNITY = 2] = "APP_TYPE_NATIVE_UNITY", e[e.APP_TYPE_NATIVE_ELECTRON = 3] = "APP_TYPE_NATIVE_ELECTRON", e[e.APP_TYPE_NATIVE_FLUTTER = 4] = "APP_TYPE_NATIVE_FLUTTER", e[e.APP_TYPE_NATIVE_UNREAL = 5] = "APP_TYPE_NATIVE_UNREAL", e[e.APP_TYPE_NATIVE_XAMARIN = 6] = "APP_TYPE_NATIVE_XAMARIN", e[e.APP_TYPE_NATIVE_API_CLOUD = 7] = "APP_TYPE_NATIVE_API_CLOUD", e[e.APP_TYPE_NATIVE_REACT_NATIVE = 8] = "APP_TYPE_NATIVE_REACT_NATIVE", e[e.APP_TYPE_NATIVE_PYTHON = 9] = "APP_TYPE_NATIVE_PYTHON", e[e.APP_TYPE_NATIVE_COCOS_CREATOR = 10] = "APP_TYPE_NATIVE_COCOS_CREATOR", e[e.APP_TYPE_NATIVE_RUST = 11] = "APP_TYPE_NATIVE_RUST", e[e.APP_TYPE_NATIVE_C_SHARP = 12] = "APP_TYPE_NATIVE_C_SHARP", e[e.APP_TYPE_NATIVE_CEF = 13] = "APP_TYPE_NATIVE_CEF", e[e.APP_TYPE_NATIVE_UNI_APP = 14] = "APP_TYPE_NATIVE_UNI_APP", e[e.APP_TYPE_WEBRTC = 1e3] = "APP_TYPE_WEBRTC", e[e.APP_TYPE_WEBRTC_REACT = 1001] = "APP_TYPE_WEBRTC_REACT", e[e.APP_TYPE_WEBRTC_VUE = 1002] = "APP_TYPE_WEBRTC_VUE", e[e.APP_TYPE_WEBRTC_ANGULAR = 1003] = "APP_TYPE_WEBRTC_ANGULAR" }(GO || (GO = {})), function (e) { e.CONNECTING = "CONNECTING", e.RECONNECTING = "RECONNECTING", e.CONNECTED = "CONNECTED", e.CLOSED = "CLOSED" }(jO || (jO = {})), function (e) { e.CONNECTION_STATE_CHANGE = "connection-state-change", e.STATE_CHANGE = "state-change", e.INSPECT_RESULT = "inspect-result", e.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e.REQUEST_NEW_WORKER_URL = "request-new-worker-url" }(HO || (HO = {})), function (e) { e[e.CONNECT_AP = 0] = "CONNECT_AP", e[e.AP_CONNECTED = 1] = "AP_CONNECTED", e[e.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e[e.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e[e.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e[e.CONNECT_WORKER = 5] = "CONNECT_WORKER", e[e.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e[e.CLOSED = 7] = "CLOSED" }(WO || (WO = {})); const JO = { getDisplayMedia: !1, getStreamFromExtension: !1, supportUnifiedPlan: !1, supportMinBitrate: !1, supportSetRtpSenderParameters: !1, supportDualStream: !0, webAudioMediaStreamDest: !1, supportReplaceTrack: !1, supportWebGL: !1, webAudioWithAEC: !1, supportRequestFrame: !1, supportShareAudio: !1, supportDualStreamEncoding: !1, supportDataChannel: !1, supportPCSetConfiguration: !1, supportWebRTCEncodedTransform: !1 }; function XO() { return JO } let qO; !function (e) { e[e.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e[e.CLOUD_PROXY = 18] = "CLOUD_PROXY", e[e.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e[e.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK" }(qO || (qO = {})); var QO = M, zO = Array.isArray || function (e) { return "Array" == QO(e) }, ZO = l, $O = zO, eC = sc, tC = X, nC = ot("species"), iC = ZO.Array, rC = function (e) { var t; return $O(e) && (t = e.constructor, (eC(t) && (t === iC || $O(t.prototype)) || tC(t) && null === (t = t[nC])) && (t = void 0)), void 0 === t ? iC : t }, oC = function (e, t) { return new (rC(e))(0 === t ? 0 : t) }, sC = Ht, aC = B, cC = Ye, EC = Ln, _C = oC, dC = _([].push), uC = function (e) { var t = 1 == e, n = 2 == e, i = 3 == e, r = 4 == e, o = 6 == e, s = 7 == e, a = 5 == e || o; return function (c, E, _, d) { for (var u, l, R = cC(c), h = aC(R), p = sC(E, _), T = EC(h), O = 0, C = d || _C, A = t ? C(c, T) : n || s ? C(c, 0) : void 0; T > O; O++)if ((a || O in h) && (l = p(u = h[O], O, R), e)) if (t) A[O] = l; else if (l) switch (e) { case 3: return !0; case 5: return u; case 6: return O; case 2: dC(A, u) } else switch (e) { case 4: return !1; case 7: dC(A, u) }return o ? -1 : i || r ? r : A } }, lC = { forEach: uC(0), map: uC(1), filter: uC(2), some: uC(3), every: uC(4), find: uC(5), findIndex: uC(6), filterReject: uC(7) }, RC = lC.forEach, hC = Yn("forEach") ? [].forEach : function (e) { return RC(this, e, arguments.length > 1 ? arguments[1] : void 0) }; In({ target: "Array", proto: !0, forced: [].forEach != hC }, { forEach: hC }); var pC = Kn("Array").forEach, TC = $r, OC = je, CC = d, AC = pC, SC = Array.prototype, gC = { DOMTokenList: !0, NodeList: !0 }, mC = function (e) { var t = e.forEach; return e === SC || CC(SC, e) && t === SC.forEach || OC(gC, TC(e)) ? AC : t }, IC = Ye, fC = lr; In({ target: "Object", stat: !0, forced: i((function () { fC(1) })) }, { keys: function (e) { return fC(IC(e)) } }); var PC = q.Object.keys, NC = zn, DC = In, vC = zO, yC = _([].reverse), LC = [1, 2]; DC({ target: "Array", proto: !0, forced: String(LC) === String(LC.reverse()) }, { reverse: function () { return vC(this) && (this.length = this.length), yC(this) } }); var wC = Kn("Array").reverse, bC = d, UC = wC, MC = Array.prototype, kC = function (e) { var t = e.reverse; return e === MC || bC(MC, e) && t === MC.reverse ? UC : t }, VC = i, xC = ce, FC = ot("species"), YC = function (e) { return xC >= 51 || !VC((function () { var t = []; return (t.constructor = {})[FC] = function () { return { foo: 1 } }, 1 !== t[e](Boolean).foo })) }, BC = In, GC = l, jC = zO, HC = sc, WC = X, KC = Vi, JC = Ln, XC = K, qC = ip, QC = ot, zC = Rc, ZC = YC("slice"), $C = QC("species"), eA = GC.Array, tA = Math.max; BC({ target: "Array", proto: !0, forced: !ZC }, { slice: function (e, t) { var n, i, r, o = XC(this), s = JC(o), a = KC(e, s), c = KC(void 0 === t ? s : t, s); if (jC(o) && (n = o.constructor, (HC(n) && (n === eA || jC(n.prototype)) || WC(n) && null === (n = n[$C])) && (n = void 0), n === eA || void 0 === n)) return zC(o, a, c); for (i = new (void 0 === n ? eA : n)(tA(c - a, 0)), r = 0; a < c; a++, r++)a in o && qC(i, r, o[a]); return i.length = r, i } }); var nA = Kn("Array").slice, iA = d, rA = nA, oA = Array.prototype, sA = function (e) { var t = e.slice; return e === oA || iA(oA, e) && t === oA.slice ? rA : t }; function aA(e, t, n, i, r) { var o, s, a, c = {}; return mC(o = PC(i)).call(o, (function (e) { c[e] = i[e] })), c.enumerable = !!c.enumerable, c.configurable = !!c.configurable, ("value" in c || c.initializer) && (c.writable = !0), c = NC(s = kC(a = sA(n).call(n)).call(a)).call(s, (function (n, i) { return i(e, t, n) || n }), c), r && void 0 !== c.initializer && (c.value = c.initializer ? c.initializer.call(r) : void 0, c.initializer = void 0), void 0 === c.initializer && (Rl(e, t, c), c = null), c } var cA = Kn("Array").keys, EA = $r, _A = je, dA = d, uA = cA, lA = Array.prototype, RA = { DOMTokenList: !0, NodeList: !0 }, hA = function (e) { var t = e.keys; return e === lA || dA(lA, e) && t === lA.keys || _A(RA, EA(e)) ? uA : t }; function pA(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function TA(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? pA(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pA(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } let OA = 0, CA = 0; function AA(e, t, n, i) { return new Cd(((r, o) => { t.timeout = t.timeout || jh("HTTP_CONNECT_TIMEOUT"), t.responseType = t.responseType || "json", t.data && !n ? (t.data = JSON.stringify(t.data), OA += qg(t.data)) : n && (t.data.size ? OA += t.data.size : t.data instanceof FormData ? OA += function (e) { let t = 0; return /DingTalk/i.test(navigator.userAgent) && e.realFormData && (e = e.realFormData), e.forEach((e => { t += "string" == typeof e ? qg(e) : e.size })), t + 138 }(t.data) : OA += qg(JSON.stringify(t.data))), t.headers = t.headers || {}, t.headers["Content-Type"] = t.headers["Content-Type"] || "application/json", t.method = "POST", t.url = e, Rh.request(t).then((e => { "string" == typeof e.data ? CA += qg(e.data) : e.data instanceof ArrayBuffer || e.data instanceof Uint8Array ? CA += e.data.byteLength : CA += qg(JSON.stringify(e.data)), i && r({ data: e.data, headers: e.headers }), r(e.data) })).catch((e => { Rh.isCancel(e) ? o(new Ch(Oh.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e.code ? o(new Ch(Oh.NETWORK_TIMEOUT, e.message)) : e.response ? o(new Ch(Oh.NETWORK_RESPONSE_ERROR, e.response.status)) : o(new Ch(Oh.NETWORK_ERROR, e.message)) })) })) } async function SA(e, t) { const n = new Blob([t.data], { type: "buffer" }); return await AA(e, TA(TA({}, t), {}, { data: n, headers: { "Content-Type": "application/octet-stream" } }), !0) } const gA = new class extends ph { set networkState(e) { Dh.info("[".concat(this._moduleName, "]") + "network state changed, " + this._networkState + " -> " + e), this.emit(bO.NETWORK_STATE_CHANGE, e, this._networkState), e === wO.ONLINE ? this.emit(bO.ONLINE) : e === wO.OFFLINE && (this.onlineWaiter = new Cd((e => { this.once(bO.ONLINE, (() => { this.onlineWaiter = void 0, e(wO.ONLINE) })) })), this.emit(bO.OFFLINE)), this._networkState = e } get networkState() { return this._networkState } constructor() { super(), hl(this, "_moduleName", "network-indicator"), hl(this, "_networkState", wO.ONLINE), hl(this, "onlineWaiter", void 0), window.addEventListener("online", (() => { this.networkState = wO.ONLINE })), window.addEventListener("offline", (() => { this.networkState = wO.OFFLINE })) } }; let mA = !1; const IA = new class extends ph { constructor() { super(...arguments), hl(this, "onAutoplayFailed", void 0), hl(this, "onAudioAutoplayFailed", void 0) } }; function fA() { if (xu(), !mA) { const e = t => { t.preventDefault(), mA = !1, al() ? document.body.removeEventListener("click", e, !0) : (document.body.removeEventListener("touchstart", e, !0), document.body.removeEventListener("mousedown", e, !0)) }; mA = !0, al() ? document.body.addEventListener("click", e, !0) : (document.body.addEventListener("touchstart", e, !0), document.body.addEventListener("mousedown", e, !0)), Dh.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), IA.onAutoplayFailed ? IA.onAutoplayFailed() : IA.onAudioAutoplayFailed ? Dh.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : Dh.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), IA.emit("autoplay-failed") } } function PA(e) { return (new TextEncoder).encode(e) } const NA = function (e, t) { const n = new Uint8Array(e.byteLength + t.byteLength); return n.set(new Uint8Array(e), 0), n.set(new Uint8Array(t), e.byteLength), n }, DA = async e => function (e, t) { let n = ""; return new Uint8Array(e).forEach((e => { n += e.toString(t).padStart(2, "0") })), n }(await crypto.subtle.digest("SHA-256", PA(e)), 16); function vA(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function yA(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? vA(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vA(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function LA() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return function (t, n, i) { const r = i.value; if ("function" == typeof r) { const o = e.className || t.__className__ || ("AgoraRTCClient" === t.constructor.name ? "Client" : t.constructor.name); i.value = function () { for (var t = arguments.length, i = new Array(t), s = 0; s < t; s++)i[s] = arguments[s]; let a = i; if (e.argsMap) try { a = e.argsMap(this, ...i) } catch (e) { Dh.warning(e), a = [] } try { JSON.stringify(a) } catch (e) { Dh.warning("arguments for method ".concat(o, ".").concat(String(n), " not serializable for apiInvoke.")), a = [] } const c = (e.report || wA).reportApiInvoke(this._sessionId || null, { name: "".concat(o, ".").concat(String(n)), options: a, tag: hT.TRACER, reportResult: e.reportResult }, e.throttleTime); try { const t = r.apply(this, i); return t instanceof Cd ? t.then((t => (c.onSuccess(e.reportResult && t), t))).catch((e => { throw c.onError(e), e })) : (c.onSuccess(e.reportResult && t), t) } catch (e) { throw c.onError(e), e } } } return i } } const wA = new class { constructor() { hl(this, "baseInfoMap", new Map), hl(this, "proxyServer", void 0), hl(this, "clientList", zh), hl(this, "eventUploadTimer", void 0), hl(this, "setSessionIdTimer", void 0), hl(this, "url", void 0), hl(this, "backupUrl", void 0), hl(this, "_appId", void 0), hl(this, "keyEventUploadPendingItems", []), hl(this, "normalEventUploadPendingItems", []), hl(this, "apiInvokeUploadPendingItems", []), hl(this, "apiInvokeCount", 0), hl(this, "ltsList", []), hl(this, "lastSendNormalEventTime", Date.now()), hl(this, "customReportCounterTimer", void 0), hl(this, "customReportCount", 0), hl(this, "extApiInvoke", (async e => { for (const t of e) { const e = yA(yA({}, t), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: hT.TRACER }); this.sendApiInvoke(e) } })), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), jh("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), jh("EVENT_REPORT_SEND_INTERVAL")) } adjustSessionStartTime(e) { if (!this.baseInfoMap.has(e) && !this.baseInfoMap.get(e)) return void Dh.error("adjust session ".concat(e, " start time, sid is not exist or info is undefined")); const t = this.baseInfoMap.get(e), n = Date.now(), i = t.startTime; t.startTime = n, Dh.debug("rewrite session ".concat(e, " startTime: ").concat(n, " , ").concat(n - i, "ms")), this.baseInfoMap.set(e, t) } setAppId(e) { this._appId = e } reportApiInvoke(e, t, n) { t.timeout = t.timeout || 6e4, t.reportResult = void 0 === t.reportResult || t.reportResult; const i = Date.now(); this.apiInvokeCount += 1; const r = this.apiInvokeCount, o = () => ({ tag: t.tag, invokeId: r, sid: e, name: t.name, apiInvokeTime: i, options: t.options, states: t.states || null }), s = !!jh("SHOW_REPORT_INVOKER_LOG"); s && Dh.info("".concat(t.name, " start"), t.options); let a = !1; Qg(t.timeout).then((() => { a || (this.sendApiInvoke(yA(yA({}, o()), {}, { error: Oh.API_INVOKE_TIMEOUT, success: !1 })), Dh.debug("".concat(t.name, " timeout"))) })); const c = new Ch(Oh.UNEXPECTED_ERROR, "".concat(t.name, ": this api invoke is end")); return { onSuccess: e => { const i = () => { if (a) throw c; return a = !0, this.sendApiInvoke(yA(yA({}, o()), {}, { success: !0 }, t.reportResult && { result: e })), s && Dh.info("".concat(t.name, " onSuccess")), e }; return n ? pm(i, t.name + "Success", n, (() => a = !0)) : i() }, onError: e => { const i = () => { if (a) throw e; a = !0, this.sendApiInvoke(yA(yA({}, o()), {}, { success: !1, error: e })), s && Dh.info("".concat(t.name, " onFailure"), e.toString()) }; return n ? pm(i, t.name + "Error", n, (() => a = !0)) : i() } } } sessionInit(e, t) { if (this.baseInfoMap.has(e)) return; const n = Date.now(), i = this.createBaseInfo(e, n); i.cname = t.cname; const r = Object.assign({}, { willUploadConsoleLog: jh("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: Lh ? "global" : "oversea", areas: jh("AREAS") && jh("AREAS").join(",") }, t.extend), o = Date.now(), s = yA(yA({}, i), {}, { eventType: _T.SESSION_INIT, appid: t.appid, browser: navigator.userAgent, build: vh, lts: o, elapse: o - n, extend: JSON.stringify(r), mode: t.mode, process: jh("PROCESS_ID"), appType: jh("APP_TYPE"), success: !0, version: yh }); this.send({ type: dT.SESSION, data: s }, !0) } joinChooseServer(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA({}, i), {}, { eventType: _T.JOIN_CHOOSE_SERVER, lts: r, eventElapse: r - t.lts, chooseServerAddr: t.csAddr, errorCode: t.ec, elapse: r - n.startTime, success: t.succ, chooseServerAddrList: JSON.stringify(t.serverList), uid: t.uid ? parseInt(t.uid) : null, cid: t.cid ? parseInt(t.cid) : null, chooseServerIp: t.csIp || "", opid: t.opid, unilbsServerIds: t.unilbsServerIds, extend: t.extend || void 0, isHttp3: t.isHttp3 }); this.send({ type: dT.JOIN_CHOOSE_SERVER, data: o }, !0) } reqUserAccount(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA({}, i), {}, { eventType: _T.REQ_USER_ACCOUNT, lts: r, success: t.success, serverAddress: t.serverAddr, stringUid: t.stringUid, uid: t.uid, errorCode: t.errorCode, elapse: r - n.startTime, eventElapse: r - t.lts, extend: JSON.stringify(t.extend) }); this.send({ type: dT.REQ_USER_ACCOUNT, data: o }, !0) } joinGateway(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info; t.vid && (i.vid = t.vid), i.uid = t.uid, i.cid = t.cid; const r = Date.now(), { firstSuccess: o, avoidJoinStartTime: s, isProxy: a, addr: c } = t, E = r - (o && s ? s : n.startTime), _ = yA(yA({}, i), {}, { eventType: _T.JOIN_GATEWAY, lts: r, gatewayAddr: t.addr, success: t.succ, errorCode: t.ec, elapse: E, eventElapse: r - t.lts, firstSuccess: o, signalChannel: t.signalChannel }), d = _.success ? 1 : 0; if (t.succ && (n.lastJoinSuccessTime = r), o) this.send({ type: dT.JOIN_GATEWAY, data: _ }, !0); else { let e; if (c) if (a) { const t = c.match(/h=(\d{1,3}-){3}\d{1,3}/g), n = c.match(/p=[0-9]{1,6}/g); e = { isSuccess: d, gatewayIp: t && t.length ? t[0].split("=")[1].replace(/-/g, ".") : "", port: n && n.length ? n[0].split("=")[1] : "", isProxy: a ? 1 : 0 } } else { const t = c.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), n = c.match(/:[0-9]{1,6}/g); e = { isSuccess: d, gatewayIp: t && t.length ? t[0].split("//")[1].replace(/-/g, ".") : "", port: n && n.length ? n[0].split(":")[1] : "", isProxy: a ? 1 : 0 } } else e = { isSuccess: d, gatewayIp: "", port: "", isProxy: a ? 1 : 0 }; delete _.success, delete _.eventType, delete _.firstSuccess, _.vid = Number(_.vid); const t = Object.assign({}, _, e, { eventType: _T.REJOIN_GATEWAY }); this.send({ type: dT.RE_JOIN_GATEWAY, data: t }, !0) } } joinChannelTimeout(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = Date.now(), r = yA(yA({}, n.info), {}, { lts: i, timeout: t, elapse: i - n.startTime }); this.send({ type: dT.JOIN_CHANNEL_TIMEOUT, data: r }, !0) } publish(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA({}, i), {}, { eventType: _T.PUBLISH, lts: r, eventElapse: t.eventElapse, elapse: r - n.startTime, success: t.succ, errorCode: t.ec, videoName: t.videoName, audioName: t.audioName, screenName: t.screenName, screenshare: t.screenshare, audio: t.audio, video: t.video, p2pid: t.p2pid, publishRequestid: t.publishRequestid }); this.send({ type: dT.PUBLISH, data: o }, !0) } subscribe(e, t, n) { const i = this.baseInfoMap.get(e); if (!i) return; const r = i.info, o = Date.now(), s = yA(yA({}, r), {}, { eventType: _T.SUBSCRIBE, lts: o, eventElapse: t.eventElapse, elapse: o - i.startTime, success: t.succ, errorCode: t.ec, video: t.video, audio: t.audio, subscribeRequestid: t.subscribeRequestid, p2pid: t.p2pid }, n && { extend: JSON.stringify({ isMassSubscribe: !0 }) }); "string" == typeof t.peerid ? s.peerSuid = t.peerid : s.peer = t.peerid, this.send({ type: dT.SUBSCRIBE, data: s }, !0) } wsCompressorInit(e) { var t; const n = [...hA(t = this.baseInfoMap).call(t)], i = n.length ? n[0] : "UnableToGetSid", r = this.baseInfoMap.get(i); if (!r) return; const o = r.info, s = Date.now(), a = yA(yA({}, o), {}, { eventType: _T.WS_COMPRESSOR_INIT, lts: s, eventElapse: e.eventElapse, elapse: s - r.startTime, status: e.status ? 1 : 2 }); this.send({ type: dT.WS_COMPRESSOR_INIT, data: a }, !0) } firstRemoteVideoDecode(e, t, n, i) { const r = this.baseInfoMap.get(e); if (!r) return; const o = r.info, s = Date.now(), a = yA(yA(yA({}, o), i), {}, { elapse: s - r.startTime, eventType: t, lts: s, firstDecodeFrame: Math.max(s - r.startTime, 0), apEnd: Math.max(i.apEnd - r.startTime, 0), apStart: Math.max(i.apStart - r.startTime, 0), joinGwEnd: Math.max(i.joinGwEnd - r.startTime, 0), joinGwStart: Math.max(i.joinGwStart - r.startTime, 0), pcEnd: Math.max(i.pcEnd - r.startTime, 0), pcStart: Math.max(i.pcStart - r.startTime, 0), subscriberEnd: Math.max(i.subscriberEnd - r.startTime, 0), subscriberStart: Math.max(i.subscriberStart - r.startTime, 0), videoAddNotify: Math.max(i.videoAddNotify - r.startTime, 0) }); this.send({ type: n, data: a }, !0) } firstRemoteFrame(e, t, n, i) { const r = this.baseInfoMap.get(e); if (!r) return; const o = r.info, s = Date.now(), a = yA(yA(yA({}, o), i), {}, { elapse: s - r.startTime, eventType: t, lts: s }); this.send({ type: n, data: a }, !0) } pcStats(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA(yA({}, i), t), {}, { vid: void 0 === i.vid ? 0 : Number(i.vid), elapse: r - n.startTime, eventType: _T.PC_STATS, lts: r }); this.send({ type: dT.PC_STATS, data: o }, !0) } onGatewayStream(e, t, n, i) { const r = this.baseInfoMap.get(e); if (!r) return; const o = r.info, s = Date.now(), a = yA(yA(yA({}, o), i), {}, { eventType: t, lts: s }); this.send({ type: n, data: a }, !0) } streamSwitch(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA({}, i), {}, { eventType: _T.STREAM_SWITCH, lts: r, isDual: t.isdual, elapse: r - n.startTime, success: t.succ }); this.send({ type: dT.STREAM_SWITCH, data: o }, !0) } requestProxyAppCenter(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA({}, i), {}, { eventType: _T.REQUEST_PROXY_APPCENTER, lts: r, eventElapse: r - t.lts, elapse: r - n.startTime, APAddr: t.APAddr, workerManagerList: t.workerManagerList, response: t.response, errorCode: t.ec, success: t.succ }); this.send({ type: dT.REQUEST_PROXY_APPCENTER, data: o }, !0) } requestProxyWorkerManager(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA({}, i), {}, { eventType: _T.REQUEST_PROXY_WORKER_MANAGER, lts: r, eventElapse: r - t.lts, elapse: r - n.startTime, workerManagerAddr: t.workerManagerAddr, response: t.response, errorCode: t.ec, success: t.succ }); this.send({ type: dT.REQUEST_PROXY_WORKER_MANAGER, data: o }, !0) } setProxyServer(e) { this.proxyServer = e, e ? Dh.debug("reportProxyServerurl: ".concat(e)) : Dh.debug("disable reportProxyServerurl: ".concat(e)) } peerPublishStatus(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA({}, i), {}, { subscribeElapse: t.subscribeElapse, peer: t.peer, peerPublishDuration: Math.max(t.audioPublishDuration, t.videoPublishDuration), audiotag: t.audioPublishDuration > 0 ? 1 : -1, videotag: t.videoPublishDuration > 0 ? 1 : -1, lts: r, elapse: r - n.startTime, joinChannelSuccessElapse: r - (n.lastJoinSuccessTime || r), peerPublishDurationVideo: t.videoPublishDuration, peerPublishDurationAudio: t.audioPublishDuration }); this.send({ type: dT.PEER_PUBLISH_STATUS, data: o }, !0) } workerEvent(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(); (function (e, t, n) { const i = e[t]; if (!i || "string" != typeof i) return [e]; e[t] = ""; const r = qg(JSON.stringify(e)); let o = 0; const s = []; let a = 0; for (let c = 0; c < i.length; c++)a += i.charCodeAt(c) <= 127 ? 1 : 3, a <= n - r || (s[s.length] = Xg(Xg({}, e), {}, { [t]: i.substring(o, c) }), o = c, a = i.charCodeAt(c) <= 127 ? 1 : 3); return o !== i.length - 1 && (s[s.length] = Xg(Xg({}, e), {}, { [t]: i.substring(o) })), s })(yA(yA(yA({}, i), t), {}, { elapse: r - n.startTime, lts: r, productType: "WebRTC" }), "payload", 1300).forEach((e => this.send({ type: dT.WORKER_EVENT, data: e }, !0))) } apworkerEvent(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA(yA({}, i), t), {}, { elapse: r - n.startTime, lts: r }); this.send({ type: dT.AP_WORKER_EVENT, data: o }, !0) } joinWebProxyAP(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA(yA({}, i), t), {}, { elapse: r - n.startTime, lts: r, extend: t.extend || void 0 }); this.send({ type: dT.JOIN_WEB_PROXY_AP, data: o }, !0) } WebSocketQuit(e, t) { const n = this.baseInfoMap.get(e); if (!n) return; const i = n.info, r = Date.now(), o = yA(yA(yA({}, i), t), {}, { elapse: r - n.startTime, lts: r }); this.send({ type: dT.WEBSOCKET_QUIT, data: o }, !0) } async sendCustomReportMessage(e, t) { if (this.customReportCount += t.length, this.customReportCount > jh("CUSTOM_REPORT_LIMIT")) throw new Ch(Oh.CUSTOM_REPORT_FREQUENCY_TOO_HIGH); this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval((() => { this.customReportCount = 0 }), 5e3)); const n = Date.now(), i = t.map((t => ({ type: dT.USER_ANALYTICS, data: yA(yA({ sid: e }, t), {}, { lts: n }) }))); try { jh("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(i) : await this.postDataToStatsCollector(i) } catch (e) { throw Dh.error("send custom report message failed", e.toString()), new Ch(Oh.CUSTOM_REPORT_SEND_FAILED, e.message) } } autoplayFailed(e, t, n, i) { if (!e) return; const r = this.baseInfoMap.get(e); if (!r) return; const o = r.info, s = Date.now(), a = yA(yA({}, o), {}, { vid: void 0 === o.vid ? 0 : Number(o.vid), lts: s, elapse: s - r.startTime, cbRegistered: IA.onAutoplayFailed || IA.onAudioAutoplayFailed ? 1 : -1, errorMsg: n, mediaType: t, trackId: i, extend: void 0 }); this.send({ type: dT.AUTOPLAY_FAILED, data: a }, !0) } sendApiInvoke(e) { const t = jh("NOT_REPORT_EVENT"); if (e.tag && t.includes && t.includes(e.tag)) return !1; if (null === e.sid) return this.apiInvokeUploadPendingItems.push(e), !1; const n = this.baseInfoMap.get(e.sid); if (!n) return this.apiInvokeUploadPendingItems.push(e), !1; const { cname: i, uid: r, cid: o } = n.info; let s; if (e.lts = e.lts || Date.now(), e.error) if (e.error instanceof Ch) { const { code: t, message: n } = e.error; s = t || n || e.error.toString() } else s = e.error.toString(); const a = { invokeId: e.invokeId, sid: e.sid, cname: i, cid: o, uid: r, lts: e.lts, success: e.success, elapse: e.lts - n.startTime, execElapse: e.lts - e.apiInvokeTime, apiName: e.name, options: e.options ? JSON.stringify(e.options) : void 0, execStates: e.states ? JSON.stringify(e.states) : void 0, execResult: e.result ? JSON.stringify(e.result) : void 0, errorCode: e.error ? s : void 0, errorMsg: e.error ? JSON.stringify(e.error) : void 0 }; return this.send({ type: dT.API_INVOKE, data: a }, !1), !0 } appendSessionId() { this.clientList.forEach((e => { if (e._sessionId) { const t = this.apiInvokeUploadPendingItems.length; for (let n = 0; n < t; n++) { const t = this.apiInvokeUploadPendingItems.shift(); t && (t.sid = e._sessionId, this.sendApiInvoke(Object.assign({}, t))) } } })) } send(e, t) { if (t) return this.keyEventUploadPendingItems.push(e), void this.sendItems(this.keyEventUploadPendingItems, !0); this.normalEventUploadPendingItems.push(e), this.normalEventUploadPendingItems.length > jh("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, !1) } doSend() { this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, !0), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, !1) } sendItems(e, t) { const n = [], i = []; for (; e.length;) { const t = e.shift(); n.length < 20 ? n.push(t) : i.push(t) } e.push(...i); for (const o of [...n]) { var r; -1 !== this.ltsList.indexOf(o.data.lts) ? (o.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(o.data.lts)) : (this.ltsList.push(o.data.lts), Wp(r = this.ltsList).call(r, ((e, t) => e - t))) } return t || (this.lastSendNormalEventTime = Date.now()), jh("ENABLE_EVENT_REPORT") ? (n.length && (jh("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(n) : this.postDataToStatsCollector(n)).catch((e => n => { jh("EVENT_REPORT_RETRY") && (t ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e), this.normalEventUploadPendingItems.length > jh("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - jh("NORMAL_EVENT_QUEUE_CAPACITY")), Dh.warning("report: drop normal events")))) })(n)), e) : e } async postDataToStatsCollector2(e) { gA.networkState === wO.OFFLINE && await Cd.race([gA.onlineWaiter, Qg(2 * Ah.maxRetryTimeout)]); const t = e => { let t = new Uint8Array; return e.forEach((e => { const n = PA(JSON.stringify(e.data)), i = new ArrayBuffer(5), r = (e => { let t = 0; return Object.entries(dT).forEach((n => { let [i, r] = n; r === e.type && (t = lT[i]) })), t })(e), o = new DataView(i); o.setUint16(0, n.byteLength, !0), o.setUint8(2, 255 & r), o.setUint8(3, r >>> 8 & 255), o.setUint8(4, r >>> 16 & 255), t = NA(t, new Uint8Array(i)), t = NA(t, n) })), t }, n = "event"; let i = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(jh("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(n) : "https://".concat(jh("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(n); for (let r = 0; r < 2; r += 1) { 1 === r && (i = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(jh("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(n) : "https://".concat(jh("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(n)); try { await AA(i, { timeout: 1e4, data: t(e), headers: yA(yA({ biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, !0) } catch (e) { if (1 === r) throw e; continue } return } } async postDataToStatsCollector(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e.map((e => JSON.stringify(e))), vid: (e => { const t = e && e.data.sid && this.baseInfoMap.get(e.data.sid); return t && t.info.vid && +t.info.vid || 0 })(e[0]) }; gA.networkState === wO.OFFLINE && await Cd.race([gA.onlineWaiter, Qg(2 * Ah.maxRetryTimeout)]); const i = t ? "/events/proto-raws" : "/events/messages"; let r = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(jh("EVENT_REPORT_DOMAIN"), "&p=").concat(jh("STATS_COLLECTOR_PORT"), "&d=").concat(i) : "https://".concat(jh("EVENT_REPORT_DOMAIN"), ":").concat(jh("STATS_COLLECTOR_PORT")).concat(i)); for (let o = 0; o < 2; o += 1) { 1 === o && (r = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(jh("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(jh("STATS_COLLECTOR_PORT"), "&d=").concat(i) : "https://".concat(jh("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(jh("STATS_COLLECTOR_PORT")).concat(i))); try { t ? await SA(r, { timeout: 1e4, data: n }) : await AA(r, { timeout: 1e4, data: n }) } catch (t) { if (1 === o) throw t; continue } return } } createBaseInfo(e, t) { const n = Object.assign({}, ET); return n.sid = e, this.baseInfoMap.set(e, { info: n, startTime: t }), n } reportResourceTiming(e, t) { const n = performance.getEntriesByName(e), i = n[n.length - 1]; i && this.reportApiInvoke(t, { name: "Client.resourceTiming", options: i, tag: hT.TRACER }).onSuccess() } }; Th.on("REPORT_LOG_UPLOAD", (e => { e.networkState = gA.networkState, wA.reportApiInvoke(null, { name: "logUploadError", options: e, tag: hT.TRACER }) })); class bA extends ph { constructor(e, t) { super(), hl(this, "trackMediaType", void 0), hl(this, "_ID", void 0), hl(this, "_rtpTransceiver", void 0), hl(this, "_lowRtpTransceiver", void 0), hl(this, "_hints", []), hl(this, "_isClosed", !1), hl(this, "_originMediaStreamTrack", void 0), hl(this, "_mediaStreamTrack", void 0), hl(this, "_external", {}), this._ID = t || Zg(8, "track-"), this._originMediaStreamTrack = e, this._mediaStreamTrack = e, function (e) { Zh.includes(e) || Zh.push(e) }(this) } toString() { return this._ID } getTrackId() { return this._ID } getMediaStreamTrack(e) { if (!e) { const e = wA.reportApiInvoke(null, { name: RT.GET_MEDIA_STREAM_TRACK, options: [], tag: hT.TRACER }); this._mediaStreamTrack && "string" == typeof this._mediaStreamTrack.label ? e.onSuccess(this._mediaStreamTrack.label) : e.onSuccess("") } return this._mediaStreamTrack } getRTCRtpTransceiver(e) { return e === uO.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver } getMediaStreamTrackSettings() { return this.getMediaStreamTrack(!0).getSettings() } close() { this._isClosed = !0, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function (e) { const t = Zh.indexOf(e); -1 !== t && Zh.splice(t, 1) }(this), this.emit(pO.CLOSED) } _updateRtpTransceiver(e, t) { if (t === uO.LOW_STREAM) { if (this._lowRtpTransceiver === e) return; this._lowRtpTransceiver = e } else { if (this._rtpTransceiver === e) return; this._rtpTransceiver = e } this.emit(hO.TRANSCEIVER_UPDATED, e, t) } } let UA, MA = 1; class kA { constructor(e) { hl(this, "lockingPromise", Cd.resolve()), hl(this, "locks", 0), hl(this, "name", ""), hl(this, "lockId", void 0), this.lockId = MA++, e && (this.name = e), Dh.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is created.")) } get isLocked() { return this.locks > 0 } lock(e) { let t; this.locks += 1, Dh.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e ? e : "")); const n = new Cd((n => { t = () => { this.locks -= 1, Dh.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is not locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e ? e : "")), n() } })), i = this.lockingPromise.then((() => t)); return this.lockingPromise = this.lockingPromise.then((() => n)), i } } function VA(e, t) { return function (n, i, r) { const o = r.value; if ("function" != typeof o) throw new Error("Cannot use mutex on object property."); return r.value = async function () { const n = this[t]; if (!n) throw new Error("mutex property key ".concat(t, " doesn't exist on ").concat(e)); const r = await n.lock("From ".concat(e, ".").concat(i)); try { for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++)a[c] = arguments[c]; return await o.apply(this, a) } finally { r() } }, r } } class xA extends bA { get isExternalTrack() { return this._isExternalTrack } get muted() { return this._muted } get enabled() { return this._enabled } get processorContext() { return this._processorContext } set processorContext(e) { this._processorContext = e } constructor(e, t) { super(e, t), hl(this, "_enabled", !0), hl(this, "_muted", !1), hl(this, "_isExternalTrack", !1), hl(this, "_isClosed", !1), hl(this, "_enabledMutex", void 0), hl(this, "processor", void 0), hl(this, "_processorContext", void 0), hl(this, "_handleTrackEnded", (() => { this.onTrackEnded() })), this._enabledMutex = new kA("".concat(this.getTrackId())), e.addEventListener("ended", this._handleTrackEnded) } getTrackLabel() { var e, t; return null !== (e = null === (t = this._originMediaStreamTrack) || void 0 === t ? void 0 : t.label) && void 0 !== e ? e : "" } close() { this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, Dh.debug("[".concat(this.getTrackId(), "] close")), this.emit(_O.NEED_CLOSE), super.close()) } async _updateOriginMediaStreamTrack(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; this._isExternalTrack = n, e !== this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t && this._originMediaStreamTrack.stop(), e.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = !1), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rm(this, _O.NEED_REPLACE_TRACK, this), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext })) } _getDefaultPlayerConfig() { return {} } onTrackEnded() { Dh.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(pO.TRACK_ENDED) } stateCheck(e, t) { if (Dh.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e, ": ").concat(t, "]")), Kp(t, e), this._enabled && this._muted && "enabled" === e && !1 === t) throw new Ch(Oh.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print(); if (!this._enabled && !this._muted && "muted" === e && !0 === t) throw new Ch(Oh.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print() } getProcessorStats() { return this.processorContext.gatherStats() } getProcessorUsage() { return this.processorContext.gatherUsage() } } function FA(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } !function (e) { e.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start", e.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end", e.IOS_INTERRUPTION_START = "ios-interruption-start", e.IOS_INTERRUPTION_END = "ios-interruption-end", e.STATE_CHANGE = "state-change" }(UA || (UA = {})); const YA = window.AudioContext || window.webkitAudioContext; let BA = null; const GA = new class extends ph { constructor() { super(...arguments), hl(this, "prevState", void 0), hl(this, "curState", void 0), hl(this, "currentTime", void 0), hl(this, "currentTimeStuckAt", void 0), hl(this, "interruptDetectorTrack", void 0), hl(this, "onLocalAudioTrackMute", (() => { Dh.info("ios15-interruption-start"), this.emit(UA.IOS_15_16_INTERRUPTION_START) })), hl(this, "onLocalAudioTrackUnmute", (async () => { Dh.info("ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? Dh.info("ios15-interruption-end-canceled") : (BA && await BA.suspend(), this.emit(UA.IOS_15_16_INTERRUPTION_END)) })) } get duringInterruption() { return "running" === this.prevState && "interrupted" === this.curState } bindInterruptDetectorTrack(e) { Dh.debug("webaudio bindInterruptDetectorTrack ".concat(e.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute) } unbindInterruptDetectorTrack(e) { Dh.debug("webaudio unbindInterruptDetectorTrack ".concat(e.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0) } }; function jA() { if (!YA) return void Dh.error("your browser is not support web audio"); Dh.info("create audio context"); const e = function (e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? FA(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FA(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e }({}, jh("WEBAUDIO_INIT_OPTIONS")); Dh.debug("audio context init option:", JSON.stringify(e)), BA = new YA(e), GA.curState = BA.state, BA.onstatechange = () => { GA.prevState = GA.curState, GA.curState = BA ? BA.state : void 0; const { prevState: e, curState: t } = GA, n = "running" === t, i = "interrupted" === t, r = "running" === e, o = "suspended" === e, s = "interrupted" === e, a = xu().osVersion; (Ju() || nl()) && r && i && (Dh.info("ios".concat(a, "-interruption-start")), GA.emit(UA.IOS_INTERRUPTION_START)), (Ju() || nl()) && (o || s) && n && (Dh.info("ios".concat(a, "-interruption-end")), GA.emit(UA.IOS_INTERRUPTION_END)), e !== t && (Dh.debug("AudioContext State Change", "".concat(e, "=>").concat(t)), GA.emit(UA.STATE_CHANGE)) }, setInterval((() => { var e; const t = null === (e = BA) || void 0 === e ? void 0 : e.currentTime; GA.currentTime !== t ? (GA.currentTimeStuckAt && (Dh.debug("AudioContext current time resume at ".concat(t)), GA.currentTimeStuckAt = void 0), GA.currentTime = t) : (t !== GA.currentTimeStuckAt && (wA.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: t }, tag: hT.TRACER }).onSuccess(), Dh.warning("AudioContext current time stuck at ".concat(t))), GA.currentTimeStuckAt = t) }), 5e3), async function (e) { const t = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"]; let n, i = !1, r = !1, o = !1; function s(t) { "running" === e.state ? a(!1) : Ju() || nl() ? "suspended" === e.state && (a(!0), t && e.resume().then(E, E)) : "closed" !== e.state && (a(!0), t && e.resume().then(E, E)) } function a(e) { if (i !== e) { i = e; for (let n = 0, i = t; n < i.length; n += 1) { const t = i[n]; e ? window.addEventListener(t, _, { capture: !0, passive: !0 }) : window.removeEventListener(t, _, { capture: !0, passive: !0 }) } } } function c() { s(!0) } function E() { s(!1) } function _() { s(!0) } function d(e) { if (!o) if (n.paused) if (e) { let t; u(!1), o = !0; try { t = n.play(), t ? t.then(l, l) : (n.addEventListener("playing", l), n.addEventListener("abort", l), n.addEventListener("error", l)) } catch (e) { l() } } else u(!0); else u(!1) } function u(e) { if (r !== e) { r = e; for (let n = 0, i = t; n < i.length; n++) { const t = i[n]; e ? window.addEventListener(t, R, { capture: !0, passive: !0 }) : window.removeEventListener(t, R, { capture: !0, passive: !0 }) } } } function l() { n.removeEventListener("playing", l), n.removeEventListener("abort", l), n.removeEventListener("error", l), o = !1, d(!1) } function R() { d(!0) } if (Ju()) { const t = e.createMediaStreamDestination(), i = document.createElement("div"); i.innerHTML = "<audio x-webkit-airplay='deny'></audio>", n = i.children.item(0), n.controls = !1, n.disableRemotePlayback = !0, n.preload = "auto", n.srcObject = t.stream, d(!0) } GA.on(UA.STATE_CHANGE, c), s(!1) }(BA) } function HA() { if (!BA) { if (jA(), !BA) throw new Ch(Oh.NOT_SUPPORTED, "can not create audio context"); return BA } return BA } function WA() { return !!BA } function KA(e) { if (function () { if (null !== JA) return JA; const e = HA(), t = e.createBufferSource(), n = e.createGain(), i = e.createGain(); t.connect(n), t.connect(i), t.disconnect(n); let r = !1; try { t.disconnect(n) } catch (e) { r = !0 } return t.disconnect(), JA = r, r }()) return; const t = e.connect, n = e.disconnect; e.connect = (n, i, r) => (e._inputNodes || (e._inputNodes = []), e._inputNodes.includes(n) || (n instanceof AudioNode ? (e._inputNodes.push(n), t.call(e, n, i, r)) : t.call(e, n, i)), e), e.disconnect = (i, r, o) => { n.call(e), i ? am(e._inputNodes, i) : e._inputNodes = []; for (const n of e._inputNodes) t.call(e, n) } } let JA = null; function XA(e, t) { let n = !1; const i = 1 / t; if (jh("DISABLE_WEBAUDIO")) { const t = window.setInterval((() => { n ? window.clearInterval(t) : e(performance.now() / 1e3) }), 1e3 * i) } else { const t = HA(); let r = t.createGain(); r.gain.value = 0, r.connect(t.destination); const o = () => { if (n) return void (r = null); const s = t.createOscillator(); s.onended = o, s.connect(r), s.start(0), s.stop(t.currentTime + i), e(t.currentTime) }; o() } return () => { n = !0 } } class qA { constructor() { hl(this, "context", void 0), hl(this, "analyserNode", void 0), hl(this, "sourceNode", void 0), this.context = HA(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = .4 } updateSource(e) { if (e !== this.sourceNode) { if (this.sourceNode) try { this.sourceNode.disconnect(this.analyserNode) } catch (e) { } this.sourceNode = e, null == e || e.connect(this.analyserNode) } } getVolumeLevel() { if (!this.sourceNode) return 0; if (!this.context || Ju() || nl() || "running" !== this.context.state && this.context.resume(), !this.analyserNode) return 0; const e = new Float32Array(this.analyserNode.fftSize); if (this.analyserNode.getFloatTimeDomainData) this.analyserNode.getFloatTimeDomainData(e); else { const t = new Uint8Array(this.analyserNode.fftSize); this.analyserNode.getByteTimeDomainData(t); for (let n = 0; n < e.length; ++n)e[n] = t[n] / 128 - 1 } const t = Zn(e).call(e, ((e, t) => e + t * t), 0) / e.length; return Math.max(10 * Math.log10(t) + 100, 0) / 100 } getAnalyserNode() { return this.analyserNode } rebuildAnalyser() { try { var e, t; null === (e = this.sourceNode) || void 0 === e || e.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = .4, null === (t = this.sourceNode) || void 0 === t || t.connect(this.analyserNode) } catch (e) { Dh.warning("rebuild analyser node failed.") } } destroy() { this.updateSource(void 0) } } class QA extends ph { get processSourceNode() { return this.sourceNode } set processedNode(e) { var t; if (!this.isDestroyed && this._processedNode !== e) { try { var n; null === (n = this.sourceNode) || void 0 === n || n.disconnect(this.outputNode) } catch (e) { } null === (t = this._processedNode) || void 0 === t || t.disconnect(), this._processedNode = e, this.connect() } } get processedNode() { return this._processedNode } constructor() { super(), hl(this, "outputNode", void 0), hl(this, "outputTrack", void 0), hl(this, "isPlayed", !1), hl(this, "sourceNode", void 0), hl(this, "context", void 0), hl(this, "audioBufferNode", void 0), hl(this, "destNode", void 0), hl(this, "audioOutputLevel", 0), hl(this, "volumeLevelAnalyser", void 0), hl(this, "_processedNode", void 0), hl(this, "playNode", void 0), hl(this, "isDestroyed", !1), hl(this, "onNoAudioInput", void 0), hl(this, "isNoAudioInput", !1), hl(this, "_noAudioInputCount", 0), this.context = HA(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), KA(this.outputNode), this.volumeLevelAnalyser = new qA } startGetAudioBuffer(e) { this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = e => { this.emit(bT.ON_AUDIO_BUFFER, function (e) { for (let t = 0; t < e.outputBuffer.numberOfChannels; t += 1) { const n = e.outputBuffer.getChannelData(t); for (let e = 0; e < n.length; e += 1)n[e] = 0 } return e.inputBuffer }(e)) }) } stopGetAudioBuffer() { this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0) } createOutputTrack() { if (!XO().webAudioMediaStreamDest) throw new Ch(Oh.NOT_SUPPORTED, "your browser is not support audio processor"); return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack } play(e) { "running" !== this.context.state && Em((() => { GA.emit("autoplay-failed") })), this.isPlayed = !0, this.playNode = e || this.context.destination, this.outputNode.connect(this.playNode) } stop() { if (this.isPlayed) try { this.outputNode.disconnect(this.playNode) } catch (e) { } this.isPlayed = !1 } getAccurateVolumeLevel() { return this.volumeLevelAnalyser.getVolumeLevel() } async checkHasAudioInput() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; if (e > 5) return this.isNoAudioInput = !0, this.onNoAudioInput && this.onNoAudioInput(), !1; Ju() || nl() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume(); const t = this.volumeLevelAnalyser.getAnalyserNode(); let n; t.getFloatTimeDomainData ? (n = new Float32Array(t.fftSize), t.getFloatTimeDomainData(n)) : (n = new Uint8Array(t.fftSize), t.getByteTimeDomainData(n)); let i = !1; for (let r = 0; r < n.length; r++)0 !== n[r] && (i = !0); return i ? (this.isNoAudioInput = !1, !0) : (await Qg(200), await this.checkHasAudioInput(e ? e + 1 : 1) && i) } getAudioVolume() { return this.outputNode.gain.value } setVolume(e) { this.outputNode.gain.setValueAtTime(e, this.context.currentTime) } destroy() { this.disconnect(), this.stop(), this.isDestroyed = !0, this.onNoAudioInput = void 0 } disconnect() { var e, t; null === (e = this.processedNode) || void 0 === e || e.disconnect(), null === (t = this.sourceNode) || void 0 === t || t.disconnect(), this.outputNode && this.outputNode.disconnect() } connect() { var e; this.processedNode ? null === (e = this.processedNode) || void 0 === e || e.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode), this.volumeLevelAnalyser.updateSource(this.outputNode) } } class zA extends QA { get isFreeze() { return !1 } constructor(e, t, n) { var i; if (super(), hl(this, "sourceNode", void 0), hl(this, "track", void 0), hl(this, "clonedTrack", void 0), hl(this, "audioElement", void 0), hl(this, "isCurrentTrackCloned", !1), hl(this, "isRemoteTrack", !1), hl(this, "originVolumeLevelAnalyser", void 0), hl(this, "rebuildWebAudio", (async () => { if (Dh.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener("click", this.rebuildWebAudio, !0), void Dh.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel()); this.context.resume().then((() => Dh.info("resume success"))), Dh.debug("rebuild web audio because of ios 12 bugs"), this.disconnect(); const e = this.track; this.track = this.track.clone(), this.isCurrentTrackCloned ? e.stop() : this.isCurrentTrackCloned = !0; const t = new MediaStream([this.track]); this.sourceNode = this.context.createMediaStreamSource(t), KA(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser(); const n = this.outputNode.gain.value; this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(n, this.context.currentTime), KA(this.outputNode), this.emit(bT.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput() })), "audio" !== e.kind) throw new Ch(Oh.UNEXPECTED_ERROR); this.track = e; const r = new MediaStream([this.track]); if (this.isRemoteTrack = !!t, this.sourceNode = this.context.createMediaStreamSource(r), KA(this.sourceNode), n) { const e = n.clone(); e.enabled = !0, this.clonedTrack = e, Dh.debug("create an unmuted track ".concat(e.id, " from the original track ").concat(n.id, " to get the volume")); const t = this.context.createMediaStreamSource(new MediaStream([e])); KA(t), this.originVolumeLevelAnalyser = new qA, this.originVolumeLevelAnalyser.updateSource(t) } this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = r; const o = xu(); t && o.os === yu.IOS && Number(null === (i = o.osVersion) || void 0 === i ? void 0 : i.split(".")[0]) < 15 && (GA.on(UA.STATE_CHANGE, (() => { "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, !0) : "running" === this.context.state && this.rebuildWebAudio() })), this.checkHasAudioInput().then((e => { e || document.body.addEventListener("click", this.rebuildWebAudio, !0) }))) } updateTrack(e) { this.sourceNode.disconnect(), this.track = e, this.isCurrentTrackCloned = !1; const t = new MediaStream([e]); this.sourceNode = this.context.createMediaStreamSource(t), KA(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(bT.UPDATE_SOURCE), this.audioElement.srcObject = t } destroy() { var e; this.audioElement.srcObject = null, this.audioElement.remove(), GA.off("state-change", this.rebuildWebAudio), null === (e = this.originVolumeLevelAnalyser) || void 0 === e || e.destroy(), this.clonedTrack = void 0, super.destroy() } createMediaStreamSourceNode(e) { return this.context.createMediaStreamSource(new MediaStream([e])) } updateOriginTrack(e) { const t = e.clone(); t.enabled = !0, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t), Dh.debug("create an unmuted track ".concat(t.id, " from the original track ").concat(e.id, " to get the volume")); const n = this.context.createMediaStreamSource(new MediaStream([t])); KA(n), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(n) } getOriginVolumeLevel() { return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel() } } async function ZA(e, t) { const n = (e, t) => e ? "number" != typeof e ? e.max || e.exact || e.ideal || e.min || t : e : t, i = { audio: !1, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e, maxHeight: n(t.height, 1080), maxWidth: n(t.width, 1920) } } }; return t.frameRate && "number" != typeof t.frameRate ? (i.video.mandatory.maxFrameRate = t.frameRate.max, i.video.mandatory.minFrameRate = t.frameRate.min) : "number" == typeof t.frameRate && (i.video.mandatory.maxFrameRate = t.frameRate), await navigator.mediaDevices.getUserMedia(i) } async function $A(e) { const t = await eS(e.mediaSource), n = await function (e) { return new Cd(((t, n) => { const i = document.createElement("div"); i.innerText = "share screen", i.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;"); const r = document.createElement("div"); r.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;"); const o = document.createElement("div"); o.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", o.setAttribute("style", "height: 12%;"); const s = document.createElement("div"); s.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;"); const a = document.createElement("div"); a.setAttribute("style", "text-align: right; padding: 16px 0;"); const c = document.createElement("button"); c.innerHTML = "cancel", c.setAttribute("style", "width: 85px;"), c.onclick = () => { document.body.removeChild(E); const e = new Error("NotAllowedError"); e.name = "NotAllowedError", n(e) }, a.appendChild(c), r.appendChild(o), r.appendChild(s), r.appendChild(a); const E = document.createElement("div"); E.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), E.appendChild(i), E.appendChild(r), document.body.appendChild(E), e.map((e => { if (e.id) { const n = document.createElement("div"); n.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;"); let i = e.thumbnail; const { width: r } = i.getSize(); r > 1920 && (i = i.resize({ width: 1920 })), n.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + i.toDataURL() + ' /></div><span style="\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + e.name.replace(/[\u00A0-\u9999<>\&]/g, (function (e) { return "&#" + e.charCodeAt(0) + ";" })) + "</span>", n.onclick = () => { document.body.removeChild(E), t(e.id) }, s.appendChild(n) } })) })) }(t); return await ZA(n, e) } async function eS(e) { let t = ["window", "screen"]; "application" !== e && "window" !== e || (t = ["window"]), "screen" === e && (t = ["screen"]); const n = nS(); if (!n) throw new Ch(Oh.ELECTRON_IS_NULL); let i = null; try { var r; i = (null === (r = n.desktopCapturer) || void 0 === r ? void 0 : r.getSources({ types: t })) || n.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t }) } catch (e) { i = null } i && i.then || (i = new Cd(((e, i) => { n.desktopCapturer.getSources({ types: t }, ((t, n) => { t ? i(t) : e(n) })) }))); try { return await i } catch (e) { throw new Ch(Oh.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e.toString()) } } let tS = null; function nS() { if (tS) return tS; try { return tS = window.require("electron"), tS } catch (e) { return null } } function iS(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } const rS = new kA("safari"); let oS = !1, sS = !1; async function aS(e, t) { let n = 0, i = null; for (; n < 2;)try { i = await cS(e, t, n > 0); break } catch (e) { if (e instanceof Ch) throw Dh.error("[".concat(t, "] ").concat(e.toString())), e; const i = ES(e.name || e.code || e, e.message); if (i.code === Oh.MEDIA_OPTION_INVALID) { Dh.debug("[".concat(t, "] detect media option invalid, retry")), n += 1, await Qg(500); continue } throw Dh.error("[".concat(t, "] ").concat(i.toString())), i } if (!i) throw new Ch(Oh.UNEXPECTED_ERROR, "can not find stream after getUserMedia"); return i } async function cS(e, t, n) { if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Ch(Oh.NOT_SUPPORTED, "can not find getUserMedia"); n && (e.video && (delete e.video.width, delete e.video.height), e.screen && (delete e.screen.width, delete e.screen.height)); const i = XO(), r = new MediaStream; if (e.audioSource && r.addTrack(e.audioSource), e.videoSource && r.addTrack(e.videoSource), !e.audio && !e.video && !e.screen) return Dh.debug("Using Video Source/ Audio Source"), r; if (e.screen) if (nS()) e.screen.sourceId ? _S(r, await ZA(e.screen.sourceId, e.screen)) : _S(r, await $A(e.screen)); else if (Hu() && e.screen.extensionId && e.screen.mandatory) { if (!i.getStreamFromExtension) throw new Ch(Oh.NOT_SUPPORTED, "This browser does not support screen sharing"); Dh.debug("[".concat(t, '] Screen access on chrome stable, looking for extension"')); const n = await (s = e.screen.extensionId, a = t, new Cd(((e, t) => { try { chrome.runtime.sendMessage(s, { getStream: !0 }, (n => { if (!n || !n.streamId) return Dh.error("[".concat(a, "] No response from Chrome Plugin. Plugin not installed properly"), n), void t(new Ch(Oh.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly")); e(n.streamId) })) } catch (e) { Dh.error("[".concat(a, "] AgoraRTC screensharing plugin is not accessible(").concat(s, ")"), e.toString()), t(new Ch(Oh.CHROME_PLUGIN_NOT_INSTALL)) } }))); e.screen.mandatory.chromeMediaSourceId = n, _S(r, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e.screen.mandatory } })) } else if (i.getDisplayMedia) { var o; e.screen.mediaSource && AO(e.screen.mediaSource); const n = { width: e.screen.width, height: e.screen.height, frameRate: e.screen.frameRate, displaySurface: null !== (o = e.screen.displaySurface) && void 0 !== o ? o : "screen" === e.screen.mediaSource ? "monitor" : e.screen.mediaSource }, { selfBrowserSurface: i, surfaceSwitching: s, systemAudio: a } = e.screen, c = { selfBrowserSurface: i, surfaceSwitching: s, systemAudio: a }; !i && delete c.selfBrowserSurface, !s && delete c.surfaceSwitching, !a && delete c.systemAudio, Dh.debug("[".concat(t, "] getDisplayMedia:"), JSON.stringify({ video: n, audio: !!e.screenAudio, controls: c })), _S(r, await navigator.mediaDevices.getDisplayMedia(function (e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? iS(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iS(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e }({ video: n, audio: !!e.screenAudio }, c))) } else { if (!Ku()) throw Dh.error("[".concat(t, "] This browser does not support screenSharing")), new Ch(Oh.NOT_SUPPORTED, "This browser does not support screen sharing"); { e.screen.mediaSource && AO(e.screen.mediaSource); const n = { video: { mediaSource: e.screen.mediaSource, width: e.screen.width, height: e.screen.height, frameRate: e.screen.frameRate } }; Dh.debug("[".concat(t, "] getUserMedia: ").concat(JSON.stringify(n))), _S(r, await navigator.mediaDevices.getUserMedia(n)) } } var s, a; if (!e.video && !e.audio) return r; let c = { video: e.video, audio: e.audio }, E = jh("MEDIA_DEVICE_CONSTRAINTS"); if (E) try { "string" == typeof E && (E = JSON.parse(E)), c = function e(t, n) { if (!Om(t) || !Om(n)) return n; if (Array.isArray(t) && !Array.isArray(n) || !Array.isArray(t) && Array.isArray(n)) return n; if (Array.isArray(n) && Array.isArray(t)) { const i = [...t]; for (let r = 0; r < n.length; r++)i[r] = e(t[r], n[r]); return i } { const i = Xg({}, t); for (const r in n) Object.prototype.hasOwnProperty.call(n, r) && (Object.prototype.hasOwnProperty.call(t, r) ? i[r] = e(t[r], n[r]) : i[r] = n[r]); return i } }(c, E) } catch (e) { } Dh.debug("[".concat(t, "] GetUserMedia"), JSON.stringify(c)), xu(); let _, d = null; (Wu() || Ju() || Bu()) && (d = await rS.lock()); try { _ = await navigator.mediaDevices.getUserMedia(c) } catch (e) { throw d && d(), e } return c.audio && (oS = !0), c.video && (sS = !0), _S(r, _), d && d(), r } function ES(e, t) { switch (e) { case "Starting video failed": case "OverconstrainedError": case "TrackStartError": return new Ch(Oh.MEDIA_OPTION_INVALID, "".concat(e, ": ").concat(t)); case "NotFoundError": case "DevicesNotFoundError": return new Ch(Oh.DEVICE_NOT_FOUND, "".concat(e, ": ").concat(t)); case "NotSupportedError": return new Ch(Oh.NOT_SUPPORTED, "".concat(e, ": ").concat(t)); case "NotReadableError": return new Ch(Oh.NOT_READABLE, "".concat(e, ": ").concat(t)); case "InvalidStateError": case "NotAllowedError": case "PERMISSION_DENIED": case "PermissionDeniedError": return new Ch(Oh.PERMISSION_DENIED, "".concat(e, ": ").concat(t)); case "ConstraintNotSatisfiedError": return new Ch(Oh.CONSTRAINT_NOT_SATISFIED, "".concat(e, ": ").concat(t)); default: return Dh.error("getUserMedia unexpected error", e), new Ch(Oh.UNEXPECTED_ERROR, "".concat(e, ": ").concat(t)) } } function _S(e, t) { const n = e.getVideoTracks()[0], i = e.getAudioTracks()[0], r = t.getVideoTracks()[0], o = t.getAudioTracks()[0]; o && (i && e.removeTrack(i), e.addTrack(o)), r && (n && e.removeTrack(n), e.addTrack(r)) } const dS = new class extends ph { get state() { return this._state } set state(e) { e !== this._state && (this.emit(TT.STATE_CHANGE, e), this._state = e) } constructor() { super(), hl(this, "_state", pT.IDLE), hl(this, "isAccessMicrophonePermission", !1), hl(this, "isAccessCameraPermission", !1), hl(this, "lastAccessMicrophonePermission", !1), hl(this, "lastAccessCameraPermission", !1), hl(this, "checkdeviceMatched", !1), hl(this, "deviceInfoMap", new Map), this.init().then((() => { navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval((() => { (jh("ENUMERATE_DEVICES_INTERVAL") || (sl() || Fu() === yu.HARMONY_OS) && ol()) && this.updateDevicesInfo() }), jh("ENUMERATE_DEVICES_INTERVAL_TIME")) })).catch((e => Dh.error(e.toString()))) } async enumerateDevices(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return new Ch(Oh.NOT_SUPPORTED, "enumerateDevices() not supported.").throw(); const i = await navigator.mediaDevices.enumerateDevices(), r = this.checkMediaDeviceInfoIsOk(i); let o = !this.isAccessMicrophonePermission && e, s = !this.isAccessCameraPermission && t; r.audio && (o = !1), r.video && (s = !1); let a = null, c = null, E = null; if (!n && (o || s)) { if (rS.isLocked && (Dh.debug("[device manager] wait GUM lock"), (await rS.lock())(), Dh.debug("[device manager] GUM unlock")), oS && (o = !1, this.isAccessMicrophonePermission = !0), sS && (s = !1, this.isAccessCameraPermission = !0), Dh.debug("[device manager] check media device permissions", e, t, o, s), o && s) { try { E = await navigator.mediaDevices.getUserMedia({ audio: !0, video: !0 }) } catch (e) { const t = ES(e.name || e.code || e, e.message); if (t.code === Oh.PERMISSION_DENIED) throw t; Dh.warning("getUserMedia failed in getDevices", t) } this.isAccessCameraPermission = !0, this.isAccessMicrophonePermission = !0 } else if (o) { try { a = await navigator.mediaDevices.getUserMedia({ audio: e }) } catch (e) { const t = ES(e.name || e.code || e, e.message); if (t.code === Oh.PERMISSION_DENIED) throw t; Dh.warning("getUserMedia failed in getDevices", t) } this.isAccessMicrophonePermission = !0 } else if (s) { try { c = await navigator.mediaDevices.getUserMedia({ video: t }) } catch (e) { const t = ES(e.name || e.code || e, e.message); if (t.code === Oh.PERMISSION_DENIED) throw t; Dh.warning("getUserMedia failed in getDevices", t) } this.isAccessCameraPermission = !0 } Dh.debug("[device manager] mic permission", e, "cam permission", t) } try { const e = await navigator.mediaDevices.enumerateDevices(); return a && a.getTracks().forEach((e => e.stop())), c && c.getTracks().forEach((e => e.stop())), E && E.getTracks().forEach((e => e.stop())), a = null, c = null, E = null, e } catch (e) { return a && a.getTracks().forEach((e => e.stop())), c && c.getTracks().forEach((e => e.stop())), E && E.getTracks().forEach((e => e.stop())), a = null, c = null, E = null, new Ch(Oh.ENUMERATE_DEVICES_FAILED, e.toString()).throw() } } async getRecordingDevices() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; return (await this.enumerateDevices(!0, !1, e)).filter((e => "audioinput" === e.kind)) } async getCamerasDevices() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; return (await this.enumerateDevices(!1, !0, e)).filter((e => "videoinput" === e.kind)) } async getSpeakers() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; return (await this.enumerateDevices(!0, !1, e)).filter((e => "audiooutput" === e.kind)) } searchDeviceIdByName(e) { let t = null; return this.deviceInfoMap.forEach((n => { n.device.label === e && (t = n.device.deviceId) })), t } async getDeviceById(e) { const t = (await this.enumerateDevices(!0, !0, !0)).find((t => t.deviceId === e)); if (!t) throw new Ch(Oh.DEVICE_NOT_FOUND, "deviceId: ".concat(e)); return t } async init() { this.state = pT.INITING; try { await this.updateDevicesInfo(), this.state = pT.INITEND } catch (e) { throw Dh.warning("Device Detection functionality cannot start properly.", e.toString()), this.state = pT.IDLE, ("boolean" == typeof isSecureContext ? isSecureContext : "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname) || new Ch(Oh.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw(), e } } async updateDevicesInfo() { const e = await this.enumerateDevices(!0, !0, !0), t = Date.now(), n = []; if (e[0] && e[0].label && !1 === this.checkdeviceMatched) { this.checkdeviceMatched = !0; const t = e.find((e => "audioinput" === e.kind && "default" === e.deviceId)), n = e.find((e => "audiooutput" === e.kind && "default" === e.deviceId)); t && n ? n.groupId === t.groupId ? Dh.debug("[device-check] default input ".concat(t.label, " and output ").concat(n.label, " is the same group")) : Dh.warning("[device-check] default input ".concat(t.label, " and output ").concat(n.label, " is not the same group")) : Dh.debug("[device-check] default input or output not found") } const i = this.checkMediaDeviceInfoIsOk(e); if (e.forEach((e => { if (!e.deviceId) return; const i = this.deviceInfoMap.get("".concat(e.kind, "_").concat(e.deviceId)); if ("ACTIVE" !== (i ? i.state : "INACTIVE")) { const i = { initAt: t, updateAt: t, device: e, state: "ACTIVE" }; this.deviceInfoMap.set("".concat(e.kind, "_").concat(e.deviceId), i), n.push(i) } i && (i.updateAt = t) })), this.deviceInfoMap.forEach(((e, i) => { "ACTIVE" === e.state && e.updateAt !== t && (e.state = "INACTIVE", n.push(e)) })), this.state !== pT.INITEND) return i.audio && (this.lastAccessMicrophonePermission = !0, this.isAccessMicrophonePermission = !0), void (i.video && (this.lastAccessCameraPermission = !0, this.isAccessCameraPermission = !0)); n.forEach((e => { switch (e.device.kind) { case "audioinput": this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(TT.RECORDING_DEVICE_CHANGED, e); break; case "videoinput": this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(TT.CAMERA_DEVICE_CHANGED, e); break; case "audiooutput": this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(TT.PLAYOUT_DEVICE_CHANGED, e) } })), i.audio && (this.lastAccessMicrophonePermission = !0, this.isAccessMicrophonePermission = !0), i.video && (this.lastAccessCameraPermission = !0, this.isAccessCameraPermission = !0) } checkMediaDeviceInfoIsOk(e) { const t = e.filter((e => "audioinput" === e.kind)), n = e.filter((e => "videoinput" === e.kind)), i = { audio: !1, video: !1 }; for (const r of t) if (r.label && r.deviceId) { i.audio = !0; break } for (const r of n) if (r.label && r.deviceId) { i.video = !0; break } return i } }, uS = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"], lS = new class { constructor() { hl(this, "onAutoplayFailed", void 0), hl(this, "elementMap", new Map), hl(this, "elementStateMap", new Map), hl(this, "elementsNeedToResume", []), hl(this, "sinkIdMap", new Map), hl(this, "autoResumeAfterInterruption", (() => { Array.from(this.elementMap.entries()).forEach((e => { let [t, n] = e; const i = this.elementStateMap.get(t), r = n.srcObject.getAudioTracks()[0]; $u() ? r && "live" === r.readyState && "running" === GA.curState && (Dh.debug("auto resume after interruption for iOS 15"), n.pause(), n.play()) : i && "paused" === i && r && "live" === r.readyState && "running" === GA.curState && (Dh.debug("auto resume after interruption for iOS"), n.play()) })) })), hl(this, "autoResumeAfterInterruptionOnIOS15_16", (() => { Array.from(this.elementMap.entries()).forEach((e => { let [t, n] = e; const i = n.srcObject.getAudioTracks()[0]; i && "live" === i.readyState && (Dh.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), n.pause(), n.play()) })) })), this.autoResumeAudioElement(), GA.on(UA.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), GA.on(UA.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), GA.on(UA.STATE_CHANGE, (() => { Ju() && "suspended" === GA.prevState && "running" === GA.curState && this.autoResumeAfterInterruption() })) } async setSinkID(e, t) { const n = this.elementMap.get(e); if (this.sinkIdMap.set(e, t), n) try { await n.setSinkId(t) } catch (e) { throw new Ch(Oh.PERMISSION_DENIED, "can not set sink id: " + e.toString()) } } play(e, t, n, i) { if (this.elementMap.has(t)) return; const r = document.createElement("audio"); r.autoplay = !0, r.srcObject = new MediaStream([e]), this.bindAudioElementEvents(t, r), this.elementMap.set(t, r), this.elementStateMap.set(t, sT.INIT), this.setVolume(t, n); const o = this.sinkIdMap.get(t); if (o) try { r.setSinkId(o).catch((e => { Dh.warning("[".concat(t, "] set sink id failed"), e.toString()) })) } catch (e) { Dh.warning("[".concat(t, "] set sink id failed"), e.toString()) } const s = r.play(); s && s.then && s.catch((e => { i && wA.autoplayFailed(i, "audio", e.message, t), Dh.warning("audio element play warning", e.toString()), this.elementMap.has(t) && "NotAllowedError" === e.name && (Dh.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(r), Em((() => { this.onAutoplayFailed && this.onAutoplayFailed(), fA() }))) })) } updateTrack(e, t) { const n = this.elementMap.get(e); n && (n.srcObject = new MediaStream([t])) } isPlaying(e) { return this.elementMap.has(e) && "playing" === this.elementStateMap.get(e) } setVolume(e, t) { const n = this.elementMap.get(e); n && (t = Math.max(0, Math.min(100, t)), n.volume = t / 100) } stop(e) { const t = this.elementMap.get(e); if (this.sinkIdMap.delete(e), !t) return; const n = this.elementsNeedToResume.indexOf(t); this.elementsNeedToResume.splice(n, 1), t.srcObject = null, t.remove(), this.elementMap.delete(e), this.elementStateMap.delete(e) } bindAudioElementEvents(e, t) { uS.forEach((n => { t.addEventListener(n, (n => { const i = this.elementStateMap.get(e), r = "pause" === n.type ? "paused" : n.type; if (Dh.debug("[".concat(e, "] audio-element-status change ").concat(i, " => ").concat(r)), "error" === n.type) { const n = null == t ? void 0 : t.error; n && Dh.error("[".concat(e, "] media error, code: ").concat(n.code, ", message: ").concat(n.message)) } this.elementStateMap.set(e, r) })) })) } getPlayerState(e) { return this.elementStateMap.get(e) || "uninit" } autoResumeAudioElement() { const e = () => { this.elementsNeedToResume.forEach((e => { e.play().then((e => { Dh.debug("Auto resume audio element success") })).catch((e => { Dh.warning("Auto resume audio element failed!", e) })) })), this.elementsNeedToResume = [] }; new Cd((e => { document.body ? e() : window.addEventListener("load", (() => e())) })).then((() => { al() ? document.body.addEventListener("click", e, !0) : (document.body.addEventListener("touchstart", e, !0), document.body.addEventListener("mousedown", e, !0)) })) } }; function RS() { return function (e, t, n) { const i = n.value; return "function" == typeof i && (n.value = function () { this._isClosed && new Ch(Oh.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning"); for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; const r = i.apply(this, t); return r instanceof Cd ? new Cd(((e, t) => { r.then(e).catch(t) })) : r }), n } } var hS = Kn("Array").values, pS = $r, TS = je, OS = d, CS = hS, AS = Array.prototype, SS = { DOMTokenList: !0, NodeList: !0 }, gS = function (e) { var t = e.values; return e === AS || OS(AS, e) && t === AS.values || TS(SS, pS(e)) ? CS : t }; function mS(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function IS(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? mS(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mS(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class fS extends ph { constructor(e) { super(), hl(this, "name", "VideoProcessorDestination"), hl(this, "ID", "0"), hl(this, "_source", void 0), hl(this, "videoContext", void 0), hl(this, "inputTrack", void 0), this.videoContext = e } get kind() { return "video" } get enabled() { return !0 } pipe() { throw new Ch(Oh.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor") } unpipe() { throw new Ch(Oh.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor") } enable() { } disable() { } updateInput(e) { if (e.context !== this.videoContext) throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination)."); e.track && e.track !== this.inputTrack && (this.videoContext.chained = !0, this.inputTrack = e.track, this.emit(UO.ON_TRACK, e.track)) } reset() { this.inputTrack = void 0, this.videoContext.chained = !1, this.emit(UO.ON_TRACK, void 0) } } class PS extends ph { set chained(e) { this._chained = e } get chained() { return this._chained } constructor(e, t) { super(), hl(this, "constraintsMap", new Map), hl(this, "statsRegistry", []), hl(this, "usageRegistry", []), hl(this, "trackId", void 0), hl(this, "direction", void 0), hl(this, "_chained", !1), this.trackId = e, this.direction = t } async getConstraints() { return await im(this, MO.REQUEST_CONSTRAINTS) } async requestApplyConstraints(e, t) { var n; return Dh.info("processor ".concat(t.name, " requestApplyConstraints for ").concat(this.trackId)), e && this.constraintsMap.set(t, e), rm(this, MO.REQUEST_UPDATE_CONSTRAINTS, Array.from(gS(n = this.constraintsMap).call(n))) } async requestRevertConstraints(e) { var t; if (this.constraintsMap.has(e)) return Dh.info("processor ".concat(e.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e), rm(this, MO.REQUEST_UPDATE_CONSTRAINTS, Array.from(gS(t = this.constraintsMap).call(t))) } registerStats(e, t, n) { this.statsRegistry.find((n => n.processorID === e.ID && n.processorName === e.name && n.type === t)) || this.statsRegistry.push({ processorName: e.name, processorID: e.ID, type: t, cb: n }) } unregisterStats(e, t) { const n = this.statsRegistry.findIndex((n => n.processorID === e.ID && n.processorName === e.name && n.type === t)); -1 !== n && this.statsRegistry.splice(n, 1) } gatherStats() { const e = []; for (const { processorID: t, processorName: n, type: i, cb: r } of this.statsRegistry) try { const o = r(); e.push({ processorID: t, processorName: n, type: i, stats: o }) } catch (e) { Dh.error(new Ch(Oh.UNEXPECTED_ERROR, e.message)) } return e } registerUsage(e, t) { this.usageRegistry.find((t => t.processorID === e.ID && t.processorName === e.name)) || this.usageRegistry.push({ processorID: e.ID, processorName: e.name, cb: t }) } unregisterUsage(e) { const t = this.usageRegistry.findIndex((t => t.processorID === e.ID && t.processorName === e.name)); -1 !== t && this.usageRegistry.splice(t, 1) } async gatherUsage() { const e = []; if (!this.chained) return []; for (const { cb: t } of this.usageRegistry) try { let n = t(); n instanceof Cd && (n = await n), e.push(IS(IS({}, n), {}, { direction: this.direction })) } catch (e) { Dh.error("gather extension usage error", e) } return e } getDirection() { return this.direction } } class NS extends ph { constructor(e) { super(), hl(this, "name", "AudioProcessorDestination"), hl(this, "ID", "0"), hl(this, "inputTrack", void 0), hl(this, "inputNode", void 0), hl(this, "audioProcessorContext", void 0), hl(this, "_source", void 0), this.audioProcessorContext = e } get kind() { return "audio" } get enabled() { return !0 } pipe() { throw new Ch(Oh.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor") } unpipe() { throw new Ch(Oh.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor") } enable() { } disable() { } reset() { this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = !1, this.emit(UO.ON_TRACK, void 0), this.emit(UO.ON_NODE, void 0) } updateInput(e) { if (e.context !== this.audioProcessorContext) throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination)."); e.track && this.inputTrack !== e.track && (this.audioProcessorContext.chained = !0, this.inputTrack = e.track, this.emit(UO.ON_TRACK, this.inputTrack)), e.node && this.inputNode !== e.node && (this.audioProcessorContext.chained = !0, this.inputNode = e.node, this.emit(UO.ON_NODE, this.inputNode)) } } class DS extends ph { set chained(e) { this._chained = e } get chained() { return this._chained } constructor(e, t, n) { super(), hl(this, "constraintsMap", new Map), hl(this, "statsRegistry", []), hl(this, "audioContext", void 0), hl(this, "trackId", void 0), hl(this, "direction", void 0), hl(this, "usageRegistry", []), hl(this, "_chained", !1), this.audioContext = e, this.trackId = t, this.direction = n } async getConstraints() { return im(this, MO.REQUEST_CONSTRAINTS) } getAudioContext() { return this.audioContext } async requestApplyConstraints(e, t) { var n; return Dh.info("processor ".concat(t.name, " requestApplyConstraints for ").concat(this.trackId)), e && this.constraintsMap.set(t, e), rm(this, MO.REQUEST_UPDATE_CONSTRAINTS, Array.from(gS(n = this.constraintsMap).call(n))) } async requestRevertConstraints(e) { var t; if (this.constraintsMap.has(e)) return this.constraintsMap.delete(e), rm(this, MO.REQUEST_UPDATE_CONSTRAINTS, Array.from(gS(t = this.constraintsMap).call(t))) } registerStats(e, t, n) { this.statsRegistry.find((n => n.processorID === e.ID && n.processorName === e.name && n.type === t)) || this.statsRegistry.push({ processorName: e.name, processorID: e.ID, type: t, cb: n }) } unregisterStats(e, t) { const n = this.statsRegistry.findIndex((n => n.processorID === e.ID && n.processorName === e.name && n.type === t)); -1 !== n && this.statsRegistry.splice(n, 1) } gatherStats() { const e = []; for (const { processorID: t, processorName: n, type: i, cb: r } of this.statsRegistry) try { const o = r(); e.push({ processorID: t, processorName: n, type: i, stats: o }) } catch (e) { Dh.error(new Ch(Oh.UNEXPECTED_ERROR, e.message)) } return e } registerUsage(e, t) { this.usageRegistry.find((t => t.processorID === e.ID && t.processorName === e.name)) || this.usageRegistry.push({ processorID: e.ID, processorName: e.name, cb: t }) } unregisterUsage(e) { const t = this.usageRegistry.findIndex((t => t.processorID === e.ID && t.processorName === e.name)); -1 !== t && this.usageRegistry.splice(t, 1) } async gatherUsage() { const e = []; if (!this.chained) return []; for (const { cb: t } of this.usageRegistry) try { let n = t(); n instanceof Cd && (n = await n), e.push(IS(IS({}, n), {}, { direction: this.direction })) } catch (e) { Dh.error("gather extension usage error", e) } return e } getDirection() { return this.direction } } class vS extends ph { get isPlayed() { return !0 } get isFreeze() { return !1 } constructor() { super(), hl(this, "context", void 0), hl(this, "processSourceNode", void 0), hl(this, "outputTrack", void 0), hl(this, "processedNode", void 0), hl(this, "clonedTrack", void 0), hl(this, "outputNode", void 0), this.outputNode = new yS } setVolume() { } createOutputTrack() { throw new Ch(Oh.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled") } getOriginVolumeLevel() { return 0 } getAccurateVolumeLevel() { return 0 } stopGetAudioBuffer() { } startGetAudioBuffer() { } play() { } stop() { } destroy() { } updateTrack() { } updateOriginTrack() { } createMediaStreamSourceNode() { } } class yS { disconnect() { } connect() { } } let LS, wS = null; class bS { constructor() { hl(this, "state", "open"), hl(this, "trigger", void 0), hl(this, "tasks", []), Dh.debug("[macro-task-queue] is created."), this.trigger = setTimeout((() => { this.state = "closed", Dh.debug("[macro-task-queue] will be closed, all remaining tasks will execute. [".concat(this.tasks.map((e => e.key)), "]")), this.trigger = void 0, this.tasks.forEach((e => { let { func: t } = e; return t() })), this.tasks.length = 0, Dh.debug("[macro-task-queue] is closed.") })) } enqueue(e, t) { "closed" !== this.state && (this.tasks.push({ key: e, func: t }), Dh.debug("[macro-task-queue] is queued, current queue ".concat(this.tasks.length, ". ").concat("string" == typeof e ? e : ""))) } runTask(e) { if ("closed" === this.state) return; const t = this.tasks.findIndex((t => t.key === e)); if (-1 !== t) { const n = this.tasks.splice(t, 1); Dh.debug("[macro-task-queue] is unqueued, current queue ".concat(this.tasks.length, ". ").concat("string" == typeof e ? e : "")), n[0].func() } } release() { this.trigger && (this.state = "closed", clearTimeout(this.trigger), this.trigger = void 0, this.tasks.length = 0, Dh.debug("[macro-task-queue] is closed.")) } } function US(e) { return function (t, n, i) { var r; const o = null !== (r = i.value) && void 0 !== r ? r : i.get, s = function () { wS && "open" === wS.state && wS.runTask(e); for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return null == o ? void 0 : o.apply(this, ...n) }; return i.value ? i.value = s : i.get = s, i } } var MS, kS, VS, xS, FS, YS, BS, GS, jS, HS, WS, KS, JS, XS, qS, QS, zS, ZS, $S, eg, tg, ng, ig, rg, og, sg, ag, cg, Eg, _g, dg, ug, lg, Rg, hg, pg, Tg, Og, Cg, Ag, Sg, gg; function mg(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function Ig(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? mg(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mg(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } !function (e) { e.UPDATE_TRACK_SOURCE = "update-track-source" }(LS || (LS = {})); let fg = (MS = US("INIT_WEBAUDIO"), kS = US("INIT_WEBAUDIO"), VS = US("INIT_WEBAUDIO"), xS = LA({ argsMap: (e, t) => [e.getTrackId(), t], throttleTime: 300 }), FS = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), YS = RS(), BS = VA("LocalAudioTrack", "_enabledMutex"), GS = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), jS = RS(), HS = VA("LocalAudioTrack", "_enabledMutex"), WS = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), KS = RS(), JS = RS(), XS = RS(), qS = LA({ argsMap: e => [e.getTrackId()] }), QS = RS(), zS = LA({ argsMap: e => [e.getTrackId()] }), ZS = RS(), $S = LA({ argsMap: e => [e.getTrackId()] }), eg = LA({ argsMap: (e, t) => [e.getTrackId(), t.name] }), tg = LA({ argsMap: e => [e.getTrackId()] }), aA((ng = class extends xA { get _source() { return this._trackSource } set _source(e) { this._trackSource = e } get processorContext() { return this._processorContext } set processorContext(e) { this._processorContext = e } get processorDestination() { return this._processorDestination } set processorDestination(e) { this._processorDestination = e } get isPlaying() { return this._useAudioElement ? lS.isPlaying(this.getTrackId()) : this._source.isPlayed } get __className__() { return "LocalAudioTrack" } constructor(e, t, n, i, r) { super(e, n), hl(this, "trackMediaType", "audio"), hl(this, "_encoderConfig", void 0), hl(this, "_trackSource", void 0), hl(this, "_enabled", !0), hl(this, "_volume", 100), hl(this, "_useAudioElement", !1), hl(this, "_bypassWebAudio", !1), hl(this, "processor", void 0), hl(this, "_processorContext", void 0), hl(this, "_processorDestination", void 0), hl(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t, this._getOriginVolumeLevel = !!i; const o = () => { this.processorContext = new DS(this._source.context, this.getTrackId(), "local"), this.processorDestination = new NS(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(bT.UPDATE_SOURCE, (() => { this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext }) })) }, s = r && Wu() && !WA(); jh("DISABLE_WEBAUDIO") ? (this._source = new vS, this._useAudioElement = !0, this._bypassWebAudio = !0) : s ? this._source = new vS : (this._source = new zA(e, !1, this._getOriginVolumeLevel ? e : void 0), jh("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = !0)), o(), !jh("DISABLE_WEBAUDIO") && s && (wS || (wS = new bS), wS).enqueue("INIT_WEBAUDIO", (() => { this._source = new zA(e, !1, this._getOriginVolumeLevel ? e : void 0), jh("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = !0), o(), this.emit(LS.UPDATE_TRACK_SOURCE) })) } setVolume(e) { Xp(e, "volume", 0, 1e3), this._volume = e, this._source.setVolume(e / 100), this._useAudioElement && lS.setVolume(this.getTrackId(), e); try { if (this._bypassWebAudio) return void Dh.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio.")); const e = this._source.createOutputTrack(); this._mediaStreamTrack !== e && (this._mediaStreamTrack = e, rm(this, _O.NEED_REPLACE_TRACK, this).then((() => { Dh.debug("[".concat(this.getTrackId(), "] replace web audio track success")) })).catch((e => { Dh.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e) }))) } catch (e) { } } getVolumeLevel() { return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel() } async setPlaybackDevice(e) { if (!this._useAudioElement) throw new Ch(Oh.NOT_SUPPORTED, "your browser does not support setting the audio output device"); await lS.setSinkID(this.getTrackId(), e) } async setEnabled(e, t, n) { return this._setEnabled(e, t, n) } async _setEnabled(e, t, n) { if (!n) { if (e === this._enabled) return; this.stateCheck("enabled", e) } if (Dh.info("[".concat(this.getTrackId(), "] start setEnabled"), e), e) { this._originMediaStreamTrack.enabled = !0; try { n || (this._enabled = !0), await rm(this, _O.NEED_ENABLE_TRACK, this), Dh.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e, " success")) } catch (e) { throw n || (this._enabled = !1), Dh.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e.toString()), e } } else { this._originMediaStreamTrack.enabled = !1, n || (this._enabled = !1); try { await rm(this, _O.NEED_DISABLE_TRACK, this) } catch (e) { throw n || (this._enabled = !0), Dh.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e.toString()), e } } } async setMuted(e) { e !== this._muted && (this.stateCheck("muted", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, Dh.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e)), e ? await rm(this, _O.NEED_MUTE_TRACK, this) : await rm(this, _O.NEED_UNMUTE_TRACK, this)) } getStats() { return um((() => { Dh.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead") }), "localAudioTrackGetStatsWarning"), om(this, _O.GET_STATS) || Ig({}, FT) } setAudioFrameCallback(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096; if (!e) return this._source.removeAllListeners(bT.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer(); this._source.startGetAudioBuffer(t), this._source.removeAllListeners(bT.ON_AUDIO_BUFFER), this._source.on(bT.ON_AUDIO_BUFFER, (t => e(t))) } play() { Dh.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (Dh.debug("[".concat(this.getTrackId(), "] start audio playback in element")), lS.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play() } stop() { Dh.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? lS.stop(this.getTrackId()) : this._source.stop() } close() { super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe(), this._source.destroy() } _updatePlayerSource() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; Dh.debug("[".concat(this.getTrackId(), "] update player source track")), e && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && lS.updateTrack(this.getTrackId(), this._mediaStreamTrack) } async _updateOriginMediaStreamTrack(e, t) { this._originMediaStreamTrack !== e && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), e.addEventListener("ended", this._handleTrackEnded), t && this._originMediaStreamTrack.stop(), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = !1), this.processor && this.processor.updateInput({ track: e, context: this.processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rm(this, _O.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e)) } renewMediaStreamTrack(e) { return Cd.resolve(void 0) } pipe(e) { if (this._bypassWebAudio) throw new Ch(Oh.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true."); if (this.processor === e) return e; if (e._source) throw new Ch(Oh.INVALID_OPERATION, "Processor ".concat(e.name, " already piped, please call unpipe beforehand.")); return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e } unpipe() { var e; if (!this.processor) return; const t = this.processor; null === (e = this._source.processSourceNode) || void 0 === e || e.disconnect(), this.processor._source = !1, this.processor = void 0, t.reset() } bindProcessorDestinationEvents() { this.processorDestination.on(UO.ON_TRACK, (async e => { e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(!1), this._source.processedNode = this._source.createMediaStreamSourceNode(e), await rm(this, _O.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rm(this, _O.NEED_REPLACE_TRACK, this)) })), this.processorDestination.on(UO.ON_NODE, (e => { this._source.processedNode = e })) } unbindProcessorDestinationEvents() { this.processorDestination.removeAllListeners(UO.ON_TRACK), this.processorDestination.removeAllListeners(UO.ON_NODE) } unbindProcessorContextEvents() { this.processorContext.removeAllListeners(MO.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(MO.REQUEST_CONSTRAINTS) } }).prototype, "_source", [MS], Object.getOwnPropertyDescriptor(ng.prototype, "_source"), ng.prototype), aA(ng.prototype, "processorContext", [kS], Object.getOwnPropertyDescriptor(ng.prototype, "processorContext"), ng.prototype), aA(ng.prototype, "processorDestination", [VS], Object.getOwnPropertyDescriptor(ng.prototype, "processorDestination"), ng.prototype), aA(ng.prototype, "setVolume", [xS], Object.getOwnPropertyDescriptor(ng.prototype, "setVolume"), ng.prototype), aA(ng.prototype, "setPlaybackDevice", [FS, YS], Object.getOwnPropertyDescriptor(ng.prototype, "setPlaybackDevice"), ng.prototype), aA(ng.prototype, "setEnabled", [BS, GS, jS], Object.getOwnPropertyDescriptor(ng.prototype, "setEnabled"), ng.prototype), aA(ng.prototype, "setMuted", [HS, WS, KS], Object.getOwnPropertyDescriptor(ng.prototype, "setMuted"), ng.prototype), aA(ng.prototype, "getStats", [JS], Object.getOwnPropertyDescriptor(ng.prototype, "getStats"), ng.prototype), aA(ng.prototype, "setAudioFrameCallback", [XS], Object.getOwnPropertyDescriptor(ng.prototype, "setAudioFrameCallback"), ng.prototype), aA(ng.prototype, "play", [qS, QS], Object.getOwnPropertyDescriptor(ng.prototype, "play"), ng.prototype), aA(ng.prototype, "stop", [zS, ZS], Object.getOwnPropertyDescriptor(ng.prototype, "stop"), ng.prototype), aA(ng.prototype, "close", [$S], Object.getOwnPropertyDescriptor(ng.prototype, "close"), ng.prototype), aA(ng.prototype, "pipe", [eg], Object.getOwnPropertyDescriptor(ng.prototype, "pipe"), ng.prototype), aA(ng.prototype, "unpipe", [tg], Object.getOwnPropertyDescriptor(ng.prototype, "unpipe"), ng.prototype), ng), Pg = (ig = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), rg = RS(), og = VA("MicrophoneAudioTrack", "_enabledMutex"), sg = LA({ argsMap: (e, t, n) => [e.getTrackId(), t, n] }), ag = RS(), cg = LA({ argsMap: e => [e.getTrackId()] }), aA((Eg = class extends fg { get __className__() { return "MicrophoneAudioTrack" } constructor(e, t, n, i) { super(e, t.encoderConfig ? Bh(t.encoderConfig) : {}, i, jh("GET_VOLUME_OF_MUTED_AUDIO_TRACK"), !0), hl(this, "_config", void 0), hl(this, "_deviceName", "default"), hl(this, "_constraints", void 0), hl(this, "_originalConstraints", void 0), hl(this, "_enabled", !0), this._config = t, this._constraints = n, this._originalConstraints = n, this._deviceName = e.label, "boolean" == typeof t.bypassWebAudio && (this._bypassWebAudio = t.bypassWebAudio), ($u() || el()) && GA.bindInterruptDetectorTrack(this), this.on(LS.UPDATE_TRACK_SOURCE, (() => { this.bindProcessorContextEvents() })), WA() && this.bindProcessorContextEvents() } async setDevice(e) { if (Dh.info("[".concat(this.getTrackId(), "] start set device to ").concat(e)), this._enabled) try { const t = await dS.getDeviceById(e), n = {}; n.audio = Ig({}, this._constraints), n.audio.deviceId = { exact: e }, this._originMediaStreamTrack.stop(); let i = null; try { i = await aS(n, this.getTrackId()) } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setDevice failed"), e.toString()), i = await aS({ audio: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(i.getAudioTracks()[0], !1), e } await this._updateOriginMediaStreamTrack(i.getAudioTracks()[0], !1), this._deviceName = t.label, this._config.microphoneId = e, this._constraints.deviceId = { exact: e } } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setDevice error"), e.toString()), e } else try { const t = await dS.getDeviceById(e); this._deviceName = t.label, this._config.microphoneId = e, this._constraints.deviceId = { exact: e } } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setDevice error"), e.toString()), e } Dh.info("[".concat(this.getTrackId(), "] set device to ").concat(e, " success")) } async setEnabled(e, t, n) { if (t) return Dh.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(e); if (!n) { if (e === this._enabled) return; this.stateCheck("enabled", e) } if (Dh.info("[".concat(this.getTrackId(), "] start setEnabled"), e), !e) { var i; this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (i = this._source.clonedTrack) || void 0 === i || i.stop(), n || (this._enabled = !1); try { await rm(this, _O.NEED_DISABLE_TRACK, this) } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setEnabled false failed"), e.toString()), e } return } const r = Ig({}, this._constraints), o = dS.searchDeviceIdByName(this._deviceName); o && !r.deviceId && (r.deviceId = o); try { n || (this._enabled = !0); const e = await aS({ audio: this._constraints }, this.getTrackId()); await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !1), await rm(this, _O.NEED_ENABLE_TRACK, this) } catch (e) { throw n || (this._enabled = !1), Dh.error("[".concat(this.getTrackId(), "] setEnabled true failed"), e.toString()), e } Dh.info("[".concat(this.getTrackId(), "] setEnabled success")) } close() { super.close(), ($u() || el()) && GA.unbindInterruptDetectorTrack(this) } onTrackEnded() { if ((Ju() || nl()) && this._enabled && !this._isClosed && GA.duringInterruption) { const e = async () => { GA.off(UA.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (Dh.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(!1), await this.setEnabled(!0)) }; GA.on(UA.IOS_INTERRUPTION_END, e) } else Dh.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(pO.TRACK_ENDED) } async renewMediaStreamTrack(e) { const t = e || this._constraints, n = dS.searchDeviceIdByName(this._deviceName); if (n && !t.deviceId && (t.deviceId = n), this._constraints = t, this._enabled) { this._originMediaStreamTrack.stop(); const e = await aS({ audio: this._constraints }, this.getTrackId()); await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !0) } } bindProcessorContextEvents() { this.processorContext.on(MO.REQUEST_UPDATE_CONSTRAINTS, (async (e, t, n) => { try { const n = Object.assign({}, this._originalConstraints, ...e); await this.renewMediaStreamTrack(n), t() } catch (e) { n(e) } })), this.processorContext.on(MO.REQUEST_CONSTRAINTS, (async e => { e(this._originMediaStreamTrack.getSettings()) })) } }).prototype, "setDevice", [ig, rg], Object.getOwnPropertyDescriptor(Eg.prototype, "setDevice"), Eg.prototype), aA(Eg.prototype, "setEnabled", [og, sg, ag], Object.getOwnPropertyDescriptor(Eg.prototype, "setEnabled"), Eg.prototype), aA(Eg.prototype, "close", [cg], Object.getOwnPropertyDescriptor(Eg.prototype, "close"), Eg.prototype), Eg), Ng = (_g = LA({ argsMap: (e, t) => [e.getTrackId(), t, e.duration] }), dg = RS(), ug = LA({ argsMap: e => [e.getTrackId()] }), lg = RS(), Rg = LA({ argsMap: e => [e.getTrackId()] }), hg = RS(), pg = LA({ argsMap: e => [e.getTrackId()] }), Tg = RS(), Og = LA({ argsMap: e => [e.getTrackId()] }), Cg = RS(), Ag = LA({ argsMap: e => [e.getTrackId()] }), Sg = RS(), aA((gg = class extends fg { get __className__() { return "BufferSourceAudioTrack" } constructor(e, t, n, i) { super(t.createOutputTrack(), n, i), hl(this, "source", void 0), hl(this, "_bufferSource", void 0), this.source = e, this._bufferSource = t, this._bufferSource.on(bT.AUDIO_SOURCE_STATE_CHANGE, (e => { this.safeEmit(pO.SOURCE_STATE_CHANGE, e) })); try { this._mediaStreamTrack = this._source.createOutputTrack() } catch (e) { } } get currentState() { return this._bufferSource.currentState } get duration() { return this._bufferSource.duration } get playbackSpeed() { return this._bufferSource.playbackSpeed } getCurrentTime() { return this._bufferSource.currentTime } startProcessAudioBuffer(e) { e && this._bufferSource.updateOptions(e), this._bufferSource.startProcessAudioBuffer() } pauseProcessAudioBuffer() { this._bufferSource.pauseProcessAudioBuffer() } seekAudioBuffer(e) { this._bufferSource.seekAudioBuffer(e) } resumeProcessAudioBuffer() { this._bufferSource.resumeProcessAudioBuffer() } stopProcessAudioBuffer() { this._bufferSource.stopProcessAudioBuffer() } setAudioBufferPlaybackSpeed(e) { Xp(e, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e) } }).prototype, "startProcessAudioBuffer", [_g, dg], Object.getOwnPropertyDescriptor(gg.prototype, "startProcessAudioBuffer"), gg.prototype), aA(gg.prototype, "pauseProcessAudioBuffer", [ug, lg], Object.getOwnPropertyDescriptor(gg.prototype, "pauseProcessAudioBuffer"), gg.prototype), aA(gg.prototype, "seekAudioBuffer", [Rg, hg], Object.getOwnPropertyDescriptor(gg.prototype, "seekAudioBuffer"), gg.prototype), aA(gg.prototype, "resumeProcessAudioBuffer", [pg, Tg], Object.getOwnPropertyDescriptor(gg.prototype, "resumeProcessAudioBuffer"), gg.prototype), aA(gg.prototype, "stopProcessAudioBuffer", [Og, Cg], Object.getOwnPropertyDescriptor(gg.prototype, "stopProcessAudioBuffer"), gg.prototype), aA(gg.prototype, "setAudioBufferPlaybackSpeed", [Ag, Sg], Object.getOwnPropertyDescriptor(gg.prototype, "setAudioBufferPlaybackSpeed"), gg.prototype), gg); class Dg extends fg { get __className__() { return "MixingAudioTrack" } get isActive() { for (const e of this.trackList) if (e._enabled && !e._isClosed && !e.muted) return !0; return !1 } constructor() { const e = HA().createMediaStreamDestination(); super(e.stream.getAudioTracks()[0], void 0, Zg(8, "track-mix-")), hl(this, "trackList", void 0), hl(this, "destNode", void 0); try { this._mediaStreamTrack = this._source.createOutputTrack() } catch (e) { } this.destNode = e, this.trackList = [] } hasAudioTrack(e) { return -1 !== this.trackList.indexOf(e) } addAudioTrack(e) { -1 === this.trackList.indexOf(e) ? (Dh.debug("add ".concat(e.getTrackId(), " to mixing track")), e._source.outputNode.connect(this.destNode), this.trackList.push(e), this.updateEncoderConfig()) : Dh.debug("track ".concat(e.getTrackId(), " is already added")) } removeAudioTrack(e) { if (-1 !== this.trackList.indexOf(e)) { Dh.debug("remove ".concat(e.getTrackId(), " from mixing track")); try { e._source.outputNode.disconnect(this.destNode) } catch (e) { } am(this.trackList, e), this.updateEncoderConfig() } } updateEncoderConfig() { const e = {}; this.trackList.forEach((t => { t._encoderConfig && ((t._encoderConfig.bitrate || 0) > (e.bitrate || 0) && (e.bitrate = t._encoderConfig.bitrate), (t._encoderConfig.sampleRate || 0) > (e.sampleRate || 0) && (e.sampleRate = t._encoderConfig.sampleRate), (t._encoderConfig.sampleSize || 0) > (e.sampleSize || 0) && (e.sampleSize = t._encoderConfig.sampleSize), t._encoderConfig.stereo && (e.stereo = !0)) })), this._encoderConfig = e } _updateRtpTransceiver(e) { this._rtpTransceiver !== e && (this._rtpTransceiver = e, this.trackList.forEach((t => { t instanceof Dg ? t.emit(hO.TRANSCEIVER_UPDATED, e) : t._updateRtpTransceiver(e) }))) } } class vg extends ph { constructor() { super(...arguments), hl(this, "resultStorage", new Map) } setLocalAudioStats(e, t, n) { this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e, this.checkAudioInputLevel(n, t)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e, this.checkSendAudioBitrate(n, t)) } setLocalVideoStats(e, t, n) { this.record("SEND_VIDEO_BITRATE_TOO_LOW", e, this.checkSendVideoBitrate(n, t)), this.record("FRAMERATE_INPUT_TOO_LOW", e, this.checkFramerateInput(n, t)), this.record("FRAMERATE_SENT_TOO_LOW", e, this.checkFramerateSent(n)) } setRemoteAudioStats(e, t) { const n = e.getUserId(); this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", n, this.checkAudioOutputLevel(t)) } setRemoteVideoStats(e, t) { const n = e.getUserId(); this.record("RECV_VIDEO_DECODE_FAILED", n, this.checkVideoDecode(t)) } record(e, t, n) { if (jh("STATS_UPDATE_INTERVAL") > 500) return; this.resultStorage.has(e) || this.resultStorage.set(e, { result: [], isPrevNormal: !0 }); const i = this.resultStorage.get(e); if (i && (i.result.push(n), i.result.length >= 5)) { const n = i.result.includes(!0); i.isPrevNormal && !n && this.emit("exception", yg[e], e, t), !i.isPrevNormal && n && this.emit("exception", yg[e] + 2e3, e + "_RECOVER", t), i.isPrevNormal = n, i.result = [] } } checkAudioOutputLevel(e) { return !(e.receiveBitrate > 0 && 0 === e.receiveLevel) } checkAudioInputLevel(e, t) { return t instanceof Dg && !t.isActive || !!t.muted || 0 !== e.sendVolumeLevel } checkFramerateInput(e, t) { let n = null; t._encoderConfig && t._encoderConfig.frameRate && (n = Yg(t._encoderConfig.frameRate)); const i = e.captureFrameRate; return !n || !i || !(n > 10 && i < 5 || n < 10 && n >= 5 && i <= 1) } checkFramerateSent(e) { return !(e.captureFrameRate && e.sendFrameRate && e.captureFrameRate > 5 && e.sendFrameRate <= 1) } checkSendVideoBitrate(e, t) { return !!t.muted || 0 !== e.sendBitrate } checkSendAudioBitrate(e, t) { return t instanceof Dg && !t.isActive || !!t.muted || 0 !== e.sendBitrate } checkVideoDecode(e) { return 0 === e.receiveBitrate || 0 !== e.decodeFrameRate } } const yg = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003 }, Lg = new class { markSubscribeStart(e, t) { performance.mark("agora-web-sdk/".concat(e, "/subscribe-").concat(t)) } markPublishStart(e, t) { performance.mark("agora-web-sdk/".concat(e, "/publish-").concat(t)) } measureFromSubscribeStart(e, t) { const n = performance.getEntriesByName("agora-web-sdk/".concat(e, "/subscribe-").concat(t)); if (n.length > 0) { const e = n[n.length - 1]; return Math.round(performance.now() - e.startTime) } return 0 } measureFromPublishStart(e, t) { const n = performance.getEntriesByName("agora-web-sdk/".concat(e, "/publish-").concat(t)); if (n.length > 0) { const e = n[n.length - 1]; return Math.round(performance.now() - e.startTime) } return 0 } }; function wg(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function bg(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? wg(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wg(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class Ug { constructor(e) { hl(this, "store", void 0), hl(this, "onStatsException", void 0), hl(this, "onUploadPublishDuration", void 0), hl(this, "onStatsChanged", void 0), hl(this, "localStats", new Map), hl(this, "remoteStats", new Map), hl(this, "updateStatsInterval", void 0), hl(this, "trafficStats", void 0), hl(this, "trafficStatsPeerList", []), hl(this, "uplinkStats", void 0), hl(this, "exceptionMonitor", void 0), hl(this, "p2pChannel", void 0), hl(this, "scalabilityMode", Uu.L1T1), hl(this, "updateStats", (() => { this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel)) })), this.store = e, this.updateStatsInterval = window.setInterval(this.updateStats, 1e3), this.exceptionMonitor = new vg, this.exceptionMonitor.on("exception", ((e, t, n) => { this.onStatsException && this.onStatsException(e, t, n) })) } reset() { this.localStats = new Map, this.remoteStats = new Map, this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0 } getLocalAudioTrackStats() { return this.localStats.get(vO.LocalAudioTrack) || bg({}, FT) } getLocalVideoTrackStats() { return this.localStats.get(vO.LocalVideoTrack) || bg({}, YT) } getRemoteAudioTrackStats(e) { const t = (e, t) => { if (!this.trafficStats) return t; const n = this.trafficStats.peer_delay.find((t => t.peer_uid === e)); return n && (t.publishDuration = n.B_ppad + (Date.now() - this.trafficStats.timestamp)), t }, n = {}; if (e) { var i; const r = null === (i = this.remoteStats.get(e)) || void 0 === i ? void 0 : i.audioStats; r && (n[e] = t(e, r)) } else Array.from(this.remoteStats.entries()).forEach((e => { let [i, { audioStats: r }] = e; r && (n[i] = t(i, r)) })); return n } getRemoteNetworkQualityStats(e) { const t = {}; if (e) { var n; const i = null === (n = this.remoteStats.get(e)) || void 0 === n ? void 0 : n.networkStats; i && (t[e] = i) } else Array.from(this.remoteStats.entries()).forEach((e => { let [n, { networkStats: i }] = e; i && (t[n] = i) })); return t } getRemoteVideoTrackStats(e) { const t = (e, t) => { if (!this.trafficStats) return t; const n = this.trafficStats.peer_delay.find((t => t.peer_uid === e)); return n && (t.publishDuration = n.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t }, n = {}; if (e) { var i; const r = null === (i = this.remoteStats.get(e)) || void 0 === i ? void 0 : i.videoStats; r && (n[e] = t(e, r)) } else Array.from(this.remoteStats.entries()).forEach((e => { let [i, { videoStats: r }] = e; r && (n[i] = t(i, r)) })); return n } getRTCStats() { let e = 0, t = 0, n = 0, i = 0; const r = this.localStats.get(vO.LocalAudioTrack); r && (e += r.sendBytes, t += r.sendBitrate); const o = this.localStats.get(vO.LocalVideoTrack); o && (e += o.sendBytes, t += o.sendBitrate); const s = this.localStats.get(vO.LocalVideoLowTrack); s && (e += s.sendBytes, t += s.sendBitrate), this.remoteStats.forEach((e => { let { audioStats: t, videoStats: r } = e; t && (n += t.receiveBytes, i += t.receiveBitrate), r && (n += r.receiveBytes, i += r.receiveBitrate) })); let a = 1; return this.trafficStats && (a += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a, SendBitrate: t, SendBytes: e, RecvBytes: n, RecvBitrate: i, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 } } addLocalStats(e) { this.localStats.set(e, void 0) } removeLocalStats(e) { e ? this.localStats.delete(e) : this.localStats.clear() } addRemoteStats(e) { this.remoteStats.set(e, {}) } removeRemoteStats(e) { e ? this.remoteStats.delete(e) : this.remoteStats.clear() } addP2PChannel(e) { this.p2pChannel = e } updateTrafficStats(e) { e.peer_delay = e.peer_delay.filter((e => void 0 !== e.B_ppad || void 0 !== e.B_ppvd)), e.peer_delay.filter((e => -1 === this.trafficStatsPeerList.indexOf(e.peer_uid))).forEach((e => { var t; const n = null === (t = this.p2pChannel) || void 0 === t ? void 0 : t.getRemoteMedia(e.peer_uid), i = null != n && n.videoSSRC ? Lg.measureFromSubscribeStart(this.store.clientId, n.videoSSRC) : 0, r = null != n && n.audioSSRC ? Lg.measureFromSubscribeStart(this.store.clientId, n.audioSSRC) : 0; void 0 !== e.B_ppad && void 0 !== e.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e.peer_uid, e.B_ppad, e.B_ppvd, i > r ? i : r), this.trafficStatsPeerList.push(e.peer_uid)) })), this.trafficStats = e } updateUplinkStats(e) { this.uplinkStats && this.uplinkStats.B_fir !== e.B_fir && Dh.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e.B_fir)), this.uplinkStats = e } static isRemoteVideoFreeze(e, t, n) { if (!e) return !1; const i = !!n && t.framesDecodeFreezeTime > n.framesDecodeFreezeTime, r = !n || t.framesDecodeCount > n.framesDecodeCount; return i || !r } static isRemoteAudioFreeze(e) { return !!e && e._isFreeze() } isLocalVideoFreeze(e) { return !(!e.inputFrame || !e.sentFrame) && e.inputFrame.frameRate > 5 && e.sentFrame.frameRate < 3 } updateLocalStats(e) { Array.from(this.localStats.entries()).forEach((t => { let [n, i] = t; switch (n) { case vO.LocalVideoTrack: case vO.LocalVideoLowTrack: { const t = i, o = bg({}, YT), s = e.getStats(), a = e.getLocalMedia(n); if (s) { const n = s.videoSend.find((e => e.ssrc === (null == a ? void 0 : a.ssrcs[0].ssrcId))); if (n) { const i = e.getLocalVideoSize(), r = e.getEncoderConfig(vO.LocalVideoTrack); "H264" !== n.codec && "H265" !== n.codec && "VP8" !== n.codec && "VP9" !== n.codec && "AV1X" !== n.codec && "AV1" !== n.codec || (o.codecType = n.codec), o.sendBytes = n.bytes, o.sendBitrate = t ? 8 * Math.max(0, o.sendBytes - t.sendBytes) : 0, n.inputFrame ? (o.captureFrameRate = n.inputFrame.frameRate, o.captureResolutionHeight = n.inputFrame.height, o.captureResolutionWidth = n.inputFrame.width) : i && (o.captureResolutionWidth = i.width, o.captureResolutionHeight = i.height), n.sentFrame ? (o.sendFrameRate = n.sentFrame.frameRate, o.sendResolutionHeight = n.sentFrame.height, o.sendResolutionWidth = n.sentFrame.width) : i && (o.sendResolutionWidth = i.width, o.sendResolutionHeight = i.height), n.avgEncodeMs && (o.encodeDelay = n.avgEncodeMs), r && r.bitrateMax && (o.targetSendBitrate = 1e3 * r.bitrateMax), o.sendPackets = n.packets, o.sendPacketsLost = n.packetsLost, o.totalDuration = t ? t.totalDuration + 1 : 1, o.totalFreezeTime = t ? t.totalFreezeTime : 0, this.isLocalVideoFreeze(n) && (o.totalFreezeTime += 1), n.scalabilityMode && this.scalabilityMode !== n.scalabilityMode && (Dh.debug("[".concat(this.store.clientId, "]: The scalabilityMode of the video sending stream is ").concat(n.scalabilityMode)), this.scalabilityMode = n.scalabilityMode) } this.trafficStats && (o.sendPacketsLost = this.trafficStats.B_pvlr4 / 100) } var r; this.localStats.set(n, o), ((null == t ? void 0 : t.sendResolutionWidth) !== o.sendResolutionWidth || (null == t ? void 0 : t.sendResolutionHeight) !== o.sendResolutionHeight) && (null === (r = this.onStatsChanged) || void 0 === r || r.call(this, "resolution", { width: o.sendResolutionWidth, height: o.sendResolutionHeight })), o && a && this.exceptionMonitor.setLocalVideoStats(this.store.uid, a.track, o); break } case vO.LocalAudioTrack: { const t = i, r = bg({}, FT), o = e.getStats(), s = e.getLocalMedia(n); if (o) { const n = o.audioSend.find((e => e.ssrc === (null == s ? void 0 : s.ssrcs[0].ssrcId))); if (n) { if ("opus" !== n.codec && "aac" !== n.codec && "PCMU" !== n.codec && "PCMA" !== n.codec && "G722" !== n.codec || (r.codecType = n.codec), n.inputLevel) r.sendVolumeLevel = Math.round(32767 * n.inputLevel); else { const t = e.getLocalAudioVolume(); t && (r.sendVolumeLevel = Math.round(32767 * t)) } r.sendBytes = n.bytes, r.sendPackets = n.packets, r.sendPacketsLost = n.packetsLost, r.sendBitrate = t ? 8 * Math.max(0, r.sendBytes - t.sendBytes) : 0 } } this.trafficStats && (r.sendPacketsLost = this.trafficStats.B_pvlr4 / 100), this.localStats.set(vO.LocalAudioTrack, r), r && s && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s.track, r); break } } })) } updateRemoteStats(e) { Array.from(this.remoteStats.entries()).forEach((t => { let [n, { videoStats: i, audioStats: r, videoPcStats: o }] = t; const s = r, a = i, c = o, E = bg({}, BT), _ = bg({}, jT), d = bg({}, GT), { audioTrack: u, videoTrack: l, audioSSRC: R, videoSSRC: h } = e.getRemoteMedia(n), p = e.getStats(), T = null == p ? void 0 : p.audioRecv.find((e => e.ssrc === R)), O = null == p ? void 0 : p.videoRecv.find((e => e.ssrc === h)), C = this.trafficStats && this.trafficStats.peer_delay.find((e => e.peer_uid === n)); if (T && ("opus" !== T.codec && "aac" !== T.codec && "PCMU" !== T.codec && "PCMA" !== T.codec && "G722" !== T.codec || (E.codecType = T.codec), T.outputLevel ? E.receiveLevel = Math.round(32767 * T.outputLevel) : u && (E.receiveLevel = Math.round(32767 * u.getVolumeLevel())), E.receiveBytes = T.bytes, E.receivePackets = T.packets, E.receivePacketsLost = T.packetsLost, E.packetLossRate = E.receivePacketsLost / (E.receivePackets + E.receivePacketsLost), E.receiveBitrate = s ? 8 * Math.max(0, E.receiveBytes - s.receiveBytes) : 0, E.totalDuration = s ? s.totalDuration + 1 : 1, E.totalFreezeTime = s ? s.totalFreezeTime : 0, E.freezeRate = E.totalFreezeTime / E.totalDuration, E.receiveDelay = T.jitterBufferMs, E.totalDuration > 10 && Ug.isRemoteAudioFreeze(u) && (E.totalFreezeTime += 1)), O) { "H264" !== O.codec && "H265" !== O.codec && "VP8" !== O.codec && "VP9" !== O.codec && "AV1X" !== O.codec && "AV1" !== O.codec || (_.codecType = O.codec), _.receiveBytes = O.bytes, _.receiveBitrate = a ? 8 * Math.max(0, _.receiveBytes - a.receiveBytes) : 0, _.decodeFrameRate = O.decodeFrameRate < 0 ? 0 : O.decodeFrameRate, _.renderFrameRate = O.decodeFrameRate < 0 ? 0 : O.decodeFrameRate, O.outputFrame && (_.renderFrameRate = O.outputFrame.frameRate), O.receivedFrame ? (_.receiveFrameRate = O.receivedFrame.frameRate, _.receiveResolutionHeight = O.receivedFrame.height, _.receiveResolutionWidth = O.receivedFrame.width) : l && (_.receiveResolutionHeight = l._videoHeight || 0, _.receiveResolutionWidth = l._videoWidth || 0), void 0 !== O.framesRateFirefox && (_.receiveFrameRate = Math.round(O.framesRateFirefox)), _.receivePackets = O.packets, _.receivePacketsLost = O.packetsLost, _.packetLossRate = _.receivePacketsLost / (_.receivePackets + _.receivePacketsLost), _.totalDuration = a ? a.totalDuration + 1 : 1, _.totalFreezeTime = a ? a.totalFreezeTime : 0, _.receiveDelay = O.jitterBufferMs || 0; const t = !!h && e.getRemoteVideoIsReady(h); l && t && Ug.isRemoteVideoFreeze(l, O, c) && (_.totalFreezeTime += 1), _.freezeRate = _.totalFreezeTime / _.totalDuration } C && (E.end2EndDelay = C.B_ad, _.end2EndDelay = C.B_vd, E.transportDelay = C.B_ed, _.transportDelay = C.B_ed, E.currentPacketLossRate = C.B_ealr4 / 100, _.currentPacketLossRate = C.B_evlr4 / 100, d.uplinkNetworkQuality = C.B_punq ? C.B_punq : 0, d.downlinkNetworkQuality = C.B_pdnq ? C.B_pdnq : 0), this.remoteStats.set(n, { audioStats: E, videoStats: _, videoPcStats: O, networkStats: d }), u && this.exceptionMonitor.setRemoteAudioStats(u, E), l && this.exceptionMonitor.setRemoteVideoStats(l, _) })) } } const Mg = new class extends ph { get visibility() { return document.visibilityState } get lastHiddenTime() { return this._lastHiddenTime } get lastVisibleTime() { return this._lastVisibleTime } constructor() { super(), hl(this, "_lastHiddenTime", 0), hl(this, "_lastVisibleTime", 0), document.addEventListener("visibilitychange", (() => { "hidden" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), Dh.debug("document visibility went ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState) })) } }; function kg(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function Vg(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? kg(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kg(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function xg(e) { return e.match(/^[\.\:\d]+$/) ? "".concat(e.replace(/[^\d]/g, "-"), ".").concat(jh("TURN_DOMAIN")) : (Dh.info("Cannot recognized as IP address ".concat(e, ". Used As Host instead")), e) } function Fg(e, t) { var n, i; const r = jh("GATEWAY_DOMAINS"); let o = r[1] && -1 !== t.indexOf(r[1]) ? 1 : 0; e.addresses = e.addresses || []; const s = e.addresses.map((e => e.domain_prefix ? { address: "".concat(e.domain_prefix, ".").concat(r[o++ % r.length], ":").concat(e.port) } : e.ip.match(/^[\.\:\d]+$/) ? { ip: e.ip, port: e.port, address: "".concat(e.ip.replace(/[^\d]/g, "-"), ".").concat(r[o++ % r.length], ":").concat(e.port) } : (Dh.info("Cannot recognized as IP address ".concat(e.ip, ". Used As Host instead")), { ip: e.ip, port: e.port, address: "".concat(e.ip, ":").concat(e.port) }))); if (null !== (n = e.detail) && void 0 !== n && n[18] && "string" == typeof (null === (i = e.detail) || void 0 === i ? void 0 : i[18])) { const t = e.detail[18], n = null == t ? void 0 : t.split(";"); for (let e = 0; e < n.length; e++) { var a; const t = Tu(a = n[e]).call(a); s[e] && t && (s[e].ip6 = t) } } return { gatewayAddrs: s, uid: e.uid, cid: e.cid, cert: e.cert, vid: e.detail && e.detail[8], uni_lbs_ip: e.detail && e.detail[1], res: e, csIp: e.detail && e.detail[502] } } function Yg(e) { return "number" == typeof e ? e : e.exact || e.ideal || e.max || e.min || 0 } function Bg(e) { const t = e._encoderConfig; if (!t) return {}; const n = { resolution: t.width && t.height ? "".concat(Yg(t.width), "x").concat(Yg(t.height)) : void 0, maxVideoBW: t.bitrateMax, minVideoBW: t.bitrateMin }; return "number" == typeof t.frameRate ? (n.maxFrameRate = t.frameRate, n.minFrameRate = t.frameRate) : t.frameRate && (n.maxFrameRate = t.frameRate.max || t.frameRate.ideal || t.frameRate.exact || t.frameRate.min, n.minFrameRate = t.frameRate.min || t.frameRate.ideal || t.frameRate.exact || t.frameRate.max), n } function Gg(e) { return e >= 0 && e < .17 ? 1 : e >= .17 && e < .36 ? 2 : e >= .36 && e < .59 ? 3 : e >= .59 && e <= 1 ? 4 : e > 1 ? 5 : 0 } function jg(e, t) { let n, i, r; switch (t) { case qO.CHOOSE_SERVER: n = 4096, i = "choose server"; break; case qO.CLOUD_PROXY: n = 1048576, i = "proxy"; break; case qO.CLOUD_PROXY_5: n = 4194304, i = "proxy5"; break; case qO.CLOUD_PROXY_FALLBACK: n = 4194310, i = "proxy fallback"; break; default: throw new Ch(Oh.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e.detail && e.detail[502], retry: !1 }) }if (e.response_body.forEach((t => { t.buffer && t.buffer.flag === n && (r = { code: t.buffer.code, addresses: (t.buffer.edges_services || []).map((e => Vg(Vg({}, e), {}, { ticket: t.buffer.cert }))), server_ts: e.enter_ts, uid: t.buffer.uid, cid: t.buffer.cid, cname: t.buffer.cname, detail: Vg(Vg({}, t.buffer.detail), e.detail), flag: t.buffer.flag, opid: e.opid, cert: t.buffer.cert }) })), !r) throw new Ch(Oh.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(i, " from multi unilbs response"), { csIp: e.detail && e.detail[502] }); return r } async function Hg(e, t) { return await Cd.all(e.addresses.map((async e => ({ address: xg(e.ip), tcpport: e.port, udpport: e.port, username: t && jh("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t.toString() : bh.username, password: t && jh("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await DA(t.toString()) : bh.password })))) } function Wg(e, t) { const n = t._videoWidth || t.getMediaStreamTrack(!0).getSettings().width; return n || Dh.warning("cannot get original video track's width, default scale down 4 times for low stream"), n ? n / Yg(e.width) : 4 } function Kg(e) { let { candidateType: t, relayProtocol: n, type: i, address: r, port: o, protocol: s } = e; return "local-candidate" === i ? { candidateType: t, relayProtocol: n, protocol: s } : { candidateType: t, relayProtocol: n, address: r, port: o, protocol: s } } function Jg(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function Xg(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? Jg(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jg(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function qg(e) { return window.TextEncoder ? (new TextEncoder).encode(e).length : e.length } function Qg(e) { return new Cd((t => { window.setTimeout(t, e) })) } function zg(e) { const t = new Ch(Oh.TIMEOUT, "timeout"); return new Cd(((n, i) => { window.setTimeout((() => i(t)), e) })) } function Zg() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, t = arguments.length > 1 ? arguments[1] : void 0; const n = Math.random().toString(16).substr(2, e).toLowerCase(); return n.length === e ? "".concat(t).concat(n) : "".concat(t).concat(n) + Zg(e - n.length, "") } function $g() { return Zg(32, "").toUpperCase() } const em = () => { }; function tm(e) { return new Cd(((t, n) => { let i = !1; const r = document.createElement("video"); r.setAttribute("autoplay", ""), r.setAttribute("muted", ""), r.muted = !0, r.autoplay = !0, r.setAttribute("playsinline", ""), r.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(r); const o = Ju() ? "canplay" : "playing"; r.addEventListener(o, (() => { const e = r.videoWidth, n = r.videoHeight; !e && Ku() || (i = !0, r.srcObject = null, r.remove(), t([e, n])) })), r.srcObject = new MediaStream([e]), r.play().catch(em), setTimeout((() => { i || (r.srcObject = null, r.remove(), t([r.videoWidth, r.videoHeight])) }), 4e3) })) } function nm(e) { return Cd.all(e.map((e => e.then((e => { throw e }), (e => e))))).then((e => { throw e }), (e => e)) } function im(e, t) { for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++)i[r - 2] = arguments[r]; return 0 === e.getListeners(t).length ? Cd.reject(new Ch(Oh.UNEXPECTED_ERROR, "can not emit promise")) : new Cd(((n, r) => { e.emit(t, ...i, n, r) })) } function rm(e, t) { if (0 === e.getListeners(t).length) return Cd.resolve(); for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++)i[r - 2] = arguments[r]; return im(e, t, ...i) } function om(e, t) { if (0 === e.getListeners(t).length) return null; for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++)i[r - 2] = arguments[r]; return sm(e, t, ...i) } function sm(e, t) { let n = null, i = null; for (var r = arguments.length, o = new Array(r > 2 ? r - 2 : 0), s = 2; s < r; s++)o[s - 2] = arguments[s]; if (e.emit(t, ...o, (e => { n = e }), (e => { i = e })), null !== i) throw i; if (null === n) throw new Ch(Oh.UNEXPECTED_ERROR, "handler is not sync"); return n } function am(e, t) { const n = e.indexOf(t); -1 !== n && e.splice(n, 1) } function cm(e) { const t = []; return e.forEach((e => { -1 === t.indexOf(e) && t.push(e) })), t } function Em(e) { Cd.resolve().then(e) } function _m(e) { return JSON.parse(JSON.stringify(e)) } const dm = {}; function um(e, t) { dm[t] || (dm[t] = !0, e()) } function lm(e) { const t = window.atob(e), n = new Uint8Array(new ArrayBuffer(t.length)); for (let i = 0; i < t.length; i += 1)n[i] = t.charCodeAt(i); return n } function Rm(e) { let t = ""; for (let n = 0; n < e.length; n += 1)t += String.fromCharCode(e[n]); return window.btoa(t) } const hm = new class { constructor() { hl(this, "fnMap", new Map) } throttleByKey(e, t, n, i) { for (var r = arguments.length, o = new Array(r > 4 ? r - 4 : 0), s = 4; s < r; s++)o[s - 4] = arguments[s]; if (this.fnMap.has(t)) { const r = this.fnMap.get(t); if (r.threshold !== n) { r.fn(...r.args), clearTimeout(r.timer); const s = window.setTimeout((() => { const e = this.fnMap.get(t); e && e.fn(...e.args), this.fnMap.delete(t) }), n); this.fnMap.set(t, { fn: e, threshold: n, timer: s, args: o, skipFn: i }) } else r.skipFn && r.skipFn(...r.args), this.fnMap.set(t, Xg(Xg({}, r), {}, { fn: e, args: o, skipFn: i })) } else { const r = window.setTimeout((() => { const e = this.fnMap.get(t); e && e.fn(...e.args), this.fnMap.delete(t) }), n); this.fnMap.set(t, { fn: e, threshold: n, timer: r, args: o, skipFn: i }) } } }, pm = hm.throttleByKey.bind(hm), Tm = async e => { let { fragementLength: t, referenceList: n, asyncMapHandler: i, allFailedhandler: r, promisesCollector: o } = e, s = 0; const a = t; let c, E = 0; const _ = async () => { const e = (() => { const e = s * a, t = e + a; return n.slice(e, t).map(i) })(); o && o.push(...e); try { c = await nm(e) } catch (e) { if (E += a, s++, !(E >= n.length)) return void (await _()); r(e) } e.forEach((e => e.cancel())) }; return await _(), c }; function Om(e) { return "object" == typeof e && null !== e && !(e instanceof RegExp) } const Cm = { [OT.ACCESS_POINT]: { [ST.NO_FLAG_SET]: { desc: "flag is zero", retry: !1 }, [ST.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: !1 }, [ST.INVALID_FALG_SET]: { desc: "invalid flag", retry: !1 }, [ST.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: !1 }, [ST.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: !1 }, [ST.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voice service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: !0 }, [ST.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: !0 } }, [OT.UNILBS]: { [AT.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: !1 }, [AT.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: !1 }, [AT.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: !1 }, [AT.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: !1 }, [AT.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: !1 }, [AT.NO_ACTIVE_STATUS]: { desc: "no active status", retry: !1 }, [AT.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: !1 }, [AT.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: !1 }, [AT.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: !1 }, [AT.USER_OVERLOAD]: { desc: "amount of users over load", retry: !1 }, [AT.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: !1 }, [AT.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: !1 } }, [OT.STRING_UID_ALLOCATOR]: { [CT.IIIEGAL_APPID]: { desc: "invalid appid", retry: !1 }, [CT.IIIEGAL_UID]: { desc: "invalid string uid", retry: !1 }, [CT.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: !0 } } }; function Am(e) { const t = Cm[Math.floor(e / 1e4)]; if (!t) return { desc: "unkonw error", retry: !1 }; const n = t[e % 1e4]; if (!n) { if (Math.floor(e / 1e4) === OT.ACCESS_POINT) { const t = e % 1e4; if ("1" === t.toString()[0]) return { desc: e.toString(), retry: !1 }; if ("2" === t.toString()[0]) return { desc: e.toString(), retry: !0 } } return { desc: "unkonw error", retry: !1 } } return n } const Sm = { [gT.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [gT.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [gT.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [gT.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [gT.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [gT.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [gT.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [gT.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [gT.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [gT.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [gT.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [gT.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [gT.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [gT.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [gT.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [gT.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [gT.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [gT.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [gT.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [gT.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [gT.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [gT.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [gT.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [gT.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [gT.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [gT.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [gT.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [gT.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [gT.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [gT.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [gT.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [gT.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [gT.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [gT.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [gT.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [gT.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [gT.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [gT.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [gT.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [gT.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [gT.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [gT.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [gT.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [gT.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [gT.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [gT.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [gT.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [gT.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [gT.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [gT.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [gT.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [gT.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [gT.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [gT.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [gT.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [gT.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [gT.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [gT.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [gT.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [gT.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [gT.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [gT.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [gT.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [gT.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } }; function gm(e) { return Sm[e] || { desc: "UNKNOW_ERROR_".concat(e), action: "failed" } } function mm(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } class Im extends ph { get url() { return this.websocket ? this.websocket.url : null } get reconnectMode() { return this._reconnectMode } set reconnectMode(e) { ["tryNext", "recover"].includes(e) && this.resetReconnectCount(e), this._reconnectMode = e } get state() { return this._state } set state(e) { e !== this._state && (this._state = e, "reconnecting" === this._state ? this.emit(HT.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(HT.CONNECTED) : "closed" === this._state ? this.emit(HT.CLOSED) : "failed" === this._state && this.emit(HT.FAILED)) } resetReconnectCount(e) { Dh.debug("websocket reset reconnect count, reason: " + e), this.reconnectCount = 0 } constructor(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r = arguments.length > 4 ? arguments[4] : void 0; super(), hl(this, "connectionID", 0), hl(this, "currentURLIndex", 0), hl(this, "urls", void 0), hl(this, "_reconnectMode", "tryNext"), hl(this, "reconnectReason", void 0), hl(this, "_initMutex", new kA("websocket")), hl(this, "name", void 0), hl(this, "_state", "closed"), hl(this, "reconnectInterrupter", void 0), hl(this, "websocket", void 0), hl(this, "retryConfig", void 0), hl(this, "reconnectCount", 0), hl(this, "forceCloseTimeout", 5e3), hl(this, "onlineReconnectListener", void 0), hl(this, "useCompress", void 0), hl(this, "tryDoubleDomain", !1), hl(this, "wsInflateLength", 0), hl(this, "wsDeflateLength", 0), hl(this, "closeEstablishingWs", (() => { })), hl(this, "store", void 0), hl(this, "joinChannelServiceRecordIndex", void 0), this.store = r, this.name = e, this.retryConfig = function (e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? mm(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mm(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e }({}, t), this.useCompress = n, this.tryDoubleDomain = i; const { timeout: o, timeoutFactor: s } = t, a = Math.max(300, Math.floor(3 * o / 5)), c = Math.max(1.2, Math.floor(8 * s) / 10); wO.ONLINE && (this.retryConfig.timeout = a, this.retryConfig.timeoutFactor = c), gA.on(bO.NETWORK_STATE_CHANGE, ((e, t) => { e !== t && (this.resetReconnectCount("network state change: ".concat(t, " -> ").concat(e)), e === wO.ONLINE ? (this.retryConfig.timeout = a, this.retryConfig.timeoutFactor = c) : (this.retryConfig.timeout = o, this.retryConfig.timeoutFactor = s)) })) } getConnection() { return this.websocket || void 0 } init(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3; this.forceCloseTimeout = t; const n = (t, n) => { this.urls = e; const i = this.urls[this.currentURLIndex]; this.state = "connecting", this.createWebSocketConnection(i).then(t).catch(n), this.once(HT.CLOSED, (() => n(new Ch(Oh.WS_DISCONNECT)))), this.once(HT.CONNECTED, (() => t())) }; return this._initMutex.lock().then((e => new Cd(((e, t) => { n(e, t) })).then((() => { e() })).catch((() => { e() })))) } close(e, t) { if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) { this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null; const e = this.websocket; t ? setTimeout((() => e.close()), 500) : e.close(), this.websocket = void 0 } this.state = e ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs() } reconnect(e, t) { if (!this.websocket) return void Dh.warning("[".concat(this.name, "] can not reconnect, no websocket")); var n; void 0 !== e && (this.reconnectMode = e), Dh.debug("[".concat(this.name, "] reconnect is triggered initiative")), "number" == typeof this.joinChannelServiceRecordIndex && (null === (n = this.store) || void 0 === n || n.recordJoinChannelService({ status: "error", errors: [new Error(t)] }, this.joinChannelServiceRecordIndex)); const i = this.websocket.onclose; this.websocket.onclose = null, this.websocket.close(), i && i.bind(this.websocket)({ code: 9999, reason: t }) } sendMessage(e) { let t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new Ch(Oh.WS_ABORT, "websocket is not ready"); try { t || (e = JSON.stringify(e)), this.websocket.send(e) } catch (e) { throw new Ch(Oh.WS_ERR, "send websocket message error" + e.toString()) } } setWsInflateData(e) { this.wsDeflateLength = this.wsDeflateLength + e.originLength, this.wsInflateLength = this.wsInflateLength + e.compressedLength } getWsInflateData() { const e = this.wsInflateLength, t = this.wsDeflateLength; return this.clearWsInflateData(), { wsInflateLength: e, wsDeflateLength: t } } clearWsInflateData() { this.wsInflateLength = 0, this.wsDeflateLength = 0 } async createWebSocketConnection(e, t) { return this.connectionID += 1, this.connectionID, this.joinChannelServiceRecordIndex = void 0, new Cd(((n, i) => { var r; const o = e => { var t; null === (t = this.store) || void 0 === t || t.signalChannelOpen(), Dh.debug("[".concat(this.name, "] websocket opened:"), e), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), n() }, s = async e => { if (Dh.debug("[".concat(this.name, "] websocket close ").concat(this.websocket && this.websocket.url, ", code: ").concat(e.code, ", reason: ").concat(e.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount < this.retryConfig.maxRetryCount) { "connected" === this.state && (this.reconnectReason = e.reason, this.state = "reconnecting"); const t = om(this, HT.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, r = await this.reconnectWithAction(t); if ("closed" === this.state) return void Dh.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect")); if (!r) return i(new Ch(Oh.WS_DISCONNECT, "websocket reconnect failed: ".concat(e.code))), void this.close(!0); n() } else i(new Ch(Oh.WS_DISCONNECT, "websocket close: ".concat(e.code))), this.close() }, a = e => { this.emit(HT.ON_MESSAGE, e) }; this.websocket && (this.websocket.onclose = null, this.websocket.close()), jh("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e = jh("GATEWAY_WSS_ADDRESS")), Dh.debug("[".concat(this.name, "] start connect, url: ").concat(e)); const c = null === (r = this.store) || void 0 === r ? void 0 : r.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" }); this.chooseBestWebsocketConnection(e, !!t, c).then((e => { var t; this.websocket = e, o && o(e.url), e.onclose = s, e.onmessage = a, null === (t = this.store) || void 0 === t || t.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c), this.joinChannelServiceRecordIndex = c })).catch((e => { var t; if (null === (t = this.store) || void 0 === t || t.recordJoinChannelService({ endTs: Date.now(), status: e instanceof Ch && e.code === Oh.WS_ABORT ? "aborted" : "error", errors: [e] }, c), "closed" !== this.state) { if (e instanceof Ch && e.code === Oh.WS_ERR) { const t = new Ch(Oh.WS_ERR, "init websocket failed! Error: ".concat(e.toString())); return Dh.error("[".concat(this.name, "]").concat(t)), void i(t) } s && s(e) } else i(new Ch(Oh.WS_DISCONNECT, "websocket is closed: ".concat(e.toString()))) })) })) } async reconnectWithAction(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; if (this.reconnectCount >= this.retryConfig.maxRetryCount) return !1; if (!this.urls) return !1; if ("closed" === this.state) return !1; this.onlineReconnectListener || gA.networkState !== wO.OFFLINE || (this.onlineReconnectListener = gA.onlineWaiter && gA.onlineWaiter.then((() => { this.onlineReconnectListener = void 0 }))); let n = !0; if (this.reconnectInterrupter = () => { n = !1 }, t) { const t = Sh(this.reconnectCount, this.retryConfig); Dh.debug("[".concat(this.name, "] wait ").concat(t, "ms to reconnect websocket, mode: ").concat(e)), await Cd.race([Qg(t), this.onlineReconnectListener || new Cd((() => { }))]) } if ("closed" === this.state || !n) return !1; this.reconnectCount += 1; const i = async (e, t) => { this.emit(HT.RECONNECT_CREATE_CONNECTION, t), await this.createWebSocketConnection(e) }; try { if ("retry" === e) { const t = this.urls[this.currentURLIndex]; this.emit(HT.RECONNECT_WAITTING_FINISH, e), await i(t, e) } else if ("tryNext" === e) { if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length) return await this.reconnectWithAction("recover", !1); Dh.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex)); const t = this.urls[this.currentURLIndex]; this.emit(HT.RECONNECT_WAITTING_FINISH, e), await i(t, e) } else if ("recover" === e) { Dh.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.emit(HT.RECONNECT_WAITTING_FINISH, e), this.urls = await im(this, HT.REQUEST_NEW_URLS), this.currentURLIndex = 0; const t = this.urls[this.currentURLIndex]; await i(t, e) } return !0 } catch (n) { var r; return Dh.error("[".concat(this.name, "] reconnect failed"), n.toString()), null != n && null !== (r = n.data) && void 0 !== r && r.desc && Array.isArray(n.data.desc) && n.data.desc.length && n.data.desc.includes("dynamic key expired") ? (this.emit(HT.ON_TOKEN_PRIVILEGE_DID_EXPIRE), !1) : await this.reconnectWithAction(e, t) } } async chooseBestWebsocketConnection(e, t, n) { return new Cd(((i, r) => { let o = !1; const s = []; this.closeEstablishingWs = () => { Dh.debug("[choose-best-ws] close establishing websockets"), s.forEach((e => { e.onclose = null, e.onopen = null, e.onmessage = null, e.close() })), r(new Ch(Oh.WS_ABORT, "choose best websocket aborted")) }; const a = jh("GATEWAY_DOMAINS"); let c; const E = e.indexOf("?h="), _ = a.find((t => -1 !== E ? e.includes(t, E) : e.includes(t))); Dh.debug("[choose-best-ws] currentDomain: ", _, ", domains: ", a); let d = !this.tryDoubleDomain || t || !_; if (!d && _) { var u; const t = Date.now(); try { a.forEach((t => { const n = -1 === E ? e.replace(_, t) : e.substr(0, E) + e.substr(E).replace(_, t), i = new WebSocket(n); i.binaryType = "arraybuffer", s.push(i), Dh.debug("[choose-best-ws] ws is connecting:", i.url) })) } catch (e) { for (Dh.debug("[choose-best-ws] ws create failed, fallback to single url"), s.forEach((e => e.close())); s.length;)s.pop(); d = !0 } null === (u = this.store) || void 0 === u || u.recordJoinChannelService({ urls: s.map((e => e.url)), service: "gateway" }, n), s.forEach((e => { e.onopen = () => { if (o) return; const n = Date.now() - t; Dh.debug("[choose-best-ws] ws open cost ".concat(n, "ms")), s.filter((t => t !== e)).forEach((e => { Dh.debug("[choose-best-ws]close backup websocket: ".concat(e.url)), e.close() })), o = !0, i(e) }, e.onclose = e => { c = e, o || s.find((e => !(e.readyState === WebSocket.CLOSED || e.readyState === WebSocket.CLOSING))) || (Dh.debug("[choose-best-ws] all websocket is closed"), o = !0, r(c)) }, e.onmessage = t => { Dh.debug("[choose-best-ws]".concat(e.url, " onmessage: ").concat(t.data)) } })), Qg(this.forceCloseTimeout).then((() => { s.forEach((e => { e.readyState !== WebSocket.OPEN && e.close() })) })) } if (d) { var l; let t; Dh.debug("[choose-best-ws] use single url: ", e), null === (l = this.store) || void 0 === l || l.recordJoinChannelService({ urls: [e], service: "gateway" }, n); try { t = new WebSocket(e), s.push(t), t.binaryType = "arraybuffer" } catch (e) { const n = new Ch(Oh.WS_ERR, "init websocket failed! Error: ".concat(e.toString())); return Dh.error("[".concat(this.name, "]").concat(n)), void r(n) } t.onopen = () => { i(t) }, t.onclose = e => { r(e) }, t.onmessage = e => { Dh.debug("[choose-best-ws]".concat(t.url, " onmessage: ").concat(e.data)) }, Qg(this.forceCloseTimeout).then((() => { t && t.readyState !== WebSocket.OPEN && t.close() })) } })).then((e => (this.closeEstablishingWs = void 0, e))).catch((e => { throw this.closeEstablishingWs = void 0, e })) } } class fm { constructor(e) { hl(this, "input", []), hl(this, "size", void 0), this.size = e } add(e) { this.input.push(e), this.input.length > this.size && this.input.splice(0, 1) } mean() { var e; return 0 === this.input.length ? 0 : Zn(e = this.input).call(e, ((e, t) => e + t)) / this.input.length } } class Pm extends ph { get connectionState() { return this._connectionState } set connectionState(e) { e !== this._connectionState && (this._connectionState = e, e === NT.CONNECTED ? this.emit(DT.WS_CONNECTED) : e === NT.RECONNECTING ? this.emit(DT.WS_RECONNECTING, this._websocketReconnectReason) : e === NT.CLOSED && this.emit(DT.WS_CLOSED, this._disconnectedReason)) } get currentURLIndex() { return this.websocket.currentURLIndex } get url() { return this.websocket ? this.websocket.url : null } get rtt() { return this.rttRolling.mean() } constructor(e, t) { super(), hl(this, "_disconnectedReason", void 0), hl(this, "_websocketReconnectReason", void 0), hl(this, "_connectionState", NT.CLOSED), hl(this, "reconnectToken", void 0), hl(this, "websocket", void 0), hl(this, "openConnectionTime", void 0), hl(this, "clientId", void 0), hl(this, "lastMsgTime", Date.now()), hl(this, "uploadCache", []), hl(this, "uploadCacheInterval", void 0), hl(this, "rttRolling", new fm(5)), hl(this, "pingpongTimer", void 0), hl(this, "wsInflateDataTimer", void 0), hl(this, "pingpongTimeoutCount", 0), hl(this, "joinResponse", void 0), hl(this, "multiIpOption", void 0), hl(this, "initError", void 0), hl(this, "spec", void 0), hl(this, "store", void 0), hl(this, "onWebsocketMessage", (e => { if (e.data instanceof ArrayBuffer) return void this.emit(DT.ON_BINARY_DATA, e.data); const t = JSON.parse(e.data); if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t, "_id")) { const e = "res-@".concat(t._id); this.emit(e, t._result, t._message) } else if (Object.prototype.hasOwnProperty.call(t, "_type")) { if (this.emit(t._type, t._message), t._type === LT.ON_NOTIFICATION && this.handleNotification(t._message), t._type === LT.ON_USER_BANNED) switch (t._message.error_code) { case 14: this.close(IT.UID_BANNED); break; case 15: this.close(IT.IP_BANNED); break; case 16: this.close(IT.CHANNEL_BANNED) }if (t._type === LT.ON_USER_LICENSE_BANNED) switch (t._message.error_code) { case gT.ERR_LICENSE_MISSING: this.close(IT.LICENSE_MISSING); break; case gT.ERR_LICENSE_EXPIRED: this.close(IT.LICENSE_EXPIRED); break; case gT.ERR_LICENSE_MINUTES_EXCEEDED: this.close(IT.LICENSE_MINUTES_EXCEEDED); break; case gT.ERR_LICENSE_PERIOD_INVALID: this.close(IT.LICENSE_PERIOD_INVALID); break; case gT.ERR_LICENSE_MULTIPLE_SDK_SERVICE: this.close(IT.LICENSE_MULTIPLE_SDK_SERVICE); break; case gT.ERR_LICENSE_ILLEGAL: this.close(IT.LICENSE_ILLEGAL); break; default: this.close() } } })), this.clientId = e.clientId, this.spec = e, this.store = t, this.websocket = new Im("gateway-".concat(this.clientId), this.spec.retryConfig, !0, !0, t), this.handleWebsocketEvents(), window.addEventListener("offline", (() => { this.connectionState === NT.CONNECTED && this.reconnect("retry", PT.OFFLINE) })) } async request(e, t, n, i) { const r = Zg(6, ""), o = { _id: r, _type: e, _message: t }, s = this.websocket.connectionID, a = () => new Cd(((t, n) => { if (this.connectionState === NT.CONNECTED) return t(); const i = () => { this.off(DT.WS_CLOSED, r), t() }, r = () => { this.off(DT.WS_CONNECTED, i), n(new Ch(Oh.WS_ABORT)) }; this.once(DT.WS_CONNECTED, i), this.once(DT.WS_CLOSED, r), e !== vT.PUBLISH && e !== vT.SUBSCRIBE && e !== vT.UNSUBSCRIBE && e !== vT.UNPUBLISH && e !== vT.CONTROL && e !== vT.RESTART_ICE || this.once(DT.DISCONNECT_P2P, (() => { n(new Ch(Oh.DISCONNECT_P2P)) })), e !== vT.PUBLISH && e !== vT.RESTART_ICE || this.once(DT.ABORT_P2P_EXECUTION, (() => { n(new Ch(Oh.DISCONNECT_P2P)) })) })); if (this.connectionState !== NT.CONNECTING && this.connectionState !== NT.RECONNECTING || e === vT.JOIN || e === vT.REJOIN || await a(), this.websocket.sendMessage(o, !0), i) return; const c = new Cd(((n, i) => { let o = !1; const a = (i, r) => { o = !0, n({ isSuccess: "success" === i, message: r || {} }), this.off(DT.WS_CLOSED, c), this.off(DT.WS_RECONNECTING, c), this.emit(DT.REQUEST_SUCCESS, e, t) }; this.once("res-@".concat(r), a); const c = () => { i(new Ch(Oh.WS_ABORT, "type: ".concat(e))), this.off(DT.WS_CLOSED, c), this.off(DT.WS_RECONNECTING, c), this.off("res-@".concat(r), a) }; this.once(DT.WS_CLOSED, c), this.once(DT.WS_RECONNECTING, c), Qg(jh("SIGNAL_REQUEST_TIMEOUT")).then((() => { this.websocket.connectionID !== s || o || (Dh.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e)), this.emit(DT.REQUEST_TIMEOUT, e, t)) })) })); let E = null; try { E = await c } catch (i) { if (this.connectionState === NT.CLOSED || e === vT.LEAVE) throw new Ch(Oh.WS_ABORT); return !this.spec.forceWaitGatewayResponse || n ? i.throw() : e === vT.JOIN || e === vT.REJOIN ? null : (await a(), await this.request(e, t)) } if (E.isSuccess) return E.message; const _ = Number(E.message.error_code || E.message.code), d = gm(_), u = new Ch(Oh.UNEXPECTED_RESPONSE, "".concat(d.desc, ": ").concat(E.message.error_str), { code: _, data: E.message }); return "success" === d.action ? E.message : (Dh.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e, ", error_code: ").concat(_, ", message: ").concat(d.desc, ", action: ").concat(d.action)), _ === gT.ERR_TOO_MANY_BROADCASTERS ? e === vT.JOIN || e === vT.REJOIN ? (this.initError = u, this.close(), u.throw()) : u.throw() : "failed" === d.action ? u.throw() : "quit" === d.action ? (this.initError = u, this.close(), u.throw()) : (_ === gT.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = E.message.option, Dh.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", PT.MULTI_IP)) : this.reconnect(d.action, PT.SERVER_ERROR), e === vT.JOIN || e === vT.REJOIN ? null : await this.request(e, t))) } waitMessage(e, t) { return new Cd((n => { const i = r => { (!t || t(r)) && (this.off(e, i), n(r)) }; this.on(e, i) })) } upload(e, t) { const n = { _type: e, _message: t }; try { this.websocket.sendMessage(n) } catch (e) { const t = jh("MAX_UPLOAD_CACHE") || 50; this.uploadCache.push(n), this.uploadCache.length > t && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval((() => { if (this.connectionState !== NT.CONNECTED) return; const e = this.uploadCache.splice(0, 1)[0]; 0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e._type, e._message) }), jh("UPLOAD_CACHE_INTERVAL") || 2e3)) } } send(e, t) { const n = { _type: e, _message: t }; this.websocket.sendMessage(n) } init(e, t) { return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Cd(((n, i) => { this.once(DT.WS_CONNECTED, (() => n(this.joinResponse))), this.once(DT.WS_CLOSED, (() => i(this.initError || new Ch(Oh.WS_ABORT)))), this.connectionState = NT.CONNECTING, this.websocket.init(e).catch(i), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval((() => { this.handleWsInflateData() }), 2e4), setTimeout((() => { t && void 0 === this.openConnectionTime && (Dh.debug("[".concat(this.clientId, "] init websocket timeout while join with fallback to proxy")), i(new Ch(Oh.INIT_WEBSOCKET_TIMEOUT))) }), jh("JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION")) })) } close(e) { this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e || IT.LEAVE, this.connectionState = NT.CLOSED, Dh.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), e === IT.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new Im("gateway-".concat(this.clientId), this.spec.retryConfig, !0, !0, this.store), this.handleWebsocketEvents()) } async join() { if (!this.joinResponse) { this.emit(DT.ABORT_P2P_EXECUTION); const e = await im(this, DT.REQUEST_JOIN_INFO), t = await this.request(vT.JOIN, e); if (!t) return this.emit(DT.REPORT_JOIN_GATEWAY, Oh.TIMEOUT, this.url || ""), !1; this.joinResponse = t, this.emit(DT.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token } return this.connectionState = NT.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), !0 } async rejoin() { if (!this.reconnectToken) throw new Ch(Oh.UNEXPECTED_ERROR, "can not rejoin, no rejoin token"); const e = sm(this, DT.REQUEST_REJOIN_INFO); e.token = this.reconnectToken; const t = await this.request(vT.REJOIN, e); return !!t && (this.connectionState = NT.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t.peers && t.peers.forEach((e => { this.emit(LT.ON_USER_ONLINE, { uid: e.uid }), e.audio && this.emit(LT.ON_ADD_AUDIO_STREAM, { uid: e.uid, uint_id: e.uint_id, audio: !0, ssrcId: e.audio_ssrc }), e.video && this.emit(LT.ON_ADD_VIDEO_STREAM, { uid: e.uid, uint_id: e.uint_id, video: !0, ssrcId: e.video_ssrc }), e.audio_mute ? this.emit(LT.MUTE_AUDIO, { uid: e.uid }) : this.emit(LT.UNMUTE_AUDIO, { uid: e.uid }), e.video_mute ? this.emit(LT.MUTE_VIDEO, { uid: e.uid }) : this.emit(LT.UNMUTE_VIDEO, { uid: e.uid }), e.audio_enable_local ? this.emit(LT.ENABLE_LOCAL_AUDIO, { uid: e.uid }) : this.emit(LT.DISABLE_LOCAL_AUDIO, { uid: e.uid }), e.video_enable_local ? this.emit(LT.ENABLE_LOCAL_VIDEO, { uid: e.uid }) : this.emit(LT.DISABLE_LOCAL_VIDEO, { uid: e.uid }), e.audio || e.video || this.emit(LT.ON_REMOVE_STREAM, { uid: e.uid, uint_id: e.uint_id }) })), !0) } reconnect(e, t) { this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, t) } handleNotification(e) { Dh.debug("[".concat(this.clientId, "] receive notification: "), e); const t = gm(e.code); if ("success" !== t.action) { if ("failed" !== t.action) return "quit" === t.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t.desc && this.close(IT.UID_BANNED), void this.close()) : void this.reconnect(t.action, PT.SERVER_ERROR); Dh.error("[".concat(this.clientId, "] ignore error: "), t.desc) } } handlePingPong() { if (!this.websocket || "connected" !== this.websocket.state) return; this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1; const e = jh("PING_PONG_TIME_OUT"), t = Date.now(); this.pingpongTimeoutCount >= e && (Dh.warning("[".concat(this.clientId, "] PINGPONG Timeout. Last Socket Message: ").concat(t - this.lastMsgTime, "ms")), t - this.lastMsgTime > jh("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", PT.TIMEOUT) : this.request(vT.PING, void 0, !0).then((() => { this.pingpongTimeoutCount = 0; const e = Date.now() - t; this.rttRolling.add(e), jh("REPORT_STATS") && this.send(vT.PING_BACK, { pingpongElapse: e }) })).catch((e => { })) } handleWsInflateData() { const { wsInflateLength: e, wsDeflateLength: t } = this.websocket.getWsInflateData(); 0 !== e && 0 !== t && this.upload(yT.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t, ws_inflate_length: e }) } handleWebsocketEvents() { this.websocket.on(HT.RECONNECT_WAITTING_FINISH, (e => { this.emit(DT.WS_RECONNECT_WAITTING_FINISH, e) })), this.websocket.on(HT.RECONNECT_CREATE_CONNECTION, (e => { this.emit(DT.WS_RECONNECT_CREATE_CONNECTION, e) })), this.websocket.on(HT.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(HT.CLOSED, (() => { this.connectionState = NT.CLOSED })), this.websocket.on(HT.FAILED, (() => { this._disconnectedReason = IT.NETWORK_ERROR, this.connectionState = NT.CLOSED })), this.websocket.on(HT.RECONNECTING, (e => { this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === NT.CONNECTED ? this.connectionState = NT.RECONNECTING : this.connectionState = NT.CONNECTING })), this.websocket.on(HT.WILL_RECONNECT, ((e, t) => { if (sm(this, DT.IS_P2P_DISCONNECTED) && "retry" === e) return Dh.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(DT.NEED_RENEW_SESSION), this.emit(DT.DISCONNECT_P2P), t("tryNext"); "retry" !== e && (Dh.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e)), this.reconnectToken = void 0, this.emit(DT.NEED_RENEW_SESSION), this.emit(DT.DISCONNECT_P2P)), t(e) })), this.websocket.on(HT.CONNECTED, (() => { this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e => { Dh.warning("[".concat(this.clientId, "] rejoin failed ").concat(e)), this.reconnect("tryNext", PT.SERVER_ERROR) })) : this.join().catch((e => { if (this.emit(DT.REPORT_JOIN_GATEWAY, e.message || e.code, this.url || ""), e instanceof Ch && e.code === Oh.UNEXPECTED_RESPONSE && e.data.code === gT.ERR_NO_AUTHORIZED) return Dh.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", PT.SERVER_ERROR); Dh.error("[".concat(this.clientId, "] join gateway request failed"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", PT.SERVER_ERROR) : (this.initError = e, this.close()) })) })), this.websocket.on(HT.REQUEST_NEW_URLS, ((e, t) => { im(this, DT.REQUEST_RECOVER, this.multiIpOption).then(e).catch(t) })), this.websocket.on(HT.ON_TOKEN_PRIVILEGE_DID_EXPIRE, (() => { this.emit(LT.ON_TOKEN_PRIVILEGE_DID_EXPIRE) })) } } function Nm(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } class Dm extends ph { get url() { return this._url ? this._url : null } get reconnectMode() { return this._reconnectMode } set reconnectMode(e) { ["tryNext", "recover"].includes(e) && this.resetReconnectCount(e), this._reconnectMode = e } get state() { return this._state } set state(e) { e !== this._state && (this._state = e, "reconnecting" === this._state ? this.emit(YO.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(YO.CONNECTED) : "closed" === this._state ? this.emit(YO.CLOSED) : "failed" === this._state && this.emit(YO.FAILED)) } constructor(e, t, n, i) { super(), hl(this, "connectionID", 0), hl(this, "currentURLIndex", 0), hl(this, "reconnectReason", void 0), hl(this, "_reconnectMode", "tryNext"), hl(this, "_initMutex", void 0), hl(this, "_name", void 0), hl(this, "_state", "closed"), hl(this, "_reconnectInterrupter", void 0), hl(this, "_url", void 0), hl(this, "_retryConfig", void 0), hl(this, "_reconnectCount", 0), hl(this, "_forceCloseTimeout", 5e3), hl(this, "_onlineReconnectListener", void 0), hl(this, "_closeEstablishingTransmitter", (() => { })), hl(this, "_store", void 0), hl(this, "_joinChannelServiceRecordIndex", void 0), hl(this, "_transmitter", void 0), hl(this, "_useCompress", void 0), hl(this, "_inflateLength", 0), hl(this, "_deflateLength", 0), this._store = i, this._name = e, this._retryConfig = function (e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? Nm(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nm(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e }({}, t), this._useCompress = n } resetReconnectCount(e) { Dh.debug("".concat(this._name, " reset reconnect count, reason: ").concat(e)), this._reconnectCount = 0 } close(e, t) { if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this._reconnectInterrupter && this._reconnectInterrupter(), this._transmitter) { this._transmitter.onclose = null, this._transmitter.onopen = null, this._transmitter.onmessage = null; const e = this._transmitter; t ? setTimeout((() => e.close()), 500) : e.close(), this._transmitter = void 0 } this.state = e ? "failed" : "closed", this._closeEstablishingTransmitter && this._closeEstablishingTransmitter() } reconnect(e, t) { if (!this._transmitter) return void Dh.warning("[".concat(this._name, "] can not reconnect, no websocket")); var n; void 0 !== e && (this.reconnectMode = e), Dh.debug("[".concat(this._name, "] reconnect is triggered initiative")), "number" == typeof this._joinChannelServiceRecordIndex && (null === (n = this._store) || void 0 === n || n.recordJoinChannelService({ status: "error", errors: [new Error(t)] }, this._joinChannelServiceRecordIndex)); const i = this._transmitter.onclose; this._transmitter.onclose = null, this._transmitter.close(), i && i.bind(this._transmitter)({ code: 9999, reason: t }) } getInflateData() { const e = this._inflateLength, t = this._deflateLength; return this.clearInflateData(), { inflateLength: e, deflateLength: t } } setInflateData(e) { this._deflateLength = this._deflateLength + e.originLength, this._inflateLength = this._inflateLength + e.compressedLength } clearInflateData() { this._inflateLength = 0, this._deflateLength = 0 } } function vm(e, t, n) { if ("getBigUint64" in DataView.prototype) return e.getBigUint64(t, n); const i = e.getUint32(t, n), r = e.getUint32(t + 4, n), o = Number(!!n), s = Number(!n); return BigInt(i * s + r * o) << BigInt(32) | BigInt(i * o + r * s) } function ym(e, t, n, i) { if ("setBigUint64" in DataView.prototype) return e.setBigUint64(t, n, i); const r = Number(n >> BigInt(32)), o = Number(n & BigInt(4294967295)); i ? (e.setUint32(t + 4, r, i), e.setUint32(t, o, i)) : (e.setUint32(t, r, i), e.setUint32(t + 4, o, i)) } let Lm; !function (e) { e[e.Default = 0] = "Default", e[e.Ack = 1] = "Ack" }(Lm || (Lm = {})); class wm { constructor(e, t, n) { hl(this, "version", 1), hl(this, "initialRTO", void 0), hl(this, "maxBatchAckCount", void 0), hl(this, "maxRTO", void 0), hl(this, "initialRTT", void 0), hl(this, "ID", void 0), hl(this, "rtt", void 0), hl(this, "packetNumber", 1), hl(this, "rtoRatioMap", new Map), hl(this, "timeoutMap", new Map), hl(this, "unorderedPacketQueue", []), hl(this, "batchAckPacketQueue", []), hl(this, "lastOrderedPacketNumber", 0), hl(this, "batchAckTimer", void 0), hl(this, "sendImpl", void 0), hl(this, "receiveImpl", void 0), this.sendImpl = e, this.receiveImpl = t, this.ID = Zg(7, "transmitter-"), this.initialRTO = void 0 !== (null == n ? void 0 : n.initialRTO) ? n.initialRTO : jh("TRANSMITTER_INITIAL_RTO"), this.initialRTT = void 0 !== (null == n ? void 0 : n.initialRTT) ? n.initialRTT : jh("TRANSMITTER_INITIAL_RTT"), this.rtt = void 0 !== (null == n ? void 0 : n.initialRTT) ? n.initialRTT : jh("TRANSMITTER_INITIAL_RTT"), this.maxBatchAckCount = void 0 !== (null == n ? void 0 : n.maxBatchAckCount) ? n.maxBatchAckCount : jh("TRANSMITTER_MAX_BATCH_ACK_COUNT"), this.maxRTO = void 0 !== (null == n ? void 0 : n.maxRTO) ? n.maxRTO : jh("TRANSMITTER_MAX_RTO") } packetize(e, t) { return { type: Lm.Default, version: this.version, packetNumber: t, payload: e } } serialize(e) { switch (e.type) { case Lm.Default: { let t; t = "string" == typeof e.payload ? (new TextEncoder).encode(e.payload) : e.payload; const n = new ArrayBuffer(t.length + 15), i = new DataView(n); return i.setUint16(0, e.version), i.setUint8(2, e.type), i.setUint32(3, e.packetNumber), ym(i, 7, BigInt(e.sendTs)), new Uint8Array(i.buffer).set(t, 15), n } case Lm.Ack: { const t = new ArrayBuffer(16), n = new DataView(t); return n.setUint16(0, e.version), n.setUint8(2, e.type), n.setUint32(3, e.maxAckPacketNumber), n.setUint8(7, e.shift), ym(n, 8, BigInt(e.ackSendTs)), t } } } deserialize(e) { const t = new DataView(e), n = t.getUint16(0), i = t.getUint8(2); switch (i) { case Lm.Default: { const r = t.getUint32(3), o = vm(t, 7), s = e.slice(15), a = (new TextDecoder).decode(s); return { version: n, type: i, packetNumber: r, sendTs: Number(o), payload: a } } case Lm.Ack: { const e = t.getUint32(3), r = t.getUint8(7), o = vm(t, 8); return { version: n, type: i, maxAckPacketNumber: e, shift: r, ackSendTs: Number(o) } } default: throw Dh.error("[".concat(this.ID, "] Unrecognized packet type ").concat(i)), new Error("Unrecognized packet type ".concat(i)) } } sendMessage(e) { const t = this.packetize(e, this.packetNumber); this.packetNumber = 4294967295 === this.packetNumber ? 1 : this.packetNumber + 1; const n = this.calculateRTO(t), i = window.setTimeout((() => { this.resendMessage(t) }), n); this.timeoutMap.set(t.packetNumber, i), this.sendPacket(t) } onData(e) { const t = this.deserialize(e); t.type === Lm.Default ? this.ack(t) : t.type === Lm.Ack && (this.updateRTT(t, Math.round(performance.now())), this.clearRTO(t)) } close() { this.rtt = this.initialRTT, this.packetNumber = 1, Array.from(this.timeoutMap.entries()).forEach((e => { let [t, n] = e; window.clearTimeout(n) })), this.timeoutMap = new Map, this.rtoRatioMap = new Map, this.unorderedPacketQueue = [], this.batchAckPacketQueue = [], this.lastOrderedPacketNumber = 0, void 0 !== this.batchAckTimer && window.clearTimeout(this.batchAckTimer) } resendMessage(e) { const t = this.calculateRTO(e), n = window.setTimeout((() => { this.resendMessage(e) }), t); this.timeoutMap.set(e.packetNumber, n), this.sendPacket(e) } calculateRTO(e) { const t = this.rtoRatioMap.get(e.packetNumber); if (void 0 === t) return this.rtoRatioMap.set(e.packetNumber, 1), this.initialRTO; { const n = 9 * this.rtt / 8 * t; return this.rtoRatioMap.set(e.packetNumber, t + 1), n > this.maxRTO ? this.maxRTO : n } } updateRTT(e, t) { const n = e.ackSendTs; this.rtt = this.rtt * (7 / 8) + (t - n - this.rtt) / 8 } ack(e) { if (e.packetNumber === this.lastOrderedPacketNumber + 1) for (this.batchAckPacketQueue.length >= this.maxBatchAckCount && this.batchAck(), this.batchAckTimer ? this.batchAckPacketQueue.push(e) : (this.batchAckPacketQueue.push(e), this.batchAckTimer = window.setTimeout((() => { this.batchAck() }), this.rtt / 8)), this.lastOrderedPacketNumber += 1, this.receiveImpl(e.payload); ;) { const e = this.unorderedPacketQueue[0]; if (!e) { this.unorderedPacketQueue.shift(); break } this.batchAckTimer && this.batchAck(), this.receiveImpl(e.payload), this.unorderedPacketQueue.shift(), this.lastOrderedPacketNumber += 1 } else if (e.packetNumber <= this.lastOrderedPacketNumber) { const t = { ackSendTs: e.sendTs, maxAckPacketNumber: e.packetNumber, shift: 0, type: Lm.Ack, version: this.version }; this.sendPacket(t) } else if (e.packetNumber > this.lastOrderedPacketNumber) { this.unorderedPacketQueue[e.packetNumber - this.lastOrderedPacketNumber - 2] = e; const t = { ackSendTs: e.sendTs, maxAckPacketNumber: e.packetNumber, shift: 0, type: Lm.Ack, version: this.version }; this.sendPacket(t) } } batchAck() { window.clearTimeout(this.batchAckTimer), this.batchAckTimer = void 0; const e = { ackSendTs: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].sendTs, maxAckPacketNumber: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].packetNumber, shift: this.batchAckPacketQueue.length - 1, type: Lm.Ack, version: this.version }; this.sendPacket(e), this.batchAckPacketQueue = [] } sendPacket(e) { e.type === Lm.Default && (e.sendTs = Math.round(performance.now())); const t = this.serialize(e); this.sendImpl(t) } clearRTO(e) { for (let t = e.maxAckPacketNumber - e.shift; t <= e.maxAckPacketNumber; t++) { const e = this.timeoutMap.get(t); void 0 !== e && window.clearTimeout(e), this.timeoutMap.delete(t), this.rtoRatioMap.delete(t) } } } class bm extends Dm { constructor(e, t) { super(e, t, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), hl(this, "_initMutex", void 0), hl(this, "_reconnectInterrupter", void 0), hl(this, "_url", void 0), hl(this, "_transmitter", void 0), hl(this, "_addresses", void 0), hl(this, "_reliableTransmission", void 0), this._initMutex = new kA("datachannel"); const { timeout: n, timeoutFactor: i } = t, r = Math.max(300, Math.floor(3 * n / 5)), o = Math.max(1.2, Math.floor(8 * i) / 10); wO.ONLINE && (this._retryConfig.timeout = r, this._retryConfig.timeoutFactor = o), gA.on(bO.NETWORK_STATE_CHANGE, ((e, t) => { e !== t && (this.resetReconnectCount("network state change: ".concat(t, " -> ").concat(e)), e === wO.ONLINE ? (this._retryConfig.timeout = r, this._retryConfig.timeoutFactor = o) : (this._retryConfig.timeout = n, this._retryConfig.timeoutFactor = i)) })) } getConnection() { if (this._reliableTransmission) return this._reliableTransmission } async init(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3; this._forceCloseTimeout = t; const n = (t, n) => { this._addresses = e, this.currentURLIndex = this._addresses.findIndex((e => e.fingerprint || jh("FINGERPRINT"))); const i = this._addresses[this.currentURLIndex]; this.state = "connecting", this.createTransmitterConnection(i).then(t).catch(n), this.once(YO.CLOSED, (() => n(new Ch(Oh.WS_DISCONNECT)))), this.once(YO.CONNECTED, (() => t())) }; return this._initMutex.lock().then((e => new Cd(((e, t) => { n(e, t) })).then((() => { e() })).catch((() => { e() })))) } sendMessage(e) { let t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (!this._transmitter || !this._reliableTransmission) throw new Ch(Oh.WS_ABORT, "datachannel is not ready"); try { t || (e = JSON.stringify(e)), this._reliableTransmission.sendMessage(e) } catch (e) { throw new Ch(Oh.WS_ERR, "send datachannel signal message error" + e.toString()) } } unbindDcCloseEventListener() { this._transmitter && (this._transmitter.onclose = null) } sendMessageWithJSON(e) { const t = JSON.stringify(e); return { compressed: t, compressedLength: t.length, origin: e } } sendMessageWithUint8Array(e) { return { compressed: e, compressedLength: e.byteLength, origin: e } } createTransmitterConnection(e) { return this.connectionID += 1, this._joinChannelServiceRecordIndex = void 0, this._url = "dc://".concat(e.ip, ":").concat(e.port), new Cd(((t, n) => { var i; const r = () => { Dh.debug("[".concat(this._name, "] datachannel opened:"), this._url), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), t() }, o = async e => { var i; if (null === (i = this._closeEstablishingTransmitter) || void 0 === i || i.call(this), Dh.debug("[".concat(this._name, "] datachannel close ").concat(this._url, ", code: ").concat(e.code, ", reason: ").concat(e.reason, ", current mode: ").concat(this.reconnectMode)), this._reconnectCount < this._retryConfig.maxRetryCount) { "connected" === this.state && (this.reconnectReason = e.reason, this.state = "reconnecting"); const i = om(this, YO.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, r = await this.reconnectWithAction(i); if ("closed" === this.state) return void Dh.debug("[".concat(this.connectionID, "] dc is closed, no need to reconnect")); if (!r) return n(new Ch(Oh.WS_DISCONNECT, "datachannel reconnect failed: ".concat(e.code))), void this.close(!0); t() } else n(new Ch(Oh.WS_DISCONNECT, "datachannel close: ".concat(e.code))), this.close() }, s = e => { var t; null === (t = this._reliableTransmission) || void 0 === t || t.onData(e.data) }; this._transmitter && (this._transmitter.onclose = null, this._transmitter.close()), this._reliableTransmission && (this._reliableTransmission.close(), this._reliableTransmission = void 0), Dh.debug("[".concat(this._name, "] start connect, address: ").concat(JSON.stringify(e))); const a = null === (i = this._store) || void 0 === i ? void 0 : i.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" }), c = Date.now(); im(this, YO.TO_CONNECT_DATACHANNEL, e).then((e => { var t, n; if (!e) throw new Error("transmissonInfo not exist yet"); const { transmitter: i, close: E } = e; this._transmitter = i, null === (t = this._store) || void 0 === t || t.signalChannelOpen(); const _ = Date.now() - c; Dh.debug("[choose dc] dc open cost ".concat(_, "ms")), this._reliableTransmission = new wm((e => { var t; this._transmitter && "open" === this._transmitter.readyState && (null === (t = this._transmitter) || void 0 === t || t.send(e)) }), (e => { "string" == typeof e && this.emit(YO.ON_MESSAGE, e) })), this._closeEstablishingTransmitter = () => { var e; null === (e = this._reliableTransmission) || void 0 === e || e.close(), this._reliableTransmission = void 0, E() }, r && r(), i.onclose = o, i.onmessage = s, null === (n = this._store) || void 0 === n || n.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a), this._joinChannelServiceRecordIndex = a })).catch((e => { var t; if (null === (t = this._store) || void 0 === t || t.recordJoinChannelService({ endTs: Date.now(), status: e instanceof Ch && e.code === Oh.WS_ABORT ? "aborted" : "error", errors: [e] }, a), "closed" !== this.state) { if (e instanceof Ch && e.code === Oh.WS_ERR) { const t = new Ch(Oh.WS_ERR, "init datachannel failed! Error: ".concat(e.toString())); return Dh.error("[".concat(this._name, "]").concat(t)), void n(t) } o && o(e) } else n(new Ch(Oh.WS_DISCONNECT, "datachannel is closed: ".concat(e.toString()))) })) })) } async reconnectWithAction(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; if (this._reconnectCount >= this._retryConfig.maxRetryCount) return !1; if (!this._addresses) return !1; if ("closed" === this.state) return !1; this._onlineReconnectListener || gA.networkState !== wO.OFFLINE || (this._onlineReconnectListener = gA.onlineWaiter && gA.onlineWaiter.then((() => { this._onlineReconnectListener = void 0 }))); let n = !0; if (this._reconnectInterrupter = () => { n = !1 }, t) { const t = Sh(this._reconnectCount, this._retryConfig); Dh.debug("[".concat(this._name, "] wait ").concat(t, "ms to reconnect datachannel, mode: ").concat(e)), await Cd.race([Qg(t), this._onlineReconnectListener || new Cd((() => { }))]) } if ("closed" === this.state || !n) return !1; this._reconnectCount += 1; const i = async (e, t) => { this.emit(YO.RECONNECT_CREATE_CONNECTION, t), await this.createTransmitterConnection(e) }; try { if ("retry" === e) { const t = this._addresses[this.currentURLIndex]; this.emit(YO.RECONNECT_WAITTING_FINISH, e), await i(t, e) } else if ("tryNext" === e) { this.currentURLIndex += 1; for (let e = this.currentURLIndex; e < this._addresses.length; e++) { if (this._addresses[e].fingerprint || jh("FINGERPRINT")) { this.currentURLIndex = e; break } this.currentURLIndex += 1 } if (this.currentURLIndex >= this._addresses.length) return Dh.debug("[".concat(this._name, "] the available addresses are exhausted, change to recover")), await this.reconnectWithAction("recover", !1); Dh.debug("[".concat(this._name, "] datachannel url length: ").concat(this._addresses.length, " current index: ").concat(this.currentURLIndex)); const t = this._addresses[this.currentURLIndex]; this.emit(YO.RECONNECT_WAITTING_FINISH, e), await i(t, e) } else "recover" === e && (Dh.debug("[".concat(this._name, "] start to failback to websocket")), this.resetReconnectCount("recover mode"), this.emit(YO.RECONNECT_WAITTING_FINISH, e), this.emit(YO.FAILBACK)); return !0 } catch (n) { var r; return Dh.error("[".concat(this._name, "] reconnect failed"), n.toString()), null != n && null !== (r = n.data) && void 0 !== r && r.desc && Array.isArray(n.data.desc) && n.data.desc.length && n.data.desc.includes("dynamic key expired") ? (this.emit(YO.ON_TOKEN_PRIVILEGE_DID_EXPIRE), !1) : await this.reconnectWithAction(e, t) } } } class Um extends ph { get connectionState() { return this._connectionState } set connectionState(e) { e !== this._connectionState && (this._connectionState = e, e === NT.CONNECTED ? this.emit(DT.WS_CONNECTED) : e === NT.RECONNECTING ? this.emit(DT.WS_RECONNECTING, this._websocketReconnectReason) : e === NT.CLOSED && this.emit(DT.WS_CLOSED, this._disconnectedReason)) } get currentURLIndex() { return this.websocket.currentURLIndex } get url() { return this.websocket ? this.websocket.url : null } get rtt() { return this.rttRolling.mean() } constructor(e, t) { super(), hl(this, "_disconnectedReason", void 0), hl(this, "_websocketReconnectReason", void 0), hl(this, "_connectionState", NT.CLOSED), hl(this, "reconnectToken", void 0), hl(this, "websocket", void 0), hl(this, "openConnectionTime", void 0), hl(this, "clientId", void 0), hl(this, "lastMsgTime", Date.now()), hl(this, "uploadCache", []), hl(this, "uploadCacheInterval", void 0), hl(this, "rttRolling", new fm(5)), hl(this, "pingpongTimer", void 0), hl(this, "inflateDataTimer", void 0), hl(this, "pingpongTimeoutCount", 0), hl(this, "joinResponse", void 0), hl(this, "multiIpOption", void 0), hl(this, "initError", void 0), hl(this, "spec", void 0), hl(this, "store", void 0), hl(this, "onWebsocketMessage", (e => { if (e instanceof ArrayBuffer) return void this.emit(DT.ON_BINARY_DATA, e); const t = JSON.parse(e); if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t, "_id")) { const e = "res-@".concat(t._id); this.emit(e, t._result, t._message) } else if (Object.prototype.hasOwnProperty.call(t, "_type") && (this.emit(t._type, t._message), t._type === LT.ON_NOTIFICATION && this.handleNotification(t._message), t._type === LT.ON_USER_BANNED)) switch (t._message.error_code) { case 14: this.close(IT.UID_BANNED); break; case 15: this.close(IT.IP_BANNED); break; case 16: this.close(IT.CHANNEL_BANNED) } })), this.clientId = e.clientId, this.spec = e, this.store = t, this.websocket = new bm("gateway-".concat(this.clientId), this.spec.retryConfig, !0, t), this.handleWebsocketEvents(), window.addEventListener("offline", (() => { this.connectionState === NT.CONNECTED && this.reconnect("retry", FO.OFFLINE) })) } async request(e, t, n, i) { const r = Zg(6, ""), o = { _id: r, _type: e, _message: t }, s = this.websocket.connectionID, a = () => new Cd(((t, n) => { if (this.connectionState === NT.CONNECTED) return t(); const i = () => { this.off(DT.WS_CLOSED, r), t() }, r = () => { this.off(DT.WS_CONNECTED, i), n(new Ch(Oh.WS_ABORT)) }; this.once(DT.WS_CONNECTED, i), this.once(DT.WS_CLOSED, r), e !== vT.PUBLISH && e !== vT.SUBSCRIBE && e !== vT.UNSUBSCRIBE && e !== vT.UNPUBLISH && e !== vT.CONTROL && e !== vT.RESTART_ICE || this.once(DT.DISCONNECT_P2P, (() => { n(new Ch(Oh.DISCONNECT_P2P)) })), e !== vT.PUBLISH && e !== vT.RESTART_ICE || this.once(DT.ABORT_P2P_EXECUTION, (() => { n(new Ch(Oh.DISCONNECT_P2P)) })) })); if (this.connectionState !== NT.CONNECTING && this.connectionState !== NT.RECONNECTING || e === vT.JOIN || e === vT.REJOIN || await a(), e === vT.LEAVE && (this.websocket.unbindDcCloseEventListener(), i = !0), this.websocket.sendMessage(o, !0, !1), i) return; const c = new Cd(((n, i) => { let o = !1; const a = (i, r) => { o = !0, n({ isSuccess: "success" === i, message: r || {} }), this.off(DT.WS_CLOSED, c), this.off(DT.WS_RECONNECTING, c), this.emit(DT.REQUEST_SUCCESS, e, t) }; this.once("res-@".concat(r), a); const c = () => { i(new Ch(Oh.WS_ABORT, "type: ".concat(e))), this.off(DT.WS_CLOSED, c), this.off(DT.WS_RECONNECTING, c), this.off("res-@".concat(r), a) }; this.once(DT.WS_CLOSED, c), this.once(DT.WS_RECONNECTING, c), Qg(jh("SIGNAL_REQUEST_TIMEOUT")).then((() => { this.websocket.connectionID !== s || o || (Dh.warning("dc request timeout, type: ".concat(e)), this.emit(DT.REQUEST_TIMEOUT, e, t)) })) })); let E = null; try { E = await c } catch (i) { if (this.connectionState === NT.CLOSED || e === vT.LEAVE) throw new Ch(Oh.WS_ABORT); return !this.spec.forceWaitGatewayResponse || n ? i.throw() : e === vT.JOIN || e === vT.REJOIN ? null : (await a(), await this.request(e, t)) } if (E.isSuccess) return E.message; const _ = Number(E.message.error_code || E.message.code), d = gm(_), u = new Ch(Oh.UNEXPECTED_RESPONSE, "".concat(d.desc, ": ").concat(E.message.error_str), { code: _, data: E.message }); return "success" === d.action ? E.message : (Dh.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e, ", error_code: ").concat(_, ", message: ").concat(d.desc, ", action: ").concat(d.action)), _ === gT.ERR_TOO_MANY_BROADCASTERS ? e === vT.JOIN || e === vT.REJOIN ? (this.initError = u, this.close(), u.throw()) : u.throw() : "failed" === d.action ? u.throw() : "quit" === d.action ? (this.initError = u, this.close(), u.throw()) : (_ === gT.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = E.message.option, Dh.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", FO.MULTI_IP)) : this.reconnect(d.action, FO.SERVER_ERROR), e === vT.JOIN || e === vT.REJOIN ? null : await this.request(e, t))) } waitMessage(e, t) { return new Cd((n => { const i = r => { (!t || t(r)) && (this.off(e, i), n(r)) }; this.on(e, i) })) } upload(e, t) { const n = { _type: e, _message: t }; try { this.websocket.sendMessage(n) } catch (e) { const t = jh("MAX_UPLOAD_CACHE") || 50; this.uploadCache.push(n), this.uploadCache.length > t && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval((() => { if (this.connectionState !== NT.CONNECTED) return; const e = this.uploadCache.splice(0, 1)[0]; 0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e._type, e._message) }), jh("UPLOAD_CACHE_INTERVAL") || 2e3)) } } send(e, t) { const n = { _type: e, _message: t }; this.websocket.sendMessage(n) } init(e, t) { return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Cd(((n, i) => { this.once(DT.WS_CONNECTED, (() => n(this.joinResponse))), this.once(DT.WS_CLOSED, (() => i(this.initError || new Ch(Oh.WS_ABORT)))), this.connectionState = NT.CONNECTING, this.websocket.init(e).catch(i), this.websocket.once(YO.FAILBACK, (() => { void 0 === this.openConnectionTime && i(new Ch(Oh.INIT_DATACHANNEL_TIMEOUT)) })), this.inflateDataTimer && window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = window.setInterval((() => { this.handleInflateData() }), 2e4), setTimeout((() => { t && void 0 === this.openConnectionTime && (Dh.debug("[".concat(this.clientId, "] init datachannel timeout while join with failback to websocket")), i(new Ch(Oh.INIT_DATACHANNEL_TIMEOUT))) }), jh("DC_JOIN_WITH_FAILBACK")) })) } close(e) { this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.inflateDataTimer && (this.handleInflateData(), window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e || IT.LEAVE, this.connectionState = NT.CLOSED, Dh.debug("[".concat(this.clientId, "] ") + "will close datachannel in signal"), this.websocket.close(), e === IT.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new bm("gateway-".concat(this.clientId), this.spec.retryConfig, !0, this.store), this.handleWebsocketEvents()) } async join() { if (!this.joinResponse) { this.emit(DT.ABORT_P2P_EXECUTION); const e = await im(this, DT.DATACHANNEL_CONNECTING), t = await this.request(vT.JOIN, e); if (!t) return this.emit(DT.REPORT_JOIN_GATEWAY, Oh.TIMEOUT, this.url || ""), !1; this.joinResponse = t, this.emit(DT.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token } return this.connectionState = NT.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), !0 } async rejoin() { if (!this.reconnectToken) throw new Ch(Oh.UNEXPECTED_ERROR, "can not rejoin, no rejoin token"); const e = sm(this, DT.REQUEST_REJOIN_INFO); e.token = this.reconnectToken; const t = await this.request(vT.REJOIN, e); return !!t && (this.connectionState = NT.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t.peers && t.peers.forEach((e => { this.emit(LT.ON_USER_ONLINE, { uid: e.uid }), e.audio && this.emit(LT.ON_ADD_AUDIO_STREAM, { uid: e.uid, uint_id: e.uint_id, audio: !0, ssrcId: e.audio_ssrc }), e.video && this.emit(LT.ON_ADD_VIDEO_STREAM, { uid: e.uid, uint_id: e.uint_id, video: !0, ssrcId: e.video_ssrc }), e.audio_mute ? this.emit(LT.MUTE_AUDIO, { uid: e.uid }) : this.emit(LT.UNMUTE_AUDIO, { uid: e.uid }), e.video_mute ? this.emit(LT.MUTE_VIDEO, { uid: e.uid }) : this.emit(LT.UNMUTE_VIDEO, { uid: e.uid }), e.audio_enable_local ? this.emit(LT.ENABLE_LOCAL_AUDIO, { uid: e.uid }) : this.emit(LT.DISABLE_LOCAL_AUDIO, { uid: e.uid }), e.video_enable_local ? this.emit(LT.ENABLE_LOCAL_VIDEO, { uid: e.uid }) : this.emit(LT.DISABLE_LOCAL_VIDEO, { uid: e.uid }), e.audio || e.video || this.emit(LT.ON_REMOVE_STREAM, { uid: e.uid, uint_id: e.uint_id }) })), !0) } reconnect(e, t) { this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, t) } handleNotification(e) { Dh.debug("[".concat(this.clientId, "] receive notification: "), e); const t = gm(e.code); if ("success" !== t.action) { if ("failed" !== t.action) return "quit" === t.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t.desc && this.close(IT.UID_BANNED), void this.close()) : void this.reconnect(t.action, FO.SERVER_ERROR); Dh.error("[".concat(this.clientId, "] ignore error: "), t.desc) } } handlePingPong() { if (!this.websocket || "connected" !== this.websocket.state) return; this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1; const e = jh("PING_PONG_TIME_OUT"), t = Date.now(); this.pingpongTimeoutCount >= e && (Dh.warning("PINGPONG Timeout. Last Socket Message: ".concat(t - this.lastMsgTime, "ms")), t - this.lastMsgTime > jh("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", FO.TIMEOUT) : this.request(vT.PING, void 0, !0).then((() => { this.pingpongTimeoutCount = 0; const e = Date.now() - t; this.rttRolling.add(e), jh("REPORT_STATS") && this.send(vT.PING_BACK, { pingpongElapse: e }) })).catch((e => { })) } handleInflateData() { const { inflateLength: e, deflateLength: t } = this.websocket.getInflateData(); 0 !== e && 0 !== t && this.upload(yT.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t, ws_inflate_length: e }) } handleWebsocketEvents() { this.websocket.on(YO.RECONNECT_WAITTING_FINISH, (e => { this.emit(DT.WS_RECONNECT_WAITTING_FINISH, e) })), this.websocket.on(YO.RECONNECT_CREATE_CONNECTION, (e => { this.emit(DT.WS_RECONNECT_CREATE_CONNECTION, e) })), this.websocket.on(YO.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(YO.CLOSED, (() => { this.connectionState = NT.CLOSED })), this.websocket.on(YO.FAILED, (() => { this._disconnectedReason = IT.NETWORK_ERROR, this.connectionState = NT.CLOSED })), this.websocket.on(YO.RECONNECTING, (e => { this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === NT.CONNECTED ? this.connectionState = NT.RECONNECTING : this.connectionState = NT.CONNECTING })), this.websocket.on(YO.WILL_RECONNECT, ((e, t) => { if (sm(this, DT.IS_P2P_DISCONNECTED) && "retry" === e) return Dh.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(DT.NEED_RENEW_SESSION), this.emit(DT.DISCONNECT_P2P), t("tryNext"); "retry" !== e && (Dh.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e)), this.reconnectToken = void 0, this.emit(DT.NEED_RENEW_SESSION), this.emit(DT.DISCONNECT_P2P)), t(e) })), this.websocket.on(YO.CONNECTED, (() => { this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e => { Dh.warning("[".concat(this.clientId, "] rejoin failed ").concat(e)), this.reconnect("tryNext", FO.SERVER_ERROR) })) : this.join().catch((e => { if (this.emit(DT.REPORT_JOIN_GATEWAY, e.message || e.code, this.url || ""), e instanceof Ch && e.code === Oh.UNEXPECTED_RESPONSE && e.data.code === gT.ERR_NO_AUTHORIZED) return Dh.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", FO.SERVER_ERROR); Dh.error("[".concat(this.clientId, "] join gateway request failed"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", FO.SERVER_ERROR) : (this.initError = e, this.close()) })) })), this.websocket.on(YO.REQUEST_NEW_URLS, ((e, t) => { im(this, DT.REQUEST_RECOVER, this.multiIpOption).then(e).catch(t) })), this.websocket.on(YO.ON_TOKEN_PRIVILEGE_DID_EXPIRE, (() => { this.emit(LT.ON_TOKEN_PRIVILEGE_DID_EXPIRE) })), this.websocket.on(YO.TO_CONNECT_DATACHANNEL, (async (e, t, n) => im(this, DT.DATACHANNEL_PRECONNECT, e).then(t).catch(n))), this.websocket.on(YO.FAILBACK, (() => { void 0 !== this.openConnectionTime && this.emit(DT.DATACHANNEL_FAILBACK) })) } } function Mm(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function km(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? Mm(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Mm(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } const Vm = new Map; class xm extends ph {
                        get state() { return this._state } set state(e) { if (e === this._state) return; const t = this._state; this._state = e, "DISCONNECTED" === e && this._disconnectedReason ? this.emit(aO.CONNECTION_STATE_CHANGE, e, t, this._disconnectedReason) : this.emit(aO.CONNECTION_STATE_CHANGE, e, t) } get joinGatewayStartTime() { return this._joinGatewayStartTime } set joinGatewayStartTime(e) { Dh.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e)), this._joinGatewayStartTime = e } constructor(e, t) { super(), hl(this, "store", void 0), hl(this, "joinInfo", void 0), hl(this, "key", void 0), hl(this, "signal", void 0), hl(this, "role", void 0), hl(this, "inChannelInfo", { joinAt: null, duration: 0 }), hl(this, "spec", void 0), hl(this, "_state", "DISCONNECTED"), hl(this, "_statsCollector", void 0), hl(this, "_disconnectedReason", void 0), hl(this, "isSignalRecover", !1), hl(this, "hasChangeBGPAddress", !1), hl(this, "trafficStatsInterval", void 0), hl(this, "networkQualityInterval", void 0), hl(this, "_joinGatewayStartTime", 0), hl(this, "_signalTimeout", !1), hl(this, "_clientRoleOptions", void 0), hl(this, "_isProactiveJoin", !1), this.store = e, this.spec = t, this.signal = this.store.useDataChannel ? new Um(km(km({}, t), {}, { retryConfig: t.websocketRetryConfig }), e) : new Pm(km(km({}, t), {}, { retryConfig: t.websocketRetryConfig }), e), this._statsCollector = t.statsCollector, this.role = t.role || "audience", this._clientRoleOptions = t.clientRoleOptions, this.handleSignalEvents() } async join(e, t, n) { if (this.signal instanceof Um) { let t = !1; "disabled" !== e.cloudProxyServer ? (Dh.debug("[".concat(this.store.clientId, "] Dc is not supported, because cloudProxyServer are not supported (").concat(e.cloudProxyServer, ")")), t = !0) : "".concat(e.apResponse.cid, "_").concat(e.apResponse.cert).length > 255 || "".concat(e.apResponse.cid, "_").concat(e.apResponse.cert).length < 22 ? (Dh.debug("[".concat(this.store.clientId, "] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255")), t = !0) : e.apResponse.addresses.some((e => e.fingerprint)) || jh("FINGERPRINT") || (Dh.debug("[".concat(this.store.clientId, "] Dc is not supported, because fingerprint does not exist")), t = !0), t && this.resetSignal() } this.store.joinGatewayStart(), "disabled" !== e.cloudProxyServer && (this.hasChangeBGPAddress = !0); const i = Date.now(); let r = Vm.get(e.cname); if (r || (r = new Map, Vm.set(e.cname, r)), this._isProactiveJoin = !0, r.has(e.uid)) { const t = new Ch(Oh.UID_CONFLICT); throw wA.joinGateway(e.sid, { lts: i, succ: !1, ec: t.message, addr: null, uid: e.uid, cid: e.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!e.proxyServer, signalChannel: this.signal instanceof Um ? "1" : "0" }), this._isProactiveJoin = !1, t } r.set(e.uid, !0), this.joinInfo = e, this.key = t; let o = 0; this.joinGatewayStartTime = i; const s = e.proxyServer; try { let t; if (Dh.debug("[".concat(this.store.clientId, "] use ").concat(this.signal instanceof Um ? "datachannel" : "websocket", " join uid ").concat(o)), this.signal instanceof Um) t = await this.signal.init(e.apResponse.addresses, n); else { const i = e.proxyServer, r = i ? e.gatewayAddrs.map((e => { const t = e.address.split(":"); return "wss://".concat(i, "/ws/?h=").concat(t[0], "&p=").concat(t[1]) })) : e.gatewayAddrs.map((e => "wss://".concat(e.address))); t = await this.signal.init(r, n) } o = t.uid, Dh.debug("[".concat(this.store.clientId, "] ").concat(this.signal instanceof Um ? "datachannel" : "websocket", " join uid ").concat(o, " cost ").concat(Date.now() - this.joinGatewayStartTime)) } catch (t) { if (t && t.code === Oh.INIT_WEBSOCKET_TIMEOUT) throw Dh.warning("[".concat(this.store.clientId, "] User join failed"), t.toString()), t; if (t && t.code === Oh.INIT_DATACHANNEL_TIMEOUT) throw Dh.warning("[".concat(this.store.clientId, "] User join datachannel failed"), t.toString()), this.resetSignal(), t; throw Dh.error("[".concat(this.store.clientId, "] User join failed"), t.toString()), wA.joinGateway(e.sid, { lts: i, succ: !1, ec: t.message, addr: this.signal.url, uid: e.uid, cid: e.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!s, signalChannel: this.signal instanceof Um ? "1" : "0" }), this._isProactiveJoin = !1, r.delete(e.uid), this.signal.close(), t } return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), Dh.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval((() => { this.updateTrafficStats().catch((e => { Dh.warning("[".concat(this.store.clientId, "] get traffic stats error"), e.toString()) })) }), 3e3), this.networkQualityInterval = window.setInterval((() => { navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(aO.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit(aO.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit(aO.NETWORK_QUALITY, { uplinkNetworkQuality: Gg(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: Gg(this._statsCollector.trafficStats.B_dnq) }) : this.emit(aO.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }) }), 2e3), this.store.joinGatewayEnd(), o } async leave() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t = arguments.length > 1 ? arguments[1] : void 0; if ("DISCONNECTED" !== this.state) { t !== IT.FALLBACK && (this.state = "DISCONNECTING"); try { e || this.signal.connectionState !== NT.CONNECTED || await function (e, t) { return t === 1 / 0 ? e : Cd.race([e, zg(t)]) }(this.signal.request(vT.LEAVE, void 0, !0), 3e3) } catch (e) { Dh.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e) } this.signal.close(t), t !== IT.FALLBACK && (this.state = "DISCONNECTED"), this.reset() } } async publish(e, t, n) { if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new Ch(Oh.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state)); const i = { state: "offer", p2p_id: this.store.p2pId, ortc: t, mode: this.spec.mode, extend: jh("PUB_EXTEND"), twcc: !!jh("PUBLISH_TWCC"), rtx: !!jh("USE_PUB_RTX") }; try { return (await this.signal.request(vT.PUBLISH, i, !0))._message } catch (i) { if (n && i.data && i.data.code === gT.ERR_PUBLISH_REQUEST_INVALID) return Dh.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), i.toString()), await this.tryUnpubBeforeRepub(e, t), this.publish(e, t, !1); throw i } } async unpublish(e, t) { try { if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new Ch(Oh.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state)); await this.signal.request(vT.UNPUBLISH, { stream_id: t, ortc: e }, !0) } catch (e) { Dh.warning("[".concat(this.store.clientId, "] unpublish warning: "), e) } } async subscribe(e, t, n) { if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new Ch(Oh.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state)); const i = { stream_id: e, stream_type: t.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!jh("SUBSCRIBE_TWCC"), rtx: !!jh("USE_SUB_RTX"), extend: jh("SUB_EXTEND"), ssrcId: t.ssrcId, svc: Array.isArray(jh("SVC")) && 0 !== jh("SVC").length ? jh("SVC") : void 0 }; try { return (await this.signal.request(vT.SUBSCRIBE, i, !0))._message } catch (i) { if (n && i.data && i.data.code === gT.ERR_SUBSCRIBE_REQUEST_INVALID) return Dh.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), i.toString()), await this.tryUnsubBeforeResub(e, t), await this.subscribe(e, t, !1); throw i } } async subscribeAll(e, t) { if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new Ch(Oh.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state)); const n = { p2p_id: this.store.p2pId, users: e, dtx: !1, rtx: !!jh("USE_SUB_RTX") }; try { return await this.signal.request(vT.SUBSCRIBE_STREAMS, n, !0) } catch (n) { if (t && n.data && n.data.code === gT.ERR_SUBSCRIBE_REQUEST_INVALID) return Dh.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), n.toString()), await this.tryMassUnsubBeforeResub(e), await this.subscribeAll(e, !1); throw n } } async setVideoProfile(e) { const t = function (e) { if (!(e.bitrateMax && e.bitrateMin && e.frameRate && e.height && e.width)) return; let t = e.frameRate, n = e.width, i = e.height, r = !0; return "number" != typeof t && (t = t.exact || t.ideal || t.max || t.min || 0, t || (r = !1)), "number" != typeof n && (n = n.exact || n.ideal || n.max || n.min || 0, n || (r = !1)), "number" != typeof i && (i = i.exact || i.ideal || i.max || i.min || 0, t || (r = !1)), r ? { stream_type: 0, width: n, height: i, fps: t, start_bps: 1e3 * e.bitrateMax, min_bps: 1e3 * e.bitrateMin, target_bps: 1e3 * e.bitrateMax } : void 0 }(e); if (t) return this.signal.request(vT.SET_VIDEO_PROFILE, t); Dh.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway")) } async unsubscribe(e, t) { try { await this.signal.request(vT.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e, stream_id: t }, !0) } catch (e) { Dh.warning("[".concat(this.store.clientId, "] unsubscribe warning: "), e) } } async massUnsubscribe(e) { try { await this.signal.request(vT.UNSUBSCRIBE_STREAMS, e, !0) } catch (e) { Dh.warning("[".concat(this.store.clientId, "] massUnsubscribeAll warning: "), e) } } async reconnectPC(e) { const { iceParameters: t, dtlsParameters: n, rtpCapabilities: i } = e; return { gatewayEstablishParams: await this.signal.request(vT.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t, dtlsParameters: n, rtpCapabilities: i } }, !0), gatewayAddress: this.getCurrentGatewayAddress() } } getGatewayInfo() { return this.signal.request(vT.GATEWAY_INFO) } async renewToken(e) { await this.signal.request(vT.RENEW_TOKEN, e), this.key = e.token } async setClientRole(e, t) { if (t && (this._clientRoleOptions = Object.assign({}, t)), "CONNECTED" !== this.state) return void (this.role = e); let n; n = "audience" === e ? this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : 0, await this.signal.request(vT.SET_CLIENT_ROLE, { role: e, level: n, client_ts: Date.now() }), this.role = e } async setRemoteVideoStreamType(e, t) { await this.signal.request(vT.SWITCH_VIDEO_STREAM, { stream_id: e, stream_type: t }) } async setDefaultRemoteVideoStreamType(e) { await this.signal.request(vT.DEFAULT_VIDEO_STREAM, { stream_type: e }) } async setStreamFallbackOption(e, t) { await this.signal.request(vT.SET_FALLBACK_OPTION, { stream_id: e, fallback_type: t }) } async pickSVCLayer(e, t) { await this.signal.request(vT.PICK_SVC_LAYER, { stream_id: e, spatial_layer: t.spatialLayer, temporal_layer: t.temporalLayer }) } getInChannelInfo() { return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), km({}, this.inChannelInfo) } async getGatewayVersion() { return (await this.signal.request(vT.GATEWAY_INFO)).version } reset() { if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) { const e = Vm.get(this.joinInfo.cname); e && e.delete(this.joinInfo.uid) } this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0) } updateTurnConfigFromSignal() { if (!this.joinInfo) return; const e = function (e) { let t; return t = e.startsWith("dc") ? e.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e.match(/(wss\:\/\/)?([^:]+):(\d+)/), t ? { username: bh.username, password: bh.password, turnServerURL: t[2], tcpport: parseInt(t[3]) + 30, udpport: parseInt(t[3]) + 30, forceturn: !1 } : null }(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || ""); this.joinInfo.turnServer.serversFromGateway = [], e && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(km(km({}, bh), {}, { turnServerURL: e.turnServerURL, tcpport: e.tcpport, udpport: e.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token })) } async updateTrafficStats() { if ("CONNECTED" !== this.state) return; const e = await this.signal.request(vT.TRAFFIC_STATS, void 0, !0); e.timestamp = Date.now(), e.peer_delay.forEach((e => { const t = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((t => t.peer_uid === e.peer_uid)); t && t.B_st !== e.B_st && Em((() => { this.emit(aO.STREAM_TYPE_CHANGE, e.peer_uid, e.B_st) })) })), this._statsCollector.updateTrafficStats(e) } getJoinMessage(e) { if (!this.joinInfo || !this.key) throw new Ch(Oh.UNEXPECTED_ERROR, "can not generate join message, no join info"); const t = Object.assign({}, this.joinInfo.apResponse); let n = jh("REPORT_APP_SCENARIO"); if ("string" != typeof n) try { n = JSON.stringify(n) } catch (e) { n = void 0 } n && n.length > 128 && (n = void 0); const i = km({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: yh, browser: navigator.userAgent, process_id: jh("PROCESS_ID"), mode: this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: t, extend: jh("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0 }, features: { rejoin: !0 }, optionalInfo: this.joinInfo.optionalInfo, appScenario: n, attributes: { userAttributes: { enablePublishedUserList: jh("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: jh("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: "number" == typeof jh("SUBSCRIBE_AUDIO_FILTER_TOPN") ? jh("SUBSCRIBE_AUDIO_FILTER_TOPN") : void 0, enablePublishAudioFilter: "boolean" == typeof jh("ENABLE_PUBLISH_AUDIO_FILTER") ? jh("ENABLE_PUBLISH_AUDIO_FILTER") : void 0, enableUserLicenseCheck: "boolean" == typeof jh("ENABLE_USER_LICENSE_CHECK") ? jh("ENABLE_USER_LICENSE_CHECK") : void 0, enableRTX: !0 === jh("USE_PUB_RTX") || !0 === jh("USE_SUB_RTX") || void 0 } }, join_ts: this.joinGatewayStartTime }, e); return this.joinInfo.stringUid && (i.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (i.aes_mode = this.joinInfo.aesmode, jh("ENCRYPT_AES") ? (i.aes_secret = this.joinInfo.aespassword, i.aes_encrypt = !0) : i.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (i.aes_salt = this.joinInfo.aessalt)), t.addresses[this.signal.websocket.currentURLIndex] && (i.ap_response.ticket = t.addresses[this.signal.websocket.currentURLIndex].ticket, delete t.addresses), void 0 !== this.joinInfo.defaultVideoStream && (i.default_video_stream = this.joinInfo.defaultVideoStream), i } getRejoinMessage() { if (!this.joinInfo) throw new Ch(Oh.UNEXPECTED_ERROR, "can not generate rejoin message, no join info"); return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) } } handleSignalEvents() { this.signal.on(DT.WS_RECONNECT_WAITTING_FINISH, (e => { ["tryNext", "recover"].includes(e) && this.joinInfo && wA.adjustSessionStartTime(this.joinInfo.sid) })), this.signal.on(DT.WS_RECONNECT_CREATE_CONNECTION, (e => { this.joinGatewayStartTime = Date.now() })), this.signal.on(DT.WS_RECONNECTING, (e => { this.joinInfo && wA.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e || PT.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", wA.sessionInit(this.joinInfo.sid, { lts: (new Date).getTime(), extend: this.isSignalRecover ? { recover: !0 } : { rejoin: !0 }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode }), this.isSignalRecover = !1, this.joinGatewayStartTime = Date.now()) })), this.signal.on(DT.WS_CLOSED, (e => { let t; switch (e) { case IT.LEAVE: t = PT.LEAVE; break; case IT.UID_BANNED: case IT.IP_BANNED: case IT.CHANNEL_BANNED: case IT.SERVER_ERROR: t = PT.SERVER_ERROR; break; case IT.FALLBACK: t = PT.FALLBACK; break; case IT.LICENSE_MISSING: case IT.LICENSE_EXPIRED: case IT.LICENSE_MINUTES_EXCEEDED: case IT.LICENSE_PERIOD_INVALID: case IT.LICENSE_MULTIPLE_SDK_SERVICE: case IT.LICENSE_ILLEGAL: t = e; break; default: t = PT.NETWORK_ERROR }Dh.debug("[".concat(this.store.clientId, "] [signal] websocket closed, reason: ").concat(t || "undefined -> " + PT.NETWORK_ERROR)), this.joinInfo && wA.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e === IT.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t }), this._disconnectedReason = e, e !== IT.FALLBACK && (this.state = "DISCONNECTED"), this.reset() })), this.signal.on(DT.WS_CONNECTED, (() => { if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo && ("audience" === this.role && this._clientRoleOptions && this._clientRoleOptions.level && (Dh.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions && this._clientRoleOptions.level)), this.setClientRole(this.role, this._clientRoleOptions)), wA.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: !0, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof Um ? "1" : "0" }), this._isProactiveJoin = !1, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion)) { const e = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/); if (!e) return void Dh.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e)); Gh("EVENT_REPORT_DOMAIN", e[1]), Gh("EVENT_REPORT_BACKUP_DOMAIN", e[1]), Gh("LOG_UPLOAD_SERVER", "".concat(e[1], ":6444")) } })), this.signal.on(LT.ON_UPLINK_STATS, (e => { this._statsCollector.updateUplinkStats(e) })), this.signal.on(DT.REQUEST_RECOVER, ((e, t, n) => { if (!this.joinInfo) return n(new Ch(Oh.UNEXPECTED_ERROR, "gateway: can not recover, no join info")); e && (this.joinInfo.multiIP = e, this.hasChangeBGPAddress = !0), this.isSignalRecover = !0, im(this, aO.REQUEST_NEW_GATEWAY_LIST).then(t).catch(n) })), this.signal.on(DT.REQUEST_JOIN_INFO, (async e => { var t; this.updateTurnConfigFromSignal(); const { iceParameters: n, dtlsParameters: i, rtpCapabilities: r } = await im(this, aO.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: null === (t = this.joinInfo) || void 0 === t ? void 0 : t.turnServer }); e(this.getJoinMessage({ ortc: { iceParameters: n, dtlsParameters: i, rtpCapabilities: r, version: "2" } })) })), this.signal.on(DT.REQUEST_REJOIN_INFO, (e => { e(this.getRejoinMessage()) })), this.signal.on(DT.REPORT_JOIN_GATEWAY, ((e, t) => { this.joinInfo && (wA.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: !1, ec: e, addr: t, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof Um ? "1" : "0" }), this._isProactiveJoin = !1) })), this.signal.on(DT.IS_P2P_DISCONNECTED, (e => { e(sm(this, aO.IS_P2P_DISCONNECTED)) })), this.signal.on(DT.DISCONNECT_P2P, (() => { this.emit(aO.DISCONNECT_P2P) })), this.signal.on(DT.NEED_RENEW_SESSION, (() => { this.emit(aO.NEED_RENEW_SESSION) })), this.signal.on(DT.REQUEST_SUCCESS, (() => { this._signalTimeout = !1 })), this.signal.on(DT.REQUEST_TIMEOUT, (() => { this._signalTimeout = !0 })), this.signal.on(DT.JOIN_RESPONSE, (e => { const t = this.getCurrentGatewayAddress(); this.emit(aO.JOIN_RESPONSE, e, t) })), this.signal.on(DT.DATACHANNEL_PRECONNECT, (async (e, t, n) => { this.updateTurnConfigFromSignal(); const i = this.getCurrentGatewayAddress(); return im(this, aO.DATACHANNEL_PRECONNECT, e, i).then(t).catch(n) })), this.signal.on(DT.DATACHANNEL_CONNECTING, (async e => { const { iceParameters: t, dtlsParameters: n, rtpCapabilities: i } = await im(this, aO.REQUEST_DC_CONNECTION_PARAMS); e(this.getJoinMessage({ ortc: { iceParameters: t, dtlsParameters: n, rtpCapabilities: i, version: "2" } })) })), this.signal.on(DT.DATACHANNEL_FAILBACK, (() => { Dh.warning("[".concat(this.store.clientId, "] User join datachannel failed")), this.reset(), this.resetSignal(), this.emit(aO.DATACHANNEL_FAILBACK) })) } async tryUnsubBeforeResub(e, t) { try { await this.signal.request(vT.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e, ortc: [t] }, !0) } catch (e) { throw Dh.warning("[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"), e), e } } async tryUnpubBeforeRepub(e, t) { try { await this.signal.request(vT.UNPUBLISH, { stream_id: e, ortc: t }, !0) } catch (e) { throw Dh.warning("[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "), e), e } } async tryMassUnsubBeforeResub(e) { const t = { users: e.map((e => ({ stream_id: e.stream_id, stream_type: e.stream_type }))) }; try { await this.signal.request(vT.UNSUBSCRIBE_STREAMS, t, !0) } catch (e) { throw Dh.warning("[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"), e), e } } async muteLocal(e, t) { const n = { action: e.find((e => e.stream_type === sO.Audio)) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e, stream_id: t }; try { await this.signal.request(vT.CONTROL, n, !0, !0) } catch (e) { throw Dh.warning("[".concat(this.store.clientId, "] gateway muteLocal warning: "), e), e } } async unmuteLocal(e, t) { const n = { action: e.find((e => e.stream_type === sO.Audio)) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e, stream_id: t }; try { await this.signal.request(vT.CONTROL, n, !0, !0) } catch (e) { throw Dh.warning("[".concat(this.store.clientId, "] gateway unmuteLocal warning: "), e), e } } uploadStats(e, t) { this.signal.upload(e, t) } getSignalRTT() { return this.signal.rtt } async restartICE(e) { const t = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e }; try { return await this.signal.request(vT.RESTART_ICE, t, !0) } catch (e) { throw Dh.warning("[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "), e), e } } reconnect() { "CONNECTED" === this.state && this.signal.reconnect(void 0, PT.P2P_FAILED) } getCurrentGatewayAddress() { var e; if (!jh("GATEWAY_WSS_ADDRESS")) return null !== (e = this.joinInfo) && void 0 !== e && e.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0 } async setPublishAudioFilterEnabled(e) { await this.signal.request(vT.SET_PARAMETER, { enablePublishAudioFilter: e }) } resetSignal() {
                            this.signal && (this.signal.removeAllListeners(), this.signal.close(IT.FALLBACK)), this.store.useDataChannel = !1, this.signal = new Pm(km(km({}, this.spec), {}, { retryConfig: this.spec.websocketRetryConfig }), this.store), this.handleSignalEvents(), this.emit(aO.RESET_SIGNAL, EO.websocket)
                            /*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */
}
                    } !function () { var e; function n(e) { var t = 0; return function () { return t < e.length ? { done: !1, value: e[t++] } : { done: !0 } } } var i, r = "function" == typeof Object.defineProperties ? Object.defineProperty : function (e, t, n) { return e == Array.prototype || e == Object.prototype || (e[t] = n.value), e }, o = function (e) { e = ["object" == typeof globalThis && globalThis, e, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof t && t]; for (var n = 0; n < e.length; ++n) { var i = e[n]; if (i && i.Math == Math) return i } throw Error("Cannot find global object") }(this); function s(e, t) { if (t) e: { var n = o; e = e.split("."); for (var i = 0; i < e.length - 1; i++) { var s = e[i]; if (!(s in n)) break e; n = n[s] } (t = t(i = n[e = e[e.length - 1]])) != i && null != t && r(n, e, { configurable: !0, writable: !0, value: t }) } } function a(e) { return (e = { next: e })[Symbol.iterator] = function () { return this }, e } function c(e) { var t = "undefined" != typeof Symbol && Symbol.iterator && e[Symbol.iterator]; return t ? t.call(e) : { next: n(e) } } if (s("Symbol", (function (e) { function t(e, t) { this.A = e, r(this, "description", { configurable: !0, writable: !0, value: t }) } if (e) return e; t.prototype.toString = function () { return this.A }; var n = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", i = 0; return function e(r) { if (this instanceof e) throw new TypeError("Symbol is not a constructor"); return new t(n + (r || "") + "_" + i++, r) } })), s("Symbol.iterator", (function (e) { if (e) return e; e = Symbol("Symbol.iterator"); for (var t = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), i = 0; i < t.length; i++) { var s = o[t[i]]; "function" == typeof s && "function" != typeof s.prototype[e] && r(s.prototype, e, { configurable: !0, writable: !0, value: function () { return a(n(this)) } }) } return e })), "function" == typeof Object.setPrototypeOf) i = Object.setPrototypeOf; else { var E; e: { var _ = {}; try { _.__proto__ = { a: !0 }, E = _.a; break e } catch (e) { } E = !1 } i = E ? function (e, t) { if (e.__proto__ = t, e.__proto__ !== t) throw new TypeError(e + " is not extensible"); return e } : null } var d = i; function u() { this.m = !1, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null } function l(e) { if (e.m) throw new TypeError("Generator is already running"); e.m = !0 } function R(e, t) { return e.h = 3, { value: t } } function h(e) { this.g = new u, this.G = e } function p(e, t, n, i) { try { var r = t.call(e.g.j, n); if (!(r instanceof Object)) throw new TypeError("Iterator result " + r + " is not an object"); if (!r.done) return e.g.m = !1, r; var o = r.value } catch (t) { return e.g.j = null, e.g.s(t), T(e) } return e.g.j = null, i.call(e.g, o), T(e) } function T(e) { for (; e.g.h;)try { var t = e.G(e.g); if (t) return e.g.m = !1, { value: t.value, done: !1 } } catch (t) { e.g.v = void 0, e.g.s(t) } if (e.g.m = !1, e.g.l) { if (t = e.g.l, e.g.l = null, t.F) throw t.D; return { value: t.return, done: !0 } } return { value: void 0, done: !0 } } function O(e) { this.next = function (t) { return e.o(t) }, this.throw = function (t) { return e.s(t) }, this.return = function (t) { return function (e, t) { l(e.g); var n = e.g.j; return n ? p(e, "return" in n ? n.return : function (e) { return { value: e, done: !0 } }, t, e.g.return) : (e.g.return(t), T(e)) }(e, t) }, this[Symbol.iterator] = function () { return this } } function C(e, t) { return t = new O(new h(t)), d && e.prototype && d(t, e.prototype), t } if (u.prototype.o = function (e) { this.v = e }, u.prototype.s = function (e) { this.l = { D: e, F: !0 }, this.h = this.C || this.u }, u.prototype.return = function (e) { this.l = { return: e }, this.h = this.u }, h.prototype.o = function (e) { return l(this.g), this.g.j ? p(this, this.g.j.next, e, this.g.o) : (this.g.o(e), T(this)) }, h.prototype.s = function (e) { return l(this.g), this.g.j ? p(this, this.g.j.throw, e, this.g.o) : (this.g.s(e), T(this)) }, s("Array.prototype.entries", (function (e) { return e || function () { return function (e, t) { e instanceof String && (e += ""); var n = 0, i = !1, r = { next: function () { if (!i && n < e.length) { var r = n++; return { value: t(r, e[r]), done: !1 } } return i = !0, { done: !0, value: void 0 } } }; return r[Symbol.iterator] = function () { return r }, r }(this, (function (e, t) { return [e, t] })) } })), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) { var A = function (e, t) { for (var n = 0; n < e.length; n++)t(e[n]) }, S = function (e) { return e.replace(/\r?\n|\r/g, "\r\n") }, g = function (e, t, n) { return t instanceof Blob ? (n = void 0 !== n ? String(n + "") : "string" == typeof t.name ? t.name : "blob", t.name === n && "[object Blob]" !== Object.prototype.toString.call(t) || (t = new File([t], n)), [String(e), t]) : [String(e), String(t)] }, m = function (e, t) { if (e.length < t) throw new TypeError(t + " argument required, but only " + e.length + " present.") }, I = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this, f = I.FormData, P = I.XMLHttpRequest && I.XMLHttpRequest.prototype.send, N = I.Request && I.fetch, D = I.navigator && I.navigator.sendBeacon, v = I.Element && I.Element.prototype, y = I.Symbol && Symbol.toStringTag; y && (Blob.prototype[y] || (Blob.prototype[y] = "Blob"), "File" in I && !File.prototype[y] && (File.prototype[y] = "File")); try { new File([], "") } catch (e) { I.File = function (e, t, n) { return e = new Blob(e, n || {}), Object.defineProperties(e, { name: { value: t }, lastModified: { value: +(n && void 0 !== n.lastModified ? new Date(n.lastModified) : new Date) }, toString: { value: function () { return "[object File]" } } }), y && Object.defineProperty(e, y, { value: "File" }), e } } var L = function (e) { return e.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22") }, w = function (e) { this.i = []; var t = this; e && A(e.elements, (function (e) { if (e.name && !e.disabled && "submit" !== e.type && "button" !== e.type && !e.matches("form fieldset[disabled] *")) if ("file" === e.type) { var n = e.files && e.files.length ? e.files : [new File([], "", { type: "application/octet-stream" })]; A(n, (function (n) { t.append(e.name, n) })) } else "select-multiple" === e.type || "select-one" === e.type ? A(e.options, (function (n) { !n.disabled && n.selected && t.append(e.name, n.value) })) : "checkbox" === e.type || "radio" === e.type ? e.checked && t.append(e.name, e.value) : (n = "textarea" === e.type ? S(e.value) : e.value, t.append(e.name, n)) })) }; if ((e = w.prototype).append = function (e, t, n) { m(arguments, 2), this.i.push(g(e, t, n)) }, e.delete = function (e) { m(arguments, 1); var t = []; e = String(e), A(this.i, (function (n) { n[0] !== e && t.push(n) })), this.i = t }, e.entries = function e() { var t, n = this; return C(e, (function (e) { if (1 == e.h && (t = 0), 3 != e.h) return t < n.i.length ? e = R(e, n.i[t]) : (e.h = 0, e = void 0), e; t++, e.h = 2 })) }, e.forEach = function (e, t) { m(arguments, 1); for (var n = c(this), i = n.next(); !i.done; i = n.next()) { var r = c(i.value); i = r.next().value, r = r.next().value, e.call(t, r, i, this) } }, e.get = function (e) { m(arguments, 1); var t = this.i; e = String(e); for (var n = 0; n < t.length; n++)if (t[n][0] === e) return t[n][1]; return null }, e.getAll = function (e) { m(arguments, 1); var t = []; return e = String(e), A(this.i, (function (n) { n[0] === e && t.push(n[1]) })), t }, e.has = function (e) { m(arguments, 1), e = String(e); for (var t = 0; t < this.i.length; t++)if (this.i[t][0] === e) return !0; return !1 }, e.keys = function e() { var t, n, i, r = this; return C(e, (function (e) { if (1 == e.h && (t = c(r), n = t.next()), 3 != e.h) return n.done ? void (e.h = 0) : (i = n.value, R(e, c(i).next().value)); n = t.next(), e.h = 2 })) }, e.set = function (e, t, n) { m(arguments, 2), e = String(e); var i = [], r = g(e, t, n), o = !0; A(this.i, (function (t) { t[0] === e ? o && (o = !i.push(r)) : i.push(t) })), o && i.push(r), this.i = i }, e.values = function e() { var t, n, i, r, o = this; return C(e, (function (e) { if (1 == e.h && (t = c(o), n = t.next()), 3 != e.h) return n.done ? void (e.h = 0) : (i = n.value, (r = c(i)).next(), R(e, r.next().value)); n = t.next(), e.h = 2 })) }, w.prototype._asNative = function () { for (var e = new f, t = c(this), n = t.next(); !n.done; n = t.next()) { var i = c(n.value); n = i.next().value, i = i.next().value, e.append(n, i) } return e }, w.prototype._blob = function () { var e = "----formdata-polyfill-" + Math.random(), t = [], n = "--" + e + '\r\nContent-Disposition: form-data; name="'; return this.forEach((function (e, i) { return "string" == typeof e ? t.push(n + L(S(i)) + '"\r\n\r\n' + S(e) + "\r\n") : t.push(n + L(S(i)) + '"; filename="' + L(e.name) + '"\r\nContent-Type: ' + (e.type || "application/octet-stream") + "\r\n\r\n", e, "\r\n") })), t.push("--" + e + "--"), new Blob(t, { type: "multipart/form-data; boundary=" + e }) }, w.prototype[Symbol.iterator] = function () { return this.entries() }, w.prototype.toString = function () { return "[object FormData]" }, v && !v.matches && (v.matches = v.matchesSelector || v.mozMatchesSelector || v.msMatchesSelector || v.oMatchesSelector || v.webkitMatchesSelector || function (e) { for (var t = (e = (this.document || this.ownerDocument).querySelectorAll(e)).length; 0 <= --t && e.item(t) !== this;); return -1 < t }), y && (w.prototype[y] = "FormData"), P) { var b = I.XMLHttpRequest.prototype.setRequestHeader; I.XMLHttpRequest.prototype.setRequestHeader = function (e, t) { b.call(this, e, t), "content-type" === e.toLowerCase() && (this.B = !0) }, I.XMLHttpRequest.prototype.send = function (e) { e instanceof w ? (e = e._blob(), this.B || this.setRequestHeader("Content-Type", e.type), P.call(this, e)) : P.call(this, e) } } N && (I.fetch = function (e, t) { return t && t.body && t.body instanceof w && (t.body = t.body._blob()), N.call(this, e, t) }), D && (I.navigator.sendBeacon = function (e, t) { return t instanceof w && (t = t._asNative()), D.call(this, e, t) }), I.FormData = w } }(); const Fm = () => { const e = jh("AREAS"); return 0 === e.length && e.push(OO.GLOBAL), Zn(e).call(e, ((e, t, n) => { const i = Ym(t); return i ? 0 === n ? i : "".concat(e, ",").concat(i) : e }), "") }, Ym = e => e === OO.OVERSEA ? "".concat(gO.ASIA, ",").concat(gO.EUROPE, ",").concat(gO.AFRICA, ",").concat(gO.NORTH_AMERICA, ",").concat(gO.SOUTH_AMERICA, ",").concat(gO.OCEANIA) : gO[e], Bm = e => { const t = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] }; return e.map((e => { const n = mO[e], i = Object.keys(n); i && i.map((e => { "CODE" !== e && (t[e] = t[e].concat(n[e])) })) })), t }, Gm = { GLOBAL: { ASIA: [OO.CHINA, OO.JAPAN, OO.INDIA, OO.KOREA, OO.HKMC], EUROPE: [], NORTH_AMERICA: [OO.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } }, jm = Object.keys(Gm[OO.GLOBAL]), Hm = [OO.CHINA, OO.NORTH_AMERICA, OO.EUROPE, OO.ASIA, OO.JAPAN, OO.INDIA, OO.OCEANIA, OO.SOUTH_AMERICA, OO.AFRICA, OO.KOREA, OO.HKMC, OO.US], Wm = function (e, t) { let n = []; if (e.includes(OO.GLOBAL)) { const o = [OO.GLOBAL, OO.OVERSEA], s = Object.keys(mO); if (t === OO.GLOBAL) throw new Ch(Oh.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value"); if (t === OO.CHINA) n = [OO.OVERSEA]; else if (r = t, jm.includes(r)) { const e = (i = t, Gm[OO.GLOBAL][i] || []), r = [...o, t, ...e]; n = s.filter((e => !r.includes(e))) } else if (function (e) { let t = !1; return jm.forEach((n => { Gm[OO.GLOBAL][n].includes(e) && (t = !0) })), t }(t)) { const e = function (e) { let t; return jm.forEach((n => { Gm[OO.GLOBAL][n].includes(e) && (t = n) })), t }(t), i = [...o, e, t]; n = s.filter((e => !i.includes(e))) } else n = e; n = function (e) { const t = []; return Hm.forEach((n => { e.includes(n) && t.push(n) })), t.concat(e.filter((e => !Hm.includes(e)))) }(n) } else n = e; var i, r; return n }; function Km(e) { if (!e && jh("AREAS").includes(OO.EXTENSIONS)) return Dh.debug("update area from ap : reset"), void Jm(wh, !0); if (!jh("AREAS").includes(OO.GLOBAL) || !e) return; let t = mO.EXTENSIONS; t && (t = { CODE: Ym(OO.EXTENSIONS), WEBCS_DOMAIN: ["ap-web-1-".concat(e, ".agora.io")], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(e, ".ap.sd-rtn.com")], PROXY_CS: ["proxy-ap-web-".concat(e, ".agora.io")], CDS_AP: ["cds-ap-web-1-".concat(e, ".agora.io"), "cds-ap-web-2-".concat(e, ".ap.sd-rtn.com")], ACCOUNT_REGISTER: ["sua-ap-web-1-".concat(e, ".agora.io"), "sua-ap-web-2-".concat(e, ".ap.sd-rtn.com")], UAP_AP: ["uap-ap-web-1-".concat(e, ".agora.io"), "uap-ap-web-2-".concat(e, ".ap.sd-rtn.com")], EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(e, ".agora.io")], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-".concat(e, ".agora.io")], LOG_UPLOAD_SERVER: ["logservice-".concat(e, ".agora.io")], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(e, ".agora.io")] }, Dh.debug("update area from ap success: ".concat(e, ",config is "), t), Gh("AREAS", [OO.EXTENSIONS], !0), Object.keys(t).map((e => { Gh(e, "LOG_UPLOAD_SERVER" === e || "EVENT_REPORT_DOMAIN" === e || "EVENT_REPORT_BACKUP_DOMAIN" === e || "PROXY_SERVER_TYPE3" === e ? t[e][0] : t[e]) }))) } function Jm(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = wA.reportApiInvoke(null, { name: RT.SET_AREA, options: e, tag: hT.TRACER }); try { let i = []; if ("string" == typeof e && (i = [e]), Array.isArray(e) && (e.forEach((e => { if (!SO.includes(e)) throw new Ch(Oh.INVALID_PARAMS, "invalid area code") })), i = e), "[object Object]" === Object.prototype.toString.call(e)) { const { areaCode: t, excludedArea: n } = e; if (!t) throw new Ch(Oh.INVALID_PARAMS, "area code is needed"); let r = t; "string" == typeof t && (r = [t]), i = n ? Wm(r, n) : r } if (!t) { if (Wh.AREAS) { const e = new Ch(Oh.PROHIBITED_OPERATION, "setArea is prohibited because of config-distribute"); return n.onError(e), void Dh.warning("setArea is prohibited because of config-distribute") } if (i.includes(OO.GLOBAL) && jh("AREAS") === OO.EXTENSIONS) { const e = new Ch(Oh.PROHIBITED_OPERATION, "setArea is prohibited because of ap extensions"); return n.onError(e), void Dh.warning("setArea is prohibited because of ap extensions") } } Gh("AREAS", i, t); const r = Bm(i); Object.keys(r).map((e => { Gh(e, "LOG_UPLOAD_SERVER" === e || "EVENT_REPORT_DOMAIN" === e || "EVENT_REPORT_BACKUP_DOMAIN" === e || "PROXY_SERVER_TYPE3" === e ? r[e][0] : r[e]) })), Dh.debug("set area success:", i.join(",")) } catch (e) { throw n.onError(e), e } n.onSuccess() } function Xm(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function qm(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? Xm(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xm(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } let Qm = 1; function zm(e, t, n, i, r) { Qm += 1; const o = { sid: n.sid, command: "convergeAllocateEdge", uid: "666", appId: n.appId, ts: Math.floor(Date.now() / 1e3), seq: Qm, requestId: Qm, version: yh, cname: n.cname }, s = { service_name: t, json_body: JSON.stringify(o) }; let a, c, E = e[0]; return gh((async () => { a = Date.now(); const e = await AA(E, { data: s, cancelToken: i, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } }); if (c = Date.now() - a, 0 !== e.code) { const t = new Ch(Oh.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e.code, { retry: !0, responseTime: c }); throw Dh.error(t.toString()), t } const n = JSON.parse(e.json_body); if (200 !== n.code) { const e = new Ch(Oh.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(n.code, ", reason: ").concat(n.reason), { code: n.code, responseTime: c }); throw Dh.error(e.toString()), e } if (!n.servers || 0 === n.servers.length) { const e = new Ch(Oh.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: n.code, responseTime: c }); throw Dh.error(e.toString()), e } const r = function (e, t) { return { addressList: e.servers.map((e => "wss://".concat(e.address.replace(/\./g, "-"), ".").concat(jh("WORKER_DOMAIN"), ":").concat(e.wss, "?serviceName=").concat(encodeURIComponent(t)))), workerToken: e.workerToken, vid: e.vid } }(n, t); return jh("LIVE_STREAMING_ADDRESS") && (r.addressList = jh("LIVE_STREAMING_ADDRESS") instanceof Array ? jh("LIVE_STREAMING_ADDRESS") : [jh("LIVE_STREAMING_ADDRESS")]), qm(qm({}, r), {}, { responseTime: c }) }), ((i, r) => (wA.apworkerEvent(n.sid, { success: !0, sc: 200, serviceName: t, responseDetail: JSON.stringify(i.addressList), firstSuccess: 0 === r, responseTime: c, serverIp: e[r % e.length] }), !1)), ((i, r) => (wA.apworkerEvent(n.sid, { success: !1, sc: i.data && i.data.code || 200, serviceName: t, responseTime: c, serverIp: e[r % e.length] }), !!(i.code !== Oh.OPERATION_ABORTED && i.code !== Oh.UNEXPECTED_RESPONSE || i.data && i.data.retry) && (E = e[(r + 1) % e.length], !0))), r) } let Zm = 1; function $m(e, t, n, i) { let { url: r, areaCode: o } = e; const s = Date.now(); let a; const [c, E] = rI(t, o, [qO.CHOOSE_SERVER]); let _ = gA.networkState; return gh((async () => { _ && gA.networkState === wO.OFFLINE && gA.onlineWaiter && await Cd.race([gA.onlineWaiter, Qg(i && i.maxRetryTimeout || Ah.maxRetryTimeout)]), _ = gA.networkState; const { data: e, headers: o } = await AA(r, { data: c, cancelToken: n, headers: { "Content-Type": "multipart/form-data;" } }, !0, !0); a = "1" === o.http3 ? 1 : -1, wA.reportResourceTiming(r, t.sid), tI(e, r, t, s, [qO.CHOOSE_SERVER], a); const E = jg(e, qO.CHOOSE_SERVER); return nI(E), Fg(E, r) }), (e => (e && wA.joinChooseServer(t.sid, { lts: s, succ: !0, csAddr: r, opid: E, serverList: e.gatewayAddrs.map((e => e.address)), ec: null, cid: e.cid.toString(), uid: e.uid.toString(), csIp: e.csIp, unilbsServerIds: [qO.CHOOSE_SERVER].toString(), isHttp3: a }), !1)), (e => e.code !== Oh.OPERATION_ABORTED && (e.code === Oh.CAN_NOT_GET_GATEWAY_SERVER ? e.data.retry : (wA.joinChooseServer(t.sid, { lts: s, succ: !1, csAddr: r, serverList: null, opid: E, ec: e.code, csIp: e.data && e.data.csIp, unilbsServerIds: [qO.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: _ }), isHttp3: a }), Dh.warning("[".concat(t.clientId, "] Choose server network error, retry"), e), !0))), i) } function eI(e, t, n, i) { let r, { url: o, areaCode: s, serviceIds: a } = e; const c = Date.now(), [E, _] = rI(t, s, a); let d; return gh((async () => { d && gA.networkState === wO.OFFLINE && gA.onlineWaiter && await Cd.race([gA.onlineWaiter, Qg(i && i.maxRetryTimeout || Ah.maxRetryTimeout)]), d = gA.networkState; const { data: e, headers: s } = await AA(o, { data: E, cancelToken: n, headers: { "Content-Type": "multipart/form-data;" } }, !0, !0); r = "1" === s.http3 ? 1 : -1, wA.reportResourceTiming(o, t.sid), tI(e, o, t, c, a, r); const _ = jg(e, qO.CHOOSE_SERVER), u = jg(e, "proxy5" === t.cloudProxyServer ? qO.CLOUD_PROXY_5 : "proxy3" === t.cloudProxyServer || "proxy4" === t.cloudProxyServer ? qO.CLOUD_PROXY : qO.CLOUD_PROXY_FALLBACK); return nI(_), { gatewayInfo: Fg(_, o), proxyInfo: u, url: o } }), (e => (e.gatewayInfo && wA.joinChooseServer(t.sid, { lts: c, succ: !0, csAddr: o, serverList: e.gatewayInfo.gatewayAddrs.map((e => e.address)), ec: null, opid: _, cid: e.gatewayInfo.cid.toString(), uid: e.gatewayInfo.uid.toString(), csIp: e.gatewayInfo.csIp, unilbsServerIds: a.toString(), isHttp3: r }), e.proxyInfo && wA.joinWebProxyAP(t.sid, { lts: c, sucess: 1, apServerAddr: o, turnServerAddrList: e.proxyInfo.addresses.map((e => e.ip)).join(","), errorCode: null, eventType: t.cloudProxyServer, unilbsServerIds: a.toString() }), !1)), (e => e.code !== Oh.OPERATION_ABORTED && (e.code === Oh.CAN_NOT_GET_GATEWAY_SERVER ? e.data.retry : (wA.joinWebProxyAP(t.sid, { lts: c, sucess: 0, apServerAddr: o, turnServerAddrList: null, errorCode: e.code, eventType: t.cloudProxyServer, unilbsServerIds: a.toString(), extend: JSON.stringify({ networkState: d }) }), Dh.warning("[".concat(t.clientId, "] multi unilbs network error, retry"), e), !0))), i) } const tI = (e, t, n, i, r, o) => { const s = [], a = s => { 4096 === s.flag ? wA.joinChooseServer(n.sid, { lts: i, succ: !1, csAddr: t, opid: e.opid, serverList: null, ec: s.error.message, csIp: s.error.data && s.error.data.csIp, unilbsServerIds: r.toString(), isHttp3: o }) : 1048576 !== s.flag && 4194304 !== s.flag && 4194310 !== s.flag || wA.joinWebProxyAP(n.sid, { lts: i, sucess: 0, apServerAddr: t, turnServerAddrList: null, errorCode: s.error.code, eventType: n.cloudProxyServer, unilbsServerIds: r.toString() }) }; if (e.response_body.forEach((t => { const n = t.buffer.code; if (23 === t.uri && 0 === n && !t.buffer.edges_services) if (4194310 === t.buffer.flag) Dh.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t.buffer.edges_services = []; else { const n = { error: new Ch(Oh.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: !0, csIp: e.detail[502] }), flag: t.buffer.flag }; s.push(n), a(n) } if (0 !== n) { const i = Am(n), r = { error: new Ch(Oh.CAN_NOT_GET_GATEWAY_SERVER, i.desc, { desc: i.desc, retry: i.retry, csIp: e.detail[502] }), flag: t.buffer.flag }; 4194310 === t.buffer.flag ? Dh.warning(r.error.toString()) : s.push(r), a(r) } })), s.length) throw Dh.warning("[".concat(n.clientId, "] multi unilbs ").concat(t, " failed, ").concat(s.map((e => "flag: ".concat(e.flag, ", message: ").concat(e.error.message, ", retry: ").concat(e.error.data.retry))).join(" | "))), new Ch(Oh.CAN_NOT_GET_GATEWAY_SERVER, s.map((e => "flag: ".concat(e.flag, ", message: ").concat(e.error.message))).join(" | "), { retry: !!s.find((e => e.error.data.retry)), csIp: e.detail[502], desc: [...new Set(s.map((e => { var t, n; return null == e || null === (t = e.error) || void 0 === t || null === (n = t.data) || void 0 === n ? void 0 : n.desc })).filter((e => !!e)))] }) }, nI = e => { var t, n, i, r; if (e.addresses && 0 === e.addresses.length && 0 === e.code) throw new Ch(Oh.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: !0, csIp: e.detail && e.detail[502] }); if (jh("AP_AREA") && (null !== (i = e.detail) && void 0 !== i && i[23] && "string" == typeof (null === (r = e.detail) || void 0 === r ? void 0 : r[23]) ? Km(e.detail[23].toLowerCase()) : Km()), null !== (t = e.detail) && void 0 !== t && t[19] && "string" == typeof (null === (n = e.detail) || void 0 === n ? void 0 : n[19])) { const t = e.detail[19], n = null == t ? void 0 : t.split(";"); for (let i = 0; i < n.length; i++) { var o; const t = Tu(o = n[i]).call(o); e.addresses[i] && n && (e.addresses[i].fingerprint = t) } } if (jh("GATEWAY_ADDRESS") && jh("GATEWAY_ADDRESS").length > 0) { Dh.debug("assign gateway address to", jh("GATEWAY_ADDRESS")); const t = jh("GATEWAY_ADDRESS").map((t => { var n, i; const r = null !== (n = null === (i = e.addresses.find((e => e.ip === t.ip && e.port === t.port))) || void 0 === i ? void 0 : i.fingerprint) && void 0 !== n ? n : ""; return { ip: t.ip, port: t.port, ticket: e.addresses[0] && e.addresses[0].ticket, fingerprint: r } })); e.addresses = t } }, iI = (e, t) => { if (e.response_body && e.response_body.length) { const t = e.response_body[0]; if (0 !== t.buffer.code) { const e = Am(t.buffer.code); throw new Ch(Oh.UPDATE_TICKET_FAILED, "[".concat(t.buffer.code, "]: ").concat(e.desc), { retry: e.retry }) } return t.buffer.ticket } throw Dh.debug("update ticket request received ap response without response body:", t), new Ch(Oh.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: !1 }) }, rI = (e, t, n) => { const i = Math.floor(Math.random() * 10 ** 12), r = { appid: e.appId, client_ts: Date.now(), opid: i, sid: e.sid, request_bodies: [{ uri: 22, buffer: { cname: e.cname, detail: { 6: e.stringUid, 11: t, 12: jh("USE_NEW_TOKEN") ? "1" : void 0, 22: t }, key: e.token, service_ids: n, uid: e.uid || 0 } }] }; r.request_bodies.forEach((t => { e.multiIP && e.multiIP.gateway_ip && (t.buffer.detail[5] = JSON.stringify({ vocs_ip: [e.multiIP.uni_lbs_ip], vos_ip: [e.multiIP.gateway_ip] })) })); const o = new FormData; return o.append("request", JSON.stringify(r)), [o, i] }, oI = (e, t) => { const n = Math.floor(Math.random() * 10 ** 12), i = { appid: e.appId, client_ts: Date.now(), opid: n, sid: e.sid, request_bodies: [{ uri: 28, buffer: { cname: e.cname, detail: { 1: "", 6: e.stringUid, 12: "1" }, token: e.token, service_ids: t, uid: e.uid || 0, edges_services: e.apResponse.addresses.map((e => ({ ip: e.ip, port: e.port }))) } }] }, r = new FormData; return r.append("request", JSON.stringify(i)), [r, n] }; let sI = 0; async function aI(e, t, n, i) { const r = async function (e, t, n, i) { let r = null; const o = [], s = async () => { const r = jh("WEBCS_DOMAIN").slice(0, jh("AJAX_REQUEST_CONCURRENT")).map((t => ({ url: e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(t + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t, "/api/v2/transpond/webrtc?v=2"), areaCode: Fm() }))), s = i.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r.map((e => e.url)) }), a = await Tm({ fragementLength: jh("FRAGEMENT_LENGTH"), referenceList: r, asyncMapHandler: i => (Dh.debug("[".concat(e.clientId, "] Connect to choose_server:"), i.url), $m(i, e, t, n)), allFailedhandler: e => { throw i.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e }, s), e[0] }, promisesCollector: o }); return i.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s), a }, a = async () => { if (await Qg(1e3), null !== r) return r; const s = jh("WEBCS_DOMAIN_BACKUP_LIST").map((t => ({ url: e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(t + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t, "/api/v2/transpond/webrtc?v=2"), areaCode: Fm() }))), a = i.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: s.map((e => e.url)) }), c = await Tm({ fragementLength: jh("FRAGEMENT_LENGTH"), referenceList: s, asyncMapHandler: i => (Dh.debug("[".concat(e.clientId, "] Connect to backup choose_server:"), i.url), $m(i, e, t, n)), allFailedhandler: e => { throw i.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e }, a), e[0] }, promisesCollector: o }); return i.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a), c }; try { return r = await nm([s(), a()]), o.length && o.forEach((e => e.cancel && "function" == typeof e.cancel && e.cancel())), r } catch (e) { throw e[0] } }(e, t, n, i); return { gatewayInfo: await r } } async function cI(e, t, n, i, r) { const o = e.cloudProxyServer; if ("disabled" === o) { if (!i) return; if (e.useLocalAccessPoint) return await aI(e, t, n, r); if (jh("JOIN_WITH_FALLBACK_MEDIA_PROXY")) { const { gatewayInfo: i, proxyInfo: o } = await dI(e, t, n, r); return e.turnServer && "auto" !== e.turnServer.mode || (e.turnServer = { mode: "manual", servers: o.map((e => ({ turnServerURL: e.address, tcpport: e.tcpport || bh.tcpport, udpport: e.udpport || bh.udpport, username: e.username || bh.username, password: e.password || bh.password, forceturn: !1, security: !0 }))) }), { gatewayInfo: i } } return await aI(e, t, n, r) } const { proxyInfo: s, gatewayInfo: a } = await dI(e, t, n, r), c = { gatewayInfo: a }; return e.turnServer = { mode: "manual", servers: s.map((e => ({ turnServerURL: e.address, tcpport: "proxy3" === o ? void 0 : e.tcpport ? e.tcpport : bh.tcpport, udpport: "proxy4" === o ? void 0 : e.udpport ? e.udpport : bh.udpport, username: e.username || bh.username, password: e.password || bh.password, forceturn: "proxy4" !== o, security: "proxy5" === o }))) }, Dh.debug("[".concat(e.clientId, "] set proxy server: ").concat(e.proxyServer, ", mode: ").concat(o)), c } async function EI(e, t, n, i, r) { const o = jh("ACCOUNT_REGISTER").slice(0, jh("AJAX_REQUEST_CONCURRENT")); let s = []; s = t.proxyServer ? o.map((e => "https://".concat(t.proxyServer, "/ap/?url=").concat(e + "/api/v1"))) : o.map((e => "https://".concat(e, "/api/v1"))); const a = null == r ? void 0 : r.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: s }); try { const o = await async function (e, t, n, i, r) { const o = Date.now(), s = { sid: n.sid, opid: 10, appid: n.appId, string_uid: t }; let a = e[0]; const c = await gh((() => AA(a + "".concat(-1 === a.indexOf("?") ? "?" : "&", "action=stringuid"), { data: s, cancelToken: i, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } })), ((n, i) => { if (0 === n.code) { if (n.uid <= 0 || n.uid >= Math.pow(2, 32)) throw Dh.error("Invalid Uint Uid ".concat(t, " => ").concat(n.uid), n), wA.reqUserAccount(s.sid, { lts: o, success: !1, serverAddr: a, stringUid: s.string_uid, uid: n.uid, errorCode: Oh.INVALID_UINT_UID_FROM_STRING_UID, extend: s }), new Ch(Oh.INVALID_UINT_UID_FROM_STRING_UID); return wA.reqUserAccount(s.sid, { lts: o, success: !0, serverAddr: a, stringUid: s.string_uid, uid: n.uid, errorCode: null, extend: s }), !1 } const r = Am(n.code); return r.retry && (a = e[(i + 1) % e.length]), wA.reqUserAccount(s.sid, { lts: o, success: !1, serverAddr: a, stringUid: s.string_uid, uid: n.uid, errorCode: r.desc, extend: s }), r.retry }), ((t, n) => t.code !== Oh.OPERATION_ABORTED && (wA.reqUserAccount(s.sid, { lts: o, success: !1, serverAddr: a, stringUid: s.string_uid, uid: null, errorCode: t.code, extend: s }), a = e[(n + 1) % e.length], !0)), r); if (0 !== c.code) { const e = Am(c.code); throw new Ch(Oh.UNEXPECTED_RESPONSE, e.desc) } return c }(s, e, t, n, i); return null == r || r.recordJoinChannelService({ status: "success", endTs: Date.now() }, a), o.uid } catch (e) { throw null == r || r.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e] }, a), e } } async function _I(e, t, n) { const i = jh("CDS_AP").slice(0, jh("AJAX_REQUEST_CONCURRENT")).map((t => e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(t + "/api/v1") : "https://".concat(t, "/api/v1?action=config"))).map((i => function (e, t, n, i) { const r = xu(), o = { flag: 64, cipher_method: 0, features: { device: r.name, system: r.os, system_general: navigator.userAgent, vendor: t.appId, version: yh, cname: t.cname, sid: t.sid, session_id: t.sid, detail: "", proxyServer: t.proxyServer } }; return gh((() => AA(e, { data: o, timeout: 1e3, cancelToken: n, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } })), void 0, (e => e.code !== Oh.OPERATION_ABORTED), i) }(i, e, t, n))); let r = null, o = null, s = {}; try { r = await nm(i) } catch (e) { if (e.code === Oh.OPERATION_ABORTED) throw e; o = e } if (i.forEach((e => e.cancel())), wA.reportApiInvoke(e.sid, { name: RT.REQUEST_CONFIG_DISTRIBUTE, options: { error: o, res: r } }).onSuccess(), r && r.test_tags) try { s = function (e) { if (!e.test_tags) return {}; const t = e.test_tags, n = Object.keys(t), i = {}; return n.forEach((e => { var n; const r = Tu(n = e.slice(4)).call(n), o = JSON.parse(t[e])[1]; i[r] = o })), i }(r) } catch (e) { } return s } async function dI(e, t, n, i) { const r = jh("PROXY_SERVER_TYPE3"), o = (e, t, n) => { let i = n || r; return Array.isArray(i) && (i = t % 2 == 0 ? r[1] : r[0]), "https://".concat(i, "/ap/?url=").concat(e) }; let s = null; const a = [], c = async () => { const r = jh("WEBCS_DOMAIN").slice(0, jh("AJAX_REQUEST_CONCURRENT")).map(((t, n) => { let i; return i = "disabled" === e.cloudProxyServer && e.proxyServer ? o("".concat(t, "/api/v2/transpond/webrtc?v=2"), n, e.proxyServer) : "disabled" === e.cloudProxyServer || "fallback" === e.cloudProxyServer ? "https://".concat(t, "/api/v2/transpond/webrtc?v=2") : o("".concat(t, "/api/v2/transpond/webrtc?v=2"), n), { url: i, areaCode: Fm(), serviceIds: [qO.CHOOSE_SERVER, "proxy5" === e.cloudProxyServer ? qO.CLOUD_PROXY_5 : "proxy3" === e.cloudProxyServer || "proxy4" === e.cloudProxyServer ? qO.CLOUD_PROXY : qO.CLOUD_PROXY_FALLBACK] } })), s = i.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r.map((e => e.url)) }), c = await Tm({ fragementLength: jh("FRAGEMENT_LENGTH"), referenceList: r, asyncMapHandler: i => (Dh.debug("[".concat(e.clientId, "] Connect to choose_server:"), i.url), eI(i, e, t, n)), allFailedhandler: e => { throw i.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e }, s), e[0] }, promisesCollector: a }); return i.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s), c }, E = async () => { if (await Qg(1e3), null !== s) return s; const r = jh("WEBCS_DOMAIN_BACKUP_LIST").map(((t, n) => { let i; return i = "disabled" === e.cloudProxyServer && e.proxyServer ? o("".concat(t, "/api/v2/transpond/webrtc?v=2"), n, e.proxyServer) : "disabled" === e.cloudProxyServer || "fallback" === e.cloudProxyServer ? "https://".concat(t, "/api/v2/transpond/webrtc?v=2") : o("".concat(t, "/api/v2/transpond/webrtc?v=2"), n), { url: i, areaCode: Fm(), serviceIds: [qO.CHOOSE_SERVER, "proxy5" === e.cloudProxyServer ? qO.CLOUD_PROXY_5 : "proxy3" === e.cloudProxyServer || "proxy4" === e.cloudProxyServer ? qO.CLOUD_PROXY : qO.CLOUD_PROXY_FALLBACK] } })), c = i.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r.map((e => e.url)) }), E = await Tm({ fragementLength: jh("FRAGEMENT_LENGTH"), referenceList: r, asyncMapHandler: i => (Dh.debug("[".concat(e.clientId, "] Connect to backup choose_server:"), i.url), eI(i, e, t, n)), allFailedhandler: e => { throw i.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e }, c), e[0] }, promisesCollector: a }); return i.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c), E }; let _, d, u; try { ({ gatewayInfo: _, proxyInfo: d, url: u } = await nm([c(), E()])) } catch (e) { throw e[0] } if (a.length && a.forEach((e => e.cancel && "function" == typeof e.cancel && e.cancel())), !_ || !d) throw new Ch(Oh.UNEXPECTED_ERROR, "missing gateway or proxy response").print(); if (e.apUrl = u, "disabled" !== e.cloudProxyServer && Array.isArray(r) && u) { const t = /^https?:\/\/(.+?)(\/.*)?$/.exec(u)[1]; r.includes(t) && (e.proxyServer = t, Dh.setProxyServer(t), wA.setProxyServer(t)) } return s = { gatewayInfo: _, proxyInfo: await Hg(d, _.uid) }, s } async function uI(e, t, n, i) { const r = jh("UAP_AP").slice(0, jh("AJAX_REQUEST_CONCURRENT")).map((e => t.proxyServer ? "https://".concat(t.proxyServer, "/ap/?url=").concat(e + "/api/v1?action=uap") : "https://".concat(e, "/api/v1?action=uap"))); return await zm(r, e, t, n, i) } async function lI(e, t, n) { const i = jh("UAP_AP").slice(0, jh("AJAX_REQUEST_CONCURRENT")).map((t => e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(t + "/api/v1?action=uap") : "https://".concat(t, "/api/v1?action=uap"))).map((i => function (e, t, n, i) { const r = { command: "convergeAllocateEdge", sid: t.sid, appId: t.appId, token: t.token, ts: Date.now(), version: yh, cname: t.cname, uid: t.uid.toString(), requestId: Zm, seq: Zm }; Zm += 1; const o = { service_name: "tele_channel", json_body: JSON.stringify(r) }; return gh((async () => { const t = await AA(e, { data: o, cancelToken: n, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } }); if (0 !== t.code) { const e = new Ch(Oh.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t.code, { retry: !0 }); throw Dh.error(e.toString()), e } const i = JSON.parse(t.json_body); if (200 !== i.code) { const e = new Ch(Oh.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(i.code, ", reason: ").concat(i.reason)); throw Dh.error(e.toString()), e } if (!i.servers || 0 === i.servers.length) { const e = new Ch(Oh.UNEXPECTED_RESPONSE, "cross channel app center empty server"); throw Dh.error(e.toString()), e } return { vid: i.vid, workerToken: i.workerToken, addressList: (jh("CHANNEL_MEDIA_RELAY_SERVERS") || i.servers).map((e => "wss://".concat(e.address.replace(/\./g, "-"), ".").concat(jh("WORKER_DOMAIN"), ":").concat(e.wss))) } }), void 0, (e => !!(e.code !== Oh.OPERATION_ABORTED && e.code !== Oh.UNEXPECTED_RESPONSE || e.data && e.data.retry)), i) }(i, e, t, n))); try { const e = await nm(i); return i.forEach((e => e.cancel())), e } catch (e) { throw e[0] } } async function RI(e, t, n) { let i = null; const r = [], o = async o => { const s = jh(o ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((t => e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(t + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t, "/api/v2/transpond/webrtc?v=2"))); return o && (await Qg(1e3), null !== i) ? i : await Tm({ fragementLength: jh("FRAGEMENT_LENGTH"), referenceList: s, asyncMapHandler: i => (Dh.debug("[".concat(e.clientId, "] update ticket, Connect to ").concat(o ? "backup" : "", " choose_server:"), i), function (e, t, n, i) { const [r] = oI(t, [qO.CHOOSE_SERVER]); let o = gA.networkState; return gh((async () => { o && gA.networkState === wO.OFFLINE && gA.onlineWaiter && await Cd.race([gA.onlineWaiter, Qg(i && i.maxRetryTimeout || Ah.maxRetryTimeout)]), o = gA.networkState; const t = await AA(e, { data: r, cancelToken: n, headers: { "Content-Type": "multipart/form-data;" } }, !0); return iI(t, e) }), (() => !1), (e => e.code !== Oh.OPERATION_ABORTED && (e.code === Oh.UPDATE_TICKET_FAILED ? e.data.retry : (Dh.warning("[".concat(t.clientId, "] update ticket network error, retry"), e), !0))), i) }(i, e, t, n)), allFailedhandler: e => { throw e[0] }, promisesCollector: r }) }; try { return i = await nm([o(!1), o(!0)]), r.length && r.forEach((e => e.cancel && "function" == typeof e.cancel && e.cancel())), i } catch (e) { throw e[0] } } function hI(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function pI(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? hI(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hI(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class TI extends ph { constructor() { super(), hl(this, "configs", void 0), hl(this, "joinInfo", void 0), hl(this, "cancelToken", void 0), hl(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), hl(this, "interval", void 0), hl(this, "mutex", new kA("config-distribute")), hl(this, "mutableParamsRead", !1) } startGetConfigDistribute(e, t) { this.joinInfo = e, this.cancelToken = t, this.interval && this.stopGetConfigDistribute(), jh("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval((() => { this.updateConfigDistribute() }), jh("CONFIG_DISTRIBUTE_INTERVAL"))) } stopGetConfigDistribute() { this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0 } async awaitConfigDistributeComplete() { this.mutex.isLocked && (await this.mutex.lock())() } async updateConfigDistribute() { if (this.mutableParamsRead || (this.mutableParamsRead = !0, wA.reportApiInvoke(null, { options: void 0, name: RT.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: hT.TRACER }).onSuccess(JSON.stringify(Wh))), !this.joinInfo || !this.cancelToken || !this.retryConfig) return void Dh.debug("[config-distribute] get config distribute interrupted have no joininfo"); let e; const t = await this.mutex.lock(); try { e = await _I(this.joinInfo, this.cancelToken, this.retryConfig), Dh.debug("[config-distribute] get config distribute", JSON.stringify(e)), e.limit_bitrate && this.handleBitrateLimit(e.limit_bitrate), this.cacheGlobalParameterConfig(e), this.configs = e } catch (e) { const t = new Ch(Oh.NETWORK_RESPONSE_ERROR, e); Dh.warning("[config-distribute] ".concat(t.toString())) } finally { t() } } getBitrateLimit() { return this.configs ? this.configs.limit_bitrate : void 0 } handleBitrateLimit(e) { var t; (t = e) && t.uplink && t.id && void 0 !== t.uplink.max_bitrate && void 0 !== t.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e.id && this.emit(IO.UPDATE_BITRATE_LIMIT, e) : this.emit(IO.UPDATE_BITRATE_LIMIT, e)) } getLowStreamConfigDistribute() { return this.configs && this.configs.limit_bitrate && pI({}, this.configs.limit_bitrate.low_stream_uplink) } cacheGlobalParameterConfig(e) { var t; const n = Wp(t = Object.keys(e).filter((e => /^webrtc_ng_global_parameter/.test(e)))).call(t); for (let r = 0; r < n.length; r++)for (let t = n.length - 1; t > r; t--) { const i = n[t]; if ("number" == typeof e[i].__priority) { const r = e[i].__priority, o = n[t - 1]; if ("number" == typeof e[o].__priority) { if (!(r > e[o].__priority)) continue; { const e = i; n[t] = n[t - 1], n[t - 1] = e } } else { const e = i; n[t] = n[t - 1], n[t - 1] = e } } } const i = {}; n.forEach((t => { const n = e[t], r = n.__expires; Object.keys(n).forEach((e => { "__priority" === e || "__expires" === e || Object.prototype.hasOwnProperty.call(i, e) || (i[e] = pI({ value: n[e] }, r && { expires: r })) })) })); try { const e = JSON.stringify(i), t = window.btoa(e); window.localStorage.setItem("websdk_ng_global_parameter", t), Dh.debug("Caching global parameters ".concat(e)) } catch (e) { Dh.error("Error caching global parameters:", e.message) } } } function OI(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function CI(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? OI(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OI(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class AI extends ph { constructor(e, t, n, i) { super(), hl(this, "spec", void 0), hl(this, "token", void 0), hl(this, "websocket", void 0), hl(this, "pingpongTimer", void 0), hl(this, "reconnectMode", "retry"), hl(this, "serviceMode", void 0), hl(this, "reqId", 0), hl(this, "commandReqId", 0), hl(this, "handleWebSocketOpen", (() => { this.reconnectMode = "retry", this.startPingPong() })), hl(this, "handleWebSocketMessage", (e => { if (!e.data) return; const t = JSON.parse(e.data); t.requestId ? this.emit("@".concat(t.requestId, "-").concat(t.sid), t) : this.serviceMode === WT.INJECT ? this.emit(ZT.INJECT_STREAM_STATUS, t) : (wA.workerEvent(this.spec.sid, { actionType: "status", serverCode: t.code, workerType: this.serviceMode === WT.TRANSCODE ? 1 : 2 }), this.emit(ZT.PUBLISH_STREAM_STATUS, t)) })), this.spec = t, this.token = e, this.serviceMode = i, this.websocket = new Im("live-streaming", n), this.websocket.on(HT.CONNECTED, this.handleWebSocketOpen), this.websocket.on(HT.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(HT.REQUEST_NEW_URLS, ((e, t) => { im(this, ZT.REQUEST_NEW_ADDRESS).then(e).catch(t) })), this.websocket.on(HT.RECONNECTING, (() => { this.websocket.reconnectMode = this.reconnectMode })) } init(e) { return this.websocket.init(e) } async request(e, t, n, i) { this.reqId += 1, "request" === e && (this.commandReqId += 1); const r = this.commandReqId, o = this.reqId; if (!o || !this.websocket) throw new Ch(Oh.UNEXPECTED_ERROR); const s = CI({ command: e, sdkVersion: "4.18.2" === yh ? "0.0.1" : yh, seq: o, requestId: o, allocate: n, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t); if ("closed" === this.websocket.state) throw new Ch(Oh.WS_DISCONNECT); const a = () => new Cd(((e, t) => { this.websocket.once(HT.CLOSED, (() => t(new Ch(Oh.WS_ABORT)))), this.websocket.once(HT.CONNECTED, e) })); "connected" !== this.websocket.state && await a(), s.clientRequest && (s.clientRequest.workerToken = this.token); const c = new Cd(((e, t) => { const n = () => { t(new Ch(Oh.WS_ABORT)) }; this.websocket.once(HT.RECONNECTING, n), this.websocket.once(HT.CLOSED, n), this.once("@".concat(o, "-").concat(this.spec.sid), (t => { e(t) })) })); i && wA.workerEvent(this.spec.sid, CI(CI({}, i), {}, { requestId: r, actionType: "request", payload: JSON.stringify(t.clientRequest), serverCode: 0, code: 0 })); const E = Date.now(); this.websocket.sendMessage(s); let _ = null; try { _ = await c } catch (i) { if ("closed" === this.websocket.state) throw i; return await a(), await this.request(e, t, n) } return i && wA.workerEvent(this.spec.sid, CI(CI({}, i), {}, { requestId: r, actionType: "response", payload: JSON.stringify(_.serverResponse), serverCode: _.code, success: 200 === _.code, responseTime: Date.now() - E })), 200 !== _.code && this.handleResponseError(_), _ } tryNextAddress() { this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext") } close() { const e = "4.18.2" === yh ? "0.0.1" : yh; this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(!1, !0)) : this.websocket.close(!1), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0) } handleResponseError(e) { switch (e.code) { case eO.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM: return void Dh.warning("live stream response already exists stream"); case eO.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR: case eO.LIVE_STREAM_RESPONSE_BAD_STREAM: case eO.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR: return new Ch(Oh.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e.code }).throw(); case eO.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST: if ("UnpublishStream" === e.serverResponse.command || "UninjectStream" === e.serverResponse.command) return; throw new Ch(Oh.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: !0 }); case eO.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED: return new Ch(Oh.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e.code }).throw(); case eO.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: { const t = new Ch(Oh.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE); return this.emit(ZT.WARNING, t, e.serverResponse.url) } case eO.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: { const t = new Ch(Oh.LIVE_STREAMING_WARN_FREQUENT_REQUEST); return this.emit(ZT.WARNING, t, e.serverResponse.url) } case eO.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH: throw new Ch(Oh.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: !0 }); case eO.LIVE_STREAM_RESPONSE_NOT_SUPPORTED: return new Ch(Oh.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e.code }).throw(); case eO.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: { const t = new Ch(Oh.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT); return this.emit(ZT.WARNING, t, e.serverResponse.url) } case eO.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR: return new Ch(Oh.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e.code }).throw(); case eO.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT: throw new Ch(Oh.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: !0, changeAddress: !0 }); case eO.LIVE_STREAM_RESPONSE_WORKER_LOST: case eO.LIVE_STREAM_RESPONSE_WORKER_QUIT: if ("UnpublishStream" === e.serverResponse.command || "UninjectStream" === e.serverResponse.command) return; throw new Ch(Oh.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: !0, changeAddress: !0 }); case eO.ERROR_FAIL_SEND_MESSAGE: if ("UnpublishStream" === e.serverResponse.command || "UninjectStream" === e.serverResponse.command) return; if ("UpdateTranscoding" === e.serverResponse.command || "ControlStream" === e.serverResponse.command) return new Ch(Oh.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e.code }).throw(); throw new Ch(Oh.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: !0, changeAddress: !0 }); case eO.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN: case eO.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT: case eO.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE: case eO.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: return new Ch(Oh.LIVE_STREAMING_CDN_ERROR, "", { code: e.code }).throw() } } startPingPong() { this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval((() => { "connected" === this.websocket.state && this.request("ping", {}).catch(em) }), 6e3) } } function SI(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function gI(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? SI(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SI(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class mI extends ph { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ah, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ah; super(), hl(this, "onLiveStreamWarning", void 0), hl(this, "onLiveStreamError", void 0), hl(this, "onInjectStatusChange", void 0), hl(this, "spec", void 0), hl(this, "retryTimeout", 1e4), hl(this, "connection", void 0), hl(this, "httpRetryConfig", void 0), hl(this, "wsRetryConfig", void 0), hl(this, "streamingTasks", new Map), hl(this, "isStartingStreamingTask", !1), hl(this, "taskMutex", new kA("live-streaming")), hl(this, "cancelToken", Rh.CancelToken.source()), hl(this, "transcodingConfig", void 0), hl(this, "injectConfig", gI({}, zT)), hl(this, "injectLoopTimes", 0), hl(this, "uapResponse", void 0), hl(this, "lastTaskId", 1), hl(this, "statusError", new Map), this.spec = e, this.httpRetryConfig = n, this.wsRetryConfig = t } async setTranscodingConfig(e) { const t = gI(gI({}, QT), e); 66 !== t.videoCodecProfile && 77 !== t.videoCodecProfile && 100 !== t.videoCodecProfile && (Dh.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t.videoCodecProfile, " -> 100")), t.videoCodecProfile = 100), t.transcodingUsers || (t.transcodingUsers = t.userConfigs), t.transcodingUsers && (t.transcodingUsers = t.transcodingUsers.map((e => gI(gI(gI({}, JT), e), {}, { zOrder: e.zOrder ? e.zOrder + 1 : 1 })))), function (e) { eT(e.width) || Xp(e.width, "config.width", 0, 1e4), eT(e.height) || Xp(e.height, "config.height", 0, 1e4), eT(e.videoBitrate) || Xp(e.videoBitrate, "config.videoBitrate", 1, 1e6), eT(e.videoFrameRate) || Xp(e.videoFrameRate, "config.videoFrameRate"), eT(e.lowLatency) || Kp(e.lowLatency, "config.lowLatency"), eT(e.audioSampleRate) || Jp(e.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), eT(e.audioBitrate) || Xp(e.audioBitrate, "config.audioBitrate", 1, 128), eT(e.audioChannels) || Jp(e.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), eT(e.videoGop) || Xp(e.videoGop, "config.videoGop"), eT(e.videoCodecProfile) || Jp(e.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), eT(e.userCount) || Xp(e.userCount, "config.userCount", 0, 17), eT(e.backgroundColor) || Xp(e.backgroundColor, "config.backgroundColor", 0, 16777215), eT(e.userConfigExtraInfo) || Qp(e.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, !1), e.transcodingUsers && !eT(e.transcodingUsers) && (zp(e.transcodingUsers, "config.transcodingUsers"), e.transcodingUsers.forEach(((e, t) => { $p(e.uid), eT(e.x) || Xp(e.x, "transcodingUser[".concat(t, "].x"), 0, 1e4), eT(e.y) || Xp(e.y, "transcodingUser[".concat(t, "].y"), 0, 1e4), eT(e.width) || Xp(e.width, "transcodingUser[".concat(t, "].width"), 0, 1e4), eT(e.height) || Xp(e.height, "transcodingUser[".concat(t, "].height"), 0, 1e4), eT(e.zOrder) || Xp(e.zOrder - 1, "transcodingUser[".concat(t, "].zOrder"), 0, 100), eT(e.alpha) || Xp(e.alpha, "transcodingUser[".concat(t, "].alpha"), 0, 1, !1) }))), eT(e.watermark) || qT(e.watermark, "watermark"), eT(e.backgroundImage) || qT(e.backgroundImage, "backgroundImage"), e.images && !eT(e.images) && (zp(e.images, "config.images"), e.images.forEach(((e, t) => { qT(e, "images[".concat(t, "]")) }))) }(t); const n = []; t.images && n.push(...t.images.map((e => gI(gI(gI({}, XT), e), {}, { zOrder: 255 })))), t.backgroundImage && (n.push(gI(gI(gI({}, XT), t.backgroundImage), {}, { zOrder: 0 })), delete t.backgroundImage), t.watermark && (n.push(gI(gI(gI({}, XT), t.watermark), {}, { zOrder: 255 })), delete t.watermark), t.images = n, t.transcodingUsers && (t.userConfigs = t.transcodingUsers.map((e => gI({}, e))), t.userCount = t.transcodingUsers.length, delete t.transcodingUsers); const i = (t.userConfigs || []).map((e => "number" == typeof e.uid ? Cd.resolve(e.uid) : EI(e.uid, this.spec, this.cancelToken.token, this.httpRetryConfig))); if ((await Cd.all(i)).forEach(((e, n) => { t.userConfigs && t.userConfigs[n] && (t.userConfigs[n].uid = e) })), this.transcodingConfig = t, this.connection) try { var r; const e = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, !1, { command: "UpdateTranscoding", workerType: 1, requestByUser: !0, tid: Array.from(gS(r = this.streamingTasks).call(r)).map((e => e.taskId)).join("#") }); Dh.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e.code, ", config:"), JSON.stringify(this.transcodingConfig)) } catch (e) { if (!e.data || !e.data.retry) throw e; e.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((t => { Dh.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e.toString(), "try to republish", t.url), this.startLiveStreamingTask(t.url, t.mode, e).then((() => { Dh.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t.url, " success")) })).catch((e => { Dh.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t.url, e.toString()), this.onLiveStreamError && this.onLiveStreamError(t.url, e) })) })) } } setInjectStreamConfig(e, t) { this.injectConfig = Object.assign({}, this.injectConfig, e), this.injectLoopTimes = t } async startLiveStreamingTask(e, t, n) { var i; if (Array.from(gS(i = this.streamingTasks).call(i)).find((e => e.mode === WT.INJECT)) && t === WT.INJECT) return new Ch(Oh.LIVE_STREAMING_TASK_CONFLICT, "inject stream over limit").throw(); if (!this.transcodingConfig && t === WT.TRANSCODE) throw new Ch(Oh.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task"); let r = { command: "PublishStream", ts: Date.now(), url: e, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: !0 }; Dh.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e, ", mode: ").concat(t)); const o = await this.taskMutex.lock(); if (!this.connection && n) return void o(); if (this.streamingTasks.get(e) && !n) return o(), new Ch(Oh.LIVE_STREAMING_TASK_CONFLICT).throw(); try { this.connection || (this.connection = await this.connect(t)) } catch (e) { throw o(), e } switch (t) { case WT.TRANSCODE: r.transcodingConfig = gI({}, this.transcodingConfig); break; case WT.RAW: break; case WT.INJECT: r = { cname: this.spec.cname, command: "InjectStream", sid: this.spec.sid, transcodingConfig: this.injectConfig, ts: Date.now(), url: e, loopTimes: this.injectLoopTimes } }this.uapResponse && this.uapResponse.vid && (r.vid = this.uapResponse.vid), this.isStartingStreamingTask = !0; const s = this.lastTaskId++; try { const i = new Cd(((t, i) => { Qg(this.retryTimeout).then((() => { if (n) return i(n); const t = this.statusError.get(e); return t ? (this.statusError.delete(e), i(t)) : void 0 })) })), a = await Cd.race([this.connection.request("request", { clientRequest: r }, !0, { url: e, command: "PublishStream", workerType: t === WT.TRANSCODE ? 1 : 2, requestByUser: !n, tid: s.toString() }), i]); this.isStartingStreamingTask = !1, Dh.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a.code)), this.streamingTasks.set(e, { clientRequest: r, mode: t, url: e, taskId: s }), o() } catch (i) { if (o(), this.isStartingStreamingTask = !1, !i.data || !i.data.retry || n) throw i; return i.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e, t, i)) : await this.startLiveStreamingTask(e, t, i) } } stopLiveStreamingTask(e) { return new Cd(((t, n) => { const i = this.streamingTasks.get(e); if (!i || !this.connection) return new Ch(Oh.UNEXPECTED_ERROR, "can not find streaming task to stop").throw(); const r = i.mode; i.abortTask = () => { Dh.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e), t() }, this.connection.request("request", { clientRequest: { command: r === WT.INJECT ? "UninjectStream" : "UnpublishStream", url: i.url } }, !1, { url: e, command: "UnPublishStream", workerType: r === WT.TRANSCODE ? 1 : 2, requestByUser: !0, tid: (this.lastTaskId++).toString() }).then((n => { Dh.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(n.code)), this.streamingTasks.delete(e), 0 === this.streamingTasks.size && r !== WT.INJECT && (this.connection && this.connection.close(), this.connection = void 0), t(), r === WT.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(KT.INJECT_STREAM_STATUS_STOP_SUCCESS, this.spec.uid, e) })).catch(n) })) } async controlInjectStream(e, t, n, i) { const r = this.streamingTasks.get(e); if (!r || !this.connection || r.mode !== WT.INJECT) throw new Ch(Oh.INVALID_OPERATION, "can not find inject stream task to control"); return (await this.connection.request("request", { clientRequest: { command: "ControlStream", url: e, control: t, audioVolume: n, position: i } })).serverResponse } resetAllTask() { var e; const t = Array.from(gS(e = this.streamingTasks).call(e)); this.terminate(); for (const n of t) this.startLiveStreamingTask(n.url, n.mode).catch((e => { this.onLiveStreamError && this.onLiveStreamError(n.url, e) })) } terminate() { this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = new Map, this.isStartingStreamingTask = !1, this.statusError = new Map, this.cancelToken = Rh.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0 } async connect(e) { if (this.connection) throw new Ch(Oh.UNEXPECTED_ERROR, "live streaming connection has already connected"); const t = await im(this, $T.REQUEST_WORKER_MANAGER_LIST, e); return this.uapResponse = t, this.connection = new AI(t.workerToken, this.spec, this.wsRetryConfig, e), this.connection.on(ZT.WARNING, ((e, t) => this.onLiveStreamWarning && this.onLiveStreamWarning(t, e))), this.connection.on(ZT.PUBLISH_STREAM_STATUS, (e => this.handlePublishStreamServer(e))), this.connection.on(ZT.INJECT_STREAM_STATUS, (e => this.handleInjectStreamServerStatus(e))), this.connection.on(ZT.REQUEST_NEW_ADDRESS, ((t, n) => { if (!this.connection) return n(new Ch(Oh.UNEXPECTED_ERROR, "can not get new live streaming address list")); im(this, $T.REQUEST_WORKER_MANAGER_LIST, e).then((e => { this.uapResponse = e, t(e.addressList) })).catch(n) })), await this.connection.init(t.addressList), this.connection } handlePublishStreamServer(e) { const t = e.serverStatus && e.serverStatus.url || "empty_url", n = this.streamingTasks.get(t), i = e.reason; switch (e.code) { case eO.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN: case eO.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT: case eO.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE: case eO.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: { const i = new Ch(Oh.LIVE_STREAMING_CDN_ERROR, "", { code: e.code }); if (n) return Dh.error(i.toString()), this.onLiveStreamError && this.onLiveStreamError(t, i); if (!this.isStartingStreamingTask) return; this.statusError.set(t, i) } case eO.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: { const e = new Ch(Oh.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, i); return this.onLiveStreamWarning && this.onLiveStreamWarning(t, e) } case eO.LIVE_STREAM_RESPONSE_WORKER_LOST: case eO.LIVE_STREAM_RESPONSE_WORKER_QUIT: { var r; if (!this.connection) return; this.connection.tryNextAddress(); const t = Array.from(gS(r = this.streamingTasks).call(r)); for (const n of t) n.abortTask ? n.abortTask() : (Dh.warning("[".concat(this.spec.clientId, "] publish stream status code"), e.code, "try to republish", n.url), this.startLiveStreamingTask(n.url, n.mode, new Ch(Oh.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e.code })).then((() => { Dh.debug("[".concat(this.spec.clientId, "] republish live stream success"), n.url) })).catch((e => { Dh.error(e.toString()), this.onLiveStreamError && this.onLiveStreamError(n.url, e) }))); return } } } handleInjectStreamServerStatus(e) { const t = Number(e.uid), n = e.serverStatus && e.serverStatus.url; switch (e.code) { case 200: return void (this.onInjectStatusChange && this.onInjectStatusChange(KT.INJECT_STREAM_STATUS_START_SUCCESS, t, n)); case 451: return this.onInjectStatusChange && this.onInjectStatusChange(KT.INJECT_STREAM_STATUS_START_ALREADY_EXISTS, t, n), void this.streamingTasks.delete(n); case 453: return this.onInjectStatusChange && this.onInjectStatusChange(KT.INJECT_STREAM_STATUS_START_UNAUTHORIZED, t, n), void this.streamingTasks.delete(n); case 470: return this.onInjectStatusChange && this.onInjectStatusChange(KT.INJECT_STREAM_STATUS_BROKEN, t, n), void this.streamingTasks.delete(n); case 499: return this.onInjectStatusChange && this.onInjectStatusChange(KT.INJECT_STREAM_STATUS_START_TIMEOUT, t, n), void this.streamingTasks.delete(n); default: return void Dh.debug("inject stream server status", e) } } hasUrl(e) { return this.streamingTasks.has(e) } } class II { constructor() { hl(this, "destChannelMediaInfos", new Map), hl(this, "srcChannelMediaInfo", void 0) } setSrcChannelInfo(e) { CO(e), this.srcChannelMediaInfo = e } addDestChannelInfo(e) { CO(e), this.destChannelMediaInfos.set(e.channelName, e) } removeDestChannelInfo(e) { Zp(e), this.destChannelMediaInfos.delete(e) } getSrcChannelMediaInfo() { return this.srcChannelMediaInfo } getDestChannelMediaInfo() { return this.destChannelMediaInfos } } function fI(e) { if (!(e instanceof II)) return new Ch(Oh.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw(); const t = e.getSrcChannelMediaInfo(), n = e.getDestChannelMediaInfo(); return t ? 0 === n.size ? new Ch(Oh.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw() : void 0 : new Ch(Oh.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw() } class PI extends ph { constructor(e, t, n) { super(), hl(this, "ws", void 0), hl(this, "requestId", 1), hl(this, "heartBeatTimer", void 0), hl(this, "joinInfo", void 0), hl(this, "clientId", void 0), hl(this, "onOpen", (() => { this.emit("open"), this.startHeartBeatCheck() })), hl(this, "onClose", (e => { this.emit("close"), this.dispose() })), hl(this, "onMessage", (e => { const t = JSON.parse(e.data); if (!t || "serverResponse" !== t.command || !t.requestId) return t && "serverStatus" === t.command && t.serverStatus && t.serverStatus.command ? (this.emit("status", t.serverStatus), void this.emit(t.serverStatus.command, t.serverStatus)) : void 0; this.emit("req_".concat(t.requestId), t) })), this.joinInfo = e, this.clientId = t, this.ws = new Im("cross-channel-".concat(this.clientId), n), this.ws.on(HT.RECONNECTING, (() => { this.ws.reconnectMode = "retry", this.emit("reconnecting") })), this.ws.on(HT.CONNECTED, this.onOpen), this.ws.on(HT.ON_MESSAGE, this.onMessage), this.ws.on(HT.CLOSED, this.onClose) } isConnect() { return "connected" === this.ws.state } sendMessage(e) { const t = this.requestId++; return e.requestId = t, e.seq = t, this.ws.sendMessage(e), t } waitStatus(e) { return new Cd(((t, n) => { const i = window.setTimeout((() => { n(new Ch(Oh.TIMEOUT, "wait status timeout, status: ".concat(e))) }), 5e3); this.once(e, (r => { window.clearTimeout(i), r.state && 0 !== r.state ? n(new Ch(Oh.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e))) : t(void 0) })), this.once("dispose", (() => { window.clearTimeout(i), n(new Ch(Oh.WS_ABORT)) })) })) } async request(e) { if ("closed" === this.ws.state) throw new Ch(Oh.WS_DISCONNECT); const t = () => new Cd(((e, t) => { this.ws.once(HT.CLOSED, (() => t(new Ch(Oh.WS_ABORT)))), this.ws.once(HT.CONNECTED, e) })); "connected" !== this.ws.state && await t(); const n = this.sendMessage(e), i = new Cd(((e, t) => { const i = () => { t(new Ch(Oh.WS_ABORT)) }; this.ws.once(HT.RECONNECTING, i), this.ws.once(HT.CLOSED, i), this.once("req_".concat(n), e), Qg(3e3).then((() => { this.removeAllListeners("req_".concat(n)), this.ws.off(HT.RECONNECTING, i), this.ws.off(HT.CLOSED, i), t(new Ch(Oh.TIMEOUT, "cross channel ws request timeout")) })) })), r = await i; if (!r || 200 !== r.code) throw new Ch(Oh.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(r))); return r } async connect(e) { this.ws.removeAllListeners(HT.REQUEST_NEW_URLS), this.ws.on(HT.REQUEST_NEW_URLS, (t => { t(e) })), await this.ws.init(e) } dispose() { this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close() } sendPing(e) { const t = this.requestId++; return e.requestId = t, this.ws.sendMessage(e), t } startHeartBeatCheck() { this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval((() => { this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +new Date, requestId: 0 }) }), 3e3) } clearHeartBeatCheck() { window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0 } } class NI extends ph { set state(e) { e !== this._state && (e !== rO.RELAY_STATE_FAILURE && (this.errorCode = oO.RELAY_OK), this.emit("state", e, this.errorCode), this._state = e) } get state() { return this._state } constructor(e, t, n, i, r) { super(), hl(this, "joinInfo", void 0), hl(this, "sid", void 0), hl(this, "clientId", void 0), hl(this, "cancelToken", Rh.CancelToken.source()), hl(this, "workerToken", void 0), hl(this, "requestId", 0), hl(this, "signal", void 0), hl(this, "prevChannelMediaConfig", void 0), hl(this, "httpRetryConfig", void 0), hl(this, "_resolution", void 0), hl(this, "_state", rO.RELAY_STATE_IDLE), hl(this, "errorCode", oO.RELAY_OK), hl(this, "onStatus", (e => { Dh.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e))), e && e.command && ("onAudioPacketReceived" === e.command && this.emit("event", iO.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e.command && this.emit("event", iO.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e.command && (this.errorCode = oO.SRC_TOKEN_EXPIRED, this.state = rO.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e.command && (this.errorCode = oO.DEST_TOKEN_EXPIRED, this.state = rO.RELAY_STATE_FAILURE)) })), hl(this, "onReconnect", (async () => { Dh.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", iO.NETWORK_DISCONNECTED), this.state = rO.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e => { this.state !== rO.RELAY_STATE_IDLE && (Dh.error("auto restart channel media relay failed", e.toString()), this.errorCode = oO.SERVER_CONNECTION_LOST, this.state = rO.RELAY_STATE_FAILURE) })) })), this.joinInfo = e, this.clientId = t, this.sid = $g(), this.signal = new PI(this.joinInfo, this.clientId, n), this.httpRetryConfig = i, this._resolution = r } async startChannelMediaRelay(e) { if (this.state !== rO.RELAY_STATE_IDLE) throw new Ch(Oh.INVALID_OPERATION); this.state = rO.RELAY_STATE_CONNECTING, await this.connect(), Dh.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success")); try { await this.sendStartRelayMessage(e) } catch (e) { if (e.data && e.data.serverResponse && "SetSourceChannel" === e.data.serverResponse.command) throw new Ch(Oh.CROSS_CHANNEL_FAILED_JOIN_SRC); if (e.data && e.data.serverResponse && "SetDestChannelStatus" === e.serverResponse.command) throw new Ch(Oh.CROSS_CHANNEL_FAILED_JOIN_DEST); if (e.data && e.data.serverResponse && "StartPacketTransfer" === e.serverResponse.command) throw new Ch(Oh.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST); throw e } this.prevChannelMediaConfig = e } async updateChannelMediaRelay(e) { if (this.state !== rO.RELAY_STATE_RUNNING) throw new Ch(Oh.INVALID_OPERATION); await this.sendUpdateMessage(e), this.prevChannelMediaConfig = e } async setVideoProfile(e) { if (this._resolution = e, this.state !== rO.RELAY_STATE_RUNNING) throw new Ch(Oh.INVALID_OPERATION); const t = this.genMessage(nO.SetVideoProfile); await this.signal.request(t), Dh.debug("[".concat(this.clientId, "] startChannelMediaRelay: setVideoProfile success")) } async stopChannelMediaRelay() { await this.sendStopRelayMessage(), Dh.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = rO.RELAY_STATE_IDLE, this.dispose() } dispose() { Dh.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = Rh.CancelToken.source(), this.state = rO.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0 } async connect() { const e = await lI(this.joinInfo, this.cancelToken.token, this.httpRetryConfig); this.workerToken = e.workerToken, await this.signal.connect(e.addressList), this.emit("event", iO.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect) } async sendStartRelayMessage(e) { const t = this.genMessage(nO.StopPacketTransfer); await this.signal.request(t), await this.signal.waitStatus("Normal Quit"), Dh.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success")); const n = this.genMessage(nO.SetSdkProfile, e); await this.signal.request(n), Dh.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success")); const i = this.genMessage(nO.SetSourceChannel, e); await this.signal.request(i), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", iO.PACKET_JOINED_SRC_CHANNEL), Dh.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success")); const r = this.genMessage(nO.SetSourceUserId, e); await this.signal.request(r), Dh.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success")); const o = this.genMessage(nO.SetDestChannel, e); await this.signal.request(o), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", iO.PACKET_JOINED_DEST_CHANNEL), Dh.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success")); const s = this.genMessage(nO.StartPacketTransfer, e); await this.signal.request(s), this.emit("event", iO.PACKET_SENT_TO_DEST_CHANNEL), this.state = rO.RELAY_STATE_RUNNING, Dh.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success")), this.setVideoProfile(this._resolution) } async sendUpdateMessage(e) { const t = this.genMessage(nO.UpdateDestChannel, e); await this.signal.request(t), this.emit("event", iO.PACKET_UPDATE_DEST_CHANNEL), Dh.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success")) } async sendStopRelayMessage() { const e = this.genMessage(nO.StopPacketTransfer); await this.signal.request(e), Dh.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success")) } genMessage(e, t) { const n = [], i = [], r = []; this.requestId += 1; const o = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: yh, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: !0, clientRequest: {} }; "4.18.2" === o.sdkVersion && (o.sdkVersion = "0.0.1"); let s = null, a = null; switch (e) { case nO.SetSdkProfile: return o.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, o; case nO.SetSourceChannel: if (a = t && t.getSrcChannelMediaInfo(), !a) throw new Ch(Oh.UNEXPECTED_ERROR, "can not find source config"); return o.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a.channelName, token: a.token || this.joinInfo.appId }, o; case nO.SetSourceUserId: if (a = t && t.getSrcChannelMediaInfo(), !a) throw new Ch(Oh.UNEXPECTED_ERROR, "can not find source config"); return o.clientRequest = { command: "SetSourceUserId", uid: a.uid + "" }, o; case nO.SetDestChannel: if (s = t && t.getDestChannelMediaInfo(), !s) throw new Ch(Oh.UNEXPECTED_ERROR, "can not find dest config"); return s.forEach((e => { n.push(e.channelName), i.push(e.uid + ""), r.push(e.token || this.joinInfo.appId) })), o.clientRequest = { command: "SetDestChannel", channelName: n, uid: i, token: r }, o; case nO.StartPacketTransfer: return o.clientRequest = { command: "StartPacketTransfer" }, o; case nO.Reconnect: return o.clientRequest = { command: "Reconnect" }, o; case nO.StopPacketTransfer: return o.clientRequest = { command: "StopPacketTransfer" }, o; case nO.UpdateDestChannel: if (s = t && t.getDestChannelMediaInfo(), !s) throw new Ch(Oh.UNEXPECTED_ERROR, "can not find dest config"); return s.forEach((e => { n.push(e.channelName), i.push(e.uid + ""), r.push(e.token || this.joinInfo.appId) })), o.clientRequest = { command: "UpdateDestChannel", channelName: n, uid: i, token: r }, o; case nO.SetVideoProfile: o.clientRequest = { command: "SetVideoProfile", width: this._resolution.width, height: this._resolution.height } }return o } } const DI = e => { const t = document.createElement("canvas"); return t.width = 2, t.height = 2, new Cd(((n, i) => { t.toBlob((async e => { if (t.remove(), e) { const i = await vI(e); n({ buffer: i, width: t.width, height: t.height }) } else i(new Ch(Oh.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED)) }), e, 1) })) }, vI = async e => { const t = await e.arrayBuffer(); return new Uint8Array(t) }; function yI(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function LI(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? yI(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yI(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class wI { get videoElementStatus() { return this._videoElementStatus } set videoElementStatus(e) { e !== this._videoElementStatus && (Dh.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e)), this._videoElementStatus = e) } constructor(e) { hl(this, "trackId", void 0), hl(this, "config", void 0), hl(this, "onFirstVideoFrameDecoded", void 0), hl(this, "freezeTimeCounterList", []), hl(this, "renderFreezeAccTime", 0), hl(this, "isKeepLastFrame", !1), hl(this, "timeUpdatedCount", 0), hl(this, "freezeTime", 0), hl(this, "playbackTime", 0), hl(this, "lastTimeUpdatedTime", 0), hl(this, "autoplayFailed", !1), hl(this, "videoTrack", void 0), hl(this, "videoElement", void 0), hl(this, "cacheVideoElement", void 0), hl(this, "videoElementCheckInterval", void 0), hl(this, "_videoElementStatus", sT.NONE), hl(this, "isGettingVideoDimensions", !1), hl(this, "startGetVideoDimensions", (() => { const e = () => { if (this.isGettingVideoDimensions = !0, this.videoElement.videoWidth * this.videoElement.videoHeight > 4) return Dh.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = !1); setTimeout(e, 500) }; !this.isGettingVideoDimensions && e() })), hl(this, "autoResumeAfterInterruption", (() => { this.videoTrack && "live" === this.videoTrack.readyState && "running" === GA.curState && (Dh.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(Yu())), tl() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play())) })), hl(this, "handleVideoEvents", (e => { switch (e.type) { case "play": case "playing": this.startGetVideoDimensions(), this.videoElementStatus = sT.PLAYING; break; case "loadeddata": if (this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) { try { this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove() } catch (e) { } this.cacheVideoElement = void 0 } break; case "canplay": this.videoElementStatus = sT.CANPLAY; break; case "stalled": this.videoElementStatus = sT.STALLED; break; case "suspend": this.videoElementStatus = sT.SUSPEND; break; case "pause": this.videoElementStatus = sT.PAUSED, Ju() || nl() || Wu() && this.autoplayFailed || !this.videoTrack || "live" !== this.videoTrack.readyState || (Dh.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play()); break; case "waiting": this.videoElementStatus = sT.WAITING; break; case "abort": this.videoElementStatus = sT.ABORT; break; case "ended": this.videoElementStatus = sT.ENDED; break; case "emptied": this.videoElementStatus = sT.EMPTIED; break; case "error": { this.videoElementStatus = sT.ERROR; const e = this.videoElement.error; e && Dh.error("[".concat(this.trackId, "] media error, code: ").concat(e.code, ", message: ").concat(e.message)); break } case "timeupdate": { const e = performance.now(); if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10) return void (this.lastTimeUpdatedTime = e); const t = e - this.lastTimeUpdatedTime, n = this.lastTimeUpdatedTime; if (this.lastTimeUpdatedTime = e, Mg.lastVisibleTime < Mg.lastHiddenTime || n < Mg.lastHiddenTime || n < Mg.lastVisibleTime) return; for (t > jh("VIDEO_FREEZE_DURATION") && (this.freezeTime += t), this.playbackTime += t; this.playbackTime >= 6e3;) { this.playbackTime -= 6e3; const e = Math.min(6e3, this.freezeTime); this.freezeTimeCounterList.push(e), this.freezeTime = Math.max(0, this.freezeTime - 6e3) } break } } })), hl(this, "autoResumeAfterInterruptionOnIOS15_16", (() => { this.videoTrack && "live" === this.videoTrack.readyState && (Dh.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(Yu())), tl() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play())) })), this.trackId = e.trackId, this.config = e, e.element instanceof HTMLVideoElement ? this.videoElement = e.element : this.videoElement = document.createElement("video"), GA.on(UA.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), GA.on(UA.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16) } getVideoElement() { return this.videoElement } getContainerElement() { var e; return null !== (e = this.videoElement.parentElement) && void 0 !== e ? e : void 0 } updateConfig(e) { this.config = e, this.trackId = e.trackId, e.element !== this.videoElement && (this.destroy(), this.videoElement = e.element), this.videoTrack && this.initVideoElement() } updateVideoTrack(e) { this.videoTrack !== e && (this.videoTrack = e, this.initVideoElement()) } play(e) { const t = this.videoElement.play(); t && t.catch && t.catch((t => { e && wA.autoplayFailed(e, "video", t.message, this.trackId), "NotAllowedError" === t.name ? (Dh.warning("detected video element autoplay failed", t), this.autoplayFailed = !0, this.handleAutoPlayFailed()) : Dh.warning("[".concat(this.trackId, "] play warning: "), t) })); const n = xu(); if (("Safari" === n.name && 15 === Number(n.version) || $u()) && t && t.then && t.catch) { const e = () => { this.config.mirror && (this.videoElement.style.transform = "rotateY(180deg)") }; t.then(e).catch(e) } } getCurrentFrame() { const e = document.createElement("canvas"); e.width = this.videoElement.videoWidth, e.height = this.videoElement.videoHeight; const t = e.getContext("2d"); if (!t) return Dh.error("create canvas context failed!"), new ImageData(2, 2); t.drawImage(this.videoElement, 0, 0, e.width, e.height); const n = t.getImageData(0, 0, e.width, e.height); return e.remove(), n } async getCurrentFrameToUint8Array(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1; const n = document.createElement("canvas"); n.width = this.videoElement.videoWidth, n.height = this.videoElement.videoHeight; const i = n.getContext("2d"); return i ? (i.drawImage(this.videoElement, 0, 0, n.width, n.height), new Cd(((i, r) => { n.toBlob((async e => { if (n.remove(), e) { const t = await vI(e); i({ buffer: t, width: n.width, height: n.height }) } else r(new Ch(Oh.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED)) }), e, t < 0 ? .1 : t > 1 ? 1 : t) }))) : await DI(e) } destroy() { GA.off(UA.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), GA.off(UA.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [] } initVideoElement() { if (this.videoElementStatus = sT.INIT, !this.videoElementCheckInterval && (bI.forEach((e => { this.videoElement.addEventListener(e, this.handleVideoEvents) })), this.videoElementCheckInterval = window.setInterval((() => { (function (e) { return e !== document.body && document.body.contains(e) })(this.videoElement) || (this.videoElementStatus = sT.DESTROYED) }), 1e3), jh("ENABLE_VIDEO_FRAME_CALLBACK"))) { var e, t; let n; const i = (e, t) => { if (this.videoElementStatus === sT.PLAYING) { if (n) { const e = t.presentationTime - n.presentationTime; e > jh("VIDEO_FREEZE_DURATION") && Mg.lastVisibleTime >= Mg.lastHiddenTime && n.timestamp > Mg.lastVisibleTime && n.timestamp > Mg.lastHiddenTime && (this.renderFreezeAccTime += e) } n = LI(LI({}, t), {}, { timestamp: e }) } var r, o; jh("ENABLE_VIDEO_FRAME_CALLBACK") && (null === (r = (o = this.videoElement).requestVideoFrameCallback) || void 0 === r || r.call(o, i)) }; null === (e = (t = this.videoElement).requestVideoFrameCallback) || void 0 === e || e.call(t, i) } this.videoElement.controls = !1, this.videoElement.setAttribute("playsinline", ""), sl() && (this.videoElement.poster = "noposter"); const n = xu(); "Safari" === n.name && 15 === Number(n.version) || $u() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = !0, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream ? this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Ku() && this.videoElement.load()) : (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Ku() && this.videoElement.load()); const i = this.videoElement.play(); void 0 !== i && i.catch((e => { Dh.debug("[".concat(this.trackId, "] playback interrupted"), e.toString()) })) } resetVideoElement() { bI.forEach((e => { this.videoElement && this.videoElement.removeEventListener(e, this.handleVideoEvents) })), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.videoElementStatus = sT.NONE } handleAutoPlayFailed() { const e = t => { t.preventDefault(), this.videoElement.play().then((() => { Dh.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed.")) })).catch((e => { Dh.error(e) })), this.autoplayFailed = !1, al() ? document.body.removeEventListener("click", e, !0) : (document.body.removeEventListener("touchstart", e, !0), document.body.removeEventListener("mousedown", e, !0)) }; al() ? document.body.addEventListener("click", e, !0) : (document.body.addEventListener("touchstart", e, !0), document.body.addEventListener("mousedown", e, !0)), fA() } } const bI = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"]; class UI extends wI { constructor(e) { super(e), hl(this, "container", void 0), hl(this, "slot", void 0), this.slot = e.element, this.updateConfig(e) } updateConfig(e) { this.config = e, this.trackId = e.trackId; const t = e.element; t !== this.slot && (this.destroy(), this.slot = t), this.createElements() } updateVideoTrack(e) { this.videoTrack !== e && (this.videoTrack = e, this.createElements()) } play(e) { var t; null !== (t = this.container) && void 0 !== t && t.contains(this.videoElement) && super.play(e) } getCurrentFrame() { var e; return null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2) } async getCurrentFrameToUint8Array(e) { var t; let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1; return null !== (t = this.container) && void 0 !== t && t.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e, n) : await DI(e) } destroy() { if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement("video"), this.container) { try { this.container.remove(), this.slot.removeChild(this.container) } catch (e) { } this.container = void 0 } } createElements() { this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", jh("KEEP_LAST_FRAME") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), this.slot.appendChild(this.container) } mountedVideoElement() { var e; !this.container || null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.style.left = "0", this.videoElement.style.top = "0" } unmountedVideoElement() { var e; if (null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement)) { super.resetVideoElement(); try { this.container && this.container.removeChild(this.videoElement) } catch (e) { } this.videoElement = document.createElement("video") } } resetVideoElement() { var e; null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement("video")) } getContainerElement() { return this.container } } function MI(e) { const t = {}; e.facingMode && (t.facingMode = e.facingMode), e.cameraId && (t.deviceId = { exact: e.cameraId }); const n = Vh(e.encoderConfig); return t.width = n.width, t.height = n.height, !rl() && n.frameRate && (t.frameRate = n.frameRate), xu().name === Lu.EDGE && "object" == typeof t.frameRate && (t.frameRate.max = 60), Ku() && (t.frameRate = { ideal: 30, max: 30 }), t } function kI(e) { const t = {}; e.screenSourceType && (t.mediaSource = e.screenSourceType), e.extensionId && Hu() && (t.extensionId = e.extensionId); const { displaySurface: n, selfBrowserSurface: i, surfaceSwitching: r, systemAudio: o } = e; (Xu(107) || qu(107) || Qu(93)) && (n && (Jp(n, "displaySurface", ["browser", "window", "monitor"]), t.displaySurface = n), i ? (Jp(i, "selfBrowserSurface", ["exclude", "include"]), t.selfBrowserSurface = i) : t.selfBrowserSurface = "include", r && (Jp(r, "surfaceSwitching", ["exclude", "include"]), t.surfaceSwitching = r)), (Xu(105) || qu(105) || Qu(91)) && o && (Jp(o, "systemAudio", ["exclude", "include"]), t.systemAudio = o), e.electronScreenSourceId && (t.sourceId = e.electronScreenSourceId); const s = e.encoderConfig ? xh(e.encoderConfig) : null; return t.mandatory = { chromeMediaSource: "desktop", maxWidth: s ? s.width : void 0, maxHeight: s ? s.height : void 0 }, s && (s.frameRate && ("number" == typeof s.frameRate ? (t.mandatory.maxFrameRate = s.frameRate, t.mandatory.minFrameRate = s.frameRate) : (t.mandatory.maxFrameRate = s.frameRate.max || s.frameRate.ideal || s.frameRate.exact || void 0, t.mandatory.minFrameRate = s.frameRate.min || s.frameRate.ideal || s.frameRate.exact || void 0), t.frameRate = s.frameRate), s.width && (t.width = s.width), s.height && (t.height = s.height)), t } function VI(e) { const t = {}; if (rl() || (void 0 !== e.AGC && (t.autoGainControl = e.AGC), void 0 !== e.AEC && (t.echoCancellation = e.AEC), void 0 !== e.ANS && (t.noiseSuppression = e.ANS, Hu() && e.ANS && (t.googHighpassFilter = e.ANS))), e.encoderConfig) { const n = Bh(e.encoderConfig); t.channelCount = n.stereo ? 2 : 1, t.sampleRate = n.sampleRate, t.sampleSize = n.sampleSize } return e.microphoneId && (t.deviceId = { exact: e.microphoneId }), sl() && (t.sampleRate = void 0), t } var xI, FI; !function (e) { e.COVERED = "COVERED", e.POSITION = "POSITION", e.SIZE = "SIZE", e.STYLE = "STYLE" }(xI || (xI = {})), function (e) { e.UNMOUNTED = "UNMOUNTED", e.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT" }(FI || (FI = {})); var YI, BI, GI, jI, HI, WI, KI, JI, XI, qI, QI, zI, ZI, $I, ef, tf, nf, rf, of, sf, af, cf, Ef, _f, df, uf, lf, Rf, hf, pf, Tf, Of, Cf, Af, Sf = new class { constructor() { hl(this, "_clientSize", null), hl(this, "getClientWidth", (() => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth)), hl(this, "getClientHeight", (() => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight)), hl(this, "getStyle", (e => window.getComputedStyle(e, null))), hl(this, "checkCssVisibleProperty", (e => { let t = !0; const n = this.getStyle(e), { display: i, visibility: r, opacity: o, filter: s } = n; return ("none" === i || ["hidden", "collapse"].includes(r) || Number(o) < .1) && (t = !1), !!t && (s && s.split(" ").filter((e => { const t = e.split("(")[0]; return ["brightness", "blur", "opacity"].includes(t) })).map((e => { const [t, n] = e.split(/\(|\)/); return [t, Number(n.match(/^[0-9\.]+/))] })).forEach((e => { const [n, i] = e; switch (n) { case "brightness": (i < .1 || i > 3) && (t = !1); break; case "blur": i > 3 && (t = !1); break; case "opacity": i < .1 && (t = !1) } })), t) })), hl(this, "checkPropertyUpToAllParentNodes", ((e, t) => { let n = !0, i = !0; const r = e => t(e); let o = e; for (; o && i;)r(o) || (n = !1, i = !1), o = o.parentElement, o || (i = !1); return n })), hl(this, "checkActualCssVisibleIncludeInherit", (e => this.checkPropertyUpToAllParentNodes(e, this.checkCssVisibleProperty))), hl(this, "getSizeAboutClient", (e => { const { width: t, height: n, left: i, right: r, top: o, bottom: s } = e.getBoundingClientRect(), a = this.getClientWidth(), c = this.getClientHeight(); return { width: t, height: n, left: i, right: r, top: o, bottom: s, clientWidth: a, clientHeight: c, clientMin: Math.min(a, c) } })), hl(this, "checkActualSize", (() => { const { width: e, height: t, clientMin: n } = this._clientSize; return this.checkSizeIsVisible(e, t, n) })), hl(this, "elementFromPoint", ((e, t) => document.elementFromPoint ? document.elementFromPoint(e, t) : null)), hl(this, "checkCoverForAPoint", ((e, t, n) => { const i = this.elementFromPoint(e, t); return null !== i && i !== n })), hl(this, "getPointPositionList", (() => { const { width: e, height: t, left: n, top: i } = this._clientSize, r = e / 6, o = t / 6, s = [], a = 10 ** 6; for (let c = 0; c < 5; c++)for (let e = 0; e < 5; e++) { const t = (n * a + (0 === c ? .1 : 4 === c ? (r * c * a - 1e5) / a : r * c) * a) / a, E = (i * a + (0 === e ? .1 : 4 === e ? (o * e * a - 1e5) / a : o * e) * a) / a; s.push({ x: t, y: E }) } return [...s] })), hl(this, "checkElementCover", (e => this.getPointPositionList().map((t => this.checkCoverForAPoint(t.x, t.y, e))).filter((e => !!e)).length > 6)), hl(this, "checkSizeIsVisible", ((e, t, n) => (e > 50 || n / e <= 10) && (t > 50 || n / t <= 10))), hl(this, "checkSizeOfPartInClient", (() => { const { left: e, right: t, top: n, bottom: i, clientHeight: r, clientWidth: o, clientMin: s } = this._clientSize; let a, c, E, _; if (e < 0) a = 0; else { if (!(e < o)) return !1; a = e } if (t < 0) return !1; if (c = t < o ? t : o, n < 0) E = 0; else { if (!(n < r)) return !1; E = n } if (i < 0) return !1; _ = i < r ? i : r; const d = c - a, u = _ - E; return this.checkSizeIsVisible(d, u, s) })), hl(this, "returnHiddenResult", (e => (this._clientSize = null, { visible: !1, reason: e }))), hl(this, "checkOneElementVisible", (e => { if (e instanceof HTMLElement) { if (this.checkElementIsMountedOnDom(e)) { if (this.checkActualCssVisibleIncludeInherit(e)) { if (this._clientSize = this.getSizeAboutClient(e), this.checkElementCover(e)) return this.returnHiddenResult(xI.COVERED); { const e = this.checkActualSize(), t = this.checkSizeOfPartInClient(); return e && !t ? this.returnHiddenResult(xI.POSITION) : e ? (this._clientSize = null, { visible: !0 }) : this.returnHiddenResult(xI.SIZE) } } return this.returnHiddenResult(xI.STYLE) } return this.returnHiddenResult(FI.UNMOUNTED) } return this.returnHiddenResult(FI.INVALID_HTML_ELEMENT) })), hl(this, "checkElementIsMountedOnDom", (e => this.checkPropertyUpToAllParentNodes(e, (e => "HTML" !== e.nodeName.toUpperCase() ? null !== e.parentElement : !!document.documentElement)))) } }; function gf(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function mf(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? gf(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gf(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } let If = (YI = LA({ argsMap: (e, t, n) => [e.getTrackId(), "string" == typeof t ? t : t instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", n] }), BI = RS(), GI = LA({ argsMap: e => [e.getTrackId()] }), jI = VA("LocalVideoTrack", "_enabledMutex"), HI = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), WI = RS(), KI = VA("LocalVideoTrack", "_enabledMutex"), JI = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), XI = RS(), qI = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), QI = RS(), zI = RS(), ZI = LA({ argsMap: (e, t, n) => [e.getTrackId(), t, n] }), $I = RS(), ef = RS(), tf = RS(), nf = RS(), rf = RS(), of = RS(), sf = RS(), af = LA({ argsMap: (e, t) => [e.getTrackId(), t.name] }), cf = LA({ argsMap: e => [e.getTrackId()] }), Ef = LA({ argsMap: e => [e.getTrackId()] }), _f = LA({ argsMap: (e, t, n) => [e.getTrackId(), t.label, n] }), aA((df = class e extends xA { get isPlaying() { return !(!this._player || this._player.videoElementStatus !== sT.PLAYING) } get processorContext() { return this._processorContext } set processorContext(e) { this._processorContext = e } get __className__() { return "LocalVideoTrack" } constructor(e, t, n, i, r, o) { if (super(e, r), hl(this, "trackMediaType", "video"), hl(this, "_player", void 0), hl(this, "_videoVisibleTimer", null), hl(this, "_previousVideoVisibleStatus", void 0), hl(this, "_clearPreviousVideoVisibleStatus", (() => this._previousVideoVisibleStatus = void 0)), hl(this, "_encoderConfig", void 0), hl(this, "_scalabiltyMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), hl(this, "_optimizationMode", void 0), hl(this, "_videoHeight", void 0), hl(this, "_videoWidth", void 0), hl(this, "_forceBitrateLimit", void 0), hl(this, "_enabled", !0), hl(this, "processorDestination", void 0), hl(this, "_processorContext", void 0), Wu()) { const { width: t, height: n } = e.getSettings(); this._videoWidth = t, this._videoHeight = n } else this.updateMediaStreamTrackResolution(); this._encoderConfig = t, this._scalabiltyMode = n, this._optimizationMode = i, this._hints = o || [], -1 === this._hints.indexOf(dO.SCREEN_TRACK) && this.updateBitrateFromProfile(), t && -1 !== this._hints.indexOf(dO.CUSTOM_TRACK) && this.setEncoderConfiguration(t), this.processorContext = new PS(this.getTrackId(), "local"), this.processorDestination = new fS(this.processorContext), this.bindProcessorDestinationEvents() } play(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if ("string" == typeof e) { const t = document.getElementById(e); t ? e = t : (Dh.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e, '" element, use document.body')), e = document.body) } Dh.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t)); const n = mf(mf(mf({}, this._getDefaultPlayerConfig()), t), {}, { trackId: this.getTrackId(), element: e }); this._player ? this._player.updateConfig(n) : (e instanceof HTMLVideoElement ? this._player = new wI(n) : this._player = new UI(n), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval((() => { try { const e = this.getVideoElementVisibleStatus(); this.safeEmit(pO.VIDEO_ELEMENT_VISIBLE_STATUS, e) } catch (e) { } }), jh("CHECK_VIDEO_VISIBLE_INTERVAL")) } stop() { this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, Dh.debug("[".concat(this.getTrackId(), "] stop video playback"))) } async setEnabled(e, t) { if (!t) { if (e === this._enabled) return; this.stateCheck("enabled", e) } if (Dh.info("[".concat(this.getTrackId(), "] start setEnabled"), e), !e) { this._originMediaStreamTrack.enabled = !1; try { await rm(this, _O.NEED_DISABLE_TRACK, this) } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e.toString()), e } return t || (this._enabled = !1), void Dh.info("[".concat(this.getTrackId(), "] setEnabled to false success")) } this._originMediaStreamTrack.enabled = !0; try { await rm(this, _O.NEED_ENABLE_TRACK, this) } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e.toString()), e } Dh.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t || (this._enabled = !0) } async setMuted(e) { e !== this._muted && (this.stateCheck("muted", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, Dh.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e)), e ? await rm(this, _O.NEED_MUTE_TRACK, this) : await rm(this, _O.NEED_UNMUTE_TRACK, this)) } async setEncoderConfiguration(e, t) { if (!this._enabled) throw new Ch(Oh.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled"); if (e = Vh(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e.bitrateMin), e.width || e.height || e.frameRate) { const t = MI({ encoderConfig: e }); (Wu() || Ju() || nl()) && (t.deviceId = void 0), Dh.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e), JSON.stringify(t)); try { await this._originMediaStreamTrack.applyConstraints(t), this.updateMediaStreamTrackResolution() } catch (e) { const t = new Ch(Oh.UNEXPECTED_ERROR, e.toString()); throw Dh.error("[".concat(this.getTrackId(), "] applyConstraints error"), t.toString()), t } } this._encoderConfig = e, -1 === this._hints.indexOf(dO.SCREEN_TRACK) && this.updateBitrateFromProfile(); try { await rm(this, _O.NEED_UPDATE_VIDEO_ENCODER, this) } catch (e) { return e.throw() } } getStats() { return um((() => { Dh.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead") }), "localVideoTrackGetStatsWarning"), om(this, _O.GET_STATS) || mf({}, YT) } async setBeautyEffect(e) { Dh.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect") } getCurrentFrameData() { return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2) } async getCurrentFrameImage(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1; return this._player ? this._player.getCurrentFrameToUint8Array(e, t) : await DI(e) } clone(t, n, i, r) { const o = this._mediaStreamTrack.clone(); return new e(o, t, n, i, r) } async setBitrateLimit(e) { if (Dh.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e))), e) { this._forceBitrateLimit = e, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e.max_bitrate ? this._encoderConfig.bitrateMax : e.max_bitrate : this._encoderConfig.bitrateMax = e.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e.min_bitrate); try { await rm(this, _O.NEED_UPDATE_VIDEO_ENCODER, this) } catch (e) { return e.throw() } } } async setOptimizationMode(e) { if ("motion" !== e && "detail" !== e && "balanced" !== e) return void Dh.error(Oh.INVALID_PARAMS, "optimization mode must be motion, detail or balanced"); const t = this._optimizationMode; try { this._optimizationMode = e, await rm(this, _O.SET_OPTIMIZATION_MODE, this) } catch (e) { throw this._optimizationMode = t, Dh.error("[".concat(this.getTrackId(), "] set optimization mode failed"), e.toString()), e } Dh.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e, ")")) } setScalabiltyMode(e) { if (1 === e.numSpatialLayers && 1 !== e.numTemporalLayers) return Dh.error(Oh.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabiltyMode = { numSpatialLayers: 1, numTemporalLayers: 1 }); this._scalabiltyMode = e, Dh.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e, ")")) } updateMediaStreamTrackResolution() { tm(this._originMediaStreamTrack).then((e => { let [t, n] = e; this._videoHeight = n, this._videoWidth = t })).catch(em) } _updatePlayerSource() { this._player && this._player.updateVideoTrack(this._mediaStreamTrack) } _getDefaultPlayerConfig() { return { fit: "contain" } } updateBitrateFromProfile() { if (!this._encoderConfig) return; const { width: e, height: t, frameRate: n } = this.getMediaStreamTrackSettings(); if (!e || !t || !n) return; const [i, r] = function (e, t, n) { const i = jh("BITRATE_ADAPTER_TYPE"); let r; const o = 200 * Math.pow(n / 15, .6) * Math.pow(e * t / 640 / 360, .75), s = o; if ("STANDARD_BITRATE" === i) r = 4 * o; else { if ("COMPATIABLE_BITRATE" !== i) return; r = 2 * o } return [Math.floor(r), Math.floor(s)] }(e, t, n) || [void 0, void 0]; this._encoderConfig.bitrateMin || this._encoderConfig.bitrateMax || (this._encoderConfig.bitrateMin = r, this._encoderConfig.bitrateMax = i, Dh.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e, ", h: ").concat(t, ", fps: ").concat(n, "] => [brMax: ").concat(i, ", brMin: ").concat(r, "]"))) } getVideoElementVisibleStatus() { try { var e, t; const n = null == this || null === (e = this._player) || void 0 === e ? void 0 : e.getContainerElement(), i = { track: this, element: null == this || null === (t = this._player) || void 0 === t ? void 0 : t.getVideoElement(), slot: null == n ? void 0 : n.parentElement }, { element: r, slot: o } = i; if (this.isPlaying && r instanceof HTMLVideoElement && o instanceof HTMLElement) { const e = Sf.checkOneElementVisible(r), t = Object.assign({}, e); if (t.visible !== this._previousVideoVisibleStatus) { this._previousVideoVisibleStatus = t.visible; const e = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] }); t.visible ? e.onSuccess("Video is visible") : e.onSuccess("Invisible because of ".concat(t.reason)) } return t } return } catch (e) { throw new Ch(Oh.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message) } } async renewMediaStreamTrack(e) { } pipe(e) { if (this.processor === e) return e; if (e._source) throw new Ch(Oh.INVALID_OPERATION, "Processor ".concat(e.name, " already piped, please call unpipe beforehand.")); return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e } unpipe() { if (!this.processor) return; const e = this.processor; this.processor._source = void 0, this.processor = void 0, e.reset() } close() { super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe() } async replaceTrack(e, t) { if (!(e instanceof MediaStreamTrack)) throw new Ch(Oh.INVALID_PARAMS, "track should be an instance of MediaStreamTrack"); if ("video" !== e.kind) throw new Ch(Oh.INVALID_PARAMS, "track should be a video MediaStreamTrack"); await this._updateOriginMediaStreamTrack(e, t, !0), this.updateMediaStreamTrackResolution() } bindProcessorDestinationEvents() { this.processorDestination.on(UO.ON_TRACK, (async e => { e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(), await rm(this, _O.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rm(this, _O.NEED_REPLACE_TRACK, this)) })) } unbindProcessorDestinationEvents() { this.processorDestination.removeAllListeners(UO.ON_TRACK) } unbindProcessorContextEvents() { this.processorContext.removeAllListeners(MO.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(MO.REQUEST_CONSTRAINTS) } }).prototype, "play", [YI, BI], Object.getOwnPropertyDescriptor(df.prototype, "play"), df.prototype), aA(df.prototype, "stop", [GI], Object.getOwnPropertyDescriptor(df.prototype, "stop"), df.prototype), aA(df.prototype, "setEnabled", [jI, HI, WI], Object.getOwnPropertyDescriptor(df.prototype, "setEnabled"), df.prototype), aA(df.prototype, "setMuted", [KI, JI, XI], Object.getOwnPropertyDescriptor(df.prototype, "setMuted"), df.prototype), aA(df.prototype, "setEncoderConfiguration", [qI, QI], Object.getOwnPropertyDescriptor(df.prototype, "setEncoderConfiguration"), df.prototype), aA(df.prototype, "getStats", [zI], Object.getOwnPropertyDescriptor(df.prototype, "getStats"), df.prototype), aA(df.prototype, "setBeautyEffect", [ZI, $I], Object.getOwnPropertyDescriptor(df.prototype, "setBeautyEffect"), df.prototype), aA(df.prototype, "getCurrentFrameData", [ef], Object.getOwnPropertyDescriptor(df.prototype, "getCurrentFrameData"), df.prototype), aA(df.prototype, "getCurrentFrameImage", [tf], Object.getOwnPropertyDescriptor(df.prototype, "getCurrentFrameImage"), df.prototype), aA(df.prototype, "setBitrateLimit", [nf], Object.getOwnPropertyDescriptor(df.prototype, "setBitrateLimit"), df.prototype), aA(df.prototype, "setOptimizationMode", [rf], Object.getOwnPropertyDescriptor(df.prototype, "setOptimizationMode"), df.prototype), aA(df.prototype, "setScalabiltyMode", [of], Object.getOwnPropertyDescriptor(df.prototype, "setScalabiltyMode"), df.prototype), aA(df.prototype, "updateMediaStreamTrackResolution", [sf], Object.getOwnPropertyDescriptor(df.prototype, "updateMediaStreamTrackResolution"), df.prototype), aA(df.prototype, "pipe", [af], Object.getOwnPropertyDescriptor(df.prototype, "pipe"), df.prototype), aA(df.prototype, "unpipe", [cf], Object.getOwnPropertyDescriptor(df.prototype, "unpipe"), df.prototype), aA(df.prototype, "close", [Ef], Object.getOwnPropertyDescriptor(df.prototype, "close"), df.prototype), aA(df.prototype, "replaceTrack", [_f], Object.getOwnPropertyDescriptor(df.prototype, "replaceTrack"), df.prototype), df), ff = (uf = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), lf = RS(), Rf = VA("CameraVideoTrack", "_enabledMutex"), hf = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), pf = RS(), Tf = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), Of = RS(), Cf = LA({ argsMap: e => [e.getTrackId()] }), aA((Af = class extends If { get __className__() { return "CameraVideoTrack" } constructor(e, t, n, i, r, o) { super(e, Vh(t.encoderConfig), i, r, o), hl(this, "_config", void 0), hl(this, "_originalConstraints", void 0), hl(this, "_constraints", void 0), hl(this, "_enabled", !0), hl(this, "_deviceName", "default"), hl(this, "tryResumeVideoForIOS15_16WeChat", (async () => { ($u() || el()) && !function () { const e = xu(); if (e.os !== yu.IOS || !e.osVersion) return !1; const t = e.osVersion.split("."); return 15 === Number(t[0]) && Number(t[1]) >= 2 }() && il() && this._enabled && !this._isClosed && (Dh.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack()) })), this._config = t, this._originalConstraints = n, this._constraints = n, this._deviceName = e.label, this._encoderConfig = Vh(this._config.encoderConfig), GA.on(UA.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), GA.on(UA.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents() } async setDevice(e) { if (Dh.info("[".concat(this.getTrackId(), "] set device to ").concat(e)), this._enabled) try { const t = await dS.getDeviceById(e), n = {}; n.video = mf({}, this._constraints), n.video.deviceId = { exact: e }, n.video.facingMode = void 0, this._originMediaStreamTrack.stop(); let i = null; try { i = await aS(n, this.getTrackId()) } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setDevice failed"), e.toString()), i = await aS({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(i.getVideoTracks()[0], !1), e } await this._updateOriginMediaStreamTrack(i.getVideoTracks()[0], !1), this.updateMediaStreamTrackResolution(), this._deviceName = t.label, this._config.cameraId = e, this._constraints.deviceId = { exact: e } } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setDevice error"), e.toString()), e } else try { const t = await dS.getDeviceById(e); this._deviceName = t.label, this._config.cameraId = e, this._constraints.deviceId = { exact: e } } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setDevice error"), e.toString()), e } Dh.info("[".concat(this.getTrackId(), "] setDevice success")) } async setEnabled(e, t) { if (!t) { if (e === this._enabled) return; this.stateCheck("enabled", e) } if (Dh.info("[".concat(this.getTrackId(), "] start setEnabled"), e), e) { try { if (this.isExternalTrack) this._originMediaStreamTrack.enabled = !0; else { const e = await aS({ video: this._constraints }, this.getTrackId()); await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !1) } await rm(this, _O.NEED_ENABLE_TRACK, this) } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setEnabled true error"), e.toString()), e } this.updateMediaStreamTrackResolution(), Dh.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t || (this._enabled = !0) } else { this.isExternalTrack ? this._originMediaStreamTrack.enabled = !1 : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t || (this._enabled = !1); try { await rm(this, _O.NEED_DISABLE_TRACK, this) } catch (e) { throw Dh.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e.toString()), e } Dh.info("[".concat(this.getTrackId(), "] setEnabled to false success")) } } async setEncoderConfiguration(e, t) { if (!this._enabled) throw new Ch(Oh.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled"); e = Vh(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e.bitrateMin); const n = _m(this._config); n.encoderConfig = e; const i = MI(n); (Wu() || Ju() || nl()) && (i.deviceId = void 0), Dh.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e), JSON.stringify(i)); try { await this._originMediaStreamTrack.applyConstraints(i), this.updateMediaStreamTrackResolution() } catch (e) { const t = new Ch(Oh.UNEXPECTED_ERROR, e.toString()); throw Dh.error("[".concat(this.getTrackId(), "] applyConstraints error"), t.toString()), t } this._config = n, this._constraints = i, this._originalConstraints = i, this._encoderConfig = e, -1 === this._hints.indexOf(dO.SCREEN_TRACK) && this.updateBitrateFromProfile(); try { await rm(this, _O.NEED_UPDATE_VIDEO_ENCODER, this) } catch (e) { return e.throw() } } _getDefaultPlayerConfig() { return { mirror: !0, fit: "cover" } } onTrackEnded() { if ((Ju() || nl()) && this._enabled && !this._isClosed && GA.duringInterruption) { const e = async () => { GA.off(UA.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (Dh.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(!1), await this.setEnabled(!0)) }; GA.on(UA.IOS_INTERRUPTION_END, e) } else Dh.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(pO.TRACK_ENDED) } async renewMediaStreamTrack(e) { const t = e || this._constraints, n = dS.searchDeviceIdByName(this._deviceName); if (n && !t.deviceId && (t.deviceId = { exact: n }), this._enabled) { const e = await aS({ video: t }, this.getTrackId()); this._constraints = t, await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !0), this.updateMediaStreamTrackResolution() } } close() { super.close(), GA.off(UA.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), GA.off(UA.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat) } bindProcessorContextEvents() { this.processorContext.on(MO.REQUEST_UPDATE_CONSTRAINTS, (async (e, t, n) => { try { const n = Object.assign({}, this._originalConstraints, ...e); await this.renewMediaStreamTrack(n), t() } catch (e) { n(e) } })), this.processorContext.on(MO.REQUEST_CONSTRAINTS, (async e => { e(this._originMediaStreamTrack.getSettings()) })) } }).prototype, "setDevice", [uf, lf], Object.getOwnPropertyDescriptor(Af.prototype, "setDevice"), Af.prototype), aA(Af.prototype, "setEnabled", [Rf, hf, pf], Object.getOwnPropertyDescriptor(Af.prototype, "setEnabled"), Af.prototype), aA(Af.prototype, "setEncoderConfiguration", [Tf, Of], Object.getOwnPropertyDescriptor(Af.prototype, "setEncoderConfiguration"), Af.prototype), aA(Af.prototype, "close", [Cf], Object.getOwnPropertyDescriptor(Af.prototype, "close"), Af.prototype), Af); class Pf { get hasVideo() { return this._video_enabled_ && !this._video_muted_ && this._video_added_ } get hasAudio() { return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_ } get audioTrack() { if (this.hasAudio) return this._audioTrack } get videoTrack() { if (this.hasVideo) return this._videoTrack } constructor(e, t) { hl(this, "uid", void 0), hl(this, "_uintid", void 0), hl(this, "_trust_in_room_", !0), hl(this, "_trust_audio_enabled_state_", !0), hl(this, "_trust_video_enabled_state_", !0), hl(this, "_trust_audio_mute_state_", !0), hl(this, "_trust_video_mute_state_", !0), hl(this, "_audio_muted_", !1), hl(this, "_video_muted_", !1), hl(this, "_audio_enabled_", !0), hl(this, "_video_enabled_", !0), hl(this, "_audio_added_", !1), hl(this, "_video_added_", !1), hl(this, "_trust_video_stream_added_state_", !0), hl(this, "_trust_audio_stream_added_state_", !0), hl(this, "_audioTrack", void 0), hl(this, "_videoTrack", void 0), hl(this, "_audioSSRC", void 0), hl(this, "_videoSSRC", void 0), hl(this, "_audioOrtc", void 0), hl(this, "_videoOrtc", void 0), hl(this, "_cname", void 0), hl(this, "_rtxSsrcId", void 0), this.uid = e, this._uintid = t } } var Nf = Od, Df = RE, vf = gE; In({ target: "Promise", stat: !0 }, { try: function (e) { var t = Df.f(this), n = vf(e); return (n.error ? t.reject : t.resolve)(n.value), t.promise } }); var yf = Nf, Lf = In, wf = l, bf = i, Uf = zO, Mf = X, kf = Ye, Vf = Ln, xf = ip, Ff = oC, Yf = YC, Bf = ce, Gf = ot("isConcatSpreadable"), jf = 9007199254740991, Hf = "Maximum allowed index exceeded", Wf = wf.TypeError, Kf = Bf >= 51 || !bf((function () { var e = []; return e[Gf] = !1, e.concat()[0] !== e })), Jf = Yf("concat"), Xf = function (e) { if (!Mf(e)) return !1; var t = e[Gf]; return void 0 !== t ? !!t : Uf(e) }; Lf({ target: "Array", proto: !0, forced: !Kf || !Jf }, { concat: function (e) { var t, n, i, r, o, s = kf(this), a = Ff(s, 0), c = 0; for (t = -1, i = arguments.length; t < i; t++)if (Xf(o = -1 === t ? s : arguments[t])) { if (c + (r = Vf(o)) > jf) throw Wf(Hf); for (n = 0; n < r; n++, c++)n in o && xf(a, c, o[n]) } else { if (c >= jf) throw Wf(Hf); xf(a, c++, o) } return a.length = c, a } }); var qf = {}, Qf = M, zf = K, Zf = bi.f, $f = Ep, eP = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; qf.f = function (e) { return eP && "Window" == Qf(e) ? function (e) { try { return Zf(e) } catch (e) { return $f(eP) } }(e) : Zf(zf(e)) }; var tP = {}, nP = ot; tP.f = nP; var iP = q, rP = je, oP = tP, sP = Wt.f, aP = function (e) { var t = iP.Symbol || (iP.Symbol = {}); rP(t, e) || sP(t, e, { value: oP.f(e) }) }, cP = In, EP = l, _P = ee, dP = O, uP = I, lP = _, RP = S, hP = de, pP = i, TP = je, OP = zO, CP = C, AP = X, SP = d, gP = Oe, mP = zt, IP = Ye, fP = K, PP = pt, NP = Lo, DP = L, vP = br, yP = lr, LP = bi, wP = qf, bP = $i, UP = A, MP = Wt, kP = _r, VP = f, xP = Rc, FP = xs, YP = Le.exports, BP = ji, GP = Xe, jP = ot, HP = tP, WP = aP, KP = na, JP = ys, XP = lC.forEach, qP = Ri("hidden"), QP = "Symbol", zP = jP("toPrimitive"), ZP = JP.set, $P = JP.getterFor(QP), eN = Object.prototype, tN = EP.Symbol, nN = tN && tN.prototype, iN = EP.TypeError, rN = EP.QObject, oN = _P("JSON", "stringify"), sN = UP.f, aN = MP.f, cN = wP.f, EN = VP.f, _N = lP([].push), dN = YP("symbols"), uN = YP("op-symbols"), lN = YP("string-to-symbol-registry"), RN = YP("symbol-to-string-registry"), hN = YP("wks"), pN = !rN || !rN.prototype || !rN.prototype.findChild, TN = RP && pP((function () { return 7 != vP(aN({}, "a", { get: function () { return aN(this, "a", { value: 7 }).a } })).a })) ? function (e, t, n) { var i = sN(eN, t); i && delete eN[t], aN(e, t, n), i && e !== eN && aN(eN, t, i) } : aN, ON = function (e, t) { var n = dN[e] = vP(nN); return ZP(n, { type: QP, tag: e, description: t }), RP || (n.description = t), n }, CN = function (e, t, n) { e === eN && CN(uN, t, n), mP(e); var i = PP(t); return mP(n), TP(dN, i) ? (n.enumerable ? (TP(e, qP) && e[qP][i] && (e[qP][i] = !1), n = vP(n, { enumerable: DP(0, !1) })) : (TP(e, qP) || aN(e, qP, DP(1, {})), e[qP][i] = !0), TN(e, i, n)) : aN(e, i, n) }, AN = function (e, t) { mP(e); var n = fP(t), i = yP(n).concat(IN(n)); return XP(i, (function (t) { RP && !uP(SN, n, t) || CN(e, t, n[t]) })), e }, SN = function (e) { var t = PP(e), n = uP(EN, this, t); return !(this === eN && TP(dN, t) && !TP(uN, t)) && (!(n || !TP(this, t) || !TP(dN, t) || TP(this, qP) && this[qP][t]) || n) }, gN = function (e, t) { var n = fP(e), i = PP(t); if (n !== eN || !TP(dN, i) || TP(uN, i)) { var r = sN(n, i); return !r || !TP(dN, i) || TP(n, qP) && n[qP][i] || (r.enumerable = !0), r } }, mN = function (e) { var t = cN(fP(e)), n = []; return XP(t, (function (e) { TP(dN, e) || TP(BP, e) || _N(n, e) })), n }, IN = function (e) { var t = e === eN, n = cN(t ? uN : fP(e)), i = []; return XP(n, (function (e) { !TP(dN, e) || t && !TP(eN, e) || _N(i, dN[e]) })), i }; if (hP || (FP(nN = (tN = function () { if (SP(nN, this)) throw iN("Symbol is not a constructor"); var e = arguments.length && void 0 !== arguments[0] ? NP(arguments[0]) : void 0, t = GP(e), n = function (e) { this === eN && uP(n, uN, e), TP(this, qP) && TP(this[qP], t) && (this[qP][t] = !1), TN(this, t, DP(1, e)) }; return RP && pN && TN(eN, t, { configurable: !0, set: n }), ON(t, e) }).prototype, "toString", (function () { return $P(this).tag })), FP(tN, "withoutSetter", (function (e) { return ON(GP(e), e) })), VP.f = SN, MP.f = CN, kP.f = AN, UP.f = gN, LP.f = wP.f = mN, bP.f = IN, HP.f = function (e) { return ON(jP(e), e) }, RP && aN(nN, "description", { configurable: !0, get: function () { return $P(this).description } })), cP({ global: !0, wrap: !0, forced: !hP, sham: !hP }, { Symbol: tN }), XP(yP(hN), (function (e) { WP(e) })), cP({ target: QP, stat: !0, forced: !hP }, { for: function (e) { var t = NP(e); if (TP(lN, t)) return lN[t]; var n = tN(t); return lN[t] = n, RN[n] = t, n }, keyFor: function (e) { if (!gP(e)) throw iN(e + " is not a symbol"); if (TP(RN, e)) return RN[e] }, useSetter: function () { pN = !0 }, useSimple: function () { pN = !1 } }), cP({ target: "Object", stat: !0, forced: !hP, sham: !RP }, { create: function (e, t) { return void 0 === t ? vP(e) : AN(vP(e), t) }, defineProperty: CN, defineProperties: AN, getOwnPropertyDescriptor: gN }), cP({ target: "Object", stat: !0, forced: !hP }, { getOwnPropertyNames: mN, getOwnPropertySymbols: IN }), cP({ target: "Object", stat: !0, forced: pP((function () { bP.f(1) })) }, { getOwnPropertySymbols: function (e) { return bP.f(IP(e)) } }), oN && cP({ target: "JSON", stat: !0, forced: !hP || pP((function () { var e = tN(); return "[null]" != oN([e]) || "{}" != oN({ a: e }) || "{}" != oN(Object(e)) })) }, { stringify: function (e, t, n) { var i = xP(arguments), r = t; if ((AP(t) || void 0 !== e) && !gP(e)) return OP(t) || (t = function (e, t) { if (CP(r) && (t = uP(r, this, e, t)), !gP(t)) return t }), i[1] = t, dP(oN, null, i) } }), !nN[zP]) { var fN = nN.valueOf; FP(nN, zP, (function (e) { return uP(fN, this) })) } KP(tN, QP), BP[qP] = !0, aP("asyncIterator"), aP("hasInstance"), aP("isConcatSpreadable"), aP("iterator"), aP("match"), aP("matchAll"), aP("replace"), aP("search"), aP("species"), aP("split"), aP("toPrimitive"), aP("toStringTag"), aP("unscopables"), na(l.JSON, "JSON", !0); var PN = q.Symbol; aP("asyncDispose"), aP("dispose"), aP("matcher"), aP("metadata"), aP("observable"), aP("patternMatch"), aP("replaceAll"); var NN = PN, DN = tP.f("asyncIterator"), vN = DN; function yN(e) { this.wrapped = e } function LN(e) { var t, n; function i(t, n) { try { var o = e[t](n), s = o.value, a = s instanceof yN; yf.resolve(a ? s.wrapped : s).then((function (e) { a ? i("return" === t ? "return" : "next", e) : r(o.done ? "return" : "normal", e) }), (function (e) { i("throw", e) })) } catch (e) { r("throw", e) } } function r(e, r) { switch (e) { case "return": t.resolve({ value: r, done: !0 }); break; case "throw": t.reject(r); break; default: t.resolve({ value: r, done: !1 }) }(t = t.next) ? i(t.key, t.arg) : n = null } this._invoke = function (e, r) { return new yf((function (o, s) { var a = { key: e, arg: r, resolve: o, reject: s, next: null }; n ? n = n.next = a : (t = n = a, i(e, r)) })) }, "function" != typeof e.return && (this.return = void 0) } function wN(e) { return function () { return new LN(e.apply(this, arguments)) } } function bN(e) { return new yN(e) } LN.prototype["function" == typeof NN && vN || "@@asyncIterator"] = function () { return this }, LN.prototype.next = function (e) { return this._invoke("next", e) }, LN.prototype.throw = function (e) { return this._invoke("throw", e) }, LN.prototype.return = function (e) { return this._invoke("return", e) }; var UN = tP.f("iterator"); function MN(e, t) { var n = {}, i = !1; function r(n, r) { return i = !0, r = new yf((function (t) { t(e[n](r)) })), { done: !1, value: t(r) } } return n[void 0 !== NN && UN || "@@iterator"] = function () { return this }, n.next = function (e) { return i ? (i = !1, e) : r("next", e) }, "function" == typeof e.throw && (n.throw = function (e) { if (i) throw i = !1, e; return r("throw", e) }), "function" == typeof e.return && (n.return = function (e) { return i ? (i = !1, e) : r("return", e) }), n } var kN = DN, VN = { exports: {} }; function xN(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function FN(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? xN(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xN(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function YN(e, t, n, i, r, o, s) { let a = [], c = [], E = [], _ = [], d = !1, u = !1; if (VN.exports.parse(e).mediaDescriptions.forEach((e => { s && s !== e.attributes.direction || ("video" !== e.media.mediaType || d || (c = e.attributes.payloads, _ = e.attributes.extmaps, d = !0), "audio" !== e.media.mediaType || u || (a = e.attributes.payloads, E = e.attributes.extmaps, u = !0)) })), !_ || 0 === c.length) throw new Error("Cannot get video capabilities from SDP."); if (!E || 0 === a.length) throw new Error("Cannot get audio capabilities from SDP."); return c.forEach((e => { var t; null !== (t = e.rtpMap) && void 0 !== t && t.clockRate && (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate)) })), a.forEach((e => { var t; null !== (t = e.rtpMap) && void 0 !== t && t.clockRate && (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate)) })), t && (a = a.filter((e => { var t; return "rtx" !== (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) })), c = c.filter((e => { var t; return "rtx" !== (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) }))), n && (c = c.filter((e => { var t; return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName) || "") }))), i && (a = a.filter((e => { var t; return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName) || "") }))), r && (null == r ? void 0 : r.length) > 0 && (a = a.filter((e => { var t; return r.includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "") }))), o && (null == o ? void 0 : o.length) > 0 && (c = c.filter((e => { var t; return o.includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "") }))), { audioCodecs: a, videoCodecs: c, audioExtensions: E, videoExtensions: _ } } function BN(e) { const t = VN.exports.parse(e); let n, i; for (const r of t.mediaDescriptions) { if (!n) { const e = r.attributes.iceUfrag, t = r.attributes.icePwd; if (!e || !t) throw new Error("Cannot get iceUfrag or icePwd from SDP."); n = { iceUfrag: e, icePwd: t } } if (!i) { const e = r.attributes.fingerprints; e.length > 0 && (i = { fingerprints: e }) } } if (!i && t.attributes.fingerprints.length > 0 && (i = { fingerprints: t.attributes.fingerprints }), !i || !n) throw new Error("Cannot get iceParameters or dtlsParameters from SDP."); return { iceParameters: n, dtlsParameters: i } } function GN(e, t) { const n = [], i = e.attributes.ssrcGroups.filter((e => "FID" === e.semantic)), r = e.attributes.ssrcGroups.find((e => "SIM" === e.semantic)), o = e.attributes.ssrcs; if (r) r.ssrcIds.forEach((e => { var r; const o = null === (r = i.find((t => t.ssrcIds[0] === e))) || void 0 === r ? void 0 : r.ssrcIds[1]; n.push({ ssrcId: e, rtx: t ? o : void 0 }) })); else if (i.length > 0) { const e = i[0].ssrcIds[0], r = i[0].ssrcIds[1]; n.push({ ssrcId: e, rtx: t ? r : void 0 }) } else { if (0 === o.length) throw new Error("No ssrcs found on local media description."); n.push({ ssrcId: o[0].ssrcId }) } return n } function jN(e, t) { const { cname: n } = e; let i; t && t.ip && "number" == typeof t.port ? (i = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t.ip, port: t.port.toString(), type: "host", extension: {} }], Dh.debug("Using remote candidate from AP ".concat(t.ip, ":").concat(t.port)), t.ip6 && (i.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t.ip6, port: t.port.toString(), type: "host", extension: {} }), Dh.debug("Using IPV6 remote candidate from AP ".concat(t.ip6, ":").concat(t.port)))) : i = e.iceParameters.candidates.map((e => ({ foundation: e.foundation, componentId: "1", transport: e.protocol, priority: e.priority.toString(), connectionAddress: e.ip, port: e.port.toString(), type: e.type, extension: {} }))); const r = { fingerprints: e.dtlsParameters.fingerprints.map((e => ({ hashFunction: e.algorithm, fingerprint: e.fingerprint }))) }, o = { iceUfrag: e.iceParameters.iceUfrag, icePwd: e.iceParameters.icePwd }; let s; switch (e.dtlsParameters.role) { case "server": s = "passive"; break; case "client": s = "active"; break; case "auto": s = "actpass" }return { dtlsParameters: r, iceParameters: o, candidates: i, rtpCapabilities: $N(e.rtpCapabilities), setup: s, cname: n } } function HN(e, t, n) { const i = [], r = []; return e.forEach((e => { let { ssrcId: o, rtx: s } = e; const a = Zg(8, "track-"), c = { ssrcId: o, attributes: FN({ label: a, mslabel: n = n || Zg(10, ""), msid: "".concat(n, " ").concat(a) }, t && { cname: t }) }; if (i.push(c), void 0 !== s) { const e = { ssrcId: s, attributes: FN({ label: a, mslabel: n, msid: "".concat(n, " ").concat(a) }, t && { cname: t }) }; i.push(e), r.push({ semantic: "FID", ssrcIds: [o, s] }) } })), e.length > 1 && r.push({ semantic: "SIM", ssrcIds: e.map((e => { let { ssrcId: t } = e; return t })) }), { ssrcs: i, ssrcGroups: r } } function WN(e, t) { t instanceof fg && e.attributes.payloads.forEach((e => { var n; const i = null === (n = e.rtpMap) || void 0 === n ? void 0 : n.encodingName.toLowerCase(); if (!i || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(i)) return; e.fmtp || (e.fmtp = { parameters: {} }), e.fmtp.parameters.minptime = "10", e.fmtp.parameters.useinbandfec = "1"; const r = t._encoderConfig; r && "pcmu" !== i && "pcma" !== i && "g722" !== i && (r.bitrate && !Ku() && (e.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * r.bitrate))), r.sampleRate && (e.fmtp.parameters.maxplaybackrate = "".concat(r.sampleRate), e.fmtp.parameters["sprop-maxcapturerate"] = "".concat(r.sampleRate)), r.stereo && (e.fmtp.parameters.stereo = "1", e.fmtp.parameters["sprop-stereo"] = "1")) })) } function KN(e) { const t = e.attributes.unrecognized.findIndex((e => "x-google-flag" === e.attField && "conference" === e.attValue)); -1 !== t && e.attributes.unrecognized.splice(t, 1) } function JN(e, t) { if (!(t instanceof If && t._encoderConfig && -1 === t._hints.indexOf(dO.SCREEN_TRACK))) return; const n = t._encoderConfig; XO().supportMinBitrate && n.bitrateMin && e.attributes.payloads.forEach((e => { var t;["h264", "h265", "vp8", "vp9", "av1"].includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "") && (e.fmtp || (e.fmtp = { parameters: {} }), e.fmtp.parameters["x-google-min-bitrate"] = "".concat(n.bitrateMin)) })), XO().supportMinBitrate && !t._hints.includes(dO.LOW_STREAM) && n.bitrateMax && e.attributes.payloads.forEach((e => { var t;["h264", "h265", "vp8", "vp9", "av1"].includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "") && (e.fmtp || (e.fmtp = { parameters: {} }), e.fmtp.parameters["x-google-start-bitrate"] = "".concat(jh("X_GOOGLE_START_BITRATE") || Math.floor(n.bitrateMax))) })) } function XN(e) { if ("video" !== e.media.mediaType) return; const t = xu(); if (t.name !== Lu.SAFARI && t.os !== yu.IOS) return; const n = e.attributes.extmaps.findIndex((e => /video-orientation/g.test(e.extensionName))); -1 !== n && e.attributes.extmaps.splice(n, 1) } function qN(e, t, n) { if (!t) return; let i, r; if ("video" === e.media.mediaType ? (i = n.videoExtensions, r = n.videoCodecs) : (i = n.audioExtensions, r = n.audioCodecs), !0 === t.twcc) { const t = i.find((e => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e.extensionName)); t && (e.attributes.extmaps.find((e => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e.extensionName)) || e.attributes.extmaps.push({ entry: t.entry, extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" }), function (e, t) { return t.filter((t => !!e.find((e => e.payloadType === t.payloadType && !!e.rtcpFeedbacks.find((e => "transport-cc" === e.type)))))) }(r, e.attributes.payloads).forEach((e => { e.rtcpFeedbacks.find((e => "transport-cc" === e.type)) || e.rtcpFeedbacks.push({ type: "transport-cc" }) }))) } else if (!1 === t.twcc) { const t = e.attributes.extmaps.findIndex((e => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e.extensionName)); -1 !== t && e.attributes.extmaps.splice(t, 1), e.attributes.payloads.forEach((e => { const t = e.rtcpFeedbacks.findIndex((e => "transport-cc" === e.type)); -1 !== t && e.rtcpFeedbacks.splice(t, 1) })) } if (!0 === t.remb) { const t = i.find((e => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e.extensionName)); t && (e.attributes.extmaps.find((e => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e.extensionName)) || e.attributes.extmaps.push({ entry: t.entry, extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" }), function (e, t) { return t.filter((t => !!e.find((e => e.payloadType === t.payloadType && !!e.rtcpFeedbacks.find((e => "goog-remb" === e.type)))))) }(r, e.attributes.payloads).forEach((e => { e.rtcpFeedbacks.find((e => "goog-remb" === e.type)) || e.rtcpFeedbacks.push({ type: "goog-remb" }) }))) } else if (!1 === t.remb) { const t = e.attributes.extmaps.findIndex((e => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e.extensionName)); -1 !== t && e.attributes.extmaps.splice(t, 1), e.attributes.payloads.forEach((e => { const t = e.rtcpFeedbacks.findIndex((e => "goog-remb" === e.type)); -1 !== t && e.rtcpFeedbacks.splice(t, 1) })) } } function QN(e, t, n) { if (Ku()) return; if ("video" !== e.media.mediaType) return; if (!(t instanceof If)) return; if ("vp9" !== n && "vp8" !== n) return; if ("vp8" === n && !jh("SIMULCAST")) return; if (void 0 === t._scalabiltyMode || t._scalabiltyMode.numSpatialLayers <= 1) return; const i = "vp8" === n ? 2 : t._scalabiltyMode.numSpatialLayers, r = e.attributes.ssrcs[0], o = e.attributes.ssrcGroups.find((e => "FID" === e.semantic && e.ssrcIds[0] === r.ssrcId)), s = { semantic: "SIM", ssrcIds: [r.ssrcId] }; for (let a = 1; a < i; a++)e.attributes.ssrcs.push({ ssrcId: r.ssrcId + a, attributes: _m(r.attributes) }), s.ssrcIds.push(r.ssrcId + a), o && (e.attributes.ssrcs.push({ ssrcId: o.ssrcIds[1] + a, attributes: _m(r.attributes) }), e.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [r.ssrcId + a, o.ssrcIds[1] + a] })); e.attributes.ssrcGroups.unshift(s) } async function zN(e, t, n, i, r) { const o = new RTCPeerConnection; o.addTransceiver("video", { direction: "sendonly" }), o.addTransceiver("audio", { direction: "sendonly" }), o.addTransceiver("video", { direction: "recvonly" }), o.addTransceiver("audio", { direction: "recvonly" }); const s = (await o.createOffer()).sdp, a = YN(s, e, t, n, i, r, "sendonly"), c = YN(s, e, t, n, i, r, "recvonly"), E = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, _ = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, d = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }; if (ZN(a, c, "videoExtensions", E, _, d), ZN(a, c, "videoCodecs", E, _, d), ZN(a, c, "audioExtensions", E, _, d), ZN(a, c, "audioCodecs", E, _, d), jh("RAISE_H264_BASELINE_PRIORITY")) { const e = d.videoCodecs.findIndex((e => { var t, n; return "h264" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && "42001f" === (null === (n = e.fmtp) || void 0 === n ? void 0 : n.parameters["profile-level-id"]) })); if (-1 !== e) { const t = d.videoCodecs.findIndex((e => { var t; return "h264" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) })); if (t < e) { Dh.debug("raising H264 baseline profile priority"); const n = d.videoCodecs[e]; d.videoCodecs.splice(e, 1), d.videoCodecs.splice(t, 0, n) } -1 !== t && (_.videoCodecs = _.videoCodecs.filter((e => { var t, n; return !("h264" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (n = e.fmtp) || void 0 === n ? void 0 : n.parameters["profile-level-id"])) }))), -1 !== t && jh("FILTER_SEND_H264_BASELINE") && (E.videoCodecs = E.videoCodecs.filter((e => { var t, n; return !("h264" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (n = e.fmtp) || void 0 === n ? void 0 : n.parameters["profile-level-id"])) }))) } } try { o.close() } catch (e) { } return { send: E, recv: _, sendrecv: d } } function ZN(e, t, n, i, r, o) { if ("videoExtensions" === n || "audioExtensions" === n) { const s = []; return e[n].forEach((e => { t[n].some(((t, n) => { if (e.entry === t.entry && e.extensionName === t.extensionName) return s.push(n), !0 })) ? o[n].push(e) : i[n].push(e) })), void t[n].forEach(((e, t) => { -1 === s.indexOf(t) && r[n].push(e) })) } if ("videoCodecs" === n || "audioCodecs" === n) { const s = []; return e[n].forEach((e => { t[n].some(((t, n) => { if (e.payloadType === t.payloadType && JSON.stringify(e) === JSON.stringify(t)) return s.push(n), !0 })) ? o[n].push(e) : i[n].push(e) })), void t[n].forEach(((e, t) => { -1 === s.indexOf(t) && r[n].push(e) })) } } function $N(e) { const { send: t, recv: n, sendrecv: i } = e; if (!i) { if (!t || !n) throw new Error("cannot merge rtp capabilities because one of send or recv is empty!"); return { send: t, recv: n } } let r, o; return t ? (r = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r.audioCodecs = [...t.audioCodecs, ...i.audioCodecs], r.videoCodecs = [...t.videoCodecs, ...i.videoCodecs], r.audioExtensions = [...t.audioExtensions, ...i.audioExtensions], r.videoExtensions = [...t.videoExtensions, ...i.videoExtensions]) : r = i, n ? (o = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o.audioCodecs = [...n.audioCodecs, ...i.audioCodecs], o.videoCodecs = [...n.videoCodecs, ...i.videoCodecs], o.audioExtensions = [...n.audioExtensions, ...i.audioExtensions], o.videoExtensions = [...n.videoExtensions, ...i.videoExtensions]) : o = i, { send: r, recv: o } } function eD(e) { "audio" === e.media.mediaType && e.attributes.payloads.filter((e => { var t; return "opus" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) })).forEach((e => { e.fmtp || (e.fmtp = { parameters: {} }), e.fmtp.parameters.stereo = "1", e.fmtp.parameters["sprop-stereo"] = "1" })) } function tD(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function nD(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? tD(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tD(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } !function (e, t) { e.exports = (() => { var e = { 8: (e, t, n) => { n.r(t), n.d(t, { Parser: () => g, Printer: () => N, parse: () => L, print: () => w }); const i = "\n", r = "".concat("\r").concat(i), o = " "; let s; function a(e) { return e >= "0" && e <= "9" } function c(e) { return e >= "!" && e <= "~" } function E(e) { return c(e) || e >= "Â€" && e <= "Ã¿" } function _(e) { return "!" === e || e >= "#" && e <= "'" || e >= "*" && e <= "+" || e >= "-" && e <= "." || e >= "0" && e <= "9" || e >= "A" && e <= "Z" || e >= "^" && e <= "~" } function d(e) { return e >= "1" && e <= "9" } function u(e) { return e >= "A" && e <= "Z" || e >= "a" && e <= "z" } function l(e) { return "d" === e || "h" === e || "m" === e || "s" === e } function R(e) { return e > "" && e < "\t" || e > "\v" && e < "\f" || e > "" && e < "Ã¿" } function h(e) { return u(e) || a(e) || "+" === e || "/" === e } function p(e) { return a(e) || u(e) || "+" === e || "/" === e || "-" === e || "_" === e } function T(e) { return u(e) || a(e) || "+" === e || "/" === e } function O(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function C(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? O(Object(n), !0).forEach((function (t) { A(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function A(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } !function (e) { e.VERSION = "v", e.ORIGIN = "o", e.SESSION_NAME = "s", e.INFORMATION = "i", e.URI = "u", e.EMAIL = "e", e.PHONE = "p", e.CONNECTION = "c", e.BANDWIDTH = "b", e.TIME = "t", e.REPEAT = "r", e.ZONE_ADJUSTMENTS = "z", e.KEY = "k", e.ATTRIBUTE = "a", e.MEDIA = "m" }(s || (s = {})); class S { consumeText(e, t) { let n = t; for (; n < e.length;) { const t = e[n]; if ("\0" === t || "\r" === t || t === i) break; n += 1 } if (n - t == 0) throw new Error("Invalid text, at ".concat(e)); return n } consumeUnicastAddress(e, t, n) { return this.consumeTill(e, t, o) } consumeOneOrMore(e, t, n) { let i = t; for (; n(e[i]);)i++; if (i - t == 0) throw new Error("Invalid rule at ".concat(t, ".")); return i } consumeSpace(e, t) { if (e[t] === o) return t + 1; throw new Error("Invalid space at ".concat(t, ".")) } consumeIP4Address(e, t) { let n = t; for (let i = 0; i < 4; i++)if (n = this.consumeDecimalUChar(e, n), 3 !== i) { if ("." !== e[n]) throw new Error("Invalid IP4 address."); n++ } return n } consumeDecimalUChar(e, t) { let n = t; for (let r = 0; r < 3 && a(e[n]); r++, n++); if (n - t == 0) throw new Error("Invalid decimal uchar."); const i = parseInt(e.slice(t, n)); if (i >= 0 && i <= 255) return n; throw new Error("Invalid decimal uchar") } consumeIP6Address(e, t) { let n = this.consumeHexpart(e, t); return ":" === e[n] ? (n += 1, n = this.consumeIP4Address(e, n), n) : n } consumeHexpart(e, t) { let n = t; if (":" === e[n] && ":" === e[n + 1]) { n += 2; try { n = this.consumeHexseq(e, n) } catch (e) { } return n } if (n = this.consumeHexseq(e, n), ":" === e[n] && ":" === e[n + 1]) { n += 2; try { n = this.consumeHexseq(e, n) } catch (e) { } return n } return n } consumeHexseq(e, t) { let n = t; for (; n = this.consumeHex4(e, n), ":" === e[n] && ":" !== e[n + 1];)n += 1; return n } consumeHex4(e, t) { let n = 0; for (; n < 4; n++)if (!((i = e[t + n]) >= "0" && i <= "9" || i >= "a" && i <= "f" || i >= "A" && i <= "F")) { if (0 === n) throw new Error("Invalid hex 4"); break } var i; return t + n } consumeFQDN(e, t) { let n = t; for (; a(e[n]) || u(e[n]) || "-" === e[n] || "." === e[n];)n += 1; if (n - t < 4) throw new Error("Invalid FQDN"); return n } consumeExtnAddr(e, t) { return this.consumeOneOrMore(e, t, E) } consumeMulticastAddress(e, t, n) { switch (n) { case "IP4": case "ip4": return this.consumeIP4MulticastAddress(e, t); case "IP6": case "ip6": return this.consumeIP6MulticastAddress(e, t); default: try { return this.consumeFQDN(e, t) } catch (n) { return this.consumeExtnAddr(e, t) } } } consumeIP6MulticastAddress(e, t) { const n = this.consumeHexpart(e, t); return "/" === e[n] ? this.consumeInteger(e, n + 1) : n } consumeIP4MulticastAddress(e, t) { let n = t + 3; const i = e.slice(t, n), r = parseInt(i); if (r < 224 || r > 239) throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255."); for (let o = 0; o < 3; o++) { if ("." !== e[n]) throw new Error("Invalid IP4 multicast address."); n += 1, n = this.consumeDecimalUChar(e, n) } return "/" === e[n] && (n += 1), n = this.consumeTTL(e, n), "/" === e[n] && (n = this.consumeInteger(e, n)), n } consumeInteger(e, t) { if (!d(e[t])) throw new Error("Invalid integer."); for (t += 1; a(e[t]);)t += 1; return t } consumeTTL(e, t) { if ("0" === e[t]) return t + 1; if (!d(e[t])) throw new Error("Invalid TTL."); t += 1; for (let n = 0; n < 2 && a(e[t]); n++)t += 1; return t } consumeToken(e, t) { return this.consumeOneOrMore(e, t, _) } consumeTime(e, t) { let n = t; if ("0" === e[n]) return n + 1; for (d(e[n]) && (n += 1); a(e[n]);)n++; if (n - t < 10) throw new Error("Invalid time"); return n } consumeAddress(e, t) { return this.consumeTill(e, t, o) } consumeTypedTime(e, t) { let n = t; return n = this.consumeOneOrMore(e, n, a), l(e[n]) ? n + 1 : n } consumeRepeatInterval(e, t) { if (!d(e[t])) throw new Error("Invalid repeat interval"); for (t += 1; a(e[t]);)t += 1; return l(e[t]) && (t += 1), t } consumePort(e, t) { return this.consumeOneOrMore(e, t, a) } consume(e, t, n) { for (let i = 0; i < n.length; i++) { if (t + i >= e.length) throw new Error("consume exceeding value length"); if (e[t + i] !== n[i]) throw new Error("consume ".concat(n, " failed at ").concat(i)) } return t + n.length } consumeTill(e, t, n) { let i = t; for (; i < e.length && ("string" != typeof n || e[i] !== n) && ("function" != typeof n || !n(e[i]));)i++; return i } } class g extends S { constructor() { super(), A(this, "records", []), A(this, "currentLine", 0) } parse(e) { const t = this.probeEOL(e); this.records = e.split(t).filter((e => !!e.trim())).map(this.parseLine), this.currentLine = 0; const n = this.parseVersion(), i = this.parseOrigin(), r = this.parseSessionName(), o = this.parseInformation(), s = this.parseUri(), a = this.parseEmail(), c = this.parsePhone(), E = this.parseConnection(), _ = this.parseBandWidth(), d = this.parseTimeFields(), u = this.parseKey(), l = this.parseSessionAttribute(), R = this.parseMediaDescription(); if (this.currentLine !== this.records.length) throw new Error("parsing failed, non exhaustive sdp lines."); return { version: n, origin: i, sessionName: r, information: o, uri: s, emails: a, phones: c, connection: E, bandwidths: _, timeFields: d, key: u, attributes: l, mediaDescriptions: R } } getCurrentRecord() { const e = this.records[this.currentLine]; if (!e) throw new Error("Record doesn't exit."); return e } probeEOL(e) { for (let t = 0; t < e.length; t++)if (e[t] === i) return "\r" === e[t - 1] ? r : i; throw new Error("Invalid newline character.") } parseLine(e, t) { if (e.length < 2) throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>."); const n = e[0]; if ("=" !== e[1]) throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.'); return { type: n, value: e.slice(2), line: t, cur: 0 } } parseSessionAttribute() { const e = new I; for (; this.currentLine < this.records.length;) { const t = this.getCurrentRecord(); if (t.type !== s.ATTRIBUTE) break; const n = { attField: this.extractOneOrMore(t, (e => _(e) && ":" !== e)), _cur: 0 }; ":" === t.value[t.cur] && (t.cur += 1, n.attValue = this.extractOneOrMore(t, R)), e.parse(n), this.currentLine++ } return e.digest() } parseMediaAttributes(e) { const t = new f(e); for (; this.currentLine < this.records.length;) { const e = this.getCurrentRecord(); if (e.type !== s.ATTRIBUTE) break; const n = { attField: this.extractOneOrMore(e, (e => _(e) && ":" !== e)), _cur: 0 }; ":" === e.value[e.cur] && (e.cur += 1, n.attValue = this.extractOneOrMore(e, R)), t.parse(n), this.currentLine++ } return t.digest() } parseKey() { const e = this.getCurrentRecord(); if (e.type === s.KEY) { if ("prompt" === e.value || "clear:" === e.value || "base64:" === e.value || "uri:" === e.value) return e.value; throw this.currentLine++, new Error("Invalid key.") } } parseZone() { const e = this.getCurrentRecord(); if (e.type === s.ZONE_ADJUSTMENTS) { const t = []; for (; ;)try { const n = this.extract(e, this.consumeTime); this.consumeSpaceForRecord(e); let i = !1; "-" === e.value[e.cur] && (i = !0, e.cur += 1); const r = this.extract(e, this.consumeTypedTime); t.push({ time: n, typedTime: r, back: i }) } catch (e) { break } if (0 === t.length) throw new Error("Invalid zone adjustments"); return this.currentLine++, t } return [] } parseRepeat() { const e = []; for (; ;) { const t = this.getCurrentRecord(); if (t.type !== s.REPEAT) break; { const n = this.extract(t, this.consumeRepeatInterval), i = this.parseTypedTime(t); e.push({ repeatInterval: n, typedTimes: i }), this.currentLine++ } } return e } parseTypedTime(e) { const t = []; for (; ;)try { this.consumeSpaceForRecord(e), t.push(this.extract(e, this.consumeTypedTime)) } catch (e) { break } if (0 === t.length) throw new Error("Invalid typed time."); return t } parseTime() { const e = this.getCurrentRecord(), t = this.extract(e, this.consumeTime); this.consumeSpaceForRecord(e); const n = this.extract(e, this.consumeTime); return this.currentLine++, { startTime: t, stopTime: n } } parseBandWidth() { const e = []; for (; this.currentLine < this.records.length;) { const t = this.getCurrentRecord(); if (t.type !== s.BANDWIDTH) break; { const n = this.extractOneOrMore(t, _); if (":" !== t.value[t.cur]) throw new Error("Invalid bandwidth field."); t.cur++; const i = this.extractOneOrMore(t, a); e.push({ bwtype: n, bandwidth: i }), this.currentLine++ } } return e } parseVersion() { const e = this.getCurrentRecord(); if (e.type !== s.VERSION) throw new Error("first sdp record must be version"); const t = e.value.slice(0, this.consumeOneOrMore(e.value, 0, a)); if (t.length !== e.value.length) throw new Error('invalid proto version, "v='.concat(e.value, '"')); return this.currentLine++, t } parseOrigin() { const e = this.getCurrentRecord(); if (e.type !== s.ORIGIN) throw new Error("second line of sdp must be origin"); const t = this.extractOneOrMore(e, E); this.consumeSpaceForRecord(e); const n = this.extractOneOrMore(e, a); this.consumeSpaceForRecord(e); const i = this.extractOneOrMore(e, a); this.consumeSpaceForRecord(e); const r = this.extractOneOrMore(e, _); this.consumeSpaceForRecord(e); const o = this.extractOneOrMore(e, _); this.consumeSpaceForRecord(e); const c = this.extract(e, this.consumeUnicastAddress); return this.currentLine++, { username: t, sessId: n, sessVersion: i, nettype: r, addrtype: o, unicastAddress: c } } parseSessionName() { const e = this.getCurrentRecord(); if (e.type === s.SESSION_NAME) { const t = this.extract(e, this.consumeText); return this.currentLine++, t } } parseInformation() { const e = this.getCurrentRecord(); if (e.type !== s.INFORMATION) return; const t = this.extract(e, this.consumeText); return this.currentLine++, t } parseUri() { const e = this.getCurrentRecord(); if (e.type === s.URI) return this.currentLine++, e.value } parseEmail() { const e = []; for (; ;) { const t = this.getCurrentRecord(); if (t.type !== s.EMAIL) break; e.push(t.value), this.currentLine++ } return e } parsePhone() { const e = []; for (; ;) { const t = this.getCurrentRecord(); if (t.type !== s.PHONE) break; e.push(t.value), this.currentLine++ } return e } parseConnection() { const e = this.getCurrentRecord(); if (e.type === s.CONNECTION) { const t = this.extractOneOrMore(e, _); this.consumeSpaceForRecord(e); const n = this.extractOneOrMore(e, _); this.consumeSpaceForRecord(e); const i = this.extract(e, this.consumeAddress); return this.currentLine++, { nettype: t, addrtype: n, address: i } } } parseMedia() { const e = this.getCurrentRecord(), t = this.extract(e, this.consumeToken); this.consumeSpaceForRecord(e); let n = this.extract(e, this.consumePort); "/" === e.value[e.cur] && (e.cur += 1, n += this.extract(e, this.consumeInteger)), this.consumeSpaceForRecord(e); const i = []; for (i.push(this.extract(e, this.consumeToken)); "/" === e.value[e.cur];)e.cur += 1, i.push(this.extract(e, this.consumeToken)); if (0 === i.length) throw new Error("Invalid proto"); const r = this.parseFmt(e); return this.currentLine++, { mediaType: t, port: n, protos: i, fmts: r } } parseTimeFields() { const e = []; for (; this.getCurrentRecord().type === s.TIME;) { const t = this.parseTime(), n = this.parseRepeat(), i = this.parseZone(); e.push({ time: t, repeats: n, zones: i }) } return e } parseMediaDescription() { const e = []; for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s.MEDIA;) { const t = this.parseMedia(), n = this.parseInformation(), i = this.parseConnections(), r = this.parseBandWidth(), o = this.parseKey(), s = this.parseMediaAttributes(t); e.push({ media: t, information: n, connections: i, bandwidths: r, key: o, attributes: s }) } return e } parseConnections() { const e = []; for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s.CONNECTION;)e.push(this.parseConnection()); return e } parseFmt(e) { const t = []; for (; ;)try { this.consumeSpaceForRecord(e), t.push(this.extract(e, this.consumeToken)) } catch (e) { break } if (0 === t.length) throw new Error("Invalid fmts"); return t } extract(e, t, ...n) { const i = t.call(this, e.value, e.cur, ...n), r = e.value.slice(e.cur, i); return e.cur = i, r } extractOneOrMore(e, t) { const n = this.consumeOneOrMore(e.value, e.cur, t), i = e.value.slice(e.cur, n); return e.cur = n, i } consumeSpaceForRecord(e) { if (e.value[e.cur] !== o) throw new Error("Invalid space at ".concat(e.cur, ".")); e.cur += 1 } } class m extends S { constructor(...e) { super(...e), A(this, "attributes", void 0), A(this, "digested", !1) } extractOneOrMore(e, t, n) { const i = this.consumeOneOrMore(e.attValue, e._cur, t), r = e.attValue.slice(e._cur, i), [o, s] = n || []; if ("number" == typeof o && r.length < o) throw new Error("error in length, should be more or equal than ".concat(o, " characters.")); if ("number" == typeof s && r.length > s) throw new Error("error in length, should be less or equal than ".concat(s, " characters.")); return e._cur = i, r } consumeAttributeSpace(e) { if (e.attValue[e._cur] !== o) throw new Error("Invalid space at ".concat(e._cur, ".")); e._cur += 1 } extract(e, t, ...n) { if (!e.attValue) throw new Error("Nothing to extract from attValue."); const i = t.call(this, e.attValue, e._cur, ...n), r = e.attValue.slice(e._cur, i); return e._cur = i, r } atEnd(e) { if (!e.attValue) throw new Error; return e._cur >= e.attValue.length } peekChar(e) { if (!e.attValue) throw new Error; return e.attValue[e._cur] } peek(e, t) { if (!e.attValue) throw new Error; for (let n = 0; n < t.length; n++)if (t[n] !== e.attValue[e._cur + n]) return !1; return !0 } parseIceUfrag(e) { if (this.attributes.iceUfrag) throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'"); this.attributes.iceUfrag = this.extractOneOrMore(e, h, [4, 256]) } parseIcePwd(e) { if (this.attributes.icePwd) throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'"); this.attributes.icePwd = this.extractOneOrMore(e, h, [22, 256]) } parseIceOptions(e) { if (this.attributes.iceOptions) throw new Error("Invalid ice-options, should be only one 'ice-options' line"); const t = []; for (; !this.atEnd(e);) { t.push(this.extractOneOrMore(e, h)); try { this.consumeAttributeSpace(e) } catch (t) { if (this.atEnd(e)) break; throw t } } this.attributes.iceOptions = t } parseFingerprint(e) { const t = this.extract(e, this.consumeToken); this.consumeAttributeSpace(e); const n = this.extract(e, this.consumeTill); this.attributes.fingerprints.push({ hashFunction: t, fingerprint: n }) } parseExtmap(e) { const t = this.extractOneOrMore(e, a); let n; "/" === this.peekChar(e) && (this.extract(e, this.consume, "/"), n = this.extract(e, this.consumeToken)), this.consumeAttributeSpace(e); const i = this.extract(e, this.consumeTill, o), r = C(C({ entry: parseInt(t, 10) }, n && { direction: n }), {}, { extensionName: i }); this.peekChar(e) === o && (this.consumeAttributeSpace(e), r.extensionAttributes = this.extract(e, this.consumeTill)), this.attributes.extmaps.push(r) } parseSetup(e) { if (this.attributes.setup) throw new Error("must only be one single 'a=setup' line."); const t = this.extract(e, this.consumeTill); if ("active" !== t && "passive" !== t && "actpass" !== t && "holdconn" !== t) throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'."); this.attributes.setup = t } } class I extends m { constructor(...e) { super(...e), A(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] }) } parse(e) { if (this.digested) throw new Error("already digested"); try { switch (e.attField) { case "group": this.parseGroup(e); break; case "ice-lite": this.parseIceLite(); break; case "ice-ufrag": this.parseIceUfrag(e); break; case "ice-pwd": this.parseIcePwd(e); break; case "ice-options": this.parseIceOptions(e); break; case "fingerprint": this.parseFingerprint(e); break; case "setup": this.parseSetup(e); break; case "tls-id": this.parseTlsId(e); break; case "identity": this.parseIdentity(e); break; case "extmap": this.parseExtmap(e); break; case "msid-semantic": this.parseMsidSemantic(e); break; default: e.ignored = !0, this.attributes.unrecognized.push(e) } } catch (t) { throw console.error("parsing session attribute ".concat(e.attField, ' error, "a=').concat(e.attField, ":").concat(e.attValue, '"')), t } if (!e.ignored && e.attValue && !this.atEnd(e)) throw new Error("attribute parsing error") } digest() { return this.digested = !0, this.attributes } parseGroup(e) { const t = this.extract(e, this.consumeToken), n = []; for (; !this.atEnd(e) && this.peekChar(e) === o;)this.consumeAttributeSpace(e), n.push(this.extract(e, this.consumeToken)); this.attributes.groups.push({ semantic: t, identificationTag: n }) } parseIceLite() { if (this.attributes.iceLite) throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'"); this.attributes.iceLite = !0 } parseTlsId(e) { if (this.attributes.tlsId) throw new Error("must be only one tld-id line"); this.attributes.tlsId = this.extractOneOrMore(e, p) } parseIdentity(e) { const t = this.extractOneOrMore(e, T), n = []; for (; !this.atEnd(e) && this.peekChar(e) === o;) { this.consumeAttributeSpace(e); const t = this.extract(e, this.consumeToken); this.extract(e, this.consume, "="); const i = this.extractOneOrMore(e, (e => e !== o && R(e))); n.push({ name: t, value: i }) } this.attributes.identities.push({ assertionValue: t, extensions: n }) } parseMsidSemantic(e) { this.peekChar(e) === o && this.consumeAttributeSpace(e); const t = { semantic: this.extract(e, this.consumeToken), identifierList: [] }; for (; ;) { try { this.consumeAttributeSpace(e) } catch (e) { break } if ("*" === this.peekChar(e)) { this.extract(e, this.consume, "*"), t.applyForAll = !0; break } { const n = this.extract(e, this.consumeTill, o); t.identifierList.push(n) } } this.attributes.msidSemantic = t } } class f extends m { constructor(e) { super(), A(this, "attributes", void 0), -1 !== e.protos.indexOf("RTP") || e.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] } } parse(e) { if (this.digested) throw new Error("already digested"); try { switch (e.attField) { case "extmap": this.parseExtmap(e); break; case "setup": this.parseSetup(e); break; case "ice-ufrag": this.parseIceUfrag(e); break; case "ice-pwd": this.parseIcePwd(e); break; case "ice-options": this.parseIceOptions(e); break; case "candidate": this.parseCandidate(e); break; case "remote-candidate": this.parseRemoteCandidate(e); break; case "end-of-candidates": this.parseEndOfCandidates(); break; case "fingerprint": this.parseFingerprint(e); break; case "rtpmap": this.parseRtpmap(e); break; case "ptime": this.parsePtime(e); break; case "maxptime": this.parseMaxPtime(e); break; case "sendrecv": case "recvonly": case "sendonly": case "inactive": this.parseDirection(e); break; case "ssrc": this.parseSSRC(e); break; case "fmtp": this.parseFmtp(e); break; case "rtcp-fb": this.parseRtcpFb(e); break; case "rtcp-mux": this.parseRTCPMux(); break; case "rtcp-mux-only": this.parseRTCPMuxOnly(); break; case "rtcp-rsize": this.parseRTCPRsize(); break; case "rtcp": this.parseRTCP(e); break; case "mid": this.parseMid(e); break; case "msid": this.parseMsid(e); break; case "imageattr": this.parseImageAttr(e); break; case "rid": this.parseRid(e); break; case "simulcast": this.parseSimulcast(e); break; case "sctp-port": this.parseSctpPort(e); break; case "max-message-size": this.parseMaxMessageSize(e); break; case "ssrc-group": this.parseSSRCGroup(e); break; default: e.ignored = !0, this.attributes.unrecognized.push(e) } } catch (t) { throw console.error("parsing media attribute ".concat(e.attField, ' error, "a=').concat(e.attField, ":").concat(e.attValue, '"')), t } if (!e.ignored && e.attValue && !this.atEnd(e)) throw new Error("attribute parsing error") } parseCandidate(e) { const t = this.extractOneOrMore(e, h, [1, 32]); this.consumeAttributeSpace(e); const n = this.extractOneOrMore(e, a, [1, 5]); this.consumeAttributeSpace(e); const i = this.extract(e, this.consumeToken); this.consumeAttributeSpace(e); const r = this.extractOneOrMore(e, a, [1, 10]); this.consumeAttributeSpace(e); const s = this.extract(e, this.consumeAddress); this.consumeAttributeSpace(e); const E = this.extract(e, this.consumePort); this.consumeAttributeSpace(e), this.extract(e, this.consume, "typ"), this.consumeAttributeSpace(e); const _ = { foundation: t, componentId: n, transport: i, priority: r, connectionAddress: s, port: E, type: this.extract(e, this.consumeToken), extension: {} }; for (this.peek(e, " raddr") && (this.extract(e, this.consume, " raddr"), this.consumeAttributeSpace(e), _.relAddr = this.extract(e, this.consumeAddress)), this.peek(e, " rport") && (this.extract(e, this.consume, " rport"), this.consumeAttributeSpace(e), _.relPort = this.extract(e, this.consumePort)); this.peekChar(e) === o;) { this.consumeAttributeSpace(e); const t = this.extract(e, this.consumeToken); this.consumeAttributeSpace(e), _.extension[t] = this.extractOneOrMore(e, c) } this.attributes.candidates.push(_) } parseRemoteCandidate(e) { const t = []; for (; ;) { const n = this.extractOneOrMore(e, a, [1, 5]); this.consumeAttributeSpace(e); const i = this.extract(e, this.consumeAddress); this.consumeAttributeSpace(e); const r = this.extract(e, this.consumePort); t.push({ componentId: n, connectionAddress: i, port: r }); try { this.consumeAttributeSpace(e) } catch (e) { break } } this.attributes.remoteCandidatesList.push(t) } parseEndOfCandidates() { if (this.attributes.endOfCandidates) throw new Error("must be only one line of end-of-candidates"); this.attributes.endOfCandidates = !0 } parseRtpmap(e) { const t = this.extract(e, this.consumeToken); this.consumeAttributeSpace(e); const n = this.extract(e, this.consumeTill, "/"); this.extract(e, this.consume, "/"); const i = { encodingName: n, clockRate: this.extractOneOrMore(e, a) }; this.atEnd(e) || "/" !== this.peekChar(e) || (this.extract(e, this.consume, "/"), i.encodingParameters = parseInt(this.extract(e, this.consumeTill), 10)); const r = this.attributes.payloads.find((e => e.payloadType === parseInt(t, 10))); r ? r.rtpMap = i : this.attributes.payloads.push({ payloadType: parseInt(t, 10), rtpMap: i, rtcpFeedbacks: [] }) } parsePtime(e) { if (this.attributes.ptime) throw new Error("must be only one line of ptime"); this.attributes.ptime = this.extract(e, this.consumeTill) } parseMaxPtime(e) { if (this.attributes.maxPtime) throw new Error("must be only one line of ptime"); this.attributes.maxPtime = this.extract(e, this.consumeTill) } parseDirection(e) { if (this.attributes.direction) throw new Error("must be only one line of direction info"); this.attributes.direction = e.attField } parseSSRC(e) { const t = this.extractOneOrMore(e, a); this.consumeAttributeSpace(e); const n = this.extract(e, this.consumeTill, ":"); let i; ":" === this.peekChar(e) && (this.extract(e, this.consume, ":"), i = this.extract(e, this.consumeTill)); const r = this.attributes.ssrcs.find((e => e.ssrcId === parseInt(t, 10))); r ? r.attributes[n] = i : this.attributes.ssrcs.push({ ssrcId: parseInt(t, 10), attributes: { [n]: i } }) } parseFmtp(e) { const t = this.extract(e, this.consumeTill, o); this.consumeAttributeSpace(e); const n = this.extract(e, this.consumeTill), i = {}; n.split(";").forEach((e => { let [t, n] = e.split("="); t = t.trim(); const r = "string" == typeof n ? n.trim() : null; "string" == typeof t && t.length > 0 && (i[t] = r) })); const r = this.attributes.payloads.find((e => e.payloadType === parseInt(t, 10))); r ? r.fmtp = { parameters: i } : this.attributes.payloads.push({ payloadType: parseInt(t, 10), rtcpFeedbacks: [], fmtp: { parameters: i } }) } parseFmtParameters(e) { const t = {}, n = this.extract(e, this.consumeTill, "="); e._cur++; const i = this.extract(e, this.consumeTill, ";"); for (t[n] = i; ";" === e.attValue[e._cur];) { const n = this.extract(e, this.consumeTill, "="); e._cur++; const i = this.extract(e, this.consumeTill, ";"); t[n] = i } return t } parseRtcpFb(e) { let t = ""; t = "*" === this.peekChar(e) ? this.extract(e, this.consume, "*") : this.extract(e, this.consumeTill, o), this.consumeAttributeSpace(e); const n = this.extract(e, this.consumeTill, o); let i; if ("trr-int" === n) i = { type: n, interval: this.extract(e, this.consumeTill) }; else { const t = { type: n }; this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.parameter = this.extract(e, this.consumeToken), this.peekChar(e) === o && (t.additional = this.extract(e, this.consumeTill))), i = t } if ("*" === t) this.attributes.rtcpFeedbackWildcards.push(i); else { const e = this.attributes.payloads.find((e => e.payloadType === parseInt(t, 10))); e ? e.rtcpFeedbacks.push(i) : this.attributes.payloads.push({ payloadType: parseInt(t, 10), rtcpFeedbacks: [i] }) } } parseRTCPMux() { if (this.attributes.rtcpMux) throw new Error("must be single line of rtcp-mux"); this.attributes.rtcpMux = !0 } parseRTCPMuxOnly() { if (this.attributes.rtcpMuxOnly) throw new Error("must be single line of rtcp-only"); this.attributes.rtcpMuxOnly = !0 } parseRTCPRsize() { if (this.attributes.rtcpRsize) throw new Error("must be single line of rtcp-rsize"); this.attributes.rtcpRsize = !0 } parseRTCP(e) { if (this.attributes.rtcp) throw new Error("must be single line of rtcp"); const t = { port: this.extract(e, this.consumePort) }; this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.netType = this.extractOneOrMore(e, _), this.consumeAttributeSpace(e), t.addressType = this.extractOneOrMore(e, _), this.consumeAttributeSpace(e), t.address = this.extract(e, this.consumeAddress)), this.attributes.rtcp = t } parseMsid(e) { const t = { id: this.extractOneOrMore(e, _, [1, 64]) }; this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.appdata = this.extractOneOrMore(e, _, [1, 64])), this.attributes.msids.push(t) } parseImageAttr(e) { this.attributes.imageattr.push(e.attValue) } parseRid(e) { const t = this.extractOneOrMore(e, (e => u(e) || a(e) || "_" === e || "-" === e)); this.consumeAttributeSpace(e); const n = { id: t, direction: this.extract(e, this.consumeToken), params: [] }; if (this.peekChar(e) === o) { if (this.consumeAttributeSpace(e), this.peek(e, "pt=")) { this.extract(e, this.consume, "pt="); const t = []; for (; ;) { const n = this.extract(e, this.consumeToken); t.push(n); try { this.extract(e, this.consume, ",") } catch (e) { break } } n.payloads = t, this.peekChar(e) === o && this.extract(e, this.consume, o) } for (; ;) { const t = this.extract(e, this.consumeToken); switch (t) { case "depend": { const i = { type: t, rids: this.extract(e, this.consume, "=").split(",") }; n.params.push(i); break } default: { const i = { type: t }; "=" === this.peekChar(e) && (this.extract(e, this.consume, "="), i.val = this.extract(e, this.consumeTill, ";")), n.params.push(i) } }try { this.extract(e, this.consume, ";") } catch (e) { break } } } this.attributes.rids.push(n) } parseSimulcast(e) { if (this.attributes.simulcast) throw new Error("must be single line of simulcast"); this.attributes.simulcast = e.attValue, this.extract(e, this.consumeTill) } parseSctpPort(e) { this.attributes.sctpPort = this.extractOneOrMore(e, a, [1, 5]) } parseMaxMessageSize(e) { this.attributes.maxMessageSize = this.extractOneOrMore(e, a, [1, void 0]) } digest() { return this.digested = !0, this.attributes } parseMid(e) { this.attributes.mid = this.extract(e, this.consumeToken) } parseSSRCGroup(e) { const t = this.extract(e, this.consumeToken), n = []; for (; ;)try { this.consumeAttributeSpace(e); const t = this.extract(e, this.consumeInteger); n.push(parseInt(t, 10)) } catch (e) { break } this.attributes.ssrcGroups.push({ semantic: t, ssrcIds: n }) } } function P(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } class N { constructor() { P(this, "eol", r) } print(e, t) { let n = ""; return t && (this.eol = t), n += this.printVersion(e.version), n += this.printOrigin(e.origin), n += this.printSessionName(e.sessionName), n += this.printInformation(e.information), n += this.printUri(e.uri), n += this.printEmail(e.emails), n += this.printPhone(e.phones), n += this.printConnection(e.connection), n += this.printBandwidth(e.bandwidths), n += this.printTimeFields(e.timeFields), n += this.printKey(e.key), n += this.printSessionAttributes(e.attributes), n += this.printMediaDescription(e.mediaDescriptions), n } printVersion(e) { return "v=".concat(e).concat(this.eol) } printOrigin(e) { return "o=".concat(e.username, " ").concat(e.sessId, " ").concat(e.sessVersion, " ").concat(e.nettype, " ").concat(e.addrtype, " ").concat(e.unicastAddress).concat(this.eol) } printSessionName(e) { return e ? "s=".concat(e).concat(this.eol) : "" } printInformation(e) { return e ? "i=".concat(e).concat(this.eol) : "" } printUri(e) { return e ? "u=".concat(e).concat(this.eol) : "" } printEmail(e) { let t = ""; for (const n of e) t += "e=".concat(n).concat(this.eol); return t } printPhone(e) { let t = ""; for (const n of e) t += "e=".concat(n).concat(this.eol); return t } printConnection(e) { return e ? "c=".concat(e.nettype, " ").concat(e.addrtype, " ").concat(e.address).concat(this.eol) : "" } printBandwidth(e) { let t = ""; for (const n of e) t += "b=".concat(n.bwtype, ":").concat(n.bandwidth).concat(this.eol); return t } printTimeFields(e) { let t = ""; for (const n of e) { t += "t=".concat(n.time.startTime, " ").concat(n.time.startTime).concat(this.eol); for (const e of n.repeats) t += "r=".concat(e.repeatInterval, " ").concat(e.typedTimes.join(" ")).concat(this.eol); n.zoneAdjustments && (t += "z=", t += "z=".concat(n.zoneAdjustments.map((e => "".concat(e.time, " ").concat(e.back ? "-" : "", " ").concat(e.typedTime))).join(" ")).concat(this.eol), t += this.eol) } return t } printKey(e) { return e ? "k=".concat(e).concat(this.eol) : "" } printAttributes(e) { let t = ""; for (const n of e) t += "a=".concat(n.attField).concat(n.attValue ? ":".concat(n.attValue) : "").concat(this.eol); return t } printMediaDescription(e) { let t = ""; for (const n of e) t += this.printMedia(n.media), t += this.printInformation(n.information), t += this.printConnections(n.connections), t += this.printBandwidth(n.bandwidths), t += this.printKey(n.key), t += this.printMediaAttributes(n); return t } printConnections(e) { let t = ""; for (const n of e) t += this.printConnection(n); return t } printMedia(e) { return "m=".concat(e.mediaType, " ").concat(e.port, " ").concat(e.protos.join("/"), " ").concat(e.fmts.join(" ")).concat(this.eol) } printSessionAttributes(e) { return new v(this.eol).print(e) } printMediaAttributes(e) { return new y(this.eol).print(e) } } class D { constructor(e) { P(this, "eol", void 0), this.eol = e } printIceUfrag(e) { return void 0 === e ? "" : "a=ice-ufrag:".concat(e).concat(this.eol) } printIcePwd(e) { return void 0 === e ? "" : "a=ice-pwd:".concat(e).concat(this.eol) } printIceOptions(e) { return void 0 === e ? "" : "a=ice-options:".concat(e.join(o)).concat(this.eol) } printFingerprints(e) { return e.length > 0 ? e.map((e => "a=fingerprint:".concat(e.hashFunction).concat(o).concat(e.fingerprint))).join(this.eol) + this.eol : "" } printExtmap(e) { return e.map((e => "a=extmap:".concat(e.entry).concat(e.direction ? "/".concat(e.direction) : "").concat(o).concat(e.extensionName).concat(e.extensionAttributes ? "".concat(o).concat(e.extensionAttributes) : "").concat(this.eol))).join("") } printSetup(e) { return void 0 === e ? "" : "a=setup:".concat(e).concat(this.eol) } printUnrecognized(e) { return e.map((e => "a=".concat(e.attField).concat(e.attValue ? ":".concat(e.attValue) : "").concat(this.eol))).join("") } } class v extends D { print(e) { let t = ""; return t += this.printGroups(e.groups), t += this.printMsidSemantic(e.msidSemantic), t += this.printIceLite(e.iceLite), t += this.printIceUfrag(e.iceUfrag), t += this.printIcePwd(e.icePwd), t += this.printIceOptions(e.iceOptions), t += this.printFingerprints(e.fingerprints), t += this.printSetup(e.setup), t += this.printTlsId(e.tlsId), t += this.printIdentity(e.identities), t += this.printExtmap(e.extmaps), t += this.printUnrecognized(e.unrecognized), t } printGroups(e) { let t = ""; return e.length > 0 && (t += e.map((e => "a=group:".concat(e.semantic).concat(e.identificationTag.map((e => "".concat(o).concat(e))).join("")).concat(this.eol))).join("")), t } printIceLite(e) { return void 0 === e ? "" : "a=ice-lite" + this.eol } printTlsId(e) { return e ? "a=tls-id:".concat(e).concat(this.eol) : "" } printIdentity(e) { return 0 === e.length ? "" : e.map((e => "a=identity:".concat(e.assertionValue).concat(e.extensions.map((e => "".concat(o).concat(e.name).concat(e.value ? "=".concat(e.value) : "")))))).join(this.eol) + this.eol } printMsidSemantic(e) { if (!e) return ""; let t = "a=msid-semantic:".concat(e.semantic); return e.applyForAll ? t += "".concat(o, "*") : e.identifierList.length > 0 && (t += e.identifierList.map((e => "".concat(o).concat(e)))), t + this.eol } } class y extends D { print(e) { const t = e.attributes; let n = ""; return n += this.printRTCP(t.rtcp), n += this.printIceUfrag(t.iceUfrag), n += this.printIcePwd(t.icePwd), n += this.printIceOptions(t.iceOptions), n += this.printCandidates(t.candidates), n += this.printRemoteCandidatesList(t.remoteCandidatesList), n += this.printEndOfCandidates(t.endOfCandidates), n += this.printFingerprints(t.fingerprints), n += this.printSetup(t.setup), n += this.printMid(t.mid), n += this.printExtmap(t.extmaps), n += this.printRTPRelated(t), n += this.printPtime(t.ptime), n += this.printMaxPtime(t.maxPtime), n += this.printDirection(t.direction), n += this.printSSRCGroups(t.ssrcGroups), n += this.printSSRC(t.ssrcs), n += this.printRTCPMux(t.rtcpMux), n += this.printRTCPMuxOnly(t.rtcpMuxOnly), n += this.printRTCPRsize(t.rtcpRsize), n += this.printMSId(t.msids), n += this.printImageattr(t.imageattr), n += this.printRid(t.rids), n += this.printSimulcast(t.simulcast), n += this.printSCTPPort(t.sctpPort), n += this.printMaxMessageSize(t.maxMessageSize), n += this.printUnrecognized(t.unrecognized), n } printCandidates(e) { return e.map((e => "a=candidate:".concat(e.foundation).concat(o).concat(e.componentId).concat(o).concat(e.transport).concat(o).concat(e.priority).concat(o).concat(e.connectionAddress).concat(o).concat(e.port).concat(o, "typ").concat(o).concat(e.type).concat(e.relAddr ? "".concat(o, "raddr").concat(o).concat(e.relAddr) : "").concat(e.relPort ? "".concat(o, "rport").concat(o).concat(e.relPort) : "").concat(Object.keys(e.extension).map((t => "".concat(o).concat(t).concat(o).concat(e.extension[t]))).join("")).concat(this.eol))).join("") } printRemoteCandidatesList(e) { return e.map((e => "a=remote-candidates:".concat(e.join(o)).concat(this.eol))).join("") } printEndOfCandidates(e) { return void 0 === e ? "" : "a=end-of-candidates" + this.eol } printRTPRelated(e) { if (!e.payloads) return ""; const t = e.payloads; let n = ""; n += e.rtcpFeedbackWildcards.map((e => this.printRTCPFeedback("*", e))).join(""); for (const i of t) n += this.printRtpMap(i.payloadType, i.rtpMap), n += this.printFmtp(i.payloadType, i.fmtp), n += i.rtcpFeedbacks.map((e => this.printRTCPFeedback(i.payloadType, e))).join(""); return n } printFmtp(e, t) { if (!t) return ""; const n = Object.keys(t.parameters); return 1 === n.length && null === t.parameters[n[0]] ? "a=fmtp:".concat(e).concat(o).concat(n[0]).concat(this.eol) : "a=fmtp:".concat(e).concat(o).concat(Object.keys(t.parameters).map((e => "".concat(e, "=").concat(t.parameters[e]))).join(";")).concat(this.eol) } printRtpMap(e, t) { return t ? "a=rtpmap:".concat(e).concat(o).concat(t.encodingName, "/").concat(t.clockRate).concat(t.encodingParameters ? "/".concat(t.encodingParameters) : "").concat(this.eol) : "" } printRTCPFeedback(e, t) { let n = "a=rtcp-fb:".concat(e).concat(o), i = t; return "trr-int" === i.type ? n += "ttr-int".concat(o).concat(i.interval) : (n += "".concat(i.type), i.parameter && (n += "".concat(o).concat(i.parameter), i.additional && (n += "".concat(o).concat(i.additional)))), n + this.eol } printPtime(e) { return void 0 === e ? "" : "a=ptime:".concat(e).concat(this.eol) } printMaxPtime(e) { return void 0 === e ? "" : "a=maxptime:".concat(e).concat(this.eol) } printDirection(e) { return void 0 === e ? "" : "a=".concat(e).concat(this.eol) } printSSRC(e) { return e.map((e => Object.keys(e.attributes).map((t => "a=ssrc:".concat(e.ssrcId.toString(10)).concat(o).concat(t).concat(e.attributes[t] ? ":".concat(e.attributes[t]) : "").concat(this.eol))).join(""))).join("") } printRTCPMux(e) { return void 0 === e ? "" : "a=rtcp-mux".concat(this.eol) } printRTCPMuxOnly(e) { return void 0 === e ? "" : "a=rtcp-mux-only".concat(this.eol) } printRTCPRsize(e) { return void 0 === e ? "" : "a=rtcp-rsize".concat(this.eol) } printRTCP(e) { if (void 0 === e) return ""; let t = "a=rtcp:".concat(e.port); return e.netType && (t += "".concat(o).concat(e.netType)), e.addressType && (t += "".concat(o).concat(e.addressType)), e.address && (t += "".concat(o).concat(e.address)), t + this.eol } printMSId(e) { return e.map((e => "a=msid:".concat(e.id).concat(e.appdata ? "".concat(o).concat(e.appdata) : "").concat(this.eol))).join("") } printImageattr(e) { return e.map((e => "a=imageattr:".concat(e).concat(this.eol))).join("") } printRid(e) { return e.map((e => { let t = "a=rid:".concat(e.id).concat(o).concat(e.direction); return e.payloads && (t += "".concat(o, "pt=").concat(e.payloads.join(","))), e.params.length > 0 && (t += "".concat(o).concat(e.params.map((e => "depend" === e.type ? "depend=".concat(e.rids.join(",")) : "".concat(e.type, "=").concat(e.val))).join(";"))), t + this.eol })).join("") } printSimulcast(e) { return void 0 === e ? "" : "a=simulcast:".concat(e).concat(this.eol) } printSCTPPort(e) { return void 0 === e ? "" : "a=sctp-port:".concat(e).concat(this.eol) } printMaxMessageSize(e) { return void 0 === e ? "" : "a=max-message-size:".concat(e).concat(this.eol) } printMid(e) { return void 0 === e ? "" : "a=mid:".concat(e).concat(this.eol) } printSSRCGroups(e) { return e.map((e => "a=ssrc-group:".concat(e.semantic).concat(e.ssrcIds.map((e => "".concat(o).concat(e.toString(10)))).join("")).concat(this.eol))).join("") } } function L(e) { return (new g).parse(e) } function w(e, t) { return (new N).print(e, t) } } }, t = {}; function n(i) { if (t[i]) return t[i].exports; var r = t[i] = { exports: {} }; return e[i](r, r.exports, n), r.exports } return n.d = (e, t) => { for (var i in t) n.o(t, i) && !n.o(e, i) && Object.defineProperty(e, i, { enumerable: !0, get: t[i] }) }, n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n(8) })() }(VN); class iD { constructor(e) { hl(this, "sessionDesc", void 0), hl(this, "localCapabilities", void 0), hl(this, "rtpCapabilities", void 0), hl(this, "candidates", void 0), hl(this, "iceParameters", void 0), hl(this, "dtlsParameters", void 0), hl(this, "setup", void 0), hl(this, "currentMidIndex", void 0), hl(this, "cname", void 0), e = _m(e); const { remoteIceParameters: t, remoteDtlsParameters: n, candidates: i, remoteRTPCapabilities: r, remoteSetup: o, localCapabilities: s, sdkCodec: a, cname: c } = e, E = VN.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n"); this.rtpCapabilities = r, this.candidates = i, this.iceParameters = t, this.dtlsParameters = n, this.setup = o, this.localCapabilities = s, this.cname = c; for (let _ = 0; _ < E.mediaDescriptions.length; _++) { const e = E.mediaDescriptions[_]; e.attributes.iceUfrag = t.iceUfrag, e.attributes.icePwd = t.icePwd, e.attributes.fingerprints = n.fingerprints, e.attributes.candidates = i, e.attributes.setup = o, "video" === e.media.mediaType && (e.media.fmts = r.videoCodecs.map((e => e.payloadType.toString(10))), e.attributes.payloads = r.videoCodecs, e.attributes.extmaps = r.videoExtensions), "audio" === e.media.mediaType && (e.media.fmts = r.audioCodecs.map((e => e.payloadType.toString(10))), e.attributes.payloads = r.audioCodecs, e.attributes.extmaps = r.audioExtensions), E.mediaDescriptions[_] = this.mungMediaDesc(e) } this.sessionDesc = E, this.currentMidIndex = E.mediaDescriptions.length - 1 } toString() { return VN.exports.print(this.sessionDesc) } send(e, t, n) { const { ssrcs: i, ssrcGroups: r } = HN(t, this.cname), o = this.sessionDesc.mediaDescriptions.find((t => e === PO.VIDEO ? "video" === t.media.mediaType : "audio" === t.media.mediaType)), s = i[0].attributes.label, a = i[0].attributes.mslabel; return o.attributes.ssrcs = o.attributes.ssrcs.concat(i), o.attributes.ssrcGroups = o.attributes.ssrcGroups.concat(r), { id: s, mslabel: a } } batchSend(e) { return e.map((e => { let { kind: t, ssrcMsg: n } = e; return this.send(t, n, void 0) })) } stopSending(e) { this.sessionDesc.mediaDescriptions.forEach((t => { const n = [], i = [], r = []; t.attributes.ssrcs.forEach((t => { e.includes(t.attributes.label || "") ? r.push(t) : n.push(t) })), t.attributes.ssrcGroups.forEach((e => { r.map((e => e.ssrcId)).includes(e.ssrcIds[0]) || i.push(e) })), t.attributes.ssrcs = n, t.attributes.ssrcGroups = i })) } mute(e) { const t = this.sessionDesc.mediaDescriptions.find((t => t.attributes.mid === e)); if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.mute.")); t.attributes.direction = "inactive" } unmute(e) { const t = this.sessionDesc.mediaDescriptions.find((t => t.attributes.mid === e)); if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.unmute.")); t.attributes.direction = "sendonly" } receive(e, t, n) { e.forEach(((e, t) => { const n = e._mediaStreamTrack, i = this.sessionDesc.mediaDescriptions.findIndex((e => e.attributes.mid === n.kind)), r = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i], e); this.sessionDesc.mediaDescriptions[i] = r })) } stopReceiving(e) { } updateCandidates(e) { e === NO.TCP ? this.candidates.forEach((e => { -1 === this.candidates.findIndex((t => "tcp" === t.transport && t.connectionAddress === e.connectionAddress && t.port === e.port)) && this.candidates.push(nD(nD({}, e), {}, { foundation: "tcpcandidate", priority: Number(e.priority) - 1 + "", transport: "tcp", port: Number(e.port) + 90 + "" })) })) : this.candidates = this.candidates.filter((e => "tcp" !== e.transport)); for (const t of this.sessionDesc.mediaDescriptions) t.attributes.candidates = this.candidates } restartICE(e) { e = _m(e), this.iceParameters = e, this.sessionDesc.mediaDescriptions.forEach((t => { t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd })) } predictReceivingMids(e) { const t = []; for (let n = 0; n < e; n++)t.push((this.currentMidIndex + n + 1).toString(10)); return t } mungRecvMediaDsec(e, t) { const n = _m(e); return WN(n, t), JN(n, t), n } updateRecvMedia(e, t) { const n = this.sessionDesc.mediaDescriptions.findIndex((t => t.attributes.mid === e)); if (-1 !== n) { const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n], t); this.sessionDesc.mediaDescriptions[n] = e } } bumpMid(e) { this.currentMidIndex += e } updateTrackLabel(e, t, n) { const i = this.sessionDesc.mediaDescriptions.find((t => e === PO.VIDEO ? "video" === t.attributes.mid : "audio" === t.attributes.mid)); if (i) { const e = i.attributes.ssrcs.find((e => e.attributes.label === t)); var r; e && (e.attributes.label = n, null === (r = e.attributes.msid) || void 0 === r || r.replace(t, n)) } } mungMediaDesc(e) { const t = _m(e); return KN(t), function (e) { const t = e.attributes.extmaps.find((e => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e.extensionName)); t && e.attributes.extmaps.splice(e.attributes.extmaps.indexOf(t), 1), e.attributes.payloads.forEach((e => { const t = e.rtcpFeedbacks.findIndex((e => "transport-cc" === e.type)); -1 !== t && e.rtcpFeedbacks.splice(t, 1) })) }(t), t } getSSRC(e) { for (const t of this.sessionDesc.mediaDescriptions) for (const n of t.attributes.ssrcs) if (n.attributes.label === e) return [n] } } function rD(e) { if (Array.isArray(e)) return e.map((e => e)); if (!oD(e)) return e; const t = {}; for (const n in e) oD(e[n]) || Array.isArray(e[n]) ? t[n] = rD(e[n]) : t[n] = e[n]; return t } function oD(e) { return !("object" != typeof e || Array.isArray(e) || !e) } function sD() { const e = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i); return e && e[0] ? Number(e[0].split("/")[1]) : null } function aD(e) { return !!window.RTCStatsReport && e.getStats() instanceof Cd } class cD { constructor(e) { hl(this, "input", []), hl(this, "size", void 0), this.size = e } add(e) { this.input.push(e), this.input.length > this.size && this.input.splice(0, 1) } diffMean() { return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length } } const ED = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" }, _D = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: ED, remoteCandidate: ED } }, dD = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0 }, uD = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, qpSumPerFrame: 0 }, lD = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0 }, RD = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0, concealedSamples: 0 }; function hD(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function pD(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? hD(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hD(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class TD { constructor(e, t) { hl(this, "onFirstVideoReceived", void 0), hl(this, "onFirstVideoDecoded", void 0), hl(this, "onFirstAudioReceived", void 0), hl(this, "onFirstVideoDecodedTimeout", void 0), hl(this, "onFirstAudioDecoded", void 0), hl(this, "onSelectedLocalCandidateChanged", void 0), hl(this, "onSelectedRemoteCandidateChanged", void 0), hl(this, "videoIsReady", !1), hl(this, "videoIsReady2", {}), hl(this, "pc", void 0), hl(this, "options", void 0), hl(this, "intervalTimer", void 0), hl(this, "stats", rD(_D)), hl(this, "isFirstVideoReceived", {}), hl(this, "isFirstVideoDecoded", {}), hl(this, "isFirstAudioReceived", {}), hl(this, "isFirstAudioDecoded", {}), hl(this, "isFirstVideoDecodedTimeout", {}), hl(this, "lossRateWindowStats", []), this.pc = e, this.options = t, this.intervalTimer = window.setInterval((async () => { this.updateStats() }), this.options.updateInterval) } getStats() { return this.stats } getSelectedCandidatePair() { return new Cd((e => { e({ local: pD({}, ED), remote: pD({}, ED) }) })) } setVideoIsReady(e) { this.videoIsReady = e } setVideoIsReady2(e, t) { this.videoIsReady2[e] = t } getVideoIsReady(e) { return this.videoIsReady2[e] || !1 } setIsFirstAudioDecoded(e) { } destroy() { window.clearInterval(this.intervalTimer), this.pc = void 0 } calcLossRate(e) { this.lossRateWindowStats.push(e), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1); const t = this.lossRateWindowStats.length, n = ["videoSend", "audioSend", "videoRecv", "audioRecv"]; let i = 0, r = 0, o = 0, s = 0; for (const a of n) e[a].forEach(((e, n) => { if (!this.lossRateWindowStats[t - 1][a][n] || !this.lossRateWindowStats[0][a][n]) return; const c = this.lossRateWindowStats[t - 1][a][n].packets - this.lossRateWindowStats[0][a][n].packets, E = this.lossRateWindowStats[t - 1][a][n].packetsLost - this.lossRateWindowStats[0][a][n].packetsLost; "videoSend" === a || "audioSend" === a ? (i += c, o += E) : (r += c, s += E), Number.isNaN(c) || Number.isNaN(c) ? e.packetLostRate = 0 : e.packetLostRate = c <= 0 || E <= 0 ? 0 : E / (c + E) })); e.sendPacketLossRate = i <= 0 || o <= 0 ? 0 : o / (i + o), e.recvPacketLossRate = r <= 0 || s <= 0 ? 0 : s / (r + s) } } function OD(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function CD(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? OD(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OD(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class AD extends TD { constructor() { super(...arguments), hl(this, "_stats", _D), hl(this, "lastDecodeVideoReceiverStats", new Map) } async updateStats() { const e = await this._getStats(), t = this.statsResponsesToObjects(e); this._stats = rD(_D); const n = t.filter((e => "ssrc" === e.type)); this.processSSRCStats(n); const i = t.find((e => "VideoBwe" === e.type)); i && this.processBandwidthStats(i), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats } processBandwidthStats(e) { this._stats.bitrate = { actualEncoded: Number(e.googActualEncBitrate), targetEncoded: Number(e.googTargetEncBitrate), retransmit: Number(e.googRetransmitBitrate), transmit: Number(e.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e.googAvailableSendBandwidth) } processSSRCStats(e) { e.forEach((e => { const t = e.id.includes("send"); switch ("".concat(e.mediaType, "_").concat(t ? "send" : "recv")) { case "video_send": { const t = rD(uD); t.codec = e.googCodecName, t.adaptionChangeReason = "none", e.googCpuLimitedResolution && (t.adaptionChangeReason = "cpu"), e.googBandwidthLimitedResolution && (t.adaptionChangeReason = "bandwidth"), t.avgEncodeMs = Number(e.googAvgEncodeMs), t.inputFrame = { width: Number(e.googFrameWidthInput) || Number(e.googFrameWidthSent), height: Number(e.googFrameHeightInput) || Number(e.googFrameHeightSent), frameRate: Number(e.googFrameRateInput) }, t.sentFrame = { width: Number(e.googFrameWidthSent), height: Number(e.googFrameHeightSent), frameRate: Number(e.googFrameRateInput) }, t.firsCount = Number(e.googFirReceived), t.nacksCount = Number(e.googNacksReceived), t.plisCount = Number(e.googPlisReceived), t.frameCount = Number(e.framesEncoded), t.bytes = Number(e.bytesSent), t.packets = Number(e.packetsSent), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.rttMs = Number(e.googRtt || 0), this._stats.videoSend.push(t), this._stats.rtt = t.rttMs; break } case "video_recv": { const t = rD(dD), n = this.lastDecodeVideoReceiverStats.get(Number(e.ssrc)); if (t.codec = e.googCodecName, t.targetDelayMs = Number(e.googTargetDelayMs), t.renderDelayMs = Number(e.googRenderDelayMs), t.currentDelayMs = Number(e.googCurrentDelayMs), t.minPlayoutDelayMs = Number(e.googMinPlayoutDelayMs), t.decodeMs = Number(e.googDecodeMs), t.maxDecodeMs = Number(e.googMaxDecodeMs), t.receivedFrame = { width: Number(e.googFrameWidthReceived), height: Number(e.googFrameHeightReceived), frameRate: Number(e.googFrameRateReceived) }, t.decodedFrame = { width: Number(e.googFrameWidthReceived), height: Number(e.googFrameHeightReceived), frameRate: Number(e.googFrameRateDecoded) }, t.decodeFrameRate = Number(e.googFrameRateDecoded), t.outputFrame = { width: Number(e.googFrameWidthReceived), height: Number(e.googFrameHeightReceived), frameRate: Number(e.googFrameRateOutput) }, t.jitterBufferMs = Number(e.googJitterBufferMs), t.firsCount = Number(e.googFirsSent), t.nacksCount = Number(e.googNacksSent), t.plisCount = Number(e.googPlisSent), t.framesDecodeCount = Number(e.framesDecoded), t.bytes = Number(e.bytesReceived), t.packets = Number(e.packetsReceived), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.packets > 0 && !this.isFirstVideoReceived[t.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t.ssrc), this.isFirstVideoReceived[t.ssrc] = !0), t.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t.ssrc, t.decodedFrame.width, t.decodedFrame.height), this.isFirstVideoDecoded[t.ssrc] = !0), n) { const i = n.stats, r = Date.now() - n.lts; t.framesDecodeFreezeTime = i.framesDecodeFreezeTime, t.framesDecodeInterval = i.framesDecodeInterval, t.framesDecodeCount > i.framesDecodeCount && this.isFirstVideoDecoded[t.ssrc] ? (n.lts = Date.now(), t.framesDecodeInterval = r, t.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e.ssrc, 10)) ? t.framesDecodeFreezeTime += t.framesDecodeInterval : this.setVideoIsReady2(parseInt(e.ssrc, 10), !0))) : t.framesDecodeCount < n.stats.framesDecodeCount && (t.framesDecodeInterval = 0) } this.lastDecodeVideoReceiverStats.set(t.ssrc, { stats: CD({}, t), lts: Date.now() }), this._stats.videoRecv.push(t); break } case "audio_recv": { const t = rD(RD); t.codec = e.googCodecName, t.outputLevel = Math.abs(Number(e.audioOutputLevel)) / 32767, t.decodingCNG = Number(e.googDecodingCNG), t.decodingCTN = Number(e.googDecodingCTN), t.decodingCTSG = Number(e.googDecodingCTSG), t.decodingNormal = Number(e.googDecodingNormal), t.decodingPLC = Number(e.googDecodingPLC), t.decodingPLCCNG = Number(e.googDecodingPLCCNG), t.expandRate = Number(e.googExpandRate), t.accelerateRate = Number(e.googAccelerateRate), t.preemptiveExpandRate = Number(e.googPreemptiveExpandRate), t.secondaryDecodedRate = Number(e.googSecondaryDecodedRate), t.speechExpandRate = Number(e.googSpeechExpandRate), t.preferredJitterBufferMs = Number(e.googPreferredJitterBufferMs), t.jitterBufferMs = Number(e.googJitterBufferMs), t.jitterMs = Number(e.googJitterReceived), t.bytes = Number(e.bytesReceived), t.packets = Number(e.packetsReceived), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.receivedFrames = Number(e.googDecodingCTN) || Number(e.packetsReceived), t.droppedFrames = Number(e.googDecodingPLC) + Number(e.googDecodingPLCCNG) || Number(e.packetsLost), t.receivedFrames > 0 && !this.isFirstAudioReceived[t.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t.ssrc), this.isFirstAudioReceived[t.ssrc] = !0), t.decodingNormal > 0 && !this.isFirstAudioDecoded[t.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t.ssrc), this.isFirstAudioDecoded[t.ssrc] = !0), this._stats.audioRecv.push(t); break } case "audio_send": { const t = rD(lD); t.codec = e.googCodecName, t.inputLevel = Math.abs(Number(e.audioInputLevel)) / 32767, t.aecReturnLoss = Number(e.googEchoCancellationReturnLoss || 0), t.aecReturnLossEnhancement = Number(e.googEchoCancellationReturnLossEnhancement || 0), t.residualEchoLikelihood = Number(e.googResidualEchoLikelihood || 0), t.residualEchoLikelihoodRecentMax = Number(e.googResidualEchoLikelihoodRecentMax || 0), t.bytes = Number(e.bytesSent), t.packets = Number(e.packetsSent), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.rttMs = Number(e.googRtt || 0), this._stats.rtt = t.rttMs, this._stats.audioSend.push(t); break } } })) } _getStats() { return new Cd(((e, t) => { this.pc.getStats(e, t) })) } statsResponsesToObjects(e) { const t = []; return e.result().forEach((e => { const n = { id: e.id, timestamp: e.timestamp.valueOf().toString(), type: e.type }; e.names().forEach((t => { n[t] = e.stat(t) })), t.push(n) })), t } } function SD(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function gD(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? SD(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SD(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class mD extends TD { constructor() { super(...arguments), hl(this, "_stats", _D), hl(this, "report", void 0), hl(this, "lastDecodeVideoReceiverStats", new Map), hl(this, "lastVideoFramesRecv", new Map), hl(this, "lastVideoFramesSent", new Map), hl(this, "lastVideoFramesDecode", new Map), hl(this, "lastVideoJBDelay", new Map), hl(this, "lastAudioJBDelay", new Map), hl(this, "mediaBytesSent", new Map), hl(this, "mediaBytesRetransmit", new Map), hl(this, "mediaBytesTargetEncode", new Map), hl(this, "lastEncoderMs", new Map) } async updateStats() { this.report = await this.pc.getStats(), this._stats = rD(_D), this.report.forEach((e => { switch (e.type) { case Mu.OUTBOUND: "audio" === e.mediaType ? this.processAudioOutboundStats(e) : "video" === e.mediaType && this.processVideoOutboundStats(e); break; case Mu.INBOUND: "audio" === e.mediaType ? this.processAudioInboundStats(e) : "video" === e.mediaType && this.processVideoInboundStats(e); break; case Mu.TRANSPORT: { const t = this.report.get(e.selectedCandidatePairId); t && this.processCandidatePairStats(t); break } case Mu.CANDIDATE_PAIR: e.selected && this.processCandidatePairStats(e) } })), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats } async getSelectedCandidatePair() { const e = await this.pc.getStats(), t = { local: gD({}, ED), remote: gD({}, ED) }; return e.forEach((n => { let i; if (n.type === Mu.TRANSPORT && (i = e.get(n.selectedCandidatePairId)), n.type === Mu.CANDIDATE_PAIR && n.selected && (i = n), i) { const n = (e, t) => { e.type = t.type, e.id = t.id, t.address && (e.address = t.address), t.candidateType && (e.candidateType = t.candidateType), t.port && (e.port = t.port), t.priority && (e.priority = t.priority), t.protocol && (e.protocol = t.protocol), t.relayProtocol && (e.relayProtocol = t.relayProtocol) }; if (i.localCandidateId) { const r = e.get(i.localCandidateId); r && n(t.local, r) } if (i.remoteCandidateId) { const r = e.get(i.remoteCandidateId); r && n(t.remote, r) } } })), t } processCandidatePairStats(e) { if (this._stats.sendBandwidth = e.availableOutgoingBitrate || 0, e.currentRoundTripTime && (this._stats.rtt = 1e3 * e.currentRoundTripTime), this._stats.videoSend.forEach((t => { e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime) })), this._stats.audioSend.forEach((t => { e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime) })), this._stats.selectedCandidatePair.id = e.id, e.localCandidateId) { const t = this.report.get(e.localCandidateId); t && this.processCandidateStats(t) } if (e.remoteCandidateId) { const t = this.report.get(e.remoteCandidateId); t && this.processCandidateStats(t) } } processCandidateStats(e) { let t; e.type === Mu.LOCAL_CANDIDATE && (t = this._stats.selectedCandidatePair.localCandidate), e.type === Mu.REMOTE_CANDIDATE && (t = this._stats.selectedCandidatePair.remoteCandidate), t && (t.type = e.type, t.id = e.id, e.address && (t.address = e.address), e.candidateType && (t.candidateType = e.candidateType), e.port && (t.port = e.port), e.priority && (t.priority = e.priority), e.protocol && (t.protocol = e.protocol), e.relayProtocol && (t.relayProtocol = e.relayProtocol), e.type === Mu.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(gD({}, t), gD({}, this.stats.selectedCandidatePair.localCandidate)), e.type === Mu.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(gD({}, t), gD({}, this.stats.selectedCandidatePair.remoteCandidate))) } processAudioInboundStats(e) { let t = this._stats.audioRecv.find((t => t.ssrc === e.ssrc)); t || (t = rD(RD), this._stats.audioRecv.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsReceived, t.packetsLost = e.packetsLost, t.bytes = e.bytesReceived, t.jitterMs = 1e3 * e.jitter, this.processAudioTrackReceiverStats(e, e.trackId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), t.receivedFrames || (t.receivedFrames = e.packetsReceived), t.droppedFrames || (t.droppedFrames = e.packetsLost), t.receivedFrames > 0 && !this.isFirstAudioReceived[t.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t.ssrc), this.isFirstAudioReceived[t.ssrc] = !0), t.outputLevel && t.outputLevel > 0 && !this.isFirstAudioDecoded[t.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t.ssrc), this.isFirstAudioDecoded[t.ssrc] = !0), "number" == typeof e.concealedSamples && (t.concealedSamples = e.concealedSamples) } processVideoInboundStats(e) { let t = this._stats.videoRecv.find((t => t.ssrc === e.ssrc)); t || (t = rD(dD), this._stats.videoRecv.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsReceived, t.packetsLost = e.packetsLost, t.bytes = e.bytesReceived, t.firsCount = e.firCount, t.nacksCount = e.nackCount, t.plisCount = e.pliCount, t.framesDecodeCount = e.framesDecoded, t.totalInterFrameDelay = e.totalInterFrameDelay, t.totalSquaredInterFrameDelay = e.totalSquaredInterFrameDelay; const n = this.lastDecodeVideoReceiverStats.get(t.ssrc), i = this.lastVideoFramesDecode.get(t.ssrc), r = Date.now(); if (t.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t.ssrc]) { const e = t.decodedFrame ? t.decodedFrame.width : 0, n = t.decodedFrame ? t.decodedFrame.height : 0; this.onFirstVideoDecoded && this.onFirstVideoDecoded(t.ssrc, e, n), this.isFirstVideoDecoded[t.ssrc] = !0 } if (n) { const i = n.stats, o = r - n.lts; t.framesDecodeFreezeTime = i.framesDecodeFreezeTime, t.framesDecodeInterval = i.framesDecodeInterval, !this.isFirstVideoDecoded[t.ssrc] && o > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t.ssrc), this.isFirstVideoDecodedTimeout[t.ssrc] = !0), t.framesDecodeCount > i.framesDecodeCount && this.isFirstVideoDecoded[t.ssrc] ? (n.lts = Date.now(), t.framesDecodeInterval = o, t.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e.ssrc)) ? t.framesDecodeFreezeTime += t.framesDecodeInterval : this.setVideoIsReady2(parseInt(e.ssrc, 10), !0))) : t.framesDecodeCount < i.framesDecodeCount && (t.framesDecodeInterval = 0), e.framesDecoded && e.qpSum && (n.stats.framesDecodeCount > e.framesDecoded ? t.qpSumPerFrame = e.qpSum / e.framesDecoded : t.qpSumPerFrame = (e.qpSum - n.qpSum) / (e.framesDecoded - n.stats.framesDecodeCount)) } i && r - i.lts >= 800 ? (t.decodeFrameRate = Math.round((t.framesDecodeCount - i.count) / ((r - i.lts) / 1e3)), this.lastVideoFramesDecode.set(t.ssrc, { count: t.framesDecodeCount, lts: r, rate: t.decodeFrameRate })) : i ? t.decodeFrameRate = i.rate : this.lastVideoFramesDecode.set(t.ssrc, { count: t.framesDecodeCount, lts: r, rate: 0 }), e.totalDecodeTime && (t.decodeMs = 1e3 * e.totalDecodeTime), this.processVideoTrackReceiverStats(e, e.trackId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), e.framerateMean && (t.framesRateFirefox = e.framerateMean), t.packets > 0 && !this.isFirstVideoReceived[t.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t.ssrc), this.isFirstVideoReceived[t.ssrc] = !0), this.lastDecodeVideoReceiverStats.set(t.ssrc, { stats: gD({}, t), lts: n ? n.lts : Date.now(), qpSum: e.qpSum }) } processVideoOutboundStats(e) { let t = this._stats.videoSend.find((t => t.ssrc === e.ssrc)); t || (t = rD(uD), this._stats.videoSend.push(t)); const n = this.mediaBytesSent.get(e.ssrc); if (n) n.add(e.bytesSent); else { const t = new cD(10); t.add(e.bytesSent), this.mediaBytesSent.set(e.ssrc, t) } if (void 0 !== e.retransmittedBytesSent) { const t = this.mediaBytesRetransmit.get(e.ssrc); if (t) t.add(e.retransmittedBytesSent); else { const t = new cD(10); t.add(e.retransmittedBytesSent), this.mediaBytesRetransmit.set(e.ssrc, t) } } if (e.totalEncodedBytesTarget) { const t = this.mediaBytesTargetEncode.get(e.ssrc); if (t) t.add(e.totalEncodedBytesTarget); else { const t = new cD(10); t.add(e.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e.ssrc, t) } } if (t.ssrc = e.ssrc, t.bytes = e.bytesSent, t.packets = e.packetsSent, t.firsCount = e.firCount, t.nacksCount = e.nackCount, t.plisCount = e.pliCount, t.frameCount = e.framesEncoded, t.adaptionChangeReason = e.qualityLimitationReason, t.scalabilityMode = e.scalabilityMode, e.totalEncodeTime && e.framesEncoded) { const n = this.lastEncoderMs.get(e.ssrc); if (!n || n.lastFrameCount > e.framesEncoded) t.avgEncodeMs = 1e3 * e.totalEncodeTime / e.framesEncoded; else { const i = e.framesEncoded - n.lastFrameCount, r = e.totalEncodeTime - n.lastEncoderTime; t.avgEncodeMs = 1e3 * r / i } } if (e.framesEncoded && e.qpSum) { const n = this.lastEncoderMs.get(e.ssrc); !n || n.lastFrameCount > e.framesEncoded ? t.qpSumPerFrame = e.qpSum / e.framesEncoded : t.qpSumPerFrame = (e.qpSum - n.lastQpSum) / (e.framesEncoded - n.lastFrameCount) } if (this.lastEncoderMs.set(e.ssrc, { lastFrameCount: e.framesEncoded, lastEncoderTime: e.totalEncodeTime, lastQpSum: e.qpSum, lts: Date.now() }), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), e.mediaSourceId && this.processVideoMediaSource(e.mediaSourceId, t), this.processVideoTrackSenderStats(e, e.trackId, t), e.remoteId) this.processRemoteInboundStats(e.remoteId, t); else { const n = this.findRemoteStatsId(e.ssrc, Mu.REMOTE_INBOUND); n && this.processRemoteInboundStats(n, t) } } processAudioOutboundStats(e) { let t = this._stats.audioSend.find((t => t.ssrc === e.ssrc)); if (t || (t = rD(lD), this._stats.audioSend.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsSent, t.bytes = e.bytesSent, e.mediaSourceId && this.processAudioMediaSource(e.mediaSourceId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), this.processAudioTrackSenderStats(e, e.trackId, t), e.remoteId) this.processRemoteInboundStats(e.remoteId, t); else { const n = this.findRemoteStatsId(e.ssrc, Mu.REMOTE_INBOUND); n && this.processRemoteInboundStats(n, t) } } findRemoteStatsId(e, t) { var n; const i = Array.from(gS(n = this.report).call(n)).find((n => n.type === t && n.ssrc === e)); return i ? i.id : null } processVideoMediaSource(e, t) { const n = this.report.get(e); n && n.width && n.height && n.framesPerSecond && (t.inputFrame = { width: n.width, height: n.height, frameRate: n.framesPerSecond }) } processAudioMediaSource(e, t) { const n = this.report.get(e); n && (t.inputLevel = n.audioLevel) } processVideoTrackSenderStats(e, t, n) { var i, r, o; const s = t ? this.report.get(t) : void 0, a = null !== (i = null == s ? void 0 : s.framesSent) && void 0 !== i ? i : e.framesSent; let c = null !== (r = null == s ? void 0 : s.frameWidth) && void 0 !== r ? r : e.frameWidth, E = null !== (o = null == s ? void 0 : s.frameHeight) && void 0 !== o ? o : e.frameHeight; if ("number" != typeof a) return; "number" == typeof c && "number" == typeof E || (c = 0, E = 0); let _ = 0; const d = Date.now(), u = this.lastVideoFramesSent.get(n.ssrc); u && d - u.lts >= 800 ? (_ = Math.round((a - u.count) / ((d - u.lts) / 1e3)), this.lastVideoFramesSent.set(n.ssrc, { count: a, lts: d, rate: _ })) : u ? _ = u.rate : this.lastVideoFramesSent.set(n.ssrc, { count: a, lts: d, rate: 0 }), n.sentFrame = { width: c, height: E, frameRate: Math.max(0, _) } } processVideoTrackReceiverStats(e, t, n) { var i, r, o, s, a; const c = t ? this.report.get(t) : void 0, E = null !== (i = null == c ? void 0 : c.framesReceived) && void 0 !== i ? i : e.framesReceived, _ = null !== (r = null == c ? void 0 : c.frameWidth) && void 0 !== r ? r : e.frameWidth, d = null !== (o = null == c ? void 0 : c.frameHeight) && void 0 !== o ? o : e.frameHeight, u = null !== (s = null == c ? void 0 : c.jitterBufferDelay) && void 0 !== s ? s : e.jitterBufferDelay, l = null !== (a = null == c ? void 0 : c.jitterBufferEmittedCount) && void 0 !== a ? a : e.jitterBufferEmittedCount; if ("number" == typeof E) { const e = this.lastVideoFramesRecv.get(n.ssrc), t = Date.now(); n.framesReceivedCount = E; let i = 0; e && t - e.lts >= 800 ? (i = Math.round((E - e.count) / ((t - e.lts) / 1e3)), this.lastVideoFramesRecv.set(n.ssrc, { count: E, lts: t, rate: i })) : e ? i = e.rate : this.lastVideoFramesRecv.set(n.ssrc, { count: E, lts: t, rate: 0 }), n.receivedFrame = { width: _ || 0, height: d || 0, frameRate: i || 0 }, n.decodedFrame = { width: _ || 0, height: d || 0, frameRate: n.decodeFrameRate || 0 }, n.outputFrame = { width: _ || 0, height: d || 0, frameRate: n.decodeFrameRate || 0 } } if (u && l) { let e = this.lastVideoJBDelay.get(n.ssrc); this.lastVideoJBDelay.set(n.ssrc, { jitterBufferDelay: u, jitterBufferEmittedCount: l }), e || (e = { jitterBufferDelay: 0, jitterBufferEmittedCount: 0 }); const t = 1e3 * (u - e.jitterBufferDelay) / (l - e.jitterBufferEmittedCount); n.jitterBufferMs = t, n.currentDelayMs = Math.round(t) } } processAudioTrackSenderStats(e, t, n) { var i, r, o, s; const a = t ? this.report.get(t) : void 0, c = null !== (i = null !== (r = null == a ? void 0 : a.echoReturnLoss) && void 0 !== r ? r : e.echoReturnLoss) && void 0 !== i ? i : 0, E = null !== (o = null !== (s = null == a ? void 0 : a.echoReturnLossEnhancement) && void 0 !== s ? s : e.echoReturnLossEnhancement) && void 0 !== o ? o : 0; n.aecReturnLoss = c, n.aecReturnLossEnhancement = E } processAudioTrackReceiverStats(e, t, n) { var i, r, o, s, a, c, E; const _ = t ? this.report.get(t) : void 0, d = null !== (i = null == _ ? void 0 : _.removedSamplesForAcceleration) && void 0 !== i ? i : e.removedSamplesForAcceleration, u = null !== (r = null == _ ? void 0 : _.totalSamplesReceived) && void 0 !== r ? r : e.totalSamplesReceived, l = null !== (o = null == _ ? void 0 : _.jitterBufferDelay) && void 0 !== o ? o : e.jitterBufferDelay, R = null !== (s = null == _ ? void 0 : _.jitterBufferEmittedCount) && void 0 !== s ? s : e.jitterBufferEmittedCount, h = null !== (a = null == _ ? void 0 : _.audioLevel) && void 0 !== a ? a : null == e ? void 0 : e.audioLevel, p = null !== (c = null == _ ? void 0 : _.totalSamplesDuration) && void 0 !== c ? c : null == e ? void 0 : e.totalSamplesDuration, T = null !== (E = null == _ ? void 0 : _.concealedSamples) && void 0 !== E ? E : e.concealedSamples; if (d && u && (n.accelerateRate = d / u), l && R) { let e = this.lastAudioJBDelay.get(n.ssrc); this.lastAudioJBDelay.set(n.ssrc, { jitterBufferDelay: l, jitterBufferEmittedCount: R }), e || (e = { jitterBufferDelay: 0, jitterBufferEmittedCount: 0 }); const t = 1e3 * (l - e.jitterBufferDelay) / (R - e.jitterBufferEmittedCount); n.jitterBufferMs = Math.round(t) } n.outputLevel = h; let O = 1920; p && u && (O = u / p / 50, n.receivedFrames = Math.round(u / O)), T && (n.droppedFrames = Math.round(T / O)) } processRemoteInboundStats(e, t) { const n = this.report.get(e); n && (t.packetsLost = n.packetsLost, n.roundTripTime && (t.rttMs = 1e3 * n.roundTripTime)) } getCodecFromCodecStats(e) { const t = this.report.get(e); if (!t) return ""; const n = t.mimeType.match(/\/(.*)$/); return n && n[1] ? n[1] : "" } updateSendBitrate() { let e = 0, t = null, n = null; this.mediaBytesSent.forEach((t => { e += t.diffMean() })), this.mediaBytesRetransmit.forEach((e => { t = null === t ? e.diffMean() : t + e.diffMean() })), this.mediaBytesTargetEncode.forEach((e => { n = null === n ? e.diffMean() : n + e.diffMean() })); const i = null !== t ? e - t : e; this._stats.bitrate = { actualEncoded: 8 * i / (this.options.updateInterval / 1e3), transmit: 8 * e / (this.options.updateInterval / 1e3) }, null !== t && (this._stats.bitrate.retransmit = 8 * t / (this.options.updateInterval / 1e3)), null !== n && (this._stats.bitrate.targetEncoded = 8 * n / (this.options.updateInterval / 1e3)) } } class ID extends TD { updateStats() { return Cd.resolve() } } function fD(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500, r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4; const o = sD(); return o ? o < 76 ? new AD(e, { updateInterval: t, lossRateInterval: n, freezeRateLimit: i, firstVideoDecodedTimeout: r }) : new mD(e, { updateInterval: t, lossRateInterval: n, freezeRateLimit: i, firstVideoDecodedTimeout: r }) : aD(e) ? new mD(e, { updateInterval: t, lossRateInterval: n, freezeRateLimit: i, firstVideoDecodedTimeout: r }) : new ID(e, { updateInterval: t, lossRateInterval: n, freezeRateLimit: i, firstVideoDecodedTimeout: r }) } var PD; function ND(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function DD(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? ND(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ND(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } let vD = (aA((PD = class e extends KO { get peerConnectionState() { return this.peerConnection.connectionState } get iceConnectionState() { return this.peerConnection.iceConnectionState } get currentLocalDescription() { return this.peerConnection.currentLocalDescription } get currentRemoteDescription() { return this.peerConnection.currentRemoteDescription } constructor(t, n) { super(t, n), hl(this, "store", void 0), hl(this, "peerConnection", void 0), hl(this, "remoteSDP", void 0), hl(this, "initialOffer", void 0), hl(this, "statsFilter", void 0), hl(this, "useRTX", !1), hl(this, "localCapabilities", void 0), hl(this, "localCandidateCount", 0), hl(this, "allCandidatesReceived", !1), hl(this, "establishPromise", void 0), hl(this, "mutex", new kA("P2PConnection-mutex")), this.store = n, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), { optional: [{ googDscp: !0 }] }), this.statsFilter = fD(this.peerConnection, jh("STATS_UPDATE_INTERVAL"), void 0, Ku() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish() } async establish() { try { const e = await this.peerConnection.createOffer({ offerToReceiveAudio: !0, offerToReceiveVideo: !0 }); if (!e.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection."); const t = BN(e.sdp), n = YN(e.sdp, !this.useRTX, jh("FILTER_VIDEO_FEC"), jh("FILTER_AUDIO_FEC"), ["opus"]); return this.localCapabilities = n, this.initialOffer = e, DD(DD({}, t), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: n }, offerSDP: e.sdp }) } catch (e) { throw new Ch(Oh.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString()) } } async connect(e, t, n, i, r, o) { try { if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer."); this.remoteSDP = new iD({ remoteIceParameters: e, remoteDtlsParameters: t, candidates: n, remoteRTPCapabilities: i.send, remoteSetup: r, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec, cname: o }); const s = this.remoteSDP.toString(); await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e.toString())) } } send(e, t) { var n = this; return wN((function* () { const i = yield bN(n.mutex.lock()); try { if (!n.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created"); const i = e.map((e => n.peerConnection.addTrack(e._mediaStreamTrack))), r = yield bN(n.peerConnection.createOffer()), o = VN.exports.parse(r.sdp), s = e.map((e => { const t = e._mediaStreamTrack, i = o.mediaDescriptions.find((e => e.attributes.mid === t.kind)); if (!i) throw new Error("Cannot extract ssrc from mediaDescription."); return function (e, t, n) { const i = e.attributes.ssrcs.filter((e => e.attributes.label === t)), r = e.attributes.ssrcGroups; if (0 === i.length) throw new Error("Cannot extract ssrc from plan-b SDP."); if (r && i.length > 1) { const e = r.find((e => -1 !== e.ssrcIds.indexOf(i[0].ssrcId))); return e ? [{ ssrcId: e.ssrcIds[0], rtx: n ? e.ssrcIds[1] : void 0 }] : [{ ssrcId: i[0].ssrcId }] } return [{ ssrcId: i[0].ssrcId }] }(i, t.id, n.useRTX) })); let a; try { a = yield s } catch (e) { throw i.forEach((e => { Wu() && e.replaceTrack(null), n.peerConnection.removeTrack(e) })), e } const c = n.mungSendOfferSDP(r.sdp, e); n.remoteSDP.receive(e, t, a); const E = n.remoteSDP.toString(); return yield bN(n.peerConnection.setLocalDescription({ type: "offer", sdp: c })), yield bN(n.applySendEncodings(i, e)), yield bN(n.peerConnection.setRemoteDescription({ type: "answer", sdp: E })), e.map(((e, t) => { const n = e._mediaStreamTrack.id; return { localSSRC: s[t], id: n } })) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e.toString())) } finally { i() } }))() } async stopSending(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created"); const t = this.peerConnection.getSenders().filter((t => { var n; return -1 !== e.indexOf((null === (n = t.track) || void 0 === n ? void 0 : n.id) || "") })); if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending."); t.map((e => { Wu() && e.replaceTrack(null), this.peerConnection.removeTrack(e) })); const n = await this.peerConnection.createOffer(); await this.peerConnection.setLocalDescription(n), this.remoteSDP.stopReceiving(e); const i = this.remoteSDP.toString(); await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e.toString())) } } async receive(e, t, n, i) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e, " before remoteSDP created.")); const { id: n, mslabel: r } = this.remoteSDP.send(e, t, i), o = new Cd(((t, i) => { const o = setTimeout((() => { i(new Error("Cannot receive track, id: ".concat(n))) }), 1e4), s = i => { const a = xu(); if (("Safari" === a.name && 11 === Number(a.version) || Ju()) && i.track.id !== n && i.streams[0].id === r) { var c; const r = i.streams[0].getTracks()[0]; return null === (c = this.remoteSDP) || void 0 === c || c.updateTrackLabel(e, n, i.track.id), this.peerConnection.removeEventListener("track", s), clearTimeout(o), void t(r) } if (i.track.id === n) return this.peerConnection.removeEventListener("track", s), clearTimeout(o), void t(i.track) }; this.peerConnection.addEventListener("track", s) })), s = this.remoteSDP.toString(); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s }); const a = await this.peerConnection.createAnswer(); return await this.peerConnection.setLocalDescription(a), { track: await o, id: n } } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e.toString())) } } async stopReceiving(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created."); this.remoteSDP.stopSending(e); const t = this.remoteSDP.toString(); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t }); const n = await this.peerConnection.createAnswer(); await this.peerConnection.setLocalDescription(n) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e.toString())) } } async muteRemote(e) { } async unmuteRemote(e) { } async muteLocal(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created."); const t = this.peerConnection.getSenders().filter((t => { var n; return -1 !== e.indexOf((null === (n = t.track) || void 0 === n ? void 0 : n.id) || "") })); if (t.length !== e.length) throw new Error("sender' length doesn't match mids' length."); t.map((e => { if (Wu() && e.track) e.track.enabled = !1; else { const t = e.getParameters(); t.encodings.forEach((e => e.active = !1)), e.setParameters(t) } })) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e.toString())) } } async unmuteLocal(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created."); const t = this.peerConnection.getSenders().filter((t => { var n; return -1 !== e.indexOf((null === (n = t.track) || void 0 === n ? void 0 : n.id) || "") })); if (t.length !== e.length) throw new Error("Senders' length doesn't match mids' length."); t.map((async e => { if (Wu() && e.track) e.track.enabled = !0; else { const t = e.getParameters(); t.encodings.forEach((e => e.active = !0)), await e.setParameters(t) } })); const n = await this.peerConnection.createOffer(); await this.peerConnection.setLocalDescription(n); const i = this.remoteSDP.toString(); await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e.toString())) } } restartICE(e) { var t = this; return wN((function* () { const n = yield bN(t.mutex.lock("From P2PConnection.restartICE")); try { if (!t.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created."); if (XO().supportPCSetConfiguration) { const n = t.peerConnection.getConfiguration(), i = e === NO.RELAY ? "relay" : "all"; n.iceTransportPolicy !== i && (Dh.debug("[".concat(t.store.clientId, "] restartICE change iceTransportPolicy from [").concat(n.iceTransportPolicy, "] to [").concat(i, "]")), n.iceTransportPolicy = i, t.peerConnection.setConfiguration(n)) } else if (e === NO.RELAY) return; e !== NO.RELAY && t.remoteSDP.updateCandidates(e); const n = yield bN(t.peerConnection.createOffer({ iceRestart: !0 })); if (!n.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist."); const i = BN(n.sdp), { remoteIceParameters: r } = yield i.iceParameters; t.remoteSDP.restartICE(r); const o = t.remoteSDP.toString(); yield bN(t.peerConnection.setLocalDescription(n)), yield bN(t.peerConnection.setRemoteDescription({ type: "answer", sdp: o })) } catch (e) { Dh.warning("[".concat(t.store.clientId, "] restart ICE failed, abort operation"), e) } finally { n() } }))() } close() { var e; this.peerConnection.close(), null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy() } getStats() { return this.statsFilter.getStats() } getRemoteVideoIsReady(e) { return this.statsFilter.getVideoIsReady(e) } async updateEncoderConfig(e, t) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created."); const e = await this.peerConnection.createOffer(), n = this.mungSendOfferSDP(e.sdp, [t]); this.remoteSDP.updateRecvMedia(t._mediaStreamTrack.kind, t); const i = this.remoteSDP.toString(); await this.peerConnection.setLocalDescription({ type: "offer", sdp: n }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, e.toString()) } } async updateSendParameters(e, t) { const n = this.peerConnection.getSenders().filter((t => { var n; return (null === (n = t.track) || void 0 === n ? void 0 : n.id) === e })); 1 === n.length && await this.applySendEncodings(n, [t]) } setStatsRemoteVideoIsReady(e, t) { this.statsFilter.setVideoIsReady2(e, t) } async replaceTrack(e, t) { const n = this.peerConnection.getSenders().find((e => { var n; return (null === (n = e.track) || void 0 === n ? void 0 : n.id) === t })); n && await n.replaceTrack(e._mediaStreamTrack) } bindPCEvents() { this.peerConnection.oniceconnectionstatechange = () => { var e; null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState) }, this.peerConnection.onconnectionstatechange = () => { var e; null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState) }, this.peerConnection.onicecandidate = e => { e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, Dh.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount)) }, setTimeout((() => { this.allCandidatesReceived || (this.allCandidatesReceived = !0, Dh.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount)) }), jh("CANDIDATE_TIMEOUT")) } unbindPCEvents() { this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null } static resolvePCConfiguration(t) { const n = { iceServers: [], sdpSemantics: "plan-b" }; return t.iceServers ? n.iceServers = t.iceServers : t.turnServer && "off" !== t.turnServer.mode && (kT(t.turnServer.servers) ? n.iceServers = t.turnServer.servers : (n.iceServers && n.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), jh("USE_TURN_SERVER_OF_GATEWAY") && n.iceServers && t.turnServer.serversFromGateway && n.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach((e => { e.forceturn && (n.iceTransportPolicy = "relay") })))), n } static turnServerConfigToIceServers(e) { const t = []; return e.forEach((e => { e.security ? e.tcpport && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turns:".concat(e.turnServerURL, ":").concat(e.tcpport, "?transport=tcp") }) : (e.udpport && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turn:".concat(e.turnServerURL, ":").concat(e.udpport, "?transport=udp") }), e.tcpport && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turn:".concat(e.turnServerURL, ":").concat(e.tcpport, "?transport=tcp") })) })), t } async applySendEncodings(e, t) { try { if (!XO().supportSetRtpSenderParameters) return; if (e.length !== t.length) return; for (let i = 0; i < e.length; i++) { var n; const r = e[i], o = t[i]; if (!o) continue; const s = {}, a = {}; if (o instanceof If) switch (o._optimizationMode) { case "motion": s.degradationPreference = "maintain-framerate"; break; case "detail": s.degradationPreference = "maintain-resolution"; break; default: s.degradationPreference = "balanced" }if (jh("DSCP_TYPE") && ol()) { const e = jh("DSCP_TYPE");["very-low", "low", "medium", "high"].includes(e) && (a.networkPriority = e) } const c = r.getParameters(), E = null === (n = c.encodings) || void 0 === n ? void 0 : n[0]; E && Object.assign(E, a), Object.assign(c, s), await r.setParameters(c) } } catch (e) { Dh.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed.")) } } mungSendOfferSDP(e, t) { const n = VN.exports.parse(e); return t.forEach(((e, t) => { const i = e._mediaStreamTrack, r = n.mediaDescriptions.find((e => e.attributes.mid === i.kind)); r && WN(r, e) })), VN.exports.print(n) } bindStatsEvents() { this.statsFilter.onFirstAudioReceived = e => { var t; null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e) }, this.statsFilter.onFirstVideoReceived = e => { var t; null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e) }, this.statsFilter.onFirstAudioDecoded = e => { var t; null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e) }, this.statsFilter.onFirstVideoDecoded = (e, t, n) => { var i; null === (i = this.onFirstVideoDecoded) || void 0 === i || i.call(this, e, t, n) }, this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => { var n; null === (n = this.onSelectedLocalCandidateChanged) || void 0 === n || n.call(this, e, t) }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => { var n; null === (n = this.onSelectedRemoteCandidateChanged) || void 0 === n || n.call(this, e, t) } } unbindStatsEvents() { this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0 } async batchReceive(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created."); const t = this.remoteSDP.batchSend(e).map(((t, n) => { let { id: i, mslabel: r } = t; const { kind: o } = e[n]; return new Cd(((e, t) => { const n = setTimeout((() => { t(new Error("Cannot receive track, id: ".concat(i))) }), 1e4), s = t => { const a = xu(); if ("Safari" === a.name && 11 === Number(a.version) && t.track.id !== i && t.streams[0].id === r) { var c; const r = t.streams[0].getTracks()[0]; return null === (c = this.remoteSDP) || void 0 === c || c.updateTrackLabel(o, i, t.track.id), this.peerConnection.removeEventListener("track", s), clearTimeout(n), void e({ track: r, id: i }) } if (t.track.id === i) return this.peerConnection.removeEventListener("track", s), clearTimeout(n), void e({ track: t.track, id: i }) }; this.peerConnection.addEventListener("track", s) })) })), n = this.remoteSDP.toString(); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: n }); const i = await this.peerConnection.createAnswer(); return await this.peerConnection.setLocalDescription(i), await Cd.all(t) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e.toString())) } } async getRemoteSSRC(e) { if (!this.remoteSDP) return; const t = this.remoteSDP.getSSRC(e); return null == t ? void 0 : t[0].ssrcId } setConfiguration(t) { if (XO().supportPCSetConfiguration) { const n = e.resolvePCConfiguration(t); this.peerConnection.setConfiguration(n) } } }).prototype, "connect", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "connect"), PD.prototype), aA(PD.prototype, "stopSending", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "stopSending"), PD.prototype), aA(PD.prototype, "receive", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "receive"), PD.prototype), aA(PD.prototype, "stopReceiving", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "stopReceiving"), PD.prototype), aA(PD.prototype, "muteRemote", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "muteRemote"), PD.prototype), aA(PD.prototype, "unmuteRemote", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "unmuteRemote"), PD.prototype), aA(PD.prototype, "muteLocal", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "muteLocal"), PD.prototype), aA(PD.prototype, "unmuteLocal", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "unmuteLocal"), PD.prototype), aA(PD.prototype, "close", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "close"), PD.prototype), aA(PD.prototype, "updateEncoderConfig", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "updateEncoderConfig"), PD.prototype), aA(PD.prototype, "updateSendParameters", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "updateSendParameters"), PD.prototype), aA(PD.prototype, "replaceTrack", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "replaceTrack"), PD.prototype), aA(PD.prototype, "getRemoteSSRC", [yD], Object.getOwnPropertyDescriptor(PD.prototype, "getRemoteSSRC"), PD.prototype), PD); function yD(e, t, n) { const i = e[t]; if ("function" != typeof i) throw new Error("Cannot use mutex on object property."); return n.value = async function () { const e = this.mutex, n = await e.lock("Locking from P2PConnection.".concat(t)); try { for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++)o[s] = arguments[s]; return await i.apply(this, o) } finally { n() } }, n } function LD(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function wD(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? LD(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LD(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } const bD = "9", UD = 4e4; class MD { get localCapabilities() { return _m(this._localCapabilities) } get rtpCapabilities() { return _m(this._rtpCapabilities) } get candidates() { return _m(this._candidates) } get iceParameters() { return _m(this._iceParameters) } get dtlsParameters() { return _m(this._dtlsParameters) } constructor(e) { hl(this, "sessionDesc", void 0), hl(this, "_localCapabilities", void 0), hl(this, "_rtpCapabilities", void 0), hl(this, "_candidates", void 0), hl(this, "_iceParameters", void 0), hl(this, "_dtlsParameters", void 0), hl(this, "setup", void 0), hl(this, "currentMidIndex", void 0), hl(this, "cname", void 0), hl(this, "firefoxSsrcMidMap", new Map), e = _m(e); const { remoteIceParameters: t, remoteDtlsParameters: n, candidates: i, remoteRTPCapabilities: r, remoteSetup: o, localCapabilities: s, cname: a } = e, c = VN.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n"); this._rtpCapabilities = r, this._candidates = i, this._iceParameters = t, this._dtlsParameters = n, this._localCapabilities = s, this.setup = o, this.cname = a; const E = this.rtpCapabilities.send; for (const _ of c.mediaDescriptions) { if (_.attributes.iceUfrag = t.iceUfrag, _.attributes.icePwd = t.icePwd, _.attributes.fingerprints = n.fingerprints, _.attributes.candidates = i, _.attributes.setup = o, "video" === _.media.mediaType && (_.media.fmts = E.videoCodecs.map((e => e.payloadType.toString(10))), _.attributes.payloads = E.videoCodecs, _.attributes.extmaps = E.videoExtensions, jh("PRELOAD_MEDIA_COUNT") > 0)) { const { ssrcs: e, ssrcGroups: t } = HN([{ ssrcId: UD, rtx: jh("USE_SUB_RTX") ? 40001 : void 0 }], this.cname); _.attributes.ssrcs = e, _.attributes.ssrcGroups = t } if ("audio" === _.media.mediaType && (_.media.fmts = E.audioCodecs.map((e => e.payloadType.toString(10))), _.attributes.payloads = E.audioCodecs, _.attributes.extmaps = E.audioExtensions, eD(_), jh("PRELOAD_MEDIA_COUNT") > 0)) { const { ssrcs: e, ssrcGroups: t } = HN([{ ssrcId: 2e4 }], this.cname); _.attributes.ssrcs = e, _.attributes.ssrcGroups = t } } this.sessionDesc = c, this.currentMidIndex = c.mediaDescriptions.length - 1 } preloadRemoteMedia() { const e = jh("PRELOAD_MEDIA_COUNT"); this.rtpCapabilities; const t = this.candidates, n = this.dtlsParameters, i = this.iceParameters, r = this.rtpCapabilities.send; for (let o = 1; o < e; o++) { const e = 2 * o + 2e4, s = 2 * o + UD, { ssrcs: a, ssrcGroups: c } = HN([{ ssrcId: e }], this.cname), { ssrcs: E, ssrcGroups: _ } = HN([{ ssrcId: s, rtx: jh("USE_SUB_RTX") ? s + 1 : void 0 }], this.cname); this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: bD, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r.videoCodecs.map((e => e.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: i.iceUfrag, icePwd: i.icePwd, unrecognized: [], candidates: t, extmaps: r.videoExtensions, fingerprints: n.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: E, ssrcGroups: _, rtcpFeedbackWildcards: [], payloads: r.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: !0, rtcpRsize: !0, mid: "".concat(2 * o) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: bD, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r.audioCodecs.map((e => e.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: i.iceUfrag, icePwd: i.icePwd, unrecognized: [], candidates: t, extmaps: r.audioExtensions, fingerprints: n.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a, ssrcGroups: c, rtcpFeedbackWildcards: [], payloads: r.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: !0, rtcpRsize: !0, mid: "".concat(2 * o + 1) } }), this.currentMidIndex += 2 } this.updateBundleMids() } toString() { return VN.exports.print(this.sessionDesc) } send(e, t, n, i) { const { ssrcs: r, ssrcGroups: o } = HN(t, this.cname, jh("SYNC_GROUP") ? n : void 0), s = this.findPreloadMediaDesc(r); if (s) { if (Ku() && this.firefoxSsrcMidMap.set(r[0].ssrcId, s.attributes.mid), i && (i.twcc || i.remb)) { const e = this.sessionDesc.mediaDescriptions.indexOf(s); return this.sessionDesc.mediaDescriptions[e] = this.mungSendMediaDesc(s, i), { mid: s.attributes.mid, needExchangeSDP: !0 } } return { mid: s.attributes.mid, needExchangeSDP: !1 } } { const t = this.findAvailableMediaIndex(e, r); let n; return -1 === t || 1 === t && (Wu() || zu()) || 0 === t && jh("USE_SUB_RTX") || Zu() ? (n = this.createOrRecycleSendMedia(e, r, o, "sendonly", i), this.updateBundleMids()) : (n = _m(this.sessionDesc.mediaDescriptions[t]), n.attributes.direction = "sendonly", n.attributes.ssrcs = r, n.attributes.ssrcGroups = o, this.sessionDesc.mediaDescriptions[t] = this.mungSendMediaDesc(n, i)), Ku() && this.firefoxSsrcMidMap.set(r[0].ssrcId, n.attributes.mid), { mid: n.attributes.mid, needExchangeSDP: !0 } } } batchSend(e) { const t = e.map((e => { let { kind: t, ssrcMsg: n, mslabel: i } = e; return this.send(t, n, i) })), n = []; let i = !1; return t.forEach((e => { let { mid: t, needExchangeSDP: r } = e; r && (i = !0), n.push(t) })), { mids: n, needExchangeSDP: i } } stopSending(e) { const t = this.sessionDesc.mediaDescriptions.filter((t => t.attributes.mid && -1 !== e.indexOf(t.attributes.mid))); if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending."); t.forEach((e => { "0" === e.attributes.mid || Ku() || Zu() ? e.attributes.ssrcs = [] : (e.attributes.ssrcs = [], e.attributes.direction = "inactive", e.media.port = "0") })), this.updateBundleMids() } mute(e) { const t = this.sessionDesc.mediaDescriptions.find((t => t.attributes.mid === e)); if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.mute.")); t.attributes.direction = "inactive" } unmute(e) { const t = this.sessionDesc.mediaDescriptions.find((t => t.attributes.mid === e)); if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.unmute.")); t.attributes.direction = "sendonly" } muteRemote(e) { const t = this.sessionDesc.mediaDescriptions.filter((t => e.includes(t.attributes.mid || ""))); if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote."); t.forEach((e => { e.attributes.direction = "inactive" })) } unmuteRemote(e) { const t = this.sessionDesc.mediaDescriptions.filter((t => e.includes(t.attributes.mid || ""))); if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote."); t.forEach((e => { e.attributes.direction = "recvonly" })) } receive(e, t, n, i) { e.forEach(((e, r) => { this.createOrRecycleRecvMedia(e, [], "recvonly", t, n, i[r]) })), this.updateBundleMids() } stopReceiving(e) { const t = this.sessionDesc.mediaDescriptions.filter((t => -1 !== e.indexOf(t.attributes.mid))); if (t.length !== e.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive."); t.forEach((e => { e.media.port = "0", e.attributes.direction = "inactive" })), this.updateBundleMids() } updateCandidates(e) { e === NO.TCP ? this._candidates.forEach((e => { -1 === this._candidates.findIndex((t => "tcp" === t.transport && t.connectionAddress === e.connectionAddress && t.port === e.port)) && this._candidates.push(wD(wD({}, e), {}, { foundation: "tcpcandidate", priority: Number(e.priority) - 1 + "", transport: "tcp", port: Number(e.port) + 90 + "" })) })) : this._candidates = this._candidates.filter((e => "tcp" !== e.transport)); for (const t of this.sessionDesc.mediaDescriptions) t.attributes.candidates = this.candidates } restartICE(e) { e = _m(e), this._iceParameters = e, this.sessionDesc.mediaDescriptions.forEach((t => { t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd })) } predictReceivingMids(e) { const t = []; for (let n = 0; n < e; n++)t.push((this.currentMidIndex + n + 1).toString(10)); return t } findAvailableMediaIndex(e, t) { return this.sessionDesc.mediaDescriptions.findIndex((n => { const i = n.media.mediaType === e && "0" !== n.media.port && ("sendonly" === n.attributes.direction || "sendrecv" === n.attributes.direction) && 0 === n.attributes.ssrcs.length; if (Ku()) { if (i) { const e = this.firefoxSsrcMidMap.get(t[0].ssrcId); return !(e || "0" !== n.attributes.mid && "1" !== n.attributes.mid) || !(!e || e !== n.attributes.mid) } return !1 } return i })) } createOrRecycleRecvMedia(e, t, n, i, r, o) { const s = e._mediaStreamTrack.kind, a = this.rtpCapabilities.recv, c = this.localCapabilities.send; let E = []; if (s === PO.VIDEO) { var _, d; if (jh("H264_PROFILE_LEVEL_ID") && "h264" === i && (E = a.videoCodecs.filter((e => { var t, n; return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(i) && (null == e || null === (n = e.fmtp) || void 0 === n ? void 0 : n.parameters["profile-level-id"]) === jh("H264_PROFILE_LEVEL_ID") }))), !E || 0 === (null === (_ = E) || void 0 === _ ? void 0 : _.length)) { const e = c.videoCodecs.filter((e => { var t; return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(i) })); 0 !== e.length && (E = a.videoCodecs.filter((t => e.some((e => e.payloadType === t.payloadType))))) } if (jh("USE_PUB_RTX")) { const e = E.map((e => e.payloadType.toString())), t = a.videoCodecs.filter((t => { var n, i; return "rtx" === (null === (n = t.rtpMap) || void 0 === n ? void 0 : n.encodingName) && e.includes((null === (i = t.fmtp) || void 0 === i ? void 0 : i.parameters.apt) || "") })); E = [...E, ...t] } 0 === E.length && (Dh.warning("codec ".concat(i, " not included in rtpCapabilities, fallback to default payloads: ").concat(null === (d = a.videoCodecs[0].rtpMap) || void 0 === d ? void 0 : d.encodingName)), E = a.videoCodecs) } else E = a.audioCodecs.filter((e => { var t; return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(r) })), 0 === E.length && (Dh.warning("codec ".concat(r, " not included in rtpCapabilities, fallback to opus")), E = a.audioCodecs.filter((e => { var t; return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes("opus") }))); const u = s === PO.VIDEO ? a.videoExtensions : a.audioExtensions; this.currentMidIndex += 1; const l = "".concat(this.currentMidIndex); let R = { media: { mediaType: s, port: bD, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: E.map((e => e.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: u, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: E, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n, rtcpMux: !0, rtcpRsize: !0, mid: "".concat(l) } }; R = this.mungRecvMediaDsec(R, e, o); const h = this.findFirstClosedMedia(s); if (h) { const e = this.sessionDesc.mediaDescriptions.indexOf(h); this.sessionDesc.mediaDescriptions[e] = R } else this.sessionDesc.mediaDescriptions.push(R); return R } createOrRecycleSendMedia(e, t, n, i, r) { const o = this.rtpCapabilities.send, s = e === PO.VIDEO ? o.videoCodecs : o.audioCodecs, a = e === PO.VIDEO ? o.videoExtensions : o.audioExtensions; this.currentMidIndex += 1; const c = "".concat(this.currentMidIndex); let E = { media: { mediaType: e, port: bD, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s.map((e => e.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t, ssrcGroups: n, rtcpFeedbackWildcards: [], payloads: s, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i, rtcpMux: !0, rtcpRsize: !0, mid: "".concat(c) } }; E = this.mungSendMediaDesc(E, r); const _ = this.findFirstClosedMedia(e); if (_) { const e = this.sessionDesc.mediaDescriptions.indexOf(_); this.sessionDesc.mediaDescriptions[e] = E } else this.sessionDesc.mediaDescriptions.push(E); return E } updateBundleMids() { this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e => "0" !== e.media.port)).map((e => e.attributes.mid)) } mungRecvMediaDsec(e, t, n) { const i = _m(e); return KN(i), WN(i, t), JN(i, t), XN(i), qN(i, n, this.localCapabilities.send), i } mungSendMediaDesc(e, t) { const n = _m(e); return qN(n, t, this.localCapabilities.recv), eD(n), n } updateRecvMedia(e, t) { const n = this.sessionDesc.mediaDescriptions.findIndex((t => t.attributes.mid === e)); if (-1 !== n) { const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n], t); this.sessionDesc.mediaDescriptions[n] = e } } bumpMid(e) { this.currentMidIndex += e } findFirstClosedMedia(e) { return this.sessionDesc.mediaDescriptions.find((t => Ku() ? "0" === t.media.port && t.media.mediaType === e : "0" === t.media.port)) } findPreloadMediaDesc(e) { return this.sessionDesc.mediaDescriptions.find((t => { var n, i; return (null === (n = t.attributes) || void 0 === n || null === (i = n.ssrcs[0]) || void 0 === i ? void 0 : i.ssrcId) === e[0].ssrcId })) } getSSRC(e) { var t; return null === (t = this.sessionDesc.mediaDescriptions.find((t => t.attributes.mid === e))) || void 0 === t ? void 0 : t.attributes.ssrcs } } var kD; function VD(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function xD(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? VD(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VD(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } let FD = (aA((kD = class e extends KO { get currentLocalDescription() { return this.peerConnection.currentLocalDescription } get currentRemoteDescription() { return this.peerConnection.currentRemoteDescription } get peerConnectionState() { return this.peerConnection.connectionState } get iceConnectionState() { return this.peerConnection.iceConnectionState } get dtlsTransportState() { var e, t, n; return null !== (e = null === (t = this.peerConnection.getReceivers()[0]) || void 0 === t || null === (n = t.transport) || void 0 === n ? void 0 : n.state) && void 0 !== e ? e : null } constructor(t, n) { super(t, n), hl(this, "store", void 0), hl(this, "peerConnection", void 0), hl(this, "remoteSDP", void 0), hl(this, "initialOffer", void 0), hl(this, "transportEventReceiver", void 0), hl(this, "statsFilter", void 0), hl(this, "localCapabilities", void 0), hl(this, "localCandidateCount", 0), hl(this, "allCandidatesReceived", !1), hl(this, "selectedCandidatePairTimer", void 0), hl(this, "establishPromise", void 0), hl(this, "mutex", new kA("P2PConnection-mutex")), this.store = n, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), { optional: [{ googDscp: !0 }] }), this.statsFilter = fD(this.peerConnection, jh("STATS_UPDATE_INTERVAL"), void 0, Ku() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish() } async establish() { try { this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" }); const e = await this.peerConnection.createOffer(); if (!e.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection."); const t = BN(e.sdp), n = await zN(!jh("USE_PUB_RTX") && !jh("USE_SUB_RTX"), jh("FILTER_VIDEO_FEC"), jh("FILTER_AUDIO_FEC")); return this.localCapabilities = $N(n), this.initialOffer = e, xD(xD({}, t), {}, { rtpCapabilities: n, offerSDP: e.sdp }) } catch (e) { throw new Ch(Oh.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString()) } } async connect(e, t, n, i, r, o) { try { if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer."); this.remoteSDP = new MD({ remoteIceParameters: e, remoteDtlsParameters: t, candidates: n, remoteRTPCapabilities: i, remoteSetup: r, localCapabilities: this.localCapabilities, cname: o }); const s = this.remoteSDP.toString(), a = VN.exports.parse(this.initialOffer.sdp), c = a.mediaDescriptions.find((e => "audio" === e.media.mediaType)); c && eD(c); const E = VN.exports.print(a), _ = this.logSDPExchange(E || "", "offer", "local", "connect"); this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: E }), null == _ || _(s), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s }); const d = this.peerConnection.getTransceivers()[0]; if (null != d && d.receiver && this.tryBindTransportEvents(d.receiver), jh("PRELOAD_MEDIA_COUNT") > 0) { this.remoteSDP.preloadRemoteMedia(); const e = this.remoteSDP.toString(); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e }); const t = await this.peerConnection.createAnswer(); await this.peerConnection.setLocalDescription(t) } } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e.toString())) } } send(e, t, n) { var i = this; return wN((function* () { const r = yield bN(i.mutex.lock("From P2PConnection.send")); try { if (!i.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created"); const o = []; e.forEach((e => { const t = i.peerConnection.addTransceiver(e._mediaStreamTrack, { direction: "sendonly" }); o.push(t), e._updateRtpTransceiver(t) })), Ku() && !0 === jh("SIMULCAST") && (yield bN(i.applySimulcastForFirefox(o, e))); const s = yield bN(i.peerConnection.createOffer()), a = i.remoteSDP.predictReceivingMids(e.length), c = i.mungSendOfferSDP(s.sdp, e, a), E = VN.exports.parse(c), _ = a.map((e => { const t = E.mediaDescriptions.find((t => t.attributes.mid === e)); if (!t) throw new Error("Cannot extract ssrc from mediaDescription."); return GN(t, jh("USE_PUB_RTX")) })); let d; try { d = yield _ } catch (r) { d = [], i.remoteSDP.receive(e, t, n, d); const o = i.remoteSDP.toString(); throw yield bN(i.peerConnection.setLocalDescription({ type: "offer", sdp: c })), yield bN(i.peerConnection.setRemoteDescription({ type: "answer", sdp: o })), yield bN(i.stopSending(a, !0)), r } i.remoteSDP.receive(e, t, n, d); const u = i.remoteSDP.toString(), l = i.logSDPExchange(c, "offer", "local", "send"); return yield bN(i.peerConnection.setLocalDescription({ type: "offer", sdp: c })), yield bN(i.applySimulcastEncodings(o, e)), yield bN(i.applySendEncodings(o, e)), null == l || l(u), yield bN(i.peerConnection.setRemoteDescription({ type: "answer", sdp: u })), o.map(((e, t) => { const n = a[t]; return { localSSRC: _[t], id: n, transceiver: e } })) } catch (e) { throw e instanceof Ch ? e : new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e.toString())) } finally { r() } }))() } async stopSending(e, t) { const n = t ? void 0 : await this.mutex.lock("From P2PConnection.stopSending"); try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created"); const t = this.peerConnection.getTransceivers().filter((t => -1 !== e.indexOf(t.mid))); if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending."); t.map((e => { var t; e.direction = "inactive", null === (t = e.stop) || void 0 === t || t.call(e) })); const n = await this.peerConnection.createOffer(), i = this.logSDPExchange(n.sdp || "", "offer", "local", "stopSending"); await this.peerConnection.setLocalDescription(n), this.remoteSDP.stopReceiving(e); const r = this.remoteSDP.toString(); null == i || i(r), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e.toString())) } finally { n && n() } } async receive(e, t, n, i) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e, " before remoteSDP created.")); const { mid: r, needExchangeSDP: o } = this.remoteSDP.send(e, t, n, i); if (o) { const t = this.remoteSDP.toString(), n = this.logSDPExchange(t, "offer", "remote", "receive"); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t }); const i = await this.peerConnection.createAnswer(), o = this.mungReceiveAnswerSDP(i.sdp, r, e); null == n || n(o || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o }), Dh.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e, " by exchanging SDP.")) } else Dh.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e, " no need to exchange SDP.")); const s = this.peerConnection.getTransceivers().find((e => e.mid === r)); if (!s) throw new Error("Cannot get transceiver after setLocalDescription."); return { track: s.receiver.track, id: r, transceiver: s } } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e.toString())) } } async batchReceive(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created."); const { mids: t, needExchangeSDP: n } = this.remoteSDP.batchSend(e); if (n) { const e = this.remoteSDP.toString(), t = this.logSDPExchange(e, "offer", "remote", "receive"); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e }); const n = await this.peerConnection.createAnswer(); null == t || t(n.sdp || ""), await this.peerConnection.setLocalDescription(n), Dh.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive by exchanging SDP.")) } else Dh.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive no need to exchange SDP.")); return t.map((e => { const t = this.peerConnection.getTransceivers().find((t => t.mid === e)); if (!t) throw new Error("Cannot get transceiver after setLocalDescription."); return { track: t.receiver.track, id: e, transceiver: t } })) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e.toString())) } } async stopReceiving(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created."); this.remoteSDP.stopSending(e); const t = this.remoteSDP.toString(), n = this.logSDPExchange(t, "offer", "remote", "stopReceiving"); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t }); const i = await this.peerConnection.createAnswer(); null == n || n(i.sdp || ""), await this.peerConnection.setLocalDescription(i) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e.toString())) } } async muteRemote(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e, " before remote SDP created.")); this.remoteSDP.mute(e); const t = this.remoteSDP.toString(), n = this.logSDPExchange(t, "offer", "remote", "muteRemote"); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t }); const i = await this.peerConnection.createAnswer(); null == n || n(i.sdp || ""), await this.peerConnection.setLocalDescription(i) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e.toString())) } } async unmuteRemote(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e, " before remote SDP created.")); this.remoteSDP.unmute(e); const t = this.remoteSDP.toString(), n = this.logSDPExchange(t, "offer", "remote", "unmuteRemote"); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t }); const i = await this.peerConnection.createAnswer(); null == n || n(i.sdp || ""), await this.peerConnection.setLocalDescription(i) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e.toString())) } } async muteLocal(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created."); const t = this.peerConnection.getTransceivers().filter((t => t.mid && -1 !== e.indexOf(t.mid))); if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length."); t.map((e => { e.direction = "inactive" })); const n = await this.peerConnection.createOffer(), i = this.logSDPExchange(n.sdp || "", "offer", "local", "muteLocal"); await this.peerConnection.setLocalDescription(n), this.remoteSDP.muteRemote(e); const r = this.remoteSDP.toString(); null == i || i(r), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e.toString())) } } async unmuteLocal(e) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created."); const t = this.peerConnection.getTransceivers().filter((t => t.mid && -1 !== e.indexOf(t.mid))); if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length."); t.map((async (e, t) => { e.direction = "sendonly" })); const n = await this.peerConnection.createOffer(), i = this.logSDPExchange(n.sdp || "", "offer", "local", "unmuteLocal"); await this.peerConnection.setLocalDescription(n), this.remoteSDP.unmuteRemote(e); const r = this.remoteSDP.toString(); null == i || i(r), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e.toString())) } } restartICE(e) { var t = this; return wN((function* () { const n = yield bN(t.mutex.lock("From P2PConnection.restartICE")); try { if (!t.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created."); if (XO().supportPCSetConfiguration) { const n = t.peerConnection.getConfiguration(), i = e === NO.RELAY ? "relay" : "all"; n.iceTransportPolicy !== i && (Dh.debug("[".concat(t.store.clientId, "] restartICE change iceTransportPolicy from [").concat(n.iceTransportPolicy, "] to [").concat(i, "]")), n.iceTransportPolicy = i, t.peerConnection.setConfiguration(n)) } else if (e === NO.RELAY) return; e !== NO.RELAY && t.remoteSDP.updateCandidates(e); const n = yield bN(t.peerConnection.createOffer({ iceRestart: !0 })); if (!n.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist."); const i = BN(n.sdp), { remoteIceParameters: r } = yield i.iceParameters; t.remoteSDP.restartICE(r); const o = t.remoteSDP.toString(), s = t.logSDPExchange(n.sdp || "", "offer", "local", "restartICE"); t.store.descriptionStart(), yield bN(t.peerConnection.setLocalDescription(n)), null == s || s(o), yield bN(t.peerConnection.setRemoteDescription({ type: "answer", sdp: o })) } catch (e) { Dh.warning("[".concat(t.store.clientId, "] restart ICE failed, abort operation"), e) } finally { n() } }))() } close() { var e; this.peerConnection.close(), null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy() } getStats() { return this.statsFilter.getStats() } getRemoteVideoIsReady(e) { return this.statsFilter.getVideoIsReady(e) } async updateEncoderConfig(e, t) { try { if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created."); const n = await this.peerConnection.createOffer(), i = this.mungSendOfferSDP(n.sdp, [t], [e]); this.remoteSDP.updateRecvMedia(e, t); const r = this.remoteSDP.toString(), o = this.logSDPExchange(i, "offer", "local", "updateEncoderConfig"); await this.peerConnection.setLocalDescription({ type: "offer", sdp: i }), null == o || o(r), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, e.toString()) } } async updateSendParameters(e, t) { const n = this.peerConnection.getTransceivers().filter((t => t.mid === e)); 1 === n.length && (this.isVP8Simulcast(t) ? Ku() || await this.applySimulcastEncodings(n, [t]) : await this.applySendEncodings(n, [t])) } setStatsRemoteVideoIsReady(e, t) { this.statsFilter.setVideoIsReady2(e, t) } async replaceTrack(e, t) { const n = this.peerConnection.getTransceivers().find((e => e.mid === t)); n && await n.sender.replaceTrack(e._mediaStreamTrack) } async getSelectedCandidatePair() { const e = this.peerConnection.getReceivers(); if (e.length > 0 && e[0].transport && e[0].transport.iceTransport && e[0].transport.iceTransport.getSelectedCandidatePair && e[0].transport.iceTransport.getSelectedCandidatePair()) { const t = e[0].transport.iceTransport, { local: n, remote: i } = t.getSelectedCandidatePair(); return { local: xD(xD({}, ED), {}, { candidateType: n.type, protocol: n.protocol, address: n.address, port: n.port }), remote: xD(xD({}, ED), {}, { candidateType: i.type, protocol: i.protocol, address: i.address, port: i.port }) } } return this.statsFilter.getSelectedCandidatePair() } bindPCEvents() { this.peerConnection.oniceconnectionstatechange = () => { var e; null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState) }, this.peerConnection.onconnectionstatechange = () => { var e; null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState) }, this.peerConnection.onicecandidate = e => { e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, Dh.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount)) }, setTimeout((() => { this.allCandidatesReceived || (this.allCandidatesReceived = !0, Dh.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount)) }), jh("CANDIDATE_TIMEOUT")) } unbindPCEvents() { this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null } static resolvePCConfiguration(t) { const n = { iceServers: [] }; return t.iceServers ? n.iceServers = t.iceServers : t.turnServer && "off" !== t.turnServer.mode && (kT(t.turnServer.servers) ? n.iceServers = t.turnServer.servers : (n.iceServers && n.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), jh("USE_TURN_SERVER_OF_GATEWAY") && n.iceServers && t.turnServer.serversFromGateway && n.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), jh("FORCE_TURN_TCP") ? n.iceTransportPolicy = "relay" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach((e => { e.forceturn && (n.iceTransportPolicy = "relay") })))), jh("ENABLE_ENCODED_TRANSFORM") && XO().supportWebRTCEncodedTransform && (n.encodedInsertableStreams = !0), n } static turnServerConfigToIceServers(e) { const t = []; return e.forEach((e => { e.security ? e.tcpport && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turns:".concat(xg(e.turnServerURL), ":").concat(e.tcpport, "?transport=tcp") }) : (e.udpport && !jh("FORCE_TURN_TCP") && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turn:".concat(e.turnServerURL, ":").concat(e.udpport, "?transport=udp") }), e.tcpport && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turn:".concat(e.turnServerURL, ":").concat(e.tcpport, "?transport=tcp") })) })), t } tryBindTransportEvents(e) { const t = e.transport; if (t) { this.transportEventReceiver = e, t.onstatechange = () => { var e; null != t && t.state && (null === (e = this.onDTLSTransportStateChange) || void 0 === e || e.call(this, t.state)) }, t.onerror = e => { var t; null === (t = this.onDTLSTransportError) || void 0 === t || t.call(this, "error" in e ? e.error : e) }; const n = t.iceTransport; n && (n.onstatechange = () => { const e = null == t ? void 0 : t.iceTransport.state; var n; e && (null === (n = this.onICETransportStateChange) || void 0 === n || n.call(this, e)) }, n.getSelectedCandidatePair && (n.onselectedcandidatepairchange = () => { if (n.getSelectedCandidatePair()) { const { local: e, remote: t } = n.getSelectedCandidatePair(); Dh.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e.type, protocol: e.protocol }), ", remote ").concat(JSON.stringify({ candidateType: t.type, protocol: t.protocol, address: t.address, port: t.port }), " )")) } })) } } tryUnbindTransportEvents() { this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null)) } async applySendEncodings(e, t) { try { if (!XO().supportSetRtpSenderParameters) return; if (e.length !== t.length) return; for (let c = 0; c < e.length; c++) { const E = e[c], _ = t[c]; if (_ && _ instanceof If) { var n, i; if (this.isVP8Simulcast(_)) continue; const e = {}, t = {}; switch (_._optimizationMode) { case "motion": e.degradationPreference = "maintain-framerate"; break; case "detail": e.degradationPreference = "maintain-resolution"; break; default: e.degradationPreference = "balanced" }var r, o, s, a; if (null !== (n = _._encoderConfig) && void 0 !== n && n.bitrateMax && (t.maxBitrate = 1e3 * (null === (r = _._encoderConfig) || void 0 === r ? void 0 : r.bitrateMax)), _._hints.includes(dO.LOW_STREAM) && (null !== (o = _._encoderConfig) && void 0 !== o && o.frameRate && (t.maxFramerate = Yg(_._encoderConfig.frameRate)), null !== (s = _._encoderConfig) && void 0 !== s && s.scaleResolutionDownBy && (null === (a = _._encoderConfig) || void 0 === a ? void 0 : a.scaleResolutionDownBy) > 1 && (t.scaleResolutionDownBy = _._encoderConfig.scaleResolutionDownBy)), jh("DSCP_TYPE") && ol()) { const e = jh("DSCP_TYPE");["very-low", "low", "medium", "high"].includes(e) && (t.networkPriority = e) } const c = E.sender.getParameters(), d = null === (i = c.encodings) || void 0 === i ? void 0 : i[0]; Ku() && !d && (e.encodings = [t]), d && Object.assign(d, t), Object.assign(c, e), await E.sender.setParameters(c) } } } catch (e) { Dh.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed.")) } } mungSendOfferSDP(e, t, n) { const i = VN.exports.parse(e); return t.forEach(((e, t) => { const r = n[t], o = i.mediaDescriptions.find((e => e.attributes.mid === r)); o && (WN(o, e), QN(o, e, this.store.codec)) })), VN.exports.print(i) } mungReceiveAnswerSDP(e, t, n) { const i = VN.exports.parse(e), r = i.mediaDescriptions.find((e => e.attributes.mid === t)); return r && n === PO.AUDIO && "audio" === r.media.mediaType && eD(r), VN.exports.print(i) } bindStatsEvents() { this.statsFilter.onFirstAudioReceived = e => { var t; null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e) }, this.statsFilter.onFirstVideoReceived = e => { var t; null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e) }, this.statsFilter.onFirstAudioDecoded = e => { var t; null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e) }, this.statsFilter.onFirstVideoDecoded = (e, t, n) => { var i; null === (i = this.onFirstVideoDecoded) || void 0 === i || i.call(this, e, t, n) }, this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => { var n; null === (n = this.onSelectedLocalCandidateChanged) || void 0 === n || n.call(this, e, t) }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => { var n; null === (n = this.onSelectedRemoteCandidateChanged) || void 0 === n || n.call(this, e, t) }, this.statsFilter.onFirstVideoDecodedTimeout = e => { var t; null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t || t.call(this, e) } } unbindStatsEvents() { this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0 } async applySimulcastForFirefox(e, t) { if (e.length === t.length) for (let s = 0; s < e.length; s++) { var n, i, r, o; const a = e[s], c = t[s]; if (c instanceof If && !c._hints.includes(dO.LOW_STREAM) && null !== (n = c._encoderConfig) && void 0 !== n && n.bitrateMax && (null === (i = c._encoderConfig) || void 0 === i ? void 0 : i.bitrateMax) > 200 && null !== (r = c._scalabiltyMode) && void 0 !== r && r.numSpatialLayers && (null === (o = c._scalabiltyMode) || void 0 === o ? void 0 : o.numSpatialLayers) > 1 && "vp8" === this.store.codec) { const e = {}, t = { high: 1e3 * (c._encoderConfig.bitrateMax - 50), medium: 5e4 }; e.encodings = [{ rid: "m", active: !0, maxBitrate: t.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: !0, maxBitrate: t.high }]; const n = a.sender.getParameters(); await a.sender.setParameters(Object.assign(n, e)) } } } async applySimulcastEncodings(e, t) { if (!Ku() && e.length === t.length) for (let n = 0; n < e.length; n++) { const i = t[n]; if (i instanceof If && this.isVP8Simulcast(i)) { const t = e[n], r = {}, o = { high: 1e3 * (i._encoderConfig.bitrateMax - 50), medium: 5e4 }; r.encodings = [{ active: !0, adaptivePtime: !1, networkPriority: "high", priority: "high", maxBitrate: o.high }, { active: !0, adaptivePtime: !1, networkPriority: "low", priority: "low", maxBitrate: o.medium, scaleResolutionDownBy: 4 }]; const s = t.sender.getParameters(); await t.sender.setParameters(Object.assign(s, r)) } } } isVP8Simulcast(e) { var t, n, i, r; return !!(e instanceof If && jh("SIMULCAST") && "vp8" === this.store.codec && !e._hints.includes(dO.LOW_STREAM) && null !== (t = e._encoderConfig) && void 0 !== t && t.bitrateMax && (null === (n = e._encoderConfig) || void 0 === n ? void 0 : n.bitrateMax) > 200 && null !== (i = e._scalabiltyMode) && void 0 !== i && i.numSpatialLayers && (null === (r = e._scalabiltyMode) || void 0 === r ? void 0 : r.numSpatialLayers) > 1) } logSDPExchange(e, t, n, i) { if (jh("SDP_LOGGING")) return Dh.upload("[".concat(this.store.clientId, "] exchanging ").concat(n, " ").concat(t, " SDP during P2PConnection.").concat(i, "\n"), e), "offer" === t ? e => { this.logSDPExchange(e, "answer", "local" === n ? "remote" : "local", i) } : void 0 } async getRemoteSSRC(e) { if (!this.remoteSDP) return; const t = this.remoteSDP.getSSRC(e); return null == t ? void 0 : t[0].ssrcId } setConfiguration(t) { if (XO().supportPCSetConfiguration) { const n = e.resolvePCConfiguration(t); this.peerConnection.setConfiguration(n) } } }).prototype, "connect", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "connect"), kD.prototype), aA(kD.prototype, "receive", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "receive"), kD.prototype), aA(kD.prototype, "batchReceive", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "batchReceive"), kD.prototype), aA(kD.prototype, "stopReceiving", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "stopReceiving"), kD.prototype), aA(kD.prototype, "muteRemote", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "muteRemote"), kD.prototype), aA(kD.prototype, "unmuteRemote", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "unmuteRemote"), kD.prototype), aA(kD.prototype, "muteLocal", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "muteLocal"), kD.prototype), aA(kD.prototype, "unmuteLocal", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "unmuteLocal"), kD.prototype), aA(kD.prototype, "close", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "close"), kD.prototype), aA(kD.prototype, "updateEncoderConfig", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "updateEncoderConfig"), kD.prototype), aA(kD.prototype, "updateSendParameters", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "updateSendParameters"), kD.prototype), aA(kD.prototype, "replaceTrack", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "replaceTrack"), kD.prototype), aA(kD.prototype, "getRemoteSSRC", [YD], Object.getOwnPropertyDescriptor(kD.prototype, "getRemoteSSRC"), kD.prototype), kD); function YD(e, t, n) { const i = e[t]; if ("function" != typeof i) throw new Error("Cannot use mutex on object property."); return n.value = async function () { const e = this.mutex, n = await e.lock("From P2PConnection.".concat(t)); try { for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++)o[s] = arguments[s]; return await i.apply(this, o) } finally { n() } }, n } function BD(e, t) { let n = document.createElement("video"), i = document.createElement("canvas"); n.setAttribute("style", "display:none"), i.setAttribute("style", "display:none"), n.setAttribute("muted", ""), n.muted = !0, n.setAttribute("autoplay", ""), n.autoplay = !0, n.setAttribute("playsinline", ""), i.width = Yg(t.width), i.height = Yg(t.height); const r = Yg(t.framerate || 15); document.body.append(n), document.body.append(i); let o = e._mediaStreamTrack; n.srcObject = new MediaStream([o]), n.play(); const s = i.getContext("2d"); if (!s) throw new Ch(Oh.UNEXPECTED_ERROR, "can not get canvas context"); const a = XO(), c = i.captureStream(a.supportRequestFrame ? 0 : r).getVideoTracks()[0], E = XA((() => (() => { if (n.paused && n.play(), n.videoHeight > 2 && n.videoWidth > 2) { const e = n.videoWidth, t = n.videoHeight / e, r = i.width * t; Math.abs(r - i.height) >= 2 && (Dh.debug("adjust low stream resolution", "".concat(i.width, "x").concat(i.height, " -> ").concat(i.width, "x").concat(r)), i.height = r) } s.drawImage(n, 0, 0, i.width, i.height), c.requestFrame && c.requestFrame(), o !== e._mediaStreamTrack && (o = e._mediaStreamTrack, n.srcObject = new MediaStream([o])) })()), r), _ = c.stop; return c.stop = () => { _.call(c), E(), n && (n.remove(), n = null), i && (i.width = 0, i.remove(), i = null), Dh.debug("clean low stream renderer") }, c } var GD, jD, HD, WD, KD, JD, XD, qD, QD, zD, ZD, $D; function ev(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function tv(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? ev(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ev(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class nv extends bA { getUserId() { return this._userId } constructor(e, t, n, i) { super(e, "track-".concat(e.kind, "-").concat(t, "-").concat(i.clientId, "_").concat(Zg(5, ""))), hl(this, "_userId", void 0), hl(this, "_uintId", void 0), hl(this, "_isDestroyed", !1), hl(this, "store", void 0), hl(this, "processor", void 0), hl(this, "processorContext", void 0), this._userId = t, this._uintId = n, this.store = i } _updateOriginMediaStreamTrack(e) { this._originMediaStreamTrack = e, this._mediaStreamTrack = e, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }) } _destroy() { this._isDestroyed = !0, Dh.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close() } getProcessorStats() { return this.processorContext.gatherStats() } getProcessorUsage() { return this.processorContext.gatherUsage() } } let iv = (GD = LA({ argsMap: (e, t, n) => [e.getTrackId(), "string" == typeof t ? t : t instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", n] }), jD = LA({ argsMap: e => [e.getTrackId()] }), HD = LA({ argsMap: (e, t) => [e.getTrackId(), t.name] }), WD = LA({ argsMap: e => [e.getTrackId()] }), aA((KD = class extends nv { get isPlaying() { return !(!this._player || this._player.videoElementStatus !== sT.PLAYING) } get __className__() { return "RemoteVideoTrack" } constructor(e, t, n, i) { super(e, t, n, i), hl(this, "_videoVisibleTimer", null), hl(this, "_previousVideoVisibleStatus", void 0), hl(this, "_clearPreviousVideoVisibleStatus", (() => this._previousVideoVisibleStatus = void 0)), hl(this, "trackMediaType", "video"), hl(this, "_videoWidth", void 0), hl(this, "_videoHeight", void 0), hl(this, "_player", void 0), hl(this, "processorDestination", void 0), hl(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new PS(this.getTrackId(), "remote"), this.processorDestination = new fS(this.processorContext), this.bindProcessorDestinationEvents() } getStats() { return um((() => { Dh.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead") }), "remoteVideoTrackGetStatsWarning"), om(this, _O.GET_STATS) || tv({}, jT) } play(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if ("string" == typeof e) { const t = document.getElementById(e); t ? e = t : (Dh.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e, '" element, use document.body')), e = document.body) } Dh.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t)); const n = tv(tv({ fit: "cover" }, t), {}, { trackId: this.getTrackId(), element: e }); this._player ? this._player.updateConfig(n) : (e instanceof HTMLVideoElement ? this._player = new wI(n) : this._player = new UI(n), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => { this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.safeEmit(TO.FIRST_FRAME_DECODED) }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval((() => { try { const e = this.getVideoElementVisibleStatus(); this.safeEmit(TO.VIDEO_ELEMENT_VISIBLE_STATUS, e) } catch (e) { } }), jh("CHECK_VIDEO_VISIBLE_INTERVAL")) } stop() { this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, Dh.debug("[".concat(this.getTrackId(), "] stop video playback"))) } getCurrentFrameData() { return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2) } updateMediaStreamTrackResolution() { tm(this._originMediaStreamTrack).then((e => { let [t, n] = e; this._videoHeight = n, this._videoWidth = t })).catch(em) } _updatePlayerSource() { Dh.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack) } getVideoElementVisibleStatus() { try { var e, t; const n = null == this || null === (e = this._player) || void 0 === e ? void 0 : e.getContainerElement(), i = { track: this, element: null == this || null === (t = this._player) || void 0 === t ? void 0 : t.getVideoElement(), slot: null == n ? void 0 : n.parentElement }, { element: r, slot: o } = i; if (this.isPlaying && r instanceof HTMLVideoElement && o instanceof HTMLElement) { const e = Sf.checkOneElementVisible(r), t = Object.assign({}, e); if (t.visible !== this._previousVideoVisibleStatus) { this._previousVideoVisibleStatus = t.visible; const e = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] }); t.visible ? e.onSuccess("Video is visible") : e.onSuccess("Invisible because of ".concat(t.reason)) } return t } return } catch (e) { throw new Ch(Oh.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message) } } pipe(e) { if (this.processor === e) return e; if (e._source) throw new Ch(Oh.INVALID_OPERATION, "Processor ".concat(e.name, " already piped, please call unpipe beforehand.")); return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e } unpipe() { if (!this.processor) return; const e = this.processor; this.processor._source = void 0, this.processor = void 0, e.reset() } bindProcessorDestinationEvents() { this.processorDestination.on(UO.ON_TRACK, (async e => { e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource()) })) } unbindProcessorDestinationEvents() { this.processorDestination.removeAllListeners(UO.ON_TRACK) } _destroy() { super._destroy(), this.unbindProcessorDestinationEvents() } }).prototype, "play", [GD], Object.getOwnPropertyDescriptor(KD.prototype, "play"), KD.prototype), aA(KD.prototype, "stop", [jD], Object.getOwnPropertyDescriptor(KD.prototype, "stop"), KD.prototype), aA(KD.prototype, "pipe", [HD], Object.getOwnPropertyDescriptor(KD.prototype, "pipe"), KD.prototype), aA(KD.prototype, "unpipe", [WD], Object.getOwnPropertyDescriptor(KD.prototype, "unpipe"), KD.prototype), KD), rv = (JD = LA({ argsMap: (e, t) => [e.getTrackId(), t], throttleTime: 300 }), XD = LA({ argsMap: (e, t) => [e.getTrackId(), t] }), qD = LA({ argsMap: e => [e.getTrackId()] }), QD = LA({ argsMap: e => [e.getTrackId()] }), zD = LA({ argsMap: (e, t) => [e.getTrackId(), t.name] }), ZD = LA({ argsMap: e => [e.getTrackId()] }), aA(($D = class extends nv { get isPlaying() { return this._useAudioElement ? lS.isPlaying(this.getTrackId()) : this._source.isPlayed } get __className__() { return "RemoteAudioTrack" } constructor(e, t, n, i) { super(e, t, n, i), hl(this, "trackMediaType", "audio"), hl(this, "_source", void 0), hl(this, "_useAudioElement", !0), hl(this, "_volume", 100), hl(this, "processorContext", void 0), hl(this, "processorDestination", void 0), hl(this, "_played", !1), hl(this, "_bypassWebAudio", !1), jh("DISABLE_WEBAUDIO") ? (this._source = new vS, this._bypassWebAudio = !0, this._useAudioElement = !0) : (this._source = new zA(e, !0), jh("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = !1)), this._source.once(bT.RECEIVE_TRACK_BUFFER, (() => { this.safeEmit(TO.FIRST_FRAME_DECODED) })), this.processorContext = new DS(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new NS(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(bT.UPDATE_SOURCE, (() => { this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext }) })) } setAudioFrameCallback(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096; if (!e) return this._source.removeAllListeners(bT.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer(); this._source.startGetAudioBuffer(t), this._source.removeAllListeners(bT.ON_AUDIO_BUFFER), this._source.on(bT.ON_AUDIO_BUFFER, (t => e(t))) } setVolume(e) { this._volume = e, this._useAudioElement ? lS.setVolume(this.getTrackId(), e) : this._source.setVolume(e / 100) } async setPlaybackDevice(e) { if (!this._useAudioElement) throw new Ch(Oh.NOT_SUPPORTED, "your browser does not support setting the audio output device"); await lS.setSinkID(this.getTrackId(), e) } getVolumeLevel() { return this._source.getAccurateVolumeLevel() } getStats() { return um((() => { Dh.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead") }), "remoteAudioTrackGetStatsWarning"), om(this, _O.GET_STATS) || tv({}, BT) } play() { Dh.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = !0, this._useAudioElement ? (Dh.debug("[".concat(this.getTrackId(), "] use audio element to play")), lS.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play() } stop() { Dh.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = !1, this._useAudioElement ? lS.stop(this.getTrackId()) : this._source.stop() } _destroy() { super._destroy(), this._played = !1, this.unbindProcessorDestinationEvents(), this._source.destroy() } _isFreeze() { return this._source.isFreeze } _updatePlayerSource() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; Dh.debug("[".concat(this.getTrackId(), "] update player source track")), e && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && lS.updateTrack(this.getTrackId(), this._mediaStreamTrack) } pipe(e) { if (this._bypassWebAudio) throw new Ch(Oh.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled"); if (this.processor === e) return e; if (e._source) throw new Ch(Oh.INVALID_OPERATION, "Processor ".concat(e.name, " already piped, please call unpipe beforehand.")); return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e } unpipe() { var e; if (this._bypassWebAudio) throw new Ch(Oh.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled"); if (!this.processor) return; const t = this.processor; null === (e = this._source.processSourceNode) || void 0 === e || e.disconnect(), this.processor._source = !1, this.processor = void 0, t.reset() } bindProcessorDestinationEvents() { this.processorDestination.on(UO.ON_TRACK, (async e => { e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(!1), this._source.processedNode = this._source.createMediaStreamSourceNode(e)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource()) })), this.processorDestination.on(UO.ON_NODE, (e => { this._source.processedNode = e; const t = !e; this._useAudioElement !== t && (this._played ? (this.stop(), this._useAudioElement = t, this.play()) : this._useAudioElement = t) })) } unbindProcessorDestinationEvents() { this.processorDestination.removeAllListeners(UO.ON_TRACK), this.processorDestination.removeAllListeners(UO.ON_NODE) } }).prototype, "setVolume", [JD], Object.getOwnPropertyDescriptor($D.prototype, "setVolume"), $D.prototype), aA($D.prototype, "setPlaybackDevice", [XD], Object.getOwnPropertyDescriptor($D.prototype, "setPlaybackDevice"), $D.prototype), aA($D.prototype, "play", [qD], Object.getOwnPropertyDescriptor($D.prototype, "play"), $D.prototype), aA($D.prototype, "stop", [QD], Object.getOwnPropertyDescriptor($D.prototype, "stop"), $D.prototype), aA($D.prototype, "pipe", [zD], Object.getOwnPropertyDescriptor($D.prototype, "pipe"), $D.prototype), aA($D.prototype, "unpipe", [ZD], Object.getOwnPropertyDescriptor($D.prototype, "unpipe"), $D.prototype), $D); function ov(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function sv(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? ov(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ov(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } class av extends ph { constructor() { super(), hl(this, "uplinkStatsUploadInterval", void 0), hl(this, "uplinkRelatedStatsUploadInterval", void 0), hl(this, "uplinkDenoiserStatsUploadInterval", void 0), hl(this, "transportStatsUploadInterval", void 0), hl(this, "uplinkExtensionStatsUploadInterval", void 0), hl(this, "downlinkExtensionStatsUploadInterval", void 0), hl(this, "extensionUsageStatsUploadInterval", void 0), hl(this, "downlinkStatsUploadInterval", void 0), hl(this, "downlinkRelatedStatsUploadInterval", void 0), hl(this, "lastStats", void 0), hl(this, "uploadUnplinkStarted", !1), hl(this, "uploadDownlinkStarted", !1), hl(this, "uploadTransportStarted", !1), hl(this, "uploadExtensionUsageStarted", !1), hl(this, "requestStats", void 0), hl(this, "requestLocalMedia", void 0), hl(this, "requestRemoteMedia", void 0), hl(this, "requestAllTracks", void 0), hl(this, "requestVideoIsReady", void 0), hl(this, "requestUpload", void 0) } startUploadTransportStats() { this.uploadTransportStarted || (this.uploadTransportStarted = !0, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = window.setInterval((() => { var e; const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this); t && this.uploadTransportStats(t) }), 1e3)) } startUploadExtensionUsageStats() { if (this.uploadExtensionUsageStarted) return; this.uploadExtensionUsageStarted = !0, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval); const e = new Map; this.extensionUsageStatsUploadInterval = window.setInterval((async () => { var t, n, i; const r = Date.now(), o = { connectionInterval: jh("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: r }; let s = []; const a = (null === (t = this.requestAllTracks) || void 0 === t ? void 0 : t.call(this)) || []; for (const e of a) !e.muted && e.enabled && (s = s.concat(await e.getProcessorUsage())); const c = (null === (n = this.requestRemoteMedia) || void 0 === n ? void 0 : n.call(this)) || []; for (const [e, d] of c) d.has(PO.VIDEO) && e.videoTrack && (s = s.concat(await e.videoTrack.getProcessorUsage())), d.has(PO.AUDIO) && e.audioTrack && (s = s.concat(await e.audioTrack.getProcessorUsage())); if (0 === s.length) return; o.details = function (e, t) { const n = {}; for (const { id: s, value: a, level: c, direction: E } of e) { var i; const e = null !== (i = t.get(s)) && void 0 !== i ? i : 0, _ = 2 === a ? e + jh("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e; var r, o; t.set(s, _), n[s] ? (2 === a && (n[s].value = a), c > n[s].level && (n[s].level = c), "remote" === E && (n[s].remoteUidCount += 1), n[s].totalTs = null !== (r = t.get(s)) && void 0 !== r ? r : 0) : n[s] = { value: a, level: c, remoteUidCount: "local" === E ? 0 : 1, totalTs: null !== (o = t.get(s)) && void 0 !== o ? o : 0 } } return Object.keys(n).map((e => { const { level: t, value: i, totalTs: r } = n[e]; return { id: e, level: t, value: i, totalTs: r } })) }(s, e); const E = Date.now(), _ = E > r ? E : r + 1; null === (i = this.requestUpload) || void 0 === i || i.call(this, yT.EXTENSION_USAGE_STATS, { usageStats: o, sendTs: _ }) }), jh("EXTENSION_USAGE_UPLOAD_INTERVAL")) } startUploadUplinkStats() { this.uploadUnplinkStarted || (this.uploadUnplinkStarted = !0, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkStatsUploadInterval = window.setInterval((() => { var e; const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this); t && (this.uploadUplinkStats(t), this.lastStats = t) }), 3e3), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkRelatedStatsUploadInterval = window.setInterval((() => { var e; const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this); t && this.uploadRelatedUplinkStats(t, this.lastStats), this.lastStats = t }), 1e3), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval = window.setInterval((() => { var e; const t = null === (e = this.requestAllTracks) || void 0 === e ? void 0 : e.call(this); t && this.uploadDenoiserStats(t) }), 2e3), this.uplinkExtensionStatsUploadInterval && window.clearInterval(this.uplinkExtensionStatsUploadInterval), this.uplinkExtensionStatsUploadInterval = window.setInterval((() => { var e; const t = null === (e = this.requestAllTracks) || void 0 === e ? void 0 : e.call(this); t && this.uploadExtensionStats(t) }), 2e3)) } uploadTransportStats(e) { Em((() => { var t; null === (t = this.requestUpload) || void 0 === t || t.call(this, yT.TRANSPORT_STATS, function (e) { const t = { connectionType: 100, googRtt: e.rtt }; if ("relay" === e.selectedCandidatePair.localCandidate.candidateType) { const n = e.selectedCandidatePair.localCandidate.relayProtocol; "udp" === n && (t.connectionType = 101), "tcp" === n && (t.connectionType = 103), "tls" === n && (t.connectionType = 104) } return t }(e)) })) } uploadUplinkStats(e) { var t; ((null === (t = this.requestLocalMedia) || void 0 === t ? void 0 : t.call(this)) || []).forEach((t => { let [n, { track: i, ssrcs: r }] = t; switch (n) { case vO.LocalVideoLowTrack: case vO.LocalVideoTrack: { const t = function (e, t, n) { var i; const r = t.videoSend.find((t => t.ssrc === e)); if (!r) return null; const o = { id: Zg(10, ""), timestamp: new Date(t.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: r.ssrc.toString() }; switch (o.A_vstd = n._originMediaStreamTrack && !n._originMediaStreamTrack.enabled || n._mediaStreamTrack && !n._mediaStreamTrack.enabled ? "1" : "0", r.sentFrame && (o.A_fhs = r.sentFrame.height.toString(), o.A_frs = r.sentFrame.frameRate.toString(), o.A_fws = r.sentFrame.width.toString()), r.adaptionChangeReason) { case "none": o.A_ac = "0"; break; case "cpu": o.A_ac = "1"; break; case "bandwidth": o.A_ac = "2"; break; case "other": o.A_ac = "3" }return o.A_lvps = aT[n._player ? n._player.videoElementStatus : "uninit"].toString(), o.A_nr = null === (i = r.nacksCount) || void 0 === i ? void 0 : i.toString(), r.avgEncodeMs && (o.A_aem = r.avgEncodeMs.toFixed(0).toString()), o }(r[0].ssrcId, e, i), o = n === vO.LocalVideoTrack ? function (e, t, n) { var i, r, o, s, a, c, E, _; const d = t.videoSend.find((t => t.ssrc === e)); if (!d) return null; const u = { id: Zg(10, ""), timestamp: new Date(t.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: d.ssrc.toString() }, l = null !== (i = null !== (r = null === (o = d.inputFrame) || void 0 === o ? void 0 : o.height) && void 0 !== r ? r : null == n ? void 0 : n._videoHeight) && void 0 !== i ? i : 0, R = null !== (s = null !== (a = null === (c = d.inputFrame) || void 0 === c ? void 0 : c.width) && void 0 !== a ? a : null == n ? void 0 : n._videoWidth) && void 0 !== s ? s : 0, h = null !== (E = null === (_ = d.inputFrame) || void 0 === _ ? void 0 : _.frameRate) && void 0 !== E ? E : 0; return l && (u.A_fhi = l + ""), R && (u.A_fwi = R + ""), h && (u.A_fri = h + ""), u }(r[0].ssrcId, e, i) : null; t && Em((() => { var e; return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, yT.PUBLISH_STATS, { stream_type: n === vO.LocalVideoLowTrack ? "low" : "high", stats: sv(sv({}, t), o) }) })); const s = function (e) { const t = { id: "bweforvideo", timestamp: new Date(e.timestamp).toISOString(), type: "VideoBwe" }; return e.bitrate.retransmit && (t.A_rb = e.bitrate.retransmit.toString()), e.bitrate.targetEncoded && (t.A_teb = e.bitrate.targetEncoded.toString()), t.A_aeb = e.bitrate.actualEncoded.toString(), t.A_tb = e.bitrate.transmit.toString(), void 0 !== e.sendBandwidth && (t.A_asb = e.sendBandwidth.toString()), t }(e); s && setTimeout((() => { var e; return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, yT.PUBLISH_STATS, { stream_type: n === vO.LocalVideoLowTrack ? "low" : "high", stats: s }) }), 1e3); break } case vO.LocalAudioTrack: { const t = function (e, t, n) { const i = t.audioSend.find((t => t.ssrc === e)); if (!i) return null; const r = { id: Zg(10, ""), timestamp: new Date(t.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: i.ssrc.toString() }; return r.A_astd = n._originMediaStreamTrack && !n._originMediaStreamTrack.enabled || n._mediaStreamTrack && !n._mediaStreamTrack.enabled ? "1" : "0", i.inputLevel ? r.A_ail = Math.round(100 * i.inputLevel).toString() : r.A_ail = Math.round(100 * n._source.getAccurateVolumeLevel()).toString(), r.A_apil = Math.round(100 * n._source.getAccurateVolumeLevel()).toString(), i.aecReturnLoss && (r.A_ecrl = Math.round(i.aecReturnLoss).toString()), i.aecReturnLossEnhancement && (r.A_ecrle = Math.round(i.aecReturnLossEnhancement).toString()), r }(r[0].ssrcId, e, i); t && Em((() => { var e; return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, yT.PUBLISH_STATS, { stream_type: "high", stats: t }) })); break } } })) } uploadRelatedUplinkStats(e, t) { var n; ((null === (n = this.requestLocalMedia) || void 0 === n ? void 0 : n.call(this)) || []).filter((e => { let [t] = e; return t === vO.LocalVideoLowTrack || t === vO.LocalVideoTrack })).forEach((t => { let [n, { ssrcs: i }] = t; const r = function (e, t) { const n = t.videoSend.find((t => t.ssrc === e)); return n ? { mediaType: "video", isVideoMute: !1, frameRateInput: n.inputFrame && n.inputFrame.frameRate.toString(), frameRateSent: n.sentFrame && n.sentFrame.frameRate.toString(), googRtt: n.rttMs.toString(), qpSumPerFrame: Math.floor(n.qpSumPerFrame).toString() } : null }(i[0].ssrcId, e); r && Em((() => { var e; null === (e = this.requestUpload) || void 0 === e || e.call(this, yT.PUBLISH_RELATED_STATS, { stream_type: n === vO.LocalVideoLowTrack ? "low" : "high", stats: r }) })) })) } uploadDenoiserStats(e) { for (let r = 0; r < e.length; r++) { const o = e[r]; if (o instanceof Pg) { var t, n, i; const e = null === (t = (n = o._external).getDenoiserStats) || void 0 === t ? void 0 : t.call(n); return void (e && (null === (i = this.requestUpload) || void 0 === i || i.call(this, yT.DENOISER_STATS, e))) } } } uploadExtensionStats(e) { for (let t = 0; t < e.length; t++)e[t].getProcessorStats().forEach((e => { var t; null === (t = this.requestUpload) || void 0 === t || t.call(this, e.type, e.stats) })) } stopUploadUplinkStats() { this.uploadUnplinkStarted && (this.uploadUnplinkStarted = !1, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkStatsUploadInterval = void 0, this.uplinkRelatedStatsUploadInterval = void 0, this.uplinkDenoiserStatsUploadInterval = void 0) } startUploadDownlinkStats() { if (this.uploadDownlinkStarted) return; let e; this.uploadDownlinkStarted = !0, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval); let t = !1; this.downlinkStatsUploadInterval = window.setInterval((() => { var n; const i = null === (n = this.requestStats) || void 0 === n ? void 0 : n.call(this); i && (this.uploadDownlinkStats(i, t, e), e = i), t = !t }), 3e3), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkRelatedStatsUploadInterval = window.setInterval((() => { var e; const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this); t && (this.uploadRelatedDownlinkStats(t, this.lastStats), this.lastStats = t) }), 1e3), this.downlinkExtensionStatsUploadInterval && window.clearInterval(this.downlinkExtensionStatsUploadInterval), this.downlinkExtensionStatsUploadInterval = window.setInterval((() => { var e; const t = null === (e = this.requestRemoteMedia) || void 0 === e ? void 0 : e.call(this); t && this.uploadDownlinkExtensionStats(t) }), 2e3) } uploadDownlinkStats(e, t, n) { var i; ((null === (i = this.requestRemoteMedia) || void 0 === i ? void 0 : i.call(this)) || []).forEach((i => { let [r, o] = i; if (o.has(PO.VIDEO) && r.videoTrack) { const i = r.videoTrack ? function (e, t, n, i, r) { const o = t.videoRecv.find((t => t.ssrc === e)); if (!o) return null; const s = { id: Zg(10, ""), timestamp: new Date(t.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: o.ssrc.toString() }; var a, c; if (s.bytesReceived = o.bytes.toString(), s.packetsLost = o.packetsLost.toString(), s.packetsReceived = o.packets.toString(), o.framesRateFirefox && (s.A_frr = o.framesRateFirefox.toString()), o.receivedFrame ? (s.A_frr = o.receivedFrame.frameRate.toString(), s.A_fhr = o.receivedFrame.height.toString(), s.A_fwr = o.receivedFrame.width.toString()) : (s.A_fhr = null === (a = i._videoHeight) || void 0 === a ? void 0 : a.toString(), s.A_fwr = null === (c = i._videoWidth) || void 0 === c ? void 0 : c.toString()), s.A_frd = o.decodeFrameRate.toString(), o.outputFrame && (s.A_fro = o.outputFrame.frameRate.toString()), void 0 !== o.jitterBufferMs && (s.A_jbm = Math.floor(o.jitterBufferMs).toString()), void 0 !== o.currentDelayMs && (s.A_cdm = Math.floor(o.currentDelayMs).toString()), s.A_fs = o.firsCount.toString(), s.A_ns = o.nacksCount.toString(), s.A_ps = o.plisCount.toString(), i && (s.A_vrtd = i._originMediaStreamTrack.enabled && i._mediaStreamTrack.enabled ? "0" : "1"), i._player && i._player.freezeTimeCounterList.length > 0 && (s.A_vrft = Math.round(i._player.freezeTimeCounterList.splice(0, 1)[0]).toString()), r && i._player && "visible" === Mg.visibility) { const e = Math.min(6e3, i._player.renderFreezeAccTime); s.A_vrrft = Math.round(e).toString(), i._player.renderFreezeAccTime = Math.max(0, i._player.renderFreezeAccTime - e) } if (s.A_rvps = aT[i._player ? i._player.videoElementStatus : "uninit"].toString(), n) { const t = n.videoRecv.find((t => t.ssrc === e)); if (t && void 0 !== o.totalInterFrameDelay && void 0 !== o.totalSquaredInterFrameDelay && void 0 !== t.totalInterFrameDelay && void 0 !== t.totalSquaredInterFrameDelay) { const e = o.totalInterFrameDelay - t.totalInterFrameDelay, n = o.totalSquaredInterFrameDelay - t.totalSquaredInterFrameDelay, i = o.framesDecodeCount - t.framesDecodeCount, r = e / i * 1e3, a = Math.round(1e3 * Math.sqrt((n - Math.pow(e, 2) / i) / i)); !isNaN(a) && r + a > Math.max(3 * r, r + 150) && (s.A_ifdsd = a.toString()) } } return s }(r._videoSSRC, e, n, r.videoTrack, t) : void 0; i && Em((() => { var e; return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, yT.SUBSCRIBE_STATS, { stream_id: r.uid, stats: i }) })) } if (o.has(PO.AUDIO) && r.audioTrack) { const t = r.audioTrack ? function (e, t, n, i) { const r = t.audioRecv.find((t => t.ssrc === e)); if (!r) return null; const o = { id: Zg(10, ""), timestamp: new Date(t.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: r.ssrc.toString() }; if (o.bytesReceived = r.bytes.toString(), o.packetsLost = r.packetsLost.toString(), o.packetsReceived = r.packets.toString(), r.outputLevel ? o.A_aol = Math.round(100 * r.outputLevel).toString() : o.A_aol = Math.round(100 * i._source.getAccurateVolumeLevel()).toString(), o.A_apol = Math.round(100 * i._source.getAccurateVolumeLevel()).toString(), i && (o.A_artd = i._originMediaStreamTrack.enabled && i._mediaStreamTrack.enabled ? "0" : "1"), o.A_jr = r.jitterMs.toString(), o.A_jbm = Math.floor(r.jitterBufferMs).toString(), o.A_cdm = Math.floor(r.jitterBufferMs).toString(), o.A_raps = aT[lS.getPlayerState(i.getTrackId())].toString(), n) { const t = n.audioRecv.find((t => t.ssrc === e)); if (t) { const e = r.concealedSamples - t.concealedSamples; e > 0 && (o.A_cs = Math.round(e).toString()) } } return o }(r._audioSSRC, e, n, r.audioTrack) : void 0; t && Em((() => { var e; return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, yT.SUBSCRIBE_STATS, { stream_id: r.uid, stats: t }) })) } })) } uploadRelatedDownlinkStats(e, t) { var n; ((null === (n = this.requestRemoteMedia) || void 0 === n ? void 0 : n.call(this)) || []).forEach((n => { let [i, r] = n; if (r.has(PO.VIDEO) && i.videoTrack) { var o; const n = !0 === (i._videoSSRC && (null === (o = this.requestVideoIsReady) || void 0 === o ? void 0 : o.call(this, i._videoSSRC)) || !1), r = function (e, t, n, i, r, o) { const s = n.videoRecv.find((t => t.ssrc === e)), a = r ? r.videoRecv.find((t => t.ssrc === e)) : void 0; if (!s) return null; const c = Ug.isRemoteVideoFreeze(o, s, a) && t, E = { mediaType: "video", isVideoMute: !1, peerId: i, frameRateReceived: s.receivedFrame && s.receivedFrame.frameRate.toString(), frameRateDecoded: s.decodedFrame && s.decodedFrame.frameRate.toString(), isFreeze: c, bytesReceived: s.bytes.toString(), packetsReceived: s.packets.toString(), packetsLost: s.packetsLost.toString(), qpSumPerFrame: Math.floor(s.qpSumPerFrame).toString() }; return s.framesRateFirefox && (E.frameRateDecoded = s.framesRateFirefox.toString(), E.frameRateReceived = s.framesRateFirefox.toString()), E }(i._videoSSRC, n, e, i.uid, t, i.videoTrack); r && Em((() => { var e; null === (e = this.requestUpload) || void 0 === e || e.call(this, yT.SUBSCRIBE_RELATED_STATS, { stream_id: i.uid, stats: r }) })) } if (r.has(PO.AUDIO) && i.audioTrack) { const t = function (e, t, n, i) { const r = t.audioRecv.find((t => t.ssrc === e)); if (!r) return null; const o = Ug.isRemoteAudioFreeze(i); return { mediaType: "audio", isAudioMute: !1, peerId: n, googJitterReceived: r.jitterMs.toString(), isFreeze: o, bytesReceived: r.bytes.toString(), packetsReceived: r.packets.toString(), packetsLost: r.packetsLost.toString(), frameReceived: r.receivedFrames.toString(), frameDropped: r.droppedFrames.toString() } }(i._audioSSRC, e, i.uid, i.audioTrack); t && Em((() => { var e; null === (e = this.requestUpload) || void 0 === e || e.call(this, yT.SUBSCRIBE_RELATED_STATS, { stream_id: i.uid, stats: t }) })) } })) } stopUploadDownlinkStats() { this.uploadDownlinkStarted && (this.uploadDownlinkStarted = !1, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkStatsUploadInterval = void 0, this.downlinkRelatedStatsUploadInterval = void 0) } stopUploadTransportStats() { this.uploadTransportStarted && (this.uploadTransportStarted = !1, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = void 0) } stopUploadExtensionUsageStats() { this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = !1, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval), this.extensionUsageStatsUploadInterval = void 0) } uploadDownlinkExtensionStats(e) { e.forEach((e => { let [t, n] = e; n.has(PO.VIDEO) && t.videoTrack && t.videoTrack.getProcessorStats().forEach((e => { var t; null === (t = this.requestUpload) || void 0 === t || t.call(this, e.type, e.stats) })), n.has(PO.AUDIO) && t.audioTrack && t.audioTrack.getProcessorStats().forEach((e => { var t; null === (t = this.requestUpload) || void 0 === t || t.call(this, e.type, e.stats) })) })) } } function cv(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function Ev(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? cv(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cv(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } const _v = "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0\na=msid-semantic: WMS\na=ice-lite\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 127.0.0.1\na=mid:0\n", dv = "9", uv = 2e4, lv = 4e4; class Rv { get localCapabilities() { return _m(this._localCapabilities) } get rtpCapabilities() { return _m(this._rtpCapabilities) } get candidates() { return _m(this._candidates) } get iceParameters() { return _m(this._iceParameters) } get dtlsParameters() { return _m(this._dtlsParameters) } constructor(e) { hl(this, "sessionDesc", void 0), hl(this, "_localCapabilities", void 0), hl(this, "_rtpCapabilities", void 0), hl(this, "_candidates", void 0), hl(this, "_iceParameters", void 0), hl(this, "_dtlsParameters", void 0), hl(this, "setup", void 0), hl(this, "currentMidIndex", void 0), hl(this, "cname", void 0), hl(this, "firefoxSsrcMidMap", new Map), e = _m(e); const { remoteIceParameters: t, remoteDtlsParameters: n, candidates: i, remoteRTPCapabilities: r, remoteSetup: o, localCapabilities: s, cname: a } = e, c = VN.exports.parse(_v); this._rtpCapabilities = r, this._candidates = i, this._iceParameters = t, this._dtlsParameters = n, this._localCapabilities = s, this.setup = o, this.cname = a; const E = this.rtpCapabilities.send; for (const _ of c.mediaDescriptions) { if (_.attributes.iceUfrag = t.iceUfrag, _.attributes.icePwd = t.icePwd, _.attributes.fingerprints = n.fingerprints, _.attributes.candidates = i, _.attributes.setup = o, "application" === _.media.mediaType && (_.attributes.sctpPort = "5000"), "video" === _.media.mediaType && (_.media.fmts = E.videoCodecs.map((e => e.payloadType.toString(10))), _.attributes.payloads = E.videoCodecs, _.attributes.extmaps = E.videoExtensions, jh("PRELOAD_MEDIA_COUNT") > 0)) { const { ssrcs: e, ssrcGroups: t } = HN([{ ssrcId: lv, rtx: jh("USE_SUB_RTX") ? 40001 : void 0 }], this.cname); _.attributes.ssrcs = e, _.attributes.ssrcGroups = t } if ("audio" === _.media.mediaType && (_.media.fmts = E.audioCodecs.map((e => e.payloadType.toString(10))), _.attributes.payloads = E.audioCodecs, _.attributes.extmaps = E.audioExtensions, eD(_), jh("PRELOAD_MEDIA_COUNT") > 0)) { const { ssrcs: e, ssrcGroups: t } = HN([{ ssrcId: uv }], this.cname); _.attributes.ssrcs = e, _.attributes.ssrcGroups = t } } this.sessionDesc = c, this.currentMidIndex = c.mediaDescriptions.length - 1 } updateRemoteRTPCapabilities(e) { const t = VN.exports.parse(_v); this._rtpCapabilities = e; const n = this.rtpCapabilities.send; for (const i of t.mediaDescriptions) { if (i.attributes.iceUfrag = this._iceParameters.iceUfrag, i.attributes.icePwd = this._iceParameters.icePwd, i.attributes.fingerprints = this._dtlsParameters.fingerprints, i.attributes.candidates = this._candidates, i.attributes.setup = this.setup, "application" === i.media.mediaType && (i.attributes.sctpPort = "5000"), "video" === i.media.mediaType && (i.media.fmts = n.videoCodecs.map((e => e.payloadType.toString(10))), i.attributes.payloads = n.videoCodecs, i.attributes.extmaps = n.videoExtensions, jh("PRELOAD_MEDIA_COUNT") > 0)) { const { ssrcs: e, ssrcGroups: t } = HN([{ ssrcId: lv, rtx: jh("USE_SUB_RTX") ? 40001 : void 0 }], this.cname); i.attributes.ssrcs = e, i.attributes.ssrcGroups = t } if ("audio" === i.media.mediaType && (i.media.fmts = n.audioCodecs.map((e => e.payloadType.toString(10))), i.attributes.payloads = n.audioCodecs, i.attributes.extmaps = n.audioExtensions, jh("PRELOAD_MEDIA_COUNT") > 0)) { const { ssrcs: e, ssrcGroups: t } = HN([{ ssrcId: uv }], this.cname); i.attributes.ssrcs = e, i.attributes.ssrcGroups = t } } this.sessionDesc = t, this.currentMidIndex = t.mediaDescriptions.length - 1 } preloadRemoteMedia(e) { this.rtpCapabilities; const t = this.candidates, n = this.dtlsParameters, i = this.iceParameters, r = this.rtpCapabilities.send; for (let o = 1; o < e; o++) { const e = 2 * o + uv, s = 2 * o + lv, { ssrcs: a, ssrcGroups: c } = HN([{ ssrcId: e }], this.cname), { ssrcs: E, ssrcGroups: _ } = HN([{ ssrcId: s, rtx: jh("USE_SUB_RTX") ? s + 1 : void 0 }], this.cname); this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: dv, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r.videoCodecs.map((e => e.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: i.iceUfrag, icePwd: i.icePwd, unrecognized: [], candidates: t, extmaps: r.videoExtensions, fingerprints: n.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: E, ssrcGroups: _, rtcpFeedbackWildcards: [], payloads: r.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: !0, rtcpRsize: !0, mid: "".concat(2 * o - 1) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: dv, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r.audioCodecs.map((e => e.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: i.iceUfrag, icePwd: i.icePwd, unrecognized: [], candidates: t, extmaps: r.audioExtensions, fingerprints: n.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a, ssrcGroups: c, rtcpFeedbackWildcards: [], payloads: r.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: !0, rtcpRsize: !0, mid: "".concat(2 * o) } }), this.currentMidIndex += 2 } this.updateBundleMids() } toString() { return VN.exports.print(this.sessionDesc) } send(e, t, n, i) { const { ssrcs: r, ssrcGroups: o } = HN(t, this.cname, jh("SYNC_GROUP") ? n : void 0), s = this.findPreloadMediaDesc(r); if (s) { if (Ku() && this.firefoxSsrcMidMap.set(r[0].ssrcId, s.attributes.mid), i && (i.twcc || i.remb)) { const e = this.sessionDesc.mediaDescriptions.indexOf(s); return this.sessionDesc.mediaDescriptions[e] = this.mungSendMediaDesc(s, i), { mid: s.attributes.mid, needExchangeSDP: !0 } } return { mid: s.attributes.mid, needExchangeSDP: !1 } } { const t = this.findAvailableMediaIndex(e, r); let n; return -1 === t || Wu() || Ju() || zu() || 0 === t && jh("USE_SUB_RTX") ? (n = this.createOrRecycleSendMedia(e, r, o, "sendonly", i), this.updateBundleMids()) : (n = _m(this.sessionDesc.mediaDescriptions[t]), n.attributes.direction = "sendonly", n.attributes.ssrcs = r, n.attributes.ssrcGroups = o, this.sessionDesc.mediaDescriptions[t] = this.mungSendMediaDesc(n, i)), Ku() && this.firefoxSsrcMidMap.set(r[0].ssrcId, n.attributes.mid), { mid: n.attributes.mid, needExchangeSDP: !0 } } } batchSend(e) { const t = e.map((e => { let { kind: t, ssrcMsg: n, mslabel: i } = e; return this.send(t, n, i) })), n = []; let i = !1; return t.forEach((e => { let { mid: t, needExchangeSDP: r } = e; r && (i = !0), n.push(t) })), { mids: n, needExchangeSDP: i } } stopSending(e) { const t = this.sessionDesc.mediaDescriptions.filter((t => t.attributes.mid && -1 !== e.indexOf(t.attributes.mid))); if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending."); t.forEach((e => { "0" === e.attributes.mid || Ku() || Wu() || Ju() ? e.attributes.ssrcs = [] : (e.attributes.ssrcs = [], e.attributes.direction = "inactive", e.media.port = "0") })), this.updateBundleMids() } mute(e) { const t = this.sessionDesc.mediaDescriptions.find((t => t.attributes.mid === e)); if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.mute.")); t.attributes.direction = "inactive" } unmute(e) { const t = this.sessionDesc.mediaDescriptions.find((t => t.attributes.mid === e)); if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.unmute.")); t.attributes.direction = "sendonly" } muteRemote(e) { const t = this.sessionDesc.mediaDescriptions.filter((t => e.includes(t.attributes.mid || ""))); if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote."); t.forEach((e => { e.attributes.direction = "inactive" })) } unmuteRemote(e) { const t = this.sessionDesc.mediaDescriptions.filter((t => e.includes(t.attributes.mid || ""))); if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote."); t.forEach((e => { e.attributes.direction = "recvonly" })) } receive(e, t, n, i) { e.forEach(((e, r) => { this.createOrRecycleRecvMedia(e, [], "recvonly", t, n, i[r]) })), this.updateBundleMids() } stopReceiving(e) { const t = this.sessionDesc.mediaDescriptions.filter((t => -1 !== e.indexOf(t.attributes.mid))); if (t.length !== e.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive."); t.forEach((e => { e.media.port = "0", e.attributes.direction = "inactive" })), this.updateBundleMids() } updateCandidates(e) { e === NO.TCP ? this._candidates.forEach((e => { -1 === this._candidates.findIndex((t => "tcp" === t.transport && t.connectionAddress === e.connectionAddress && t.port === e.port)) && this._candidates.push(Ev(Ev({}, e), {}, { foundation: "tcpcandidate", priority: Number(e.priority) - 1 + "", transport: "tcp", port: Number(e.port) + 90 + "" })) })) : this._candidates = this._candidates.filter((e => "tcp" !== e.transport)); for (const t of this.sessionDesc.mediaDescriptions) t.attributes.candidates = this.candidates } restartICE(e) { e = _m(e), this._iceParameters = e, this.sessionDesc.mediaDescriptions.forEach((t => { t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd })) } predictReceivingMids(e) { const t = []; for (let n = 0; n < e; n++)t.push((this.currentMidIndex + n + 1).toString(10)); return t } findAvailableMediaIndex(e, t) { return this.sessionDesc.mediaDescriptions.findIndex((n => { const i = n.media.mediaType === e && "0" !== n.media.port && ("sendonly" === n.attributes.direction || "sendrecv" === n.attributes.direction) && 0 === n.attributes.ssrcs.length; if (Ku()) { if (i) { const e = this.firefoxSsrcMidMap.get(t[0].ssrcId); return !(e || "0" !== n.attributes.mid && "1" !== n.attributes.mid) || !(!e || e !== n.attributes.mid) } return !1 } return i })) } createOrRecycleRecvMedia(e, t, n, i, r, o) { const s = e._mediaStreamTrack.kind, a = this.rtpCapabilities.recv, c = this.localCapabilities.send; let E = []; if (s === PO.VIDEO) { var _, d; if (jh("H264_PROFILE_LEVEL_ID") && "h264" === i && (E = a.videoCodecs.filter((e => { var t, n; return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(i) && (null == e || null === (n = e.fmtp) || void 0 === n ? void 0 : n.parameters["profile-level-id"]) === jh("H264_PROFILE_LEVEL_ID") }))), !E || 0 === (null === (_ = E) || void 0 === _ ? void 0 : _.length)) { const e = c.videoCodecs.filter((e => { var t; return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(i) })); 0 !== e.length && (E = a.videoCodecs.filter((t => e.some((e => e.payloadType === t.payloadType))))) } if (jh("USE_PUB_RTX")) { const e = E.map((e => e.payloadType.toString())), t = a.videoCodecs.filter((t => { var n, i; return "rtx" === (null === (n = t.rtpMap) || void 0 === n ? void 0 : n.encodingName) && e.includes((null === (i = t.fmtp) || void 0 === i ? void 0 : i.parameters.apt) || "") })); E = [...E, ...t] } 0 === E.length && (Dh.warning("codec ".concat(i, " not included in rtpCapabilities, fallback to default payloads: ").concat(null === (d = a.videoCodecs[0].rtpMap) || void 0 === d ? void 0 : d.encodingName)), E = a.videoCodecs) } else E = a.audioCodecs.filter((e => { var t; return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(r) })), 0 === E.length && (Dh.warning("codec ".concat(r, " not included in rtpCapabilities, fallback to opus")), E = a.audioCodecs.filter((e => { var t; return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes("opus") }))); const u = s === PO.VIDEO ? a.videoExtensions : a.audioExtensions; this.currentMidIndex += 1; const l = "".concat(this.currentMidIndex); let R = { media: { mediaType: s, port: dv, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: E.map((e => e.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: u, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: E, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n, rtcpMux: !0, rtcpRsize: !0, mid: "".concat(l) } }; R = this.mungRecvMediaDsec(R, e, o); const h = this.findFirstClosedMedia(s); if (h) { const e = this.sessionDesc.mediaDescriptions.indexOf(h); this.sessionDesc.mediaDescriptions[e] = R } else this.sessionDesc.mediaDescriptions.push(R); return R } createOrRecycleSendMedia(e, t, n, i, r) { const o = this.rtpCapabilities.send, s = e === PO.VIDEO ? o.videoCodecs : o.audioCodecs, a = e === PO.VIDEO ? o.videoExtensions : o.audioExtensions; this.currentMidIndex += 1; const c = "".concat(this.currentMidIndex); let E = { media: { mediaType: e, port: dv, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s.map((e => e.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t, ssrcGroups: n, rtcpFeedbackWildcards: [], payloads: s, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i, rtcpMux: !0, rtcpRsize: !0, mid: "".concat(c) } }; E = this.mungSendMediaDesc(E, r); const _ = this.findFirstClosedMedia(e); if (_) { const e = this.sessionDesc.mediaDescriptions.indexOf(_); this.sessionDesc.mediaDescriptions[e] = E } else this.sessionDesc.mediaDescriptions.push(E); return E } updateBundleMids() { this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e => "0" !== e.media.port)).map((e => e.attributes.mid)) } mungRecvMediaDsec(e, t, n) { const i = _m(e); return KN(i), WN(i, t), JN(i, t), XN(i), qN(i, n, this.localCapabilities.send), i } mungSendMediaDesc(e, t) { const n = _m(e); return qN(n, t, this.localCapabilities.recv), eD(n), n } updateRecvMedia(e, t) { const n = this.sessionDesc.mediaDescriptions.findIndex((t => t.attributes.mid === e)); if (-1 !== n) { const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n], t); this.sessionDesc.mediaDescriptions[n] = e } } bumpMid(e) { this.currentMidIndex += e } findFirstClosedMedia(e) { return this.sessionDesc.mediaDescriptions.find((t => Ku() ? "0" === t.media.port && t.media.mediaType === e : "0" === t.media.port)) } findPreloadMediaDesc(e) { return this.sessionDesc.mediaDescriptions.find((t => { var n, i; return (null === (n = t.attributes) || void 0 === n || null === (i = n.ssrcs[0]) || void 0 === i ? void 0 : i.ssrcId) === e[0].ssrcId })) } getSSRC(e) { var t; return null === (t = this.sessionDesc.mediaDescriptions.find((t => t.attributes.mid === e))) || void 0 === t ? void 0 : t.attributes.ssrcs } } var hv; function pv(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function Tv(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? pv(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pv(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } let Ov = (aA((hv = class e extends KO { get currentLocalDescription() { return this.peerConnection.currentLocalDescription } get currentRemoteDescription() { return this.peerConnection.currentRemoteDescription } get peerConnectionState() { return this.peerConnection.connectionState } get iceConnectionState() { return this.peerConnection.iceConnectionState } constructor(e, t, n) { super(e, t), hl(this, "store", void 0), hl(this, "peerConnection", void 0), hl(this, "remoteSDP", void 0), hl(this, "initialOffer", void 0), hl(this, "transportEventReceiver", void 0), hl(this, "statsFilter", void 0), hl(this, "localCapabilities", void 0), hl(this, "localCandidateCount", 0), hl(this, "allCandidatesReceived", !1), hl(this, "establishPromise", void 0), hl(this, "mutex", new kA("NVExtentionsConnection-mutex")), hl(this, "rtcMedia", void 0), this.store = t, this.peerConnection = n, this.statsFilter = fD(this.peerConnection, jh("STATS_UPDATE_INTERVAL"), void 0, Ku() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish() } async establish(e) { try { const e = await this.peerConnection.createOffer(); if (!e.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection."); const t = BN(e.sdp), n = await zN(!jh("USE_PUB_RTX") && !jh("USE_SUB_RTX"), jh("FILTER_VIDEO_FEC"), jh("FILTER_AUDIO_FEC")); return this.localCapabilities = n, this.initialOffer = e, Tv(Tv({}, t), {}, { rtpCapabilities: n, offerSDP: e.sdp }) } catch (e) { throw new Ch(Oh.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString()) } } async connect(e, t, n, i, r, o) { try { if (!this.initialOffer) throw new Error("Cannot establish NVConnection without initial offer."); this.remoteSDP = new Rv({ remoteIceParameters: e, remoteDtlsParameters: t, candidates: n, remoteRTPCapabilities: i, remoteSetup: r, localCapabilities: $N(this.localCapabilities), cname: o }); const s = this.remoteSDP.toString(), a = VN.exports.parse(this.initialOffer.sdp), c = a.mediaDescriptions.find((e => "audio" === e.media.mediaType)); c && eD(c); const E = VN.exports.print(a), _ = this.logSDPExchange(E || "", "offer", "local", "connect"); await this.peerConnection.setLocalDescription({ type: "offer", sdp: E }), null == _ || _(s), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "NV.connect failed; ".concat(e.toString())) } } async updateRemoteConnect(e) { var t, n, i; null === (t = this.remoteSDP) || void 0 === t || t.updateRemoteRTPCapabilities(e), null === (n = this.remoteSDP) || void 0 === n || n.preloadRemoteMedia(2); const r = null === (i = this.remoteSDP) || void 0 === i ? void 0 : i.toString(); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: r }); const o = await this.peerConnection.createAnswer(); await this.peerConnection.setLocalDescription(o), Dh.debug("[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.") } send(e, t, n) { var i = this; return wN((function* () { const r = yield bN(i.mutex.lock("From NVExtentionsConnection.send")); try { if (!i.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.send before remote SDP created"); const o = []; e.forEach((e => { const t = i.peerConnection.addTransceiver(e._mediaStreamTrack, { direction: "sendonly" }); o.push(t) })), Ku() && !0 === jh("SIMULCAST") && (yield bN(i.applySimulcastForFirefox(o, e))); const s = yield bN(i.peerConnection.createOffer()), a = i.remoteSDP.predictReceivingMids(e.length), c = i.mungSendOfferSDP(s.sdp, e, a), E = VN.exports.parse(c), _ = a.map((e => { const t = E.mediaDescriptions.find((t => t.attributes.mid === e)); if (!t) throw new Error("Cannot extract ssrc from mediaDescription."); return GN(t, jh("USE_PUB_RTX")) })); let d; try { d = yield _ } catch (r) { d = [], i.remoteSDP.receive(e, t, n, d); const o = i.remoteSDP.toString(); throw yield bN(i.peerConnection.setLocalDescription({ type: "offer", sdp: c })), yield bN(i.peerConnection.setRemoteDescription({ type: "answer", sdp: o })), yield bN(i.stopSending(a, !0)), r } i.remoteSDP.receive(e, t, n, d); const u = i.remoteSDP.toString(), l = i.logSDPExchange(c, "offer", "local", "send"); return yield bN(i.peerConnection.setLocalDescription({ type: "offer", sdp: c })), yield bN(i.applySimulcastEncodings(o, e)), yield bN(i.applySendEncodings(o, e)), null == l || l(u), yield bN(i.peerConnection.setRemoteDescription({ type: "answer", sdp: u })), o.map(((e, t) => { const n = a[t]; return { localSSRC: _[t], id: n, transceiver: e } })) } catch (e) { throw e instanceof Ch ? e : new Ch(Oh.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.send failed; ".concat(e.toString())) } finally { r() } }))() } async stopSending(e, t) { const n = t ? void 0 : await this.mutex.lock("From NVExtentionsConnection.stopSending"); try { if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.stopSending before remote SDP created"); const t = this.peerConnection.getTransceivers().filter((t => -1 !== e.indexOf(t.mid))); if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending."); t.map((e => { var t; e.direction = "inactive", null === (t = e.stop) || void 0 === t || t.call(e) })); const n = await this.peerConnection.createOffer(), i = this.logSDPExchange(n.sdp || "", "offer", "local", "stopSending"); await this.peerConnection.setLocalDescription(n), this.remoteSDP.stopReceiving(e); const r = this.remoteSDP.toString(); null == i || i(r), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.stopSending failed; ".concat(e.toString())) } finally { n && n() } } async receive(e, t, n, i) { try { if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.receive ".concat(e, " before remoteSDP created.")); const { mid: r, needExchangeSDP: o } = this.remoteSDP.send(e, t, n, i); if (o) { const t = this.remoteSDP.toString(), n = this.logSDPExchange(t, "offer", "remote", "receive"); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t }); const i = await this.peerConnection.createAnswer(), o = this.mungReceiveAnswerSDP(i.sdp, r, e); null == n || n(o || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o }), Dh.debug("[NVExtentionsConnection] receive ".concat(e, " by exchanging SDP.")) } else Dh.debug("[NVExtentionsConnection] receive ".concat(e, " no need to exchange SDP.")); const s = this.peerConnection.getTransceivers().find((e => e.mid === r)); if (!s) throw new Error("Cannot get transceiver after setLocalDescription."); return { track: s.receiver.track, id: r } } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e.toString())) } } async batchReceive(e) { try { if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.batchReceive before remoteSDP created."); const { mids: t, needExchangeSDP: n } = this.remoteSDP.batchSend(e); if (n) { const e = this.remoteSDP.toString(), t = this.logSDPExchange(e, "offer", "remote", "receive"); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e }); const n = await this.peerConnection.createAnswer(); null == t || t(n.sdp || ""), await this.peerConnection.setLocalDescription(n), Dh.debug("[NVExtentionsConnection] batchReceive by exchanging SDP.") } else Dh.debug("[NVExtentionsConnection] batchReceive no need to exchange SDP."); return t.map((e => { const t = this.peerConnection.getTransceivers().find((t => t.mid === e)); if (!t) throw new Error("Cannot get transceiver after setLocalDescription."); return { track: t.receiver.track, id: e } })) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e.toString())) } } async stopReceiving(e) { try { if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.stopReceiving before remote SDP created."); this.remoteSDP.stopSending(e); const t = this.remoteSDP.toString(), n = this.logSDPExchange(t, "offer", "remote", "stopReceiving"); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t }); const i = await this.peerConnection.createAnswer(); null == n || n(i.sdp || ""), await this.peerConnection.setLocalDescription(i) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "NVExtentionsConnection stopReceiving failed; ".concat(e.toString())) } } async muteRemote(e) { try { if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.muteRemote mid=".concat(e, " before remote SDP created.")); this.remoteSDP.mute(e); const t = this.remoteSDP.toString(), n = this.logSDPExchange(t, "offer", "remote", "muteRemote"); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t }); const i = await this.peerConnection.createAnswer(); null == n || n(i.sdp || ""), await this.peerConnection.setLocalDescription(i) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteRemote failed; ".concat(e.toString())) } } async unmuteRemote(e) { try { if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.unmuteRemote mid=".concat(e, " before remote SDP created.")); this.remoteSDP.unmute(e); const t = this.remoteSDP.toString(), n = this.logSDPExchange(t, "offer", "remote", "unmuteRemote"); await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t }); const i = await this.peerConnection.createAnswer(); null == n || n(i.sdp || ""), await this.peerConnection.setLocalDescription(i) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteRemote failed; ".concat(e.toString())) } } async muteLocal(e) { try { if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.muteLocal before remote SDP created."); const t = this.peerConnection.getTransceivers().filter((t => t.mid && -1 !== e.indexOf(t.mid))); if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length."); t.map((e => { e.direction = "inactive" })); const n = await this.peerConnection.createOffer(), i = this.logSDPExchange(n.sdp || "", "offer", "local", "muteLocal"); await this.peerConnection.setLocalDescription(n), this.remoteSDP.muteRemote(e); const r = this.remoteSDP.toString(); null == i || i(r), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteLocal failed; ".concat(e.toString())) } } async unmuteLocal(e) { try { if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created."); const t = this.peerConnection.getTransceivers().filter((t => t.mid && -1 !== e.indexOf(t.mid))); if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length."); t.map((async (e, t) => { e.direction = "sendonly" })); const n = await this.peerConnection.createOffer(), i = this.logSDPExchange(n.sdp || "", "offer", "local", "unmuteLocal"); await this.peerConnection.setLocalDescription(n), this.remoteSDP.unmuteRemote(e); const r = this.remoteSDP.toString(); null == i || i(r), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteLocal failed; ".concat(e.toString())) } } restartICE(e) { var t = this; return wN((function* () { const n = yield bN(t.mutex.lock("From NVExtentionsConnection.restartICE")); try { if (!t.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created."); if (XO().supportPCSetConfiguration) { const n = t.peerConnection.getConfiguration(), i = e === NO.RELAY ? "relay" : "all"; n.iceTransportPolicy !== i && (Dh.debug("restartICE change iceTransportPolicy from [".concat(n.iceTransportPolicy, "] to [").concat(i, "]")), n.iceTransportPolicy = i, t.peerConnection.setConfiguration(n)) } else if (e === NO.RELAY) return; e !== NO.RELAY && t.remoteSDP.updateCandidates(e); const n = yield bN(t.peerConnection.createOffer({ iceRestart: !0 })); if (!n.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist."); const i = BN(n.sdp), { remoteIceParameters: r } = yield i.iceParameters; t.remoteSDP.restartICE(r); const o = t.remoteSDP.toString(), s = t.logSDPExchange(n.sdp || "", "offer", "local", "restartICE"); yield bN(t.peerConnection.setLocalDescription(n)), null == s || s(o), yield bN(t.peerConnection.setRemoteDescription({ type: "answer", sdp: o })) } catch (e) { Dh.warning("restart ICE failed, abort operation", e) } finally { n() } }))() } close() { var e; null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy() } getStats() { return this.statsFilter.getStats() } getRemoteVideoIsReady(e) { return this.statsFilter.getVideoIsReady(e) } async updateEncoderConfig(e, t) { try { if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created."); const n = await this.peerConnection.createOffer(), i = this.mungSendOfferSDP(n.sdp, [t], [e]); this.remoteSDP.updateRecvMedia(e, t); const r = this.remoteSDP.toString(), o = this.logSDPExchange(i, "offer", "local", "updateEncoderConfig"); await this.peerConnection.setLocalDescription({ type: "offer", sdp: i }), null == o || o(r), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r }) } catch (e) { throw new Ch(Oh.EXCHANGE_SDP_FAILED, e.toString()) } } async updateSendParameters(e, t) { const n = this.peerConnection.getTransceivers().filter((t => t.mid === e)); 1 === n.length && (this.isVP8Simulcast(t) ? Ku() || await this.applySimulcastEncodings(n, [t]) : await this.applySendEncodings(n, [t])) } setStatsRemoteVideoIsReady(e, t) { this.statsFilter.setVideoIsReady2(e, t) } async replaceTrack(e, t) { const n = this.peerConnection.getTransceivers().find((e => e.mid === t)); n && await n.sender.replaceTrack(e._mediaStreamTrack) } getP2PConnectionParams() { var e; if (null === (e = this.peerConnection.currentLocalDescription) || void 0 === e || !e.sdp || !this.localCapabilities) throw new Error; return Tv(Tv({}, BN(this.peerConnection.currentLocalDescription.sdp)), {}, { rtpCapabilities: this.localCapabilities }) } bindPCEvents() { this.peerConnection.oniceconnectionstatechange = () => { var e; null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState) }, this.peerConnection.onconnectionstatechange = () => { var e; null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState) }, this.peerConnection.onicecandidate = e => { e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, Dh.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount)) }, setTimeout((() => { this.allCandidatesReceived || (this.allCandidatesReceived = !0, Dh.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount)) }), jh("CANDIDATE_TIMEOUT")) } unbindPCEvents() { this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null } static resolvePCConfiguration(t) { const n = { iceServers: [] }; return t.iceServers ? n.iceServers = t.iceServers : t.turnServer && "off" !== t.turnServer.mode && (kT(t.turnServer.servers) ? n.iceServers = t.turnServer.servers : (n.iceServers && n.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), jh("USE_TURN_SERVER_OF_GATEWAY") && n.iceServers && t.turnServer.serversFromGateway && n.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), jh("FORCE_TURN_TCP") ? n.iceTransportPolicy = "relay" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach((e => { e.forceturn && (n.iceTransportPolicy = "relay") })))), n } static turnServerConfigToIceServers(e) { const t = []; return e.forEach((e => { e.security ? e.tcpport && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turns:".concat(xg(e.turnServerURL), ":").concat(e.tcpport, "?transport=tcp") }) : (e.udpport && !jh("FORCE_TURN_TCP") && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turn:".concat(e.turnServerURL, ":").concat(e.udpport, "?transport=udp") }), e.tcpport && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turn:".concat(e.turnServerURL, ":").concat(e.tcpport, "?transport=tcp") })) })), t } async applySendEncodings(e, t) { try { if (!XO().supportSetRtpSenderParameters) return; if (e.length !== t.length) return; for (let c = 0; c < e.length; c++) { const E = e[c], _ = t[c]; if (_ && _ instanceof If) { var n, i; if (this.isVP8Simulcast(_)) continue; const e = {}, t = {}; switch (_._optimizationMode) { case "motion": e.degradationPreference = "maintain-framerate"; break; case "detail": e.degradationPreference = "maintain-resolution"; break; default: e.degradationPreference = "balanced" }var r, o, s, a; if (null !== (n = _._encoderConfig) && void 0 !== n && n.bitrateMax && (t.maxBitrate = 1e3 * (null === (r = _._encoderConfig) || void 0 === r ? void 0 : r.bitrateMax)), _._hints.includes(dO.LOW_STREAM) && (null !== (o = _._encoderConfig) && void 0 !== o && o.frameRate && (t.maxFramerate = Yg(_._encoderConfig.frameRate)), null !== (s = _._encoderConfig) && void 0 !== s && s.scaleResolutionDownBy && (null === (a = _._encoderConfig) || void 0 === a ? void 0 : a.scaleResolutionDownBy) > 1 && (t.scaleResolutionDownBy = _._encoderConfig.scaleResolutionDownBy)), jh("DSCP_TYPE") && ol()) { const e = jh("DSCP_TYPE");["very-low", "low", "medium", "high"].includes(e) && (t.networkPriority = e) } const c = E.sender.getParameters(), d = null === (i = c.encodings) || void 0 === i ? void 0 : i[0]; Ku() && !d && (e.encodings = [t]), d && Object.assign(d, t), Object.assign(c, e), await E.sender.setParameters(c) } } } catch (e) { Dh.debug("Apply RTPSendEncodings failed.") } } mungSendOfferSDP(e, t, n) { const i = VN.exports.parse(e); return t.forEach(((e, t) => { const r = n[t], o = i.mediaDescriptions.find((e => e.attributes.mid === r)); o && (WN(o, e), QN(o, e, this.store.codec)) })), VN.exports.print(i) } mungReceiveAnswerSDP(e, t, n) { const i = VN.exports.parse(e), r = i.mediaDescriptions.find((e => e.attributes.mid === t)); return r && n === PO.AUDIO && "audio" === r.media.mediaType && eD(r), VN.exports.print(i) } bindStatsEvents() { this.statsFilter.onFirstAudioReceived = e => { var t; null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e) }, this.statsFilter.onFirstVideoReceived = e => { var t; null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e) }, this.statsFilter.onFirstAudioDecoded = e => { var t; null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e) }, this.statsFilter.onFirstVideoDecoded = (e, t, n) => { var i; null === (i = this.onFirstVideoDecoded) || void 0 === i || i.call(this, e, t, n) }, this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => { var n; null === (n = this.onSelectedLocalCandidateChanged) || void 0 === n || n.call(this, e, t) }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => { var n; null === (n = this.onSelectedRemoteCandidateChanged) || void 0 === n || n.call(this, e, t) }, this.statsFilter.onFirstVideoDecodedTimeout = e => { var t; null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t || t.call(this, e) } } unbindStatsEvents() { this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0 } async applySimulcastForFirefox(e, t) { if (e.length === t.length) for (let s = 0; s < e.length; s++) { var n, i, r, o; const a = e[s], c = t[s]; if (c instanceof If && !c._hints.includes(dO.LOW_STREAM) && null !== (n = c._encoderConfig) && void 0 !== n && n.bitrateMax && (null === (i = c._encoderConfig) || void 0 === i ? void 0 : i.bitrateMax) > 200 && null !== (r = c._scalabiltyMode) && void 0 !== r && r.numSpatialLayers && (null === (o = c._scalabiltyMode) || void 0 === o ? void 0 : o.numSpatialLayers) > 1 && "vp8" === this.store.codec) { const e = {}, t = { high: 1e3 * (c._encoderConfig.bitrateMax - 50), medium: 5e4 }; e.encodings = [{ rid: "m", active: !0, maxBitrate: t.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: !0, maxBitrate: t.high }]; const n = a.sender.getParameters(); await a.sender.setParameters(Object.assign(n, e)) } } } async applySimulcastEncodings(e, t) { if (!Ku() && e.length === t.length) for (let n = 0; n < e.length; n++) { const i = t[n]; if (i instanceof If && this.isVP8Simulcast(i)) { const t = e[n], r = {}, o = { high: 1e3 * (i._encoderConfig.bitrateMax - 50), medium: 5e4 }; r.encodings = [{ active: !0, adaptivePtime: !1, networkPriority: "high", priority: "high", maxBitrate: o.high }, { active: !0, adaptivePtime: !1, networkPriority: "low", priority: "low", maxBitrate: o.medium, scaleResolutionDownBy: 4 }]; const s = t.sender.getParameters(); await t.sender.setParameters(Object.assign(s, r)) } } } isVP8Simulcast(e) { var t, n, i, r; return !!(e instanceof If && jh("SIMULCAST") && "vp8" === this.store.codec && !e._hints.includes(dO.LOW_STREAM) && null !== (t = e._encoderConfig) && void 0 !== t && t.bitrateMax && (null === (n = e._encoderConfig) || void 0 === n ? void 0 : n.bitrateMax) > 200 && null !== (i = e._scalabiltyMode) && void 0 !== i && i.numSpatialLayers && (null === (r = e._scalabiltyMode) || void 0 === r ? void 0 : r.numSpatialLayers) > 1) } logSDPExchange(e, t, n, i) { if (jh("SDP_LOGGING")) return Dh.upload("exchanging ".concat(n, " ").concat(t, " SDP during NVExtentionsConnection.").concat(i, "\n"), e), "offer" === t ? e => { this.logSDPExchange(e, "answer", "local" === n ? "remote" : "local", i) } : void 0 } async getRemoteSSRC(e) { if (!this.remoteSDP) return; const t = this.remoteSDP.getSSRC(e); return null == t ? void 0 : t[0].ssrcId } setConfiguration(t) { if (XO().supportPCSetConfiguration) { const n = e.resolvePCConfiguration(t); this.peerConnection.setConfiguration(n) } } }).prototype, "connect", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "connect"), hv.prototype), aA(hv.prototype, "updateRemoteConnect", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "updateRemoteConnect"), hv.prototype), aA(hv.prototype, "receive", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "receive"), hv.prototype), aA(hv.prototype, "batchReceive", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "batchReceive"), hv.prototype), aA(hv.prototype, "stopReceiving", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "stopReceiving"), hv.prototype), aA(hv.prototype, "muteRemote", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "muteRemote"), hv.prototype), aA(hv.prototype, "unmuteRemote", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "unmuteRemote"), hv.prototype), aA(hv.prototype, "muteLocal", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "muteLocal"), hv.prototype), aA(hv.prototype, "unmuteLocal", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "unmuteLocal"), hv.prototype), aA(hv.prototype, "close", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "close"), hv.prototype), aA(hv.prototype, "updateEncoderConfig", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "updateEncoderConfig"), hv.prototype), aA(hv.prototype, "updateSendParameters", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "updateSendParameters"), hv.prototype), aA(hv.prototype, "replaceTrack", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "replaceTrack"), hv.prototype), aA(hv.prototype, "getRemoteSSRC", [Cv], Object.getOwnPropertyDescriptor(hv.prototype, "getRemoteSSRC"), hv.prototype), hv); function Cv(e, t, n) { const i = e[t]; if ("function" != typeof i) throw new Error("Cannot use mutex on object property."); return n.value = async function () { const e = this.mutex, n = await e.lock("From NVExtentionsConnection.".concat(t)); try { for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++)o[s] = arguments[s]; return await i.apply(this, o) } finally { n() } }, n } var Av; function Sv(e) { var t, n, i, r = 2; for ("undefined" != typeof Symbol && (n = kN, i = Symbol.iterator); r--;) { if (n && null != (t = e[n])) return t.call(e); if (i && null != (t = e[i])) return new gv(t.call(e)); n = "@@asyncIterator", i = "@@iterator" } throw new TypeError("Object is not async iterable") } function gv(e) { function t(e) { if (Object(e) !== e) return Cd.reject(new TypeError(e + " is not an object.")); var t = e.done; return Cd.resolve(e.value).then((function (e) { return { value: e, done: t } })) } return (gv = function (e) { this.s = e, this.n = e.next }).prototype = { s: null, n: null, next: function () { return t(this.n.apply(this.s, arguments)) }, return: function (e) { var n = this.s.return; return void 0 === n ? Cd.resolve({ value: e, done: !0 }) : t(n.apply(this.s, arguments)) }, throw: function (e) { var n = this.s.return; return void 0 === n ? Cd.reject(e) : t(n.apply(this.s, arguments)) } }, new gv(e) } let mv = (aA((Av = class e extends KO { get currentLocalDescription() { return this.peerConnection.currentLocalDescription } get currentRemoteDescription() { return this.peerConnection.currentRemoteDescription } get peerConnectionState() { return this.peerConnection.connectionState } get iceConnectionState() { return this.peerConnection.iceConnectionState } constructor(t, n) { super(t, n), hl(this, "store", void 0), hl(this, "peerConnection", void 0), hl(this, "cname", void 0), hl(this, "mutex", new kA("DataChannelConnection-mutex")), hl(this, "dataChannel", void 0), hl(this, "_p2pConnection", void 0), hl(this, "establishPromise", void 0), hl(this, "_nvMedia", void 0), this.store = n, this.store.dcId = this.store.dcId + 1, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), { optional: [{ googDscp: !0 }] }), this.dataChannel = this.peerConnection.createDataChannel("agora-signal", { ordered: !1, maxPacketLifeTime: 50 }), this.dataChannel.binaryType = "arraybuffer", this._p2pConnection = new Ov(t, n, this.peerConnection), this.bindPCEvents(), this.establishPromise = this._p2pConnection.establishPromise } async establish() { var e; const t = null === (e = this._nvMedia) || void 0 === e ? void 0 : e.getLocalRtpCapabilities(); return await this._p2pConnection.establish(t) } getP2PConnectionParams() { return this._p2pConnection.getP2PConnectionParams() } async connect(e, t, n, i, r, o) { return this.cname = o, await this._p2pConnection.connect(e, t, n, i, r, o), await new Cd(((e, t) => { const i = setTimeout((() => { this.closeSignal(), t(new Ch(Oh.DATACHANNEL_CONNECTION_TIMEOUT, "Datachannel connection timed out, candidates: ".concat(JSON.stringify(n)))) }), 2e3); this.dataChannel.onopen = () => { if ("open" === this.dataChannel.readyState) return clearTimeout(i), void e() }, this.dataChannel.onerror = e => { this.closeSignal(), t(e) } })), { transmitter: this.dataChannel, close: this.closeSignal.bind(this) } } send(e, t, n) { var i = this; return wN((function* () { const r = yield bN(i.mutex.lock("From DataChannelConnection.send")); try { return yield* MN(Sv(i._p2pConnection.send(e, t, n)), bN) } finally { r() } }))() } async stopSending(e, t) { return this._p2pConnection.stopSending(e, t) } async receive(e, t, n, i) { return this._nvMedia ? (Dh.debug("[DataChannelConnection] receive ".concat(e, " by DataChannel.")), await this._nvMedia.reveiveByRTCMedia(e, t, this.cname)) : (Dh.debug("[DataChannelConnection] receive ".concat(e, " by WebRTC.")), await this._p2pConnection.receive(e, t, n, i)) } async batchReceive(e) { return [...await this._p2pConnection.batchReceive(e)] } async stopReceiving(e) { return await this._p2pConnection.stopReceiving(e) } async muteRemote(e) { return await this._p2pConnection.muteRemote(e) } async unmuteRemote(e) { return await this._p2pConnection.unmuteRemote(e) } async muteLocal(e) { return await this._p2pConnection.muteLocal(e) } async unmuteLocal(e) { return await this._p2pConnection.unmuteLocal(e) } restartICE(e) { var t = this; return wN((function* () { return yield* MN(Sv(t._p2pConnection.restartICE(e)), bN) }))() } close() { var e; null === (e = this._nvMedia) || void 0 === e || e.close(), this._p2pConnection.close(), this.unbindConnectionEvents(this._p2pConnection) } getStats() { return this._p2pConnection.getStats() } getRemoteVideoIsReady(e) { return this._p2pConnection.getRemoteVideoIsReady(e) } updateRemoteConnect(e) { var t; null === (t = this._nvMedia) || void 0 === t || t.setRemoteRtpCapabilities(e), this._p2pConnection.updateRemoteConnect(e) } async updateEncoderConfig(e, t) { return await this._p2pConnection.updateEncoderConfig(e, t) } async updateSendParameters(e, t) { return await this._p2pConnection.updateSendParameters(e, t) } setStatsRemoteVideoIsReady(e, t) { this._p2pConnection.setStatsRemoteVideoIsReady(e, t) } async replaceTrack(e, t) { return await this._p2pConnection.replaceTrack(e, t) } async getRemoteSSRC(e) { return this._p2pConnection.getRemoteSSRC(e) } logSDPExchange(e, t, n, i) { if (jh("SDP_LOGGING")) return Dh.upload("exchanging ".concat(n, " ").concat(t, " SDP during DataChannelConnection.").concat(i, "\n"), e), "offer" === t ? e => { this.logSDPExchange(e, "answer", "local" === n ? "remote" : "local", i) } : void 0 } static resolvePCConfiguration(t) { const n = { iceServers: [] }; return t.iceServers ? n.iceServers = t.iceServers : t.turnServer && "off" !== t.turnServer.mode && (kT(t.turnServer.servers) ? n.iceServers = t.turnServer.servers : (n.iceServers && n.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), jh("USE_TURN_SERVER_OF_GATEWAY") && n.iceServers && t.turnServer.serversFromGateway && n.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), jh("FORCE_TURN_TCP") ? n.iceTransportPolicy = "relay" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach((e => { e.forceturn && (n.iceTransportPolicy = "relay") })))), n } static turnServerConfigToIceServers(e) { const t = []; return e.forEach((e => { e.security ? e.tcpport && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turns:".concat(xg(e.turnServerURL), ":").concat(e.tcpport, "?transport=tcp") }) : (e.udpport && !jh("FORCE_TURN_TCP") && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turn:".concat(e.turnServerURL, ":").concat(e.udpport, "?transport=udp") }), e.tcpport && t.push({ username: e.username, credential: e.password, credentialType: "password", urls: "turn:".concat(e.turnServerURL, ":").concat(e.tcpport, "?transport=tcp") })) })), t } bindPCEvents() { this._p2pConnection.onICEConnectionStateChange = e => { var t; return null === (t = this.onICEConnectionStateChange) || void 0 === t ? void 0 : t.call(this, e) }, this._p2pConnection.onConnectionStateChange = e => { var t; return null === (t = this.onConnectionStateChange) || void 0 === t ? void 0 : t.call(this, e) }, this._p2pConnection.onDTLSTransportStateChange = e => { var t; return null === (t = this.onDTLSTransportStateChange) || void 0 === t ? void 0 : t.call(this, e) }, this._p2pConnection.onDTLSTransportError = e => { var t; return null === (t = this.onDTLSTransportError) || void 0 === t ? void 0 : t.call(this, e) }, this._p2pConnection.onICETransportStateChange = e => { var t; return null === (t = this.onICETransportStateChange) || void 0 === t ? void 0 : t.call(this, e) }, this._p2pConnection.onFirstAudioReceived = e => { var t; return null === (t = this.onFirstAudioReceived) || void 0 === t ? void 0 : t.call(this, e) }, this._p2pConnection.onFirstVideoReceived = e => { var t; return null === (t = this.onFirstVideoReceived) || void 0 === t ? void 0 : t.call(this, e) }, this._p2pConnection.onFirstAudioDecoded = e => { var t; return null === (t = this.onFirstAudioDecoded) || void 0 === t ? void 0 : t.call(this, e) }, this._p2pConnection.onFirstVideoDecoded = (e, t, n) => { var i; return null === (i = this.onFirstVideoDecoded) || void 0 === i ? void 0 : i.call(this, e, t, n) }, this._p2pConnection.onFirstVideoDecodedTimeout = e => { var t; return null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t ? void 0 : t.call(this, e) }, this._p2pConnection.onSelectedLocalCandidateChanged = (e, t) => { var n; return null === (n = this.onSelectedLocalCandidateChanged) || void 0 === n ? void 0 : n.call(this, e, t) }, this._p2pConnection.onSelectedRemoteCandidateChanged = (e, t) => { var n; return null === (n = this.onSelectedRemoteCandidateChanged) || void 0 === n ? void 0 : n.call(this, e, t) } } closeSignal() { this.dataChannel.close(), this.peerConnection.close() } unbindConnectionEvents(e) { e.onConnectionStateChange = void 0, e.onICEConnectionStateChange = void 0, e.onICETransportStateChange = void 0, e.onDTLSTransportStateChange = void 0, e.onDTLSTransportError = void 0, e.onFirstAudioDecoded = void 0, e.onFirstAudioReceived = void 0, e.onFirstVideoDecoded = void 0, e.onFirstVideoReceived = void 0, e.onSelectedLocalCandidateChanged = void 0, e.onSelectedRemoteCandidateChanged = void 0, e.onFirstVideoDecodedTimeout = void 0 } setConfiguration(e) { this._p2pConnection.setConfiguration(e) } }).prototype, "connect", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "connect"), Av.prototype), aA(Av.prototype, "receive", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "receive"), Av.prototype), aA(Av.prototype, "stopReceiving", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "stopReceiving"), Av.prototype), aA(Av.prototype, "muteRemote", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "muteRemote"), Av.prototype), aA(Av.prototype, "unmuteRemote", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "unmuteRemote"), Av.prototype), aA(Av.prototype, "muteLocal", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "muteLocal"), Av.prototype), aA(Av.prototype, "unmuteLocal", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "unmuteLocal"), Av.prototype), aA(Av.prototype, "close", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "close"), Av.prototype), aA(Av.prototype, "updateEncoderConfig", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "updateEncoderConfig"), Av.prototype), aA(Av.prototype, "updateSendParameters", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "updateSendParameters"), Av.prototype), aA(Av.prototype, "replaceTrack", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "replaceTrack"), Av.prototype), aA(Av.prototype, "getRemoteSSRC", [Iv], Object.getOwnPropertyDescriptor(Av.prototype, "getRemoteSSRC"), Av.prototype), Av); function Iv(e, t, n) { const i = e[t]; if ("function" != typeof i) throw new Error("Cannot use mutex on object property."); return n.value = async function () { const e = this.mutex, n = await e.lock("From DataChannelConnection.".concat(t)); try { for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++)o[s] = arguments[s]; return await i.apply(this, o) } finally { n() } }, n } var fv; function Pv(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function Nv(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? Pv(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Pv(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function Dv(e) { var t, n, i, r = 2; for ("undefined" != typeof Symbol && (n = kN, i = Symbol.iterator); r--;) { if (n && null != (t = e[n])) return t.call(e); if (i && null != (t = e[i])) return new vv(t.call(e)); n = "@@asyncIterator", i = "@@iterator" } throw new TypeError("Object is not async iterable") } function vv(e) { function t(e) { if (Object(e) !== e) return Cd.reject(new TypeError(e + " is not an object.")); var t = e.done; return Cd.resolve(e.value).then((function (e) { return { value: e, done: t } })) } return (vv = function (e) { this.s = e, this.n = e.next }).prototype = { s: null, n: null, next: function () { return t(this.n.apply(this.s, arguments)) }, return: function (e) { var n = this.s.return; return void 0 === n ? Cd.resolve({ value: e, done: !0 }) : t(n.apply(this.s, arguments)) }, throw: function (e) { var n = this.s.return; return void 0 === n ? Cd.reject(e) : t(n.apply(this.s, arguments)) } }, new vv(e) } let yv = (aA((fv = class extends ph { get state() { return this._state } set state(e) { const t = this._state; this._state = e, this.emit(LO.StateChange, t, this._state) } constructor(e, t) { super(), hl(this, "store", void 0), hl(this, "statsUploader", void 0), hl(this, "connection", void 0), hl(this, "localTrackMap", new Map), hl(this, "remoteUserMap", new Map), hl(this, "pendingLocalTracks", []), hl(this, "pendingRemoteTracks", []), hl(this, "statsCollector", void 0), hl(this, "isPlanB", !1), hl(this, "shouldForwardP2PCreation", void 0), hl(this, "iceFailedCount", 0), hl(this, "dtlsFailedCount", 0), hl(this, "mutex", new kA("P2PChannel-mutex")), hl(this, "_state", yO.Disconnected), hl(this, "_pcStatsUploadType", jh("NEW_ICE_RESTART") ? DO.FIRST_CONNECTION : DO.OLD_FIRST_CONNECTION), hl(this, "_isInRestartIce", !1), hl(this, "_isStartRestartIce", !1), hl(this, "_restartStates", ["disconnected", "failed"]), hl(this, "_restartTimer", void 0), hl(this, "_isFirstConnected", !0), hl(this, "handleMuteLocalTrack", (async (e, t, n) => { const i = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack"); try { if (!this.connection || this.state !== yO.Connected) return void n(new Ch(Oh.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established.")); const i = this.filterTobeMutedTracks(e); if (0 === i.length) return void t(); const r = i.find((e => "videoLowTrack" === e[0])); r && r[1].track._originMediaStreamTrack.stop(), await this.connection.muteLocal(i.map((e => { let [, { id: t }] = e; return t }))); const o = this.createMuteMessage(i); await rm(this, LO.RequestMuteLocal, o), t() } catch (e) { n(e) } finally { i() } })), hl(this, "handleUnmuteLocalTrack", (async (e, t, n) => { const i = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack"); try { if (!this.connection || this.state !== yO.Connected) return void n(new Ch(Oh.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established.")); const i = this.filterTobeUnmutedTracks(e); if (0 === i.length) return void t(); const r = i.find((e => "videoLowTrack" === e[0])); if (r) { const t = r[1]; if (t.track._originMediaStreamTrack.stop(), XO().supportDualStreamEncoding) { const n = e._mediaStreamTrack.clone(); t.track._mediaStreamTrack = n, t.track._originMediaStreamTrack = n } else { const n = BD(e, sm(this, LO.RequestLowStreamParameter)); t.track._mediaStreamTrack = n, t.track._originMediaStreamTrack = n } await new Cd(((e, n) => { this.handleReplaceTrack(t.track, e, n, !0) })) } await this.connection.unmuteLocal(i.map((e => { let [, { id: t }] = e; return t }))); const o = this.createUnmuteMessage(i); await rm(this, LO.RequestUnmuteLocal, o), t() } catch (e) { n(e) } finally { i() } })), hl(this, "handleUpdateVideoEncoder", (async (e, t, n) => { const i = await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder"); try { const n = this.localTrackMap.get(vO.LocalVideoTrack); if (!this.connection || !n || n.track !== e || this.state !== yO.Connected) return void t(); const { id: i, track: r } = n; await this.connection.updateSendParameters(i, r), await this.connection.updateEncoderConfig(i, r), this.emit(LO.UpdateVideoEncoder, r), t() } catch (e) { n(e) } finally { i() } })), hl(this, "handleSetOptimizationMode", (async (e, t, n) => { const i = await this.mutex.lock("Locking from P2PChannel.handleSetOptimizationMode"); try { const n = this.localTrackMap.get(vO.LocalVideoTrack); if (!this.connection || !n || n.track !== e || this.state !== yO.Connected) return; const { id: i, track: r } = n; await this.connection.updateSendParameters(i, r), t() } catch (e) { n(e) } finally { i() } })), hl(this, "handleReplaceTrack", (async (e, t, n, i) => { let r; Dh.debug("[".concat(this.store.clientId, "] P2PChannel handleReplaceTrack for [track-id-").concat(e.getTrackId(), "]")), "boolean" == typeof i && i || (r = await this.mutex.lock("From P2PChannel.handleReplaceTrack")); try { var o; const n = Array.from(this.localTrackMap.entries()).find((t => { let [, { track: n }] = t; return e === n })); if (!this.connection || !n || this.state !== yO.Connected) return void t(); if (await (null === (o = this.connection) || void 0 === o ? void 0 : o.replaceTrack(e, n[1].id)), this.isPlanB) { const t = n[1]; t.id = e._mediaStreamTrack.id, this.localTrackMap.set(n[0], t) } if (n[0] === vO.LocalVideoTrack && XO().supportDualStreamEncoding) { const t = this.localTrackMap.get(vO.LocalVideoLowTrack); if (t) { const n = e._mediaStreamTrack.clone(); t.track._originMediaStreamTrack.stop(), t.track._mediaStreamTrack = n, t.track._originMediaStreamTrack = n, await new Cd(((e, n) => { this.handleReplaceTrack(t.track, e, n, !0) })) } } t() } catch (e) { n(e) } finally { var s; null === (s = r) || void 0 === s || s() } })), hl(this, "handleGetLocalVideoStats", (e => { e(this.statsCollector.getLocalVideoTrackStats()) })), hl(this, "handleGetLocalAudioStats", (e => { e(this.statsCollector.getLocalAudioTrackStats()) })), hl(this, "handleGetRemoteVideoStats", (e => this.statsCollector.getRemoteVideoTrackStats(e.uid)[e.uid])), hl(this, "handleGetRemoteAudioStats", (e => this.statsCollector.getRemoteAudioTrackStats(e.uid)[e.uid])), this.store = e, this.statsCollector = t, this.statsCollector.addP2PChannel(this), this.statsUploader = new av, this.bindStatsUploaderEvents(), this.isPlanB = !XO().supportUnifiedPlan || jh("CHROME_FORCE_PLAN_B") && ol(), this.shouldForwardP2PCreation = jh("FORWARD_P2P_CREATION") && XO().supportPCSetConfiguration, this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new mv({}, this.store) : this.isPlanB ? new vD({}, this.store) : new FD({}, this.store), this.bindConnectionEvents(this.connection)) } async startP2PConnection(e, t) { var n; this.state = yO.New; const i = this.shouldForwardP2PCreation && "closed" === (null === (n = this.connection) || void 0 === n ? void 0 : n.peerConnectionState); if (this.shouldForwardP2PCreation && !i || (i && this.connection && (Dh.warning("[".concat(this.store.clientId, "] P2PChannel.startP2PConnection ForwardP2P closed.")), this.connection.close(), this.unbindConnectionEvents(this.connection)), this.connection = this.store.useDataChannel ? new mv(e, this.store) : this.isPlanB ? new vD(e, this.store) : new FD(e, this.store), this.bindConnectionEvents(this.connection)), !this.connection) throw new Ch(Oh.UNEXPECTED_ERROR, "Cannot P2PChannel.startConnection before P2PConnection initialization ."); return this._pcStatsUploadType = jh("NEW_ICE_RESTART") ? DO.FIRST_CONNECTION : DO.OLD_FIRST_CONNECTION, this._isFirstConnected = !0, this._isInRestartIce = !1, this._isStartRestartIce = !1, this.connection.setConfiguration(e), this.connection.establishPromise } async connect(e, t, n, i, r, o) { if (!this.connection) throw new Ch(Oh.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection ."); this.connection instanceof mv ? this.connection.updateRemoteConnect(i) : (this.store.peerConnectionStart(), await this.connection.connect(e, t, n, i, r, o), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = yO.Connected) } async preConnect(e, t, n, i, r, o) { if (!this.connection) throw new Ch(Oh.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection ."); this.store.peerConnectionStart(); const s = await this.connection.connect(e, t, n, i, r, o); return this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = yO.Connected, s } getEstablishParams() { if (this.connection instanceof mv) return this.connection.getP2PConnectionParams(); throw new Error("Only DataChannelConnection needs to obtain establishParams") } publish(e, t, n) { var i = this; return wN((function* () { const r = yield bN(i.mutex.lock("From P2PChannel.publish")); try { if (!i.connection || i.state !== yO.Connected) { if (i.state === yO.Disconnected) throw new Ch(Oh.UNEXPECTED_ERROR, "PeerConnection already disconnected."); i.throwIfTrackTypeNotMatch(e); const t = e.filter((e => -1 === i.pendingLocalTracks.indexOf(e))); return void (i.pendingLocalTracks = i.pendingLocalTracks.concat(t)) } i.store.pubId = i.store.pubId + 1, Lg.markPublishStart(i.store.clientId, i.store.pubId); const r = i.filterTobePublishedTracks(e, t, n); if (0 === r.length) return void (yield bN(i.tryToUnmuteAudio(e))); yield* MN(Dv(i.doPublish(i.connection, r)), bN) } finally { r() } }))() } doPublish(e, t) { var n = this; return wN((function* () { t.forEach((e => { let { track: t, type: i } = e; const r = Date.now(); n.store.publish(t.getTrackId(), i === vO.LocalAudioTrack ? "audio" : "video", r) })), n.bindLocalTrackEvents(t); const i = yield bN(e.send(t.map((e => { let { track: t } = e; return t })), n.store.codec, n.store.audioCodec)), r = (yield bN(i.next())).value, o = n.createGatewayPublishMessage(t, r); let s; try { s = yield o } catch (e) { throw i.throw(e), (null == e ? void 0 : e.code) === Oh.WS_ABORT && t.forEach((e => { let { track: t } = e; -1 === n.pendingLocalTracks.indexOf(t) && n.pendingLocalTracks.push(t) })), n.unbindLocalTrackEvents(t), e } const a = n.mapPubResToRemoteConfig(o, s), c = (yield bN(i.next(a))).value; t.forEach((e => { let { type: t } = e; n.statsCollector.addLocalStats(t) })), n.assignLocalTracks(t, c), n.statsUploader.startUploadUplinkStats(), t.forEach((e => { let { track: t, type: i } = e; const r = Date.now(); n.store.publish(t.getTrackId(), i === vO.LocalAudioTrack ? "audio" : "video", void 0, r) })) }))() } publishLowStream(e) { var t = this; return wN((function* () { if (!t.connection || t.state !== yO.Connected) return; const n = yield bN(t.mutex.lock("Locking from P2PChannel.publishLowStream")); try { const n = t.localTrackMap.get(vO.LocalVideoTrack); if (!n) throw new Ch(Oh.UNEXPECTED_ERROR, "Could not find high stream"); if (t.localTrackMap.has(vO.LocalVideoLowTrack)) throw new Ch(Oh.UNEXPECTED_ERROR, "[".concat(t.store.clientId, "] Can't publish low stream when stream already publish")); const r = [{ track: t.getLowVideoTrack(n.track, e), type: vO.LocalVideoLowTrack }]; if (yield* MN(Dv(t.doPublish(t.connection, r)), bN), n.track.muted || !n.track.enabled) { var i; const e = null === (i = t.localTrackMap.get(vO.LocalVideoLowTrack)) || void 0 === i ? void 0 : i.id; void 0 !== e && (yield bN(t.connection.muteLocal([e]))) } } finally { n() } }))() } async republish() { this.pendingLocalTracks.length > 0 && (Dh.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await im(this, LO.RequestRePublish, this.pendingLocalTracks), this.emit(LO.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []) } async reSubscribe(e) { for (let t = this.pendingRemoteTracks.length - 1; t >= 0; t--) { const { user: e, kind: n } = this.pendingRemoteTracks[t]; (n !== PO.AUDIO || e._audio_added_ && e._audioSSRC) && (n !== PO.VIDEO || e._video_added_ && e._videoSSRC) || this.pendingRemoteTracks.splice(t, 1) } if (e) await im(this, LO.RequestReSubscribe, this.pendingRemoteTracks); else for (const { user: t, kind: n } of this.pendingRemoteTracks) await this.subscribe(t, n, n === PO.VIDEO ? t._videoSSRC : t._audioSSRC); this.pendingRemoteTracks.forEach((e => { let { user: t } = e; this.emit(LO.MediaReconnectEnd, t.uid) })), this.pendingRemoteTracks = [] } async unpublish(e) { if (!this.connection || this.state !== yO.Connected) return void e.forEach((e => { const t = this.pendingLocalTracks.indexOf(e); -1 !== t && this.pendingLocalTracks.splice(t, 1) })); const t = this.filterTobeUnpublishedTracks(e); if (0 === t.length) return; const n = t.find((e => "videoLowTrack" === e[0])); return n && n[1].track.close(), this.doUnpublish(this.connection, t) } async unpublishLowStream() { if (!this.connection || this.state !== yO.Connected) return; const e = this.localTrackMap.get(vO.LocalVideoLowTrack); if (!e) return; e.track.close(); const t = [[vO.LocalVideoLowTrack, e]]; return this.doUnpublish(this.connection, t) } async doUnpublish(e, t) { const n = this.createGatewayUnpublishMessage(t); return await e.stopSending(t.map((e => { let [, { id: t }] = e; return t }))), this.withdrawLocalTracks(t), this.unbindLocalTrackEvents(t.map((e => { let [t, { track: n }] = e; return { type: t, track: n } }))), t.forEach((e => { let [t] = e; this.statsCollector.removeLocalStats(t) })), 0 === this.localTrackMap.size && this.statsUploader.stopUploadUplinkStats(), n } async subscribe(e, t, n, i, r) { var o; if (!this.connection || this.state !== yO.Connected) throw new Ch(Oh.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected."); if (null !== (o = this.remoteUserMap.get(e)) && void 0 !== o && o.has(t)) return; let s, a, c; if (r) { const n = r.find((e => { let { stream_type: n } = e; return n === t })); if (!n) throw new Ch(Oh.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t, " for user: ").concat(e.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t, ".")); const i = await this.connection.receive(t, n.ssrcs, String(e._uintid), n.attributes); this.connection instanceof FD && (c = i.transceiver), s = i.track, a = i.id } else { const r = await this.connection.receive(t, [{ ssrcId: n, rtx: i }], String(e._uintid), void 0); this.connection instanceof FD && (c = r.transceiver), s = r.track, a = r.id } t === PO.AUDIO ? (e._audioTrack ? e._audioTrack._updateOriginMediaStreamTrack(s) : (e._audioTrack = new rv(s, e.uid, e._uintid, this.store), Dh.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e._audioTrack.getTrackId()))), c && e._audioTrack._updateRtpTransceiver(c), this.bindRemoteTrackEvents(e, e._audioTrack)) : (e._videoTrack ? e._videoTrack._updateOriginMediaStreamTrack(s) : (e._videoTrack = new iv(s, e.uid, e._uintid, this.store), Dh.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e._videoTrack.getTrackId()))), c && e._videoTrack._updateRtpTransceiver(c), this.bindRemoteTrackEvents(e, e._videoTrack)); const E = this.remoteUserMap.get(e); E ? E.set(t, a) : this.remoteUserMap.set(e, new Map([[t, a]])), this.statsCollector.addRemoteStats(e.uid), this.statsUploader.startUploadDownlinkStats(); const _ = this.pendingRemoteTracks.findIndex((n => { let { user: i, kind: r } = n; return i.uid === e.uid && t === r })); -1 !== _ && (this.pendingRemoteTracks.splice(_, 1), this.emit(LO.MediaReconnectEnd, e.uid)) } async massSubscribe(e) { return this.massSubscribeNoLock(e) } async massSubscribeNoLock(e) { if (!this.connection || this.state !== yO.Connected) throw new Ch(Oh.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected."); e = e.filter((e => { var t; let { user: n, mediaType: i } = e; return !(null !== (t = this.remoteUserMap.get(n)) && void 0 !== t && t.has(i)) })); const t = await this.connection.batchReceive(e.map((e => { let { user: t, mediaType: n, ssrcId: i, rtxSsrcId: r } = e; return { kind: n, ssrcMsg: [{ ssrcId: i, rtx: r }], mslabel: String(t._uintid) } }))); e.forEach(((e, n) => { let { user: i, mediaType: r } = e; const { track: o, id: s, transceiver: a } = t[n]; r === PO.AUDIO ? (i._audioTrack ? i._audioTrack._updateOriginMediaStreamTrack(o) : (i._audioTrack = new rv(o, i.uid, i._uintid, this.store), Dh.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(i._audioTrack.getTrackId()))), a && i._audioTrack._updateRtpTransceiver(a), this.bindRemoteTrackEvents(i, i._audioTrack)) : (i._videoTrack ? i._videoTrack._updateOriginMediaStreamTrack(o) : (i._videoTrack = new iv(o, i.uid, i._uintid, this.store), Dh.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(i._videoTrack.getTrackId()))), a && i._videoTrack._updateRtpTransceiver(a), this.bindRemoteTrackEvents(i, i._videoTrack)); const c = this.remoteUserMap.get(i); c ? c.set(r, s) : this.remoteUserMap.set(i, new Map([[r, s]])), this.statsCollector.addRemoteStats(i.uid), this.statsUploader.startUploadDownlinkStats(); const E = this.pendingRemoteTracks.findIndex((e => { let { user: t, kind: n } = e; return t.uid === i.uid && r === n })); -1 !== E && (this.pendingRemoteTracks.splice(E, 1), this.emit(LO.MediaReconnectEnd, i.uid)) })) } async unsubscribe(e, t, n) { const i = this.pendingRemoteTracks.filter((n => { let { user: i, kind: r } = n; return void 0 !== t ? i.uid === e.uid && t === r : i.uid === e.uid })); if (i.forEach((e => { const t = this.pendingRemoteTracks.indexOf(e); this.pendingRemoteTracks.splice(t, 1) })), this.connection && this.state === yO.Connected || n || i.forEach((t => { let { kind: n } = t; var i; if (n === PO.AUDIO) null === (i = e._audioTrack) || void 0 === i || i._destroy(), e._audioTrack = void 0; else if (n === PO.VIDEO) { var r; null === (r = e._videoTrack) || void 0 === r || r._destroy(), e._videoTrack = void 0 } })), !this.connection || this.state !== yO.Connected) return; const r = this.filterTobeUnSubscribedTracks(e, t); if (0 === r.length) return; await this.connection.stopReceiving(r.map((e => { let [, { id: t }] = e; return t }))); const o = this.createUnsubscribeMessage(r); return this.withdrawRemoteTracks(r), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), r.forEach((e => { let [t, { kind: i }] = e; var r, o; if (i === PO.VIDEO && t._videoSSRC && (null === (r = this.connection) || void 0 === r || r.setStatsRemoteVideoIsReady(t._videoSSRC, !1)), i === PO.VIDEO) this.unbindRemoteTrackEvents(t._videoTrack), n || (null === (o = t._videoTrack) || void 0 === o || o._destroy(), t._videoTrack = void 0); else if (i === PO.AUDIO) { var s; this.unbindRemoteTrackEvents(t._audioTrack), n || (null === (s = t._audioTrack) || void 0 === s || s._destroy(), t._audioTrack = void 0) } })), o } async massUnsubscribe(e) { return this.massUnsubscribeNoLock(e) } async massUnsubscribeNoLock(e) { let t = []; for (const { user: r, mediaType: o } of e) { const e = this.pendingRemoteTracks.filter((e => { let { user: t, kind: n } = e; return void 0 !== o ? t.uid === r.uid && o === n : t.uid === r.uid })); e.forEach((e => { const t = this.pendingRemoteTracks.indexOf(e); this.pendingRemoteTracks.splice(t, 1) })), t = t.concat(e) } if (!this.connection || this.state !== yO.Connected) return void t.forEach((e => { let { user: t, kind: n } = e; var i; if (n === PO.AUDIO) null === (i = t._audioTrack) || void 0 === i || i._destroy(), t._audioTrack = void 0; else if (n === PO.VIDEO) { var r; null === (r = t._videoTrack) || void 0 === r || r._destroy(), t._videoTrack = void 0 } })); const n = Zn(e).call(e, ((e, t) => { let { user: n, mediaType: i } = t; const r = this.filterTobeUnSubscribedTracks(n, i); return e.concat(r) }), []); if (0 === n.length) return; await this.connection.stopReceiving(n.map((e => { let [, { id: t }] = e; return t }))); const i = this.createUnsubscribeAllMessage(n); return this.withdrawRemoteTracks(n), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), n.forEach((e => { let [t, { kind: n }] = e; var i, r; if (n === PO.VIDEO && t._videoSSRC && (null === (i = this.connection) || void 0 === i || i.setStatsRemoteVideoIsReady(t._videoSSRC, !1)), n === PO.VIDEO) this.unbindRemoteTrackEvents(t._videoTrack), null === (r = t._videoTrack) || void 0 === r || r._destroy(), t._videoTrack = void 0; else if (n === PO.AUDIO) { var o; this.unbindRemoteTrackEvents(t._audioTrack), null === (o = t._audioTrack) || void 0 === o || o._destroy(), t._audioTrack = void 0 } })), i } async muteRemote(e, t) { if (!this.connection) return; const n = this.remoteUserMap.get(e); if (!n) return void Dh.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e.uid, ".")); if (!n.get(t)) return void Dh.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e.uid, " media type ").concat(t, ".")); const i = t === PO.VIDEO ? e._videoSSRC : e._audioSSRC; void 0 !== i && this.connection.setStatsRemoteVideoIsReady(i, !1) } async unmuteRemote(e, t) { return this.unmuteRemoteNoLock(e, t) } async unmuteRemoteNoLock(e, t) { if (!this.connection) return; const n = this.remoteUserMap.get(e); n ? n.get(t) || Dh.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e.uid, " media type ").concat(t, ".")) : Dh.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e.uid, ".")) } getAllTracks(e) { const t = this.localTrackMap.get(vO.LocalAudioTrack); if ((null == t ? void 0 : t.track) instanceof Dg) { const n = t.track; return Array.from(this.localTrackMap.entries()).filter((e => { let [t] = e; return t !== vO.LocalAudioTrack })).filter((t => { let [n] = t; return !(e && n === vO.LocalVideoLowTrack) })).map((e => { let [, { track: t }] = e; return t })).concat(n.trackList) } return Array.from(this.localTrackMap.entries()).filter((t => { let [n] = t; return !(e && n === vO.LocalVideoLowTrack) })).map((e => { let [, { track: t }] = e; return t })) } reportPublishEvent(e, t, n, i, r) { if (e) { const n = this.localTrackMap.get(vO.LocalAudioTrack), o = i ? this.localTrackMap.get(vO.LocalVideoLowTrack) : this.localTrackMap.get(vO.LocalVideoTrack); wA.publish(this.store.sessionId, { eventElapse: Lg.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e, ec: t, audioName: null == n ? void 0 : n.track.getTrackLabel(), videoName: null == o ? void 0 : o.track.getTrackLabel(), screenshare: -1 !== (null == o ? void 0 : o.track._hints.indexOf(dO.SCREEN_TRACK)), audio: !!n, video: !!o, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r }) } else { var o; n || (n = []); const s = n.find((e => e instanceof fg)), a = i ? null === (o = this.localTrackMap.get(vO.LocalVideoTrack)) || void 0 === o ? void 0 : o.track : n.find((e => e instanceof If)); wA.publish(this.store.sessionId, { eventElapse: Lg.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e, ec: t, audioName: null == s ? void 0 : s.getTrackLabel(), videoName: null == a ? void 0 : a.getTrackLabel(), screenshare: -1 !== (null == a ? void 0 : a._hints.indexOf(dO.SCREEN_TRACK)), audio: !!s, video: !!a, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r }) } } reportSubscribeEvent(e, t, n, i) { const r = i === PO.VIDEO ? n._videoSSRC : n._audioSSRC; r && wA.subscribe(this.store.sessionId, { succ: e, ec: t, video: i === PO.VIDEO, audio: i === PO.AUDIO, peerid: n.uid, subscribeRequestid: i === PO.VIDEO ? n._videoSSRC : n._audioSSRC, p2pid: this.store.p2pId, eventElapse: Lg.measureFromSubscribeStart(this.store.clientId, r) }) } reset() { Dh.debug("[".concat(this.store.clientId, "] P2PChannel.reset")), this.mutex = new kA("P2PChannel-mutex"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new mv({}, this.store) : this.isPlanB ? new vD({}, this.store) : new FD({}, this.store), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver(); const e = this.localTrackMap.get(vO.LocalAudioTrack); if ((null == e ? void 0 : e.track) instanceof Dg) { if (e.track.trackList.length > 0) { const t = e.track; e.track.trackList.forEach((e => { t.removeAudioTrack(e) })) } e.track.close() } this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.state = yO.Disconnected } getStats() { var e; return null === (e = this.connection) || void 0 === e ? void 0 : e.getStats() } getRemoteVideoIsReady(e) { var t; return (null === (t = this.connection) || void 0 === t ? void 0 : t.getRemoteVideoIsReady(e)) || !1 } getLocalAudioVolume() { const e = this.localTrackMap.get(vO.LocalAudioTrack); if (e) return e.track.getVolumeLevel() } getLocalVideoSize() { const e = this.localTrackMap.get(vO.LocalVideoTrack); if (e) return { width: e.track._videoWidth || 0, height: e.track._videoHeight || 0 } } getEncoderConfig(e) { const t = this.localTrackMap.get(e); return t && t.track instanceof If || t && t.track instanceof fg ? t.track._encoderConfig : void 0 } getLocalMedia(e) { return this.localTrackMap.get(e) } hasLocalMedia() { return this.localTrackMap.size > 0 } hasRemoteMedia(e, t) { if (!e) return this.remoteUserMap.size > 0; const n = this.remoteUserMap.get(e); return !!n && (!t || n.has(t)) } async hasRemoteMediaWithLock(e, t) { if (!e) return this.remoteUserMap.size > 0; const n = this.remoteUserMap.get(e); return !!n && (!t || n.has(t)) } getRemoteMedia(e) { var t; const n = Array.from(hA(t = this.remoteUserMap).call(t)).find((t => t.uid === e)); return n ? { audioTrack: n.audioTrack, audioSSRC: n._audioSSRC, videoTrack: n.videoTrack, videoSSRC: n._videoSSRC } : {} } getAudioLevels() { let e = Array.from(this.remoteUserMap.entries()).map((e => { let [t] = e; return { uid: t.uid, level: t.audioTrack ? 100 * t.audioTrack._source.getAccurateVolumeLevel() : 0 } })); const t = this.localTrackMap.get(vO.LocalAudioTrack); return t && e.push({ level: 100 * t.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e = Wp(e).call(e, ((e, t) => e.level - t.level)), e } async disconnectForReconnect() { this.connection && (Dh.debug("[".concat(this.store.clientId, "] P2PChannel.disconnectForReconnect closing P2PConnection")), this.state = yO.Reconnecting, jh("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e => { let [t] = e; var n; t._videoTrack && t._videoTrack._player && (null === (n = t._videoTrack._player.getVideoElement()) || void 0 === n || n.pause(), t._videoTrack._player.isKeepLastFrame = !0, t._videoTrack._originMediaStreamTrack.stop()) })), this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new mv({}, this.store) : this.isPlanB ? new vD({}, this.store) : new FD({}, this.store), this.bindConnectionEvents(this.connection)), 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e => { let [t, { track: n }] = e; switch (t) { case vO.LocalVideoTrack: n._hints.includes(dO.LOW_STREAM) ? n.close() : this.pendingLocalTracks.push(n); break; case vO.LocalAudioTrack: n instanceof Dg ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n.trackList) : this.pendingLocalTracks.push(n); case vO.LocalVideoLowTrack: } })), this.emit(LO.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e => { let [t, n] = e; Array.from(hA(n).call(n)).forEach((e => { this.setPendingRemoteMedia(t, e) })), this.emit(LO.MediaReconnectStart, t.uid) })), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), Dh.debug("[".concat(this.store.clientId, "] P2PChannel disconnected, waiting to reconnect."))) } hasPendingRemoteMedia(e, t) { for (const n of this.pendingRemoteTracks) { const { user: i, kind: r } = n; if ((e instanceof Pf ? e.uid : e) === i.uid && t === r) return !0 } return !1 } setPendingRemoteMedia(e, t) { this.hasPendingRemoteMedia(e, t) || this.pendingRemoteTracks.push({ user: e, kind: t }) } restartICE(e) { var t = this; return wN((function* () { if (!t.connection || t.state !== yO.Connected || t.connection instanceof mv) return; const n = yield bN(t.mutex.lock("From P2PChannel.restartICE")); let i; try { i = yield bN(t.connection.restartICE(e)); const n = yield bN(i.next()); if (n.done) return; const r = n.value, o = yield r; switch (t.reportPCDisconnectedOrFailed(e), e) { case NO.TCP: t._pcStatsUploadType = DO.TCP_RESTART; break; case NO.RELAY: t._pcStatsUploadType = DO.RELAY_RESTART; break; default: t._pcStatsUploadType = DO.OLD_RESTART }t._isInRestartIce = !0, i.next(o) } catch (e) { var r; null === (r = i) || void 0 === r || r.throw(e) } finally { n() } }))() } getUplinkNetworkQuality() { if (!this.connection) return 0; const e = this.connection.getStats(), t = this.localTrackMap.get(vO.LocalVideoTrack), n = this.localTrackMap.get(vO.LocalAudioTrack), i = e.videoSend.find((e => e.ssrc === (null == t ? void 0 : t.ssrcs[0].ssrcId))), r = e.audioSend.find((e => e.ssrc === (null == n ? void 0 : n.ssrcs[0].ssrcId))); if (!i || !r) return 1; const o = om(this, LO.NeedSignalRTT), s = i ? i.rttMs : void 0, a = r ? r.rttMs : void 0, c = s && a ? (s + a) / 2 : s || a, E = (c && o ? (c + o) / 2 : c || o) || 0, _ = 100 * e.sendPacketLossRate * .7 / 50 + .3 * E / 1500, d = _ < .17 ? 1 : _ < .36 ? 2 : _ < .59 ? 3 : _ < .1 ? 4 : 5, u = null == t ? void 0 : t.track; if (u && u._encoderConfig && -1 === u._hints.indexOf(dO.SCREEN_TRACK)) { const t = u._encoderConfig.bitrateMax, n = e.bitrate.actualEncoded; if (t && n) { const e = (1e3 * t - n) / (1e3 * t); return Qh[e < .15 ? 0 : e < .3 ? 1 : e < .45 ? 2 : e < .6 ? 3 : 4][d] } } return d } getDownlinkNetworkQuality() { if (!this.connection) return 0; const e = this.connection.getStats(); let t = 0; return Array.from(this.remoteUserMap.entries()).forEach((n => { let [i] = n; const r = i._audioSSRC, o = i._videoSSRC, s = e.audioRecv.find((e => e.ssrc === r)), a = e.videoRecv.find((e => e.ssrc === o)); if (!s && !a) return void (t += 1); const c = om(this, LO.NeedSignalRTT), E = e.rtt, _ = (E && c ? (E + c) / 2 : E || c) || 0, d = s ? s.jitterMs : void 0, u = e.recvPacketLossRate; let l = .7 * u * 100 / 50 + .3 * _ / 1500; d && (l = .6 * u * 100 / 50 + .2 * _ / 1500 + .2 * d / 400), t += l < .1 ? 1 : l < .17 ? 2 : l < .36 ? 3 : l < .59 ? 4 : 5 })), this.remoteUserMap.size > 0 ? Math.round(t / this.remoteUserMap.size) : t } async muteLocalTrack(e) { return new Cd(((t, n) => { this.handleMuteLocalTrack(e, t, n) })) } filterTobePublishedTracks(e, t, n) { const i = [], r = XO(), o = this.getAllTracks(); e = cm(e = e.filter((e => -1 === o.indexOf(e)))); let s = !1, a = !1; for (const c of e) { if (c instanceof If && (this.localTrackMap.has(vO.LocalVideoTrack) || s ? new Ch(Oh.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (i.push({ track: c, type: vO.LocalVideoTrack }), s = !0), t)) { const e = this.getLowVideoTrack(c, n); i.push({ track: e, type: vO.LocalVideoLowTrack }) } if (c instanceof fg) { const e = this.localTrackMap.get(vO.LocalAudioTrack); if (e) { if (!(e.track instanceof Dg)) throw new Ch(Oh.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing"); if (c._bypassWebAudio) throw new Ch(Oh.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio"); e.track.addAudioTrack(c), this.bindLocalAudioTrackEvents(c, !0) } else if (a) { const e = i.find((e => { let { type: t } = e; return t === vO.LocalAudioTrack })); if (!(e.track instanceof Dg)) throw new Ch(Oh.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing"); if (c._bypassWebAudio) throw new Ch(Oh.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio"); e.track.addAudioTrack(c) } else { if (!r.webAudioMediaStreamDest || c instanceof Dg || c._bypassWebAudio) i.push({ track: c, type: vO.LocalAudioTrack }); else { const e = new Dg; e.addAudioTrack(c), i.push({ track: e, type: vO.LocalAudioTrack }) } a = !0 } } } return i } filterTobeUnpublishedTracks(e) { const t = [], n = this.getAllTracks(); e = cm(e = e.filter((e => -1 !== n.indexOf(e)))); for (const i of e) { if (i instanceof fg) { const e = this.localTrackMap.get(vO.LocalAudioTrack); if (!e) continue; e.track instanceof Dg ? (e.track.removeAudioTrack(i), this.unbindLocalAudioTrackEvents(i), 0 === e.track.trackList.length && (t.push([vO.LocalAudioTrack, e]), e.track.close())) : t.push([vO.LocalAudioTrack, e]) } if (i instanceof If) { const e = this.localTrackMap.get(vO.LocalVideoTrack); if (!e) continue; t.push([vO.LocalVideoTrack, e]); const n = this.localTrackMap.get(vO.LocalVideoLowTrack); n && t.push([vO.LocalVideoLowTrack, n]) } } return t } bindLocalTrackEvents(e) { e.forEach((e => { let { track: t, type: n } = e; switch (n) { case vO.LocalVideoTrack: t.addListener(_O.GET_STATS, this.handleGetLocalVideoStats), t.addListener(_O.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t.addListener(_O.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t.addListener(_O.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t.addListener(_O.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t.addListener(_O.NEED_REPLACE_TRACK, this.handleReplaceTrack), t.addListener(_O.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t.addListener(_O.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack); break; case vO.LocalAudioTrack: this.bindLocalAudioTrackEvents(t); case vO.LocalVideoLowTrack: } })) } bindLocalAudioTrackEvents(e, t) { e instanceof Dg ? e.trackList.forEach((e => { e.addListener(_O.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.addListener(_O.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.addListener(_O.GET_STATS, this.handleGetLocalAudioStats), e.addListener(_O.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.addListener(_O.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack) })) : (e.addListener(_O.GET_STATS, this.handleGetLocalAudioStats), e.addListener(_O.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.addListener(_O.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.addListener(_O.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.addListener(_O.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t || e.addListener(_O.NEED_REPLACE_TRACK, this.handleReplaceTrack)) } unbindLocalTrackEvents(e) { e || (e = Array.from(this.localTrackMap.entries()).map((e => { let [t, { track: n }] = e; return { track: n, type: t } }))), e.forEach((e => { let { track: t, type: n } = e; switch (n) { case vO.LocalVideoTrack: t.off(_O.GET_STATS, this.handleGetLocalVideoStats), t.off(_O.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t.off(_O.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t.off(_O.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t.off(_O.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t.off(_O.NEED_REPLACE_TRACK, this.handleReplaceTrack), t.off(_O.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t.off(_O.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack); break; case vO.LocalAudioTrack: this.unbindLocalAudioTrackEvents(t); case vO.LocalVideoLowTrack: } })) } unbindLocalAudioTrackEvents(e) { e instanceof Dg ? e.trackList.forEach((e => { e.off(_O.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(_O.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(_O.GET_STATS, this.handleGetLocalAudioStats), e.off(_O.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(_O.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack) })) : (e.off(_O.GET_STATS, this.handleGetLocalAudioStats), e.off(_O.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(_O.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(_O.NEED_REPLACE_TRACK, this.handleReplaceTrack), e.off(_O.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(_O.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack)) } bindRemoteTrackEvents(e, t) { t instanceof iv && t.addListener(_O.GET_STATS, (t => { t(this.handleGetRemoteVideoStats(e)) })), t instanceof rv && t.addListener(_O.GET_STATS, (t => { t(this.handleGetRemoteAudioStats(e)) })) } unbindRemoteTrackEvents(e) { e && e.removeAllListeners(_O.GET_STATS) } unbindAllRemoteTrackEvents() { Array.from(this.remoteUserMap.entries()).forEach((e => { let [t, n] = e; n.has(PO.AUDIO) && this.unbindRemoteTrackEvents(t._audioTrack), n.has(PO.VIDEO) && this.unbindRemoteTrackEvents(t._videoTrack) })) } createGatewayPublishMessage(e, t) { return e.map(((e, n) => { let i, r, { track: o, type: s } = e; switch (s) { case vO.LocalAudioTrack: i = sO.Audio, r = { dtx: o instanceof Pg && o._config.DTX, hq: !1, lq: !1, stereo: !1, speech: !1 }; break; case vO.LocalVideoTrack: i = o._hints.includes(dO.SCREEN_TRACK) ? sO.Screen : sO.High, r = Nv(Nv({}, Bg(o)), {}, { codec: this.store.codec }); break; case vO.LocalVideoLowTrack: i = sO.Low, r = Nv(Nv({}, Bg(o)), {}, { codec: this.store.codec }) }return { stream_type: i, attributes: r, ssrcs: t[n] } })) } createGatewayUnpublishMessage(e) { return e.map((e => { let t, [n, { track: i, ssrcs: r, id: o }] = e; switch (n) { case vO.LocalVideoTrack: t = i._hints.includes(dO.SCREEN_TRACK) ? sO.Screen : sO.High; break; case vO.LocalAudioTrack: t = sO.Audio; break; case vO.LocalVideoLowTrack: t = sO.Low }return { stream_type: t, ssrcs: r, mid: o } })) } assignLocalTracks(e, t) { e.forEach(((e, n) => { let { track: i, type: r } = e; this.localTrackMap.set(r, { track: i, id: t[n].id, ssrcs: t[n].localSSRC }) })) } withdrawLocalTracks(e) { e.forEach((e => { let [t] = e; this.localTrackMap.delete(t) })) } bindConnectionEvents(e) { e.onConnectionStateChange = async t => { if (Dh.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t, ")")), this.emit(LO.PeerConnectionStateChange, t), "connected" !== t || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t && (this._restartTimer && (clearTimeout(this._restartTimer), this._restartTimer = void 0), (this._isFirstConnected || this._isInRestartIce) && this.reportPCStats(Date.now(), !0, this._pcStatsUploadType), this._isInRestartIce = !1, this._isFirstConnected = !1, this._isStartRestartIce = !1), jh("NEW_ICE_RESTART")) { if (this._restartStates.includes(t)) { if (this._isStartRestartIce) return; this._isStartRestartIce = !0; const t = t => { "disconnected" !== e.iceConnectionState && "checking" !== e.iceConnectionState && "failed" !== e.iceConnectionState || (Dh.debug("[".concat(this.store.clientId, "] [P2PChannel] start use restartICE, type is ").concat(t)), "CONNECTED" === om(this, LO.QueryClientConnectionState) && this.emit(LO.RequestRestartICE, t)) }, n = () => { "disconnected" !== e.iceConnectionState && "checking" !== e.iceConnectionState && "failed" !== e.iceConnectionState || (this.reportPCStats(Date.now(), !1, this._pcStatsUploadType), Dh.debug("[".concat(this.store.clientId, "] P2PConnection disconnected timeout, force reconnect")), setTimeout((() => this.emit(LO.P2PLost)), 0), this.iceFailedCount += 1, this.requestReconnect()) }, i = jh("ICE_RESTART_INTERVAL"); return void (this._restartTimer = window.setTimeout((() => { if (jh("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && XO().supportPCSetConfiguration) t(NO.RELAY), this._restartTimer = window.setTimeout(n, i); else if (Ku()) t(NO.UDP), this._restartTimer = window.setTimeout(n, 4e3); else { if (t(NO.TCP), XO().supportPCSetConfiguration) return void (this._restartTimer = window.setTimeout((() => { t(NO.RELAY), this._restartTimer = window.setTimeout(n, i) }), i)); this._restartTimer = window.setTimeout(n, i) } }), 800)) } } else { if ("disconnected" === t && "disconnected" === e.iceConnectionState) return setTimeout((() => { "disconnected" === e.iceConnectionState && jh("ICE_RESTART") && "CONNECTED" === om(this, LO.QueryClientConnectionState) && this.emit(LO.RequestRestartICE) }), 800), void setTimeout((() => { "disconnected" === e.peerConnectionState && (Dh.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection disconnected timeout 4000ms, force reconnect")), this.reportPCStats(Date.now(), !1, this._pcStatsUploadType), this._isInRestartIce = !1, setTimeout((() => this.emit(LO.P2PLost)), 0), this.iceFailedCount += 1, this.requestReconnect()) }), 4e3); "failed" === t && (Dh.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection state failed, force reconnect")), this.reportPCDisconnectedOrFailed(), setTimeout((() => this.emit(LO.P2PLost)), 0), this.iceFailedCount += 1, await this.requestReconnect()) } }, e.onICEConnectionStateChange = e => { "connected" !== e || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), Dh.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e, ")")), wA.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e, tag: hT.TRACER }).onSuccess(), this.emit(LO.IceConnectionStateChange, e) }, e.onICETransportStateChange = e => { Dh.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e, ")")) }, e.onDTLSTransportStateChange = e => { Dh.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e, ")")) }, e.onDTLSTransportError = e => { Dh.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e, ")")) }, e.onFirstAudioDecoded = e => { var t; const n = Array.from(hA(t = this.remoteUserMap).call(t)).find((t => t._audioSSRC === e)); var i; n && (this.store.subscribe(n.uid, "audio", void 0, void 0, void 0, Date.now()), null === (i = n.audioTrack) || void 0 === i || i.emit(TO.FIRST_FRAME_DECODED), wA.firstRemoteFrame(this.store.sessionId, _T.FIRST_AUDIO_DECODE, dT.FIRST_AUDIO_DECODE, { peer: n._uintid, subscribeElapse: Lg.measureFromSubscribeStart(this.store.clientId, e), subscribeRequestid: e, p2pid: this.store.p2pId })) }, e.onFirstAudioReceived = e => { var t; const n = Array.from(hA(t = this.remoteUserMap).call(t)).find((t => t._audioSSRC === e)); n && wA.firstRemoteFrame(this.store.sessionId, _T.FIRST_AUDIO_RECEIVED, dT.FIRST_AUDIO_RECEIVED, { peer: n._uintid, subscribeElapse: Lg.measureFromSubscribeStart(this.store.clientId, e), subscribeRequestid: e, p2pid: this.store.p2pId }) }, e.onFirstVideoDecoded = (e, t, n) => { this.reportVideoFirstFrameDecoded(e, t, n) }, e.onFirstVideoReceived = e => { var t; const n = Array.from(hA(t = this.remoteUserMap).call(t)).find((t => t._videoSSRC === e)); n && wA.firstRemoteFrame(this.store.sessionId, _T.FIRST_VIDEO_RECEIVED, dT.FIRST_VIDEO_RECEIVED, { peer: n._uintid, subscribeElapse: Lg.measureFromSubscribeStart(this.store.clientId, e), subscribeRequestid: e, p2pid: this.store.p2pId }) }, e.onSelectedLocalCandidateChanged = (e, t) => { const n = "relay" === e.candidateType, i = "relay" === t.candidateType; "unknown" !== t.candidateType && n === i || this.emit(LO.ConnectionTypeChange, n), Dh.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(Kg(t)), " -> ").concat(JSON.stringify(Kg(e)), ")")) }, e.onSelectedRemoteCandidateChanged = (e, t) => { Dh.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(Kg(t)), " -> ").concat(JSON.stringify(Kg(e)), ")")) }, e.onFirstVideoDecodedTimeout = e => { this.reportVideoFirstFrameDecoded(e, void 0, void 0, !0) } } unbindConnectionEvents(e) { e.onConnectionStateChange = void 0, e.onICEConnectionStateChange = void 0, e.onICETransportStateChange = void 0, e.onDTLSTransportStateChange = void 0, e.onDTLSTransportError = void 0, e.onFirstAudioDecoded = void 0, e.onFirstAudioReceived = void 0, e.onFirstVideoDecoded = void 0, e.onFirstVideoReceived = void 0, e.onSelectedLocalCandidateChanged = void 0, e.onSelectedRemoteCandidateChanged = void 0, e.onFirstVideoDecodedTimeout = void 0 } filterTobeMutedTracks(e) { const t = []; if (-1 === this.getAllTracks().indexOf(e)) return t; const n = this.localTrackMap.get(vO.LocalAudioTrack); if (e instanceof fg && (null == n ? void 0 : n.track) instanceof Dg) return n.track.isActive || t.push([vO.LocalAudioTrack, n]), t; const i = Array.from(this.localTrackMap.entries()).find((t => { let [, { track: n }] = t; return e === n })); if (i && (t.push(i), i[0] === vO.LocalVideoTrack)) { const e = this.localTrackMap.get(vO.LocalVideoLowTrack); e && t.push([vO.LocalVideoLowTrack, e]) } return t } filterTobeUnmutedTracks(e) { const t = [], n = this.localTrackMap.get(vO.LocalAudioTrack); if (e instanceof fg && (null == n ? void 0 : n.track) instanceof Dg) return n.track.isActive && t.push([vO.LocalAudioTrack, n]), t; const i = Array.from(this.localTrackMap.entries()).find((t => { let [, { track: n }] = t; return e === n })); if (i) if (i[0] === vO.LocalVideoTrack) { t.push(i); const e = this.localTrackMap.get(vO.LocalVideoLowTrack); e && t.push([vO.LocalVideoLowTrack, e]) } else t.push(i); return t } createMuteMessage(e) { return e.map((e => { let t, [n, { track: i, ssrcs: r, id: o }] = e; switch (n) { case vO.LocalAudioTrack: t = sO.Audio; break; case vO.LocalVideoTrack: t = i._hints.includes(dO.SCREEN_TRACK) ? sO.Screen : sO.High; break; case vO.LocalVideoLowTrack: t = sO.Low }return { stream_type: t, ssrcs: r, mid: o } })) } createUnmuteMessage(e) { return e.map((e => { let t, [n, { track: i, ssrcs: r, id: o }] = e; switch (n) { case vO.LocalAudioTrack: t = sO.Audio; break; case vO.LocalVideoTrack: t = i._hints.includes(dO.SCREEN_TRACK) ? sO.Screen : sO.High; break; case vO.LocalVideoLowTrack: t = sO.Low }return { stream_type: t, ssrcs: r, mid: o } })) } filterTobeUnSubscribedTracks(e, t) { const n = [], i = this.remoteUserMap.get(e); if (!i) return n; if (t) { const r = i.get(t); if (!r) return n; n.push([e, { kind: t, id: r }]) } else Array.from(i.entries()).forEach((t => { let [i, r] = t; n.push([e, { kind: i, id: r }]) })); return n } createUnsubscribeMessage(e) { const t = []; return e.forEach((e => { let [n, { kind: i, id: r }] = e; switch (i) { case PO.VIDEO: return void (n._videoSSRC && t.push({ stream_type: PO.VIDEO, ssrcId: n._videoSSRC })); case PO.AUDIO: return void (n._audioSSRC && t.push({ stream_type: PO.AUDIO, ssrcId: n._audioSSRC })) } })), t } createUnsubscribeAllMessage(e) { const t = new Map; return e.forEach((e => { let [n, { kind: i }] = e; if (t.has(n)) { let e = t.get(n); i === PO.VIDEO ? e |= cO.Video : e |= cO.Audio, t.set(n, e) } else i === PO.VIDEO ? t.set(n, cO.Video) : t.set(n, cO.Audio) })), { users: Array.from(t.entries()).map((e => { let [t, n] = e; return { stream_id: t.uid, stream_type: n } })) } } withdrawRemoteTracks(e) { e.forEach((e => { let [t, { kind: n }] = e; const i = this.remoteUserMap.get(t); i && (i.delete(n), 0 === Array.from(i.entries()).length && this.remoteUserMap.delete(t)) })) } async updateBitrateLimit(e) { const t = this.localTrackMap.get(vO.LocalVideoTrack), n = this.localTrackMap.get(vO.LocalVideoLowTrack); t && await t.track.setBitrateLimit(e.uplink), n && e.low_stream_uplink && await n.track.setBitrateLimit({ max_bitrate: e.low_stream_uplink.bitrate, min_bitrate: e.low_stream_uplink.bitrate || 0 }) } isP2PDisconnected() { return !this.connection || "connected" !== this.connection.peerConnectionState } mapPubResToRemoteConfig(e, t) { return e.map(((e, n) => { var i; let { stream_type: r } = e; return null === (i = t.find((e => { let { stream_type: t } = e; return r === t }))) || void 0 === i ? void 0 : i.attributes })) } async tryToUnmuteAudio(e) { for (let n = 0; n < e.length; n++)if (e[n] instanceof fg) { var t; const i = this.filterTobeUnmutedTracks(e[n]); if (0 === i.length) continue; await (null === (t = this.connection) || void 0 === t ? void 0 : t.unmuteLocal(i.map((e => { let [, { id: t }] = e; return t })))); const r = this.createUnmuteMessage(i); return void (await rm(this, LO.RequestUnmuteLocal, r)) } } bindStatsUploaderEvents() { this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = e => { var t; return !(null === (t = this.connection) || void 0 === t || !t.getRemoteVideoIsReady(e)) }, this.statsUploader.requestUpload = (e, t) => this.emit(LO.RequestUploadStats, e, t), this.statsUploader.requestAllTracks = () => this.getAllTracks() } unbindStatsUploaderEvents() { this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0 } async requestReconnect() { this.dtlsFailedCount += 1, await Qg(Sh(this.dtlsFailedCount, Ah)), this.emit(LO.RequestReconnect) } async reconnectP2P() { const e = Array.from(this.localTrackMap.entries()), t = this.createGatewayUnpublishMessage(e); Array.from(this.remoteUserMap.entries()), t.length > 0 && await im(this, LO.RequestUnpublishForReconnectPC, t), this.disconnectForReconnect(), this.emit(LO.RequestReconnectPC) } canPublishLowStream() { return this.localTrackMap.has(vO.LocalVideoTrack) || this.pendingLocalTracks.some((e => e instanceof If)) } throwIfTrackTypeNotMatch(e) { if (e.filter((e => e instanceof If)).length > 1) throw new Ch(Oh.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS); if (e.filter((e => e instanceof fg)).length > 1 && (e.some((e => e instanceof fg && e._bypassWebAudio)) || !XO().webAudioMediaStreamDest)) throw new Ch(Oh.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode"); for (const t of e) { if (t instanceof If && this.pendingLocalTracks.some((e => e instanceof If))) throw new Ch(Oh.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS); if (t instanceof fg && this.pendingLocalTracks.some((e => e instanceof fg)) && (!XO().webAudioMediaStreamDest || t._bypassWebAudio || this.pendingLocalTracks.some((e => e instanceof fg && e._bypassWebAudio)))) throw new Ch(Oh.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode") } } getLowVideoTrack(e, t) { const n = XO().supportDualStreamEncoding, i = Nv(Nv({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t); let r; r = n ? e._mediaStreamTrack.clone() : BD(e, i); const o = Zg(8, "track-low-"), s = new If(r, Nv(Nv({}, n && { scaleResolutionDownBy: Wg(i, e) }), {}, { frameRate: i.framerate, bitrateMax: i.bitrate, bitrateMin: i.bitrate }), void 0, void 0, o); return s.on(hO.TRANSCEIVER_UPDATED, (t => { e._updateRtpTransceiver(t, uO.LOW_STREAM) })), s._hints.push(dO.LOW_STREAM), e.addListener(_O.NEED_CLOSE, (() => { s.close() })), s } async globalLock() { return this.mutex.lock("From P2PChannel.globalLock") } async reportPCStats(e, t, n) { let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; if (this.connection && this.connection instanceof FD) { var r, o, s, a; const c = this.store.keyMetrics.descriptionStart || 0, { iceConnectionState: E, dtlsTransportState: _, peerConnectionState: d } = this.connection, { local: u, remote: l } = await this.connection.getSelectedCandidatePair(); wA.pcStats(this.store.sessionId, { startTime: c, eventElapse: e - c || 0, iceconnectionsate: E, dtlsstate: _, connectionstate: d, intSucc: t ? 1 : 2, error: i, selectedLocalCandidateProtocol: null !== (r = null == u ? void 0 : u.protocol) && void 0 !== r ? r : "", selectedLocalCandidateType: null !== (o = u.candidateType) && void 0 !== o ? o : "", selectedLocalCandidateAddress: "".concat(u.address, ":").concat(u.port), selectedRemoteCandidateProtocol: null !== (s = l.protocol) && void 0 !== s ? s : "", selectedRemoteCandidateType: null !== (a = l.candidateType) && void 0 !== a ? a : "", selectedRemoteCandidateAddress: "".concat(l.address, ":").concat(l.port), restartCnt: n }) } } reportVideoFirstFrameDecoded(e, t, n, i) { var r; const o = Array.from(hA(r = this.remoteUserMap).call(r)).find((t => t._videoSSRC === e)); if (o) { i || this.store.subscribe(o.uid, "video", void 0, void 0, void 0, void 0, Date.now()); const r = this.store.keyMetrics, s = r.subscribe.find((e => e.userId === o.uid && "video" === e.type)); wA.firstRemoteVideoDecode(this.store.sessionId, _T.FIRST_VIDEO_DECODE, dT.FIRST_VIDEO_DECODE, { peer: o._uintid, videowidth: t, videoheight: n, subscribeElapse: Lg.measureFromSubscribeStart(this.store.clientId, e), subscribeRequestid: e, p2pid: this.store.p2pId, apEnd: r.requestAPEnd || 0, apStart: r.requestAPStart || 0, joinGwEnd: r.joinGatewayEnd || 0, joinGwStart: r.joinGatewayStart || 0, pcEnd: r.peerConnectionEnd || 0, pcStart: r.peerConnectionStart || 0, subscriberEnd: (null == s ? void 0 : s.subscribeEnd) || 0, subscriberStart: (null == s ? void 0 : s.subscribeStart) || 0, videoAddNotify: (null == s ? void 0 : s.streamAdded) || 0, state: i ? 1 : 0 }) } } async remoteMediaSsrcChanged(e, t, n) { if (!this.connection) return !1; const i = this.remoteUserMap.get(e); if (!i) return !1; const r = i.get(t); if (!r) return !1; const o = await this.connection.getRemoteSSRC(r); return void 0 !== o && o !== n } resetConnection(e) { Dh.debug("[".concat(this.store.clientId, "] [P2PChannel] reset connection to ").concat(e)), this.state === yO.Connected ? (Dh.debug("[".concat(this.store.clientId, "] [P2PChannel] fallback to websocket but P2PChannel state still connected, disconnect first")), this.disconnectForReconnect()) : (this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = e === EO.datachannel ? new mv({}, this.store) : this.isPlanB ? new vD({}, this.store) : new FD({}, this.store), this.bindConnectionEvents(this.connection))) } unbindRtpTransceiver() { 0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e => { let [t, { track: n }] = e; t === vO.LocalVideoLowTrack ? n._updateRtpTransceiver(void 0, uO.LOW_STREAM) : n._updateRtpTransceiver(void 0) })) } reportPCDisconnectedOrFailed(e) { this.connection && this.connection instanceof FD && ("disconnected" !== this.connection.iceConnectionState && "checking" !== this.connection.iceConnectionState && "failed" !== this.connection.iceConnectionState || (this._isFirstConnected ? (this.reportPCStats(Date.now(), !1, this._pcStatsUploadType), this._isFirstConnected = !1) : this._pcStatsUploadType === DO.TCP_RESTART && e === NO.RELAY ? this.reportPCStats(Date.now(), !1, this._pcStatsUploadType) : this.reportPCStats(Date.now(), !1, DO.DISCONNECTED_OR_FAILED))) } }).prototype, "startP2PConnection", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "startP2PConnection"), fv.prototype), aA(fv.prototype, "connect", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "connect"), fv.prototype), aA(fv.prototype, "preConnect", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "preConnect"), fv.prototype), aA(fv.prototype, "unpublish", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "unpublish"), fv.prototype), aA(fv.prototype, "unpublishLowStream", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "unpublishLowStream"), fv.prototype), aA(fv.prototype, "subscribe", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "subscribe"), fv.prototype), aA(fv.prototype, "massSubscribe", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "massSubscribe"), fv.prototype), aA(fv.prototype, "unsubscribe", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "unsubscribe"), fv.prototype), aA(fv.prototype, "massUnsubscribe", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "massUnsubscribe"), fv.prototype), aA(fv.prototype, "muteRemote", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "muteRemote"), fv.prototype), aA(fv.prototype, "unmuteRemote", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "unmuteRemote"), fv.prototype), aA(fv.prototype, "hasRemoteMediaWithLock", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "hasRemoteMediaWithLock"), fv.prototype), aA(fv.prototype, "disconnectForReconnect", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "disconnectForReconnect"), fv.prototype), aA(fv.prototype, "updateBitrateLimit", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "updateBitrateLimit"), fv.prototype), aA(fv.prototype, "remoteMediaSsrcChanged", [Lv], Object.getOwnPropertyDescriptor(fv.prototype, "remoteMediaSsrcChanged"), fv.prototype), fv); function Lv(e, t, n) { const i = e[t]; if ("function" != typeof i) throw new Error("Cannot use mutex on object property."); return n.value = async function () { const e = this.mutex, n = await e.lock("From P2PChannel.".concat(t)); try { for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++)o[s] = arguments[s]; return await i.apply(this, o) } finally { n() } }, n } function wv(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function bv(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? wv(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wv(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } var Uv; !function (e) { e.SET_SESSION_ID = "SET_SESSION_ID", e.SET_P2P_ID = "SET_P2P_id", e.SET_DC_ID = "SET_DC_id", e.SET_UID = "SET_UID", e.SET_PUB_ID = "SET_PUB_ID", e.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e.AVOID_JOIN_START = "AVOID_JOIN_START", e.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START", e.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e.RESET_KEY_METRICS = "RESET_KEY_METRICS", e.SET_USE_DATACHANNEL = "SET_USE_DATACHANNEL" }(Uv || (Uv = {})); class Mv { constructor(e, t, n, i) { hl(this, "state", void 0), this.state = { codec: e, audioCodec: t, mode: n, clientId: i, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, avoidJoinStart: 0, keyMetrics: { publish: [], subscribe: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled", useDataChannel: !1 } } dispatch(e) { this.state = function (e, t) { switch (t.type) { case Uv.SET_SESSION_ID: return bv(bv({}, e), {}, { sessionId: t.sessionId }); case Uv.SET_P2P_ID: return bv(bv({}, e), {}, { p2pId: t.p2pId }); case Uv.SET_UID: return bv(bv({}, e), {}, { uid: t.uid }); case Uv.SET_PUB_ID: return bv(bv({}, e), {}, { pubId: t.pubId }); case Uv.KEY_METRIC_CLIENT_CREATED: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { clientCreated: t.metric }) }); case Uv.KEY_METRIC_JOIN_START: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { joinStart: t.metric }) }); case Uv.AVOID_JOIN_START: return bv(bv({}, e), {}, { avoidJoinStart: t.avoidJoinStart }); case Uv.KEY_METRIC_JOIN_END: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { joinEnd: t.metric }) }); case Uv.KEY_METRIC_REQUEST_AP_START: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { requestAPStart: t.metric }) }); case Uv.KEY_METRIC_REQUEST_AP_END: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { requestAPEnd: t.metric }) }); case Uv.KEY_METRIC_JOIN_GATEWAY_START: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { joinGatewayStart: t.metric }) }); case Uv.KEY_METRIC_JOIN_GATEWAY_END: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { joinGatewayEnd: t.metric }) }); case Uv.KEY_METRIC_PEER_CONNECTION_START: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { peerConnectionStart: t.metric }) }); case Uv.KEY_METRIC_PEER_CONNECTION_END: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { peerConnectionEnd: t.metric }) }); case Uv.KEY_METRIC_DESCRIPTION_START: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { descriptionStart: t.metric }) }); case Uv.KEY_METRIC_SIGNAL_CHANNEL_OPEN: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { signalChannelOpen: t.metric }) }); case Uv.KEY_METRIC_ICE_CONNECTION_END: return bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { iceConnectionEnd: t.metric }) }); case Uv.KEY_METRIC_PUBLISH: { const n = e.keyMetrics.publish, i = n.findIndex((e => e.trackId === t.metric.trackId)); return -1 !== i ? (n[i] = bv(bv({}, n[i]), t.metric), bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { publish: [...n] }) })) : bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { publish: [...e.keyMetrics.publish, t.metric] }) }) } case Uv.KEY_METRIC_SUBSCRIBE: { const n = e.keyMetrics.subscribe, i = n.findIndex((e => e.userId === t.metric.userId && e.type === t.metric.type)); return -1 !== i ? (n[i] = bv(bv({}, n[i]), t.metric), bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { subscribe: [...n] }) })) : bv(bv({}, e), {}, { keyMetrics: bv(bv({}, e.keyMetrics), {}, { subscribe: [...e.keyMetrics.subscribe, t.metric] }) }) } case Uv.SET_CLOUD_PROXY_SERVER_MODE: return e.cloudProxyServerMode = t.mode, e; case Uv.RECORD_JOIN_CHANNEL_SERVICE: return "number" != typeof t.index ? e.joinChannelServiceRecords = [...e.joinChannelServiceRecords, t.record] : (e.joinChannelServiceRecords[t.index] = bv(bv({}, e.joinChannelServiceRecords[t.index]), t.record), e.joinChannelServiceRecords = [...e.joinChannelServiceRecords]), e; case Uv.RESET_JOIN_CHANNEL_SERVICE_RECORDS: return e.joinChannelServiceRecords = [], e; case Uv.RESET_KEY_METRICS: return e.keyMetrics = { publish: [], subscribe: [] }, e; case Uv.SET_USE_DATACHANNEL: return bv(bv({}, e), {}, { useDataChannel: t.val }); default: return e } }(this.state, e) } set sessionId(e) { this.dispatch({ type: Uv.SET_SESSION_ID, sessionId: e }) } get sessionId() { return this.state.sessionId } get codec() { return this.state.codec } get audioCodec() { return this.state.audioCodec } get clientId() { return this.state.clientId } set p2pId(e) { this.dispatch({ type: Uv.SET_P2P_ID, p2pId: e }) } get p2pId() { return this.state.p2pId } set dcId(e) { this.dispatch({ type: Uv.SET_DC_ID, dcId: e }) } get dcId() { return this.state.dcId } set uid(e) { this.dispatch({ type: Uv.SET_UID, uid: e }) } get uid() { return this.state.uid } set pubId(e) { this.dispatch({ type: Uv.SET_PUB_ID, pubId: e }) } get pubId() { return this.state.pubId } set cloudProxyServerMode(e) { this.dispatch({ type: Uv.SET_CLOUD_PROXY_SERVER_MODE, mode: e }) } get cloudProxyServerMode() { return this.state.cloudProxyServerMode } set useDataChannel(e) { this.dispatch({ type: Uv.SET_USE_DATACHANNEL, val: e }) } get useDataChannel() { return this.state.useDataChannel } clientCreated() { this.dispatch({ type: Uv.KEY_METRIC_CLIENT_CREATED, metric: Date.now() }) } joinStart() { this.dispatch({ type: Uv.KEY_METRIC_JOIN_START, metric: Date.now() }) } joinEnd() { this.dispatch({ type: Uv.KEY_METRIC_JOIN_END, metric: Date.now() }) } requestAPStart() { this.dispatch({ type: Uv.KEY_METRIC_REQUEST_AP_START, metric: Date.now() }) } requestAPEnd() { this.dispatch({ type: Uv.KEY_METRIC_REQUEST_AP_END, metric: Date.now() }) } joinGatewayStart() { this.dispatch({ type: Uv.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() }) } joinGatewayEnd() { this.dispatch({ type: Uv.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() }) } peerConnectionStart() { this.dispatch({ type: Uv.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() }) } peerConnectionEnd() { this.dispatch({ type: Uv.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() }) } descriptionStart() { this.dispatch({ type: Uv.KEY_METRIC_DESCRIPTION_START, metric: Date.now() }) } signalChannelOpen() { this.dispatch({ type: Uv.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() }) } iceConnectionEnd() { this.dispatch({ type: Uv.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() }) } publish(e, t, n, i) { this.dispatch({ type: Uv.KEY_METRIC_PUBLISH, metric: bv(bv({ trackId: e, type: t }, n && { publishStart: n }), i && { publishEnd: i }) }) } subscribe(e, t, n, i, r, o, s) { this.dispatch({ type: Uv.KEY_METRIC_SUBSCRIBE, metric: bv(bv(bv(bv(bv({ userId: e, type: t }, n && { subscribeStart: n }), i && { subscribeEnd: i }), r && { firstFrame: r }), o && { streamAdded: o }), s && { firstDecoded: s }) }) } massSubscribe(e, t, n, i) { e.forEach((e => { this.dispatch({ type: Uv.KEY_METRIC_SUBSCRIBE, metric: bv(bv(bv({ userId: e.userId, type: e.type }, t && { subscribeStart: t }), n && { subscribeEnd: n }), i && { firstFrame: i }) }) })) } get keyMetrics() { return this.state.keyMetrics } recordJoinChannelService(e, t) { "gateway" === e.service && Array.isArray(e.urls) && (e.urls = e.urls.map((e => e.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")))); try { return "number" != typeof t ? (this.dispatch({ type: Uv.RECORD_JOIN_CHANNEL_SERVICE, record: bv(bv({}, e), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.state.joinChannelServiceRecords.length - 1) : (t < 0 || t >= this.state.joinChannelServiceRecords.length || this.dispatch({ type: Uv.RECORD_JOIN_CHANNEL_SERVICE, record: e, index: t }), t) } catch (e) { return 0 } } resetJoinChannelServiceRecords() { this.dispatch({ type: Uv.RESET_JOIN_CHANNEL_SERVICE_RECORDS }) } resetKeyMetrics() { this.dispatch({ type: Uv.RESET_KEY_METRICS }) } get joinChannelServiceRecords() { try { return this.state.joinChannelServiceRecords } catch (e) { return [] } } get avoidJoinStart() { return this.state.avoidJoinStart } set avoidJoinStart(e) { this.dispatch({ type: Uv.AVOID_JOIN_START, avoidJoinStart: e }) } } let kv; const Vv = () => "HTTPS" === (kv || kv || (kv = (window.location.protocol.split(":")[0] || "").toUpperCase(), kv)), xv = () => void 0 !== window.isSecureContext; function Fv(e) { let t = Qv(); return function (e, t) { let n = e.appId; void 0 !== n && (_y(t, 10), iy(t, n)); let i = e.cid; void 0 !== i && (_y(t, 16), _y(t, i)); let r = e.cname; void 0 !== r && (_y(t, 26), iy(t, r)); let o = e.deviceId; void 0 !== o && (_y(t, 34), iy(t, o)); let s = e.elapse; void 0 !== s && (_y(t, 40), dy(t, s)); let a = e.fileSize; void 0 !== a && (_y(t, 48), dy(t, Xv(a))); let c = e.height; void 0 !== c && (_y(t, 56), dy(t, Xv(c))); let E = e.jpg; void 0 !== E && (_y(t, 66), _y(t, E.length), function (e, t) { let n = ey(e, t.length); e.bytes.set(t, n) }(t, E)); let _ = e.networkType; void 0 !== _ && (_y(t, 72), dy(t, Xv(_))); let d = e.osType; void 0 !== d && (_y(t, 80), dy(t, Xv(d))); let u = e.requestId; void 0 !== u && (_y(t, 90), iy(t, u)); let l = e.sdkVersion; void 0 !== l && (_y(t, 98), iy(t, l)); let R = e.sequence; void 0 !== R && (_y(t, 104), dy(t, Xv(R))); let h = e.sid; void 0 !== h && (_y(t, 114), iy(t, h)); let p = e.timestamp; void 0 !== p && (_y(t, 120), dy(t, p)); let T = e.uid; void 0 !== T && (_y(t, 128), _y(t, T)); let O = e.vid; void 0 !== O && (_y(t, 136), _y(t, O)); let C = e.width; void 0 !== C && (_y(t, 144), dy(t, Xv(C))); let A = e.service; void 0 !== A && (_y(t, 152), _y(t, A)); let S = e.callbackData; void 0 !== S && (_y(t, 162), iy(t, S)); let g = e.jpgEncryption; void 0 !== g && (_y(t, 168), _y(t, g)); let m = e.requestType; void 0 !== m && (_y(t, 176), _y(t, m)); let I = e.scorePorn; void 0 !== I && (_y(t, 185), cy(t, I)); let f = e.scoreSexy; void 0 !== f && (_y(t, 193), cy(t, f)); let P = e.scoreNeutral; void 0 !== P && (_y(t, 201), cy(t, P)); let N = e.scene; void 0 !== N && (_y(t, 208), _y(t, N)); let D = e.ossFilePrefix; void 0 !== D && (_y(t, 218), iy(t, D)); let v = e.serviceVendor; if (void 0 !== v) for (let y of v) { _y(t, 226); let e = Qv(); Gv(y, e), _y(t, e.limit), ry(t, e), zv(e) } }(e, t), function (e) { let t = e.bytes, n = e.limit; return t.length === n ? t : t.subarray(0, n) }(t) } function Yv(e) { return function (e) { let t = {}; e: for (; !$v(e);) { let n = Ey(e); switch (n >>> 3) { case 0: break e; case 1: t.code = Ey(e); break; case 2: t.msg = ny(e, Ey(e)); break; case 3: { let n = jv(e); t.data = Bv(e), e.limit = n; break } default: Hv(e, 7 & n) } } return t }({ bytes: t = e, offset: 0, limit: t.length }); var t } function Bv(e) { let t = {}; e: for (; !$v(e);) { let n = Ey(e); switch (n >>> 3) { case 0: break e; case 1: t.requestId = ny(e, Ey(e)); break; case 2: t.requestType = Ey(e) >>> 0; break; case 3: t.scorePorn = ay(e); break; case 4: t.scoreSexy = ay(e); break; case 5: t.scoreNeutral = ay(e); break; case 6: t.requestScene = Ey(e) >>> 0; break; case 7: t.scene = Ey(e) >>> 0; break; default: Hv(e, 7 & n) } } return t } function Gv(e, t) { let n = e.service; void 0 !== n && (_y(t, 8), _y(t, n)); let i = e.vendor; void 0 !== i && (_y(t, 16), _y(t, i)); let r = e.token; void 0 !== r && (_y(t, 26), iy(t, r)); let o = e.callbackUrl; void 0 !== o && (_y(t, 34), iy(t, o)) } function jv(e) { let t = Ey(e), n = e.limit; return e.limit = e.offset + t, n } function Hv(e, t) { switch (t) { case 0: for (; 128 & oy(e);); break; case 2: Zv(e, Ey(e)); break; case 5: Zv(e, 4); break; case 1: Zv(e, 8); break; default: throw new Error("Unimplemented type: " + t) } } let Wv = new Float32Array(1); new Uint8Array(Wv.buffer); let Kv = new Float64Array(1), Jv = new Uint8Array(Kv.buffer); function Xv(e) { return { low: e |= 0, high: e >> 31, unsigned: e >= 0 } } let qv = []; function Qv() { const e = qv.pop(); return e ? (e.offset = e.limit = 0, e) : { bytes: new Uint8Array(64), offset: 0, limit: 0 } } function zv(e) { qv.push(e) } function Zv(e, t) { if (e.offset + t > e.limit) throw new Error("Skip past limit"); e.offset += t } function $v(e) { return e.offset >= e.limit } function ey(e, t) { let n = e.bytes, i = e.offset, r = e.limit, o = i + t; if (o > n.length) { let t = new Uint8Array(2 * o); t.set(n), e.bytes = t } return e.offset = o, o > r && (e.limit = o), i } function ty(e, t) { let n = e.offset; if (n + t > e.limit) throw new Error("Read past limit"); return e.offset += t, n } function ny(e, t) { let n = ty(e, t), i = String.fromCharCode, r = e.bytes, o = "ï¿½", s = ""; for (let a = 0; a < t; a++) { let e, c, E, _, d = r[a + n]; 0 == (128 & d) ? s += i(d) : 192 == (224 & d) ? a + 1 >= t ? s += o : (e = r[a + n + 1], 128 != (192 & e) ? s += o : (_ = (31 & d) << 6 | 63 & e, _ < 128 ? s += o : (s += i(_), a++))) : 224 == (240 & d) ? a + 2 >= t ? s += o : (e = r[a + n + 1], c = r[a + n + 2], 32896 != (49344 & (e | c << 8)) ? s += o : (_ = (15 & d) << 12 | (63 & e) << 6 | 63 & c, _ < 2048 || _ >= 55296 && _ <= 57343 ? s += o : (s += i(_), a += 2))) : 240 == (248 & d) ? a + 3 >= t ? s += o : (e = r[a + n + 1], c = r[a + n + 2], E = r[a + n + 3], 8421504 != (12632256 & (e | c << 8 | E << 16)) ? s += o : (_ = (7 & d) << 18 | (63 & e) << 12 | (63 & c) << 6 | 63 & E, _ < 65536 || _ > 1114111 ? s += o : (_ -= 65536, s += i(55296 + (_ >> 10), 56320 + (1023 & _)), a += 3))) : s += o } return s } function iy(e, t) { let n = t.length, i = 0; for (let s = 0; s < n; s++) { let e = t.charCodeAt(s); e >= 55296 && e <= 56319 && s + 1 < n && (e = (e << 10) + t.charCodeAt(++s) - 56613888), i += e < 128 ? 1 : e < 2048 ? 2 : e < 65536 ? 3 : 4 } _y(e, i); let r = ey(e, i), o = e.bytes; for (let s = 0; s < n; s++) { let e = t.charCodeAt(s); e >= 55296 && e <= 56319 && s + 1 < n && (e = (e << 10) + t.charCodeAt(++s) - 56613888), e < 128 ? o[r++] = e : (e < 2048 ? o[r++] = e >> 6 & 31 | 192 : (e < 65536 ? o[r++] = e >> 12 & 15 | 224 : (o[r++] = e >> 18 & 7 | 240, o[r++] = e >> 12 & 63 | 128), o[r++] = e >> 6 & 63 | 128), o[r++] = 63 & e | 128) } } function ry(e, t) { let n = ey(e, t.limit), i = e.bytes, r = t.bytes; for (let o = 0, s = t.limit; o < s; o++)i[o + n] = r[o] } function oy(e) { return e.bytes[ty(e, 1)] } function sy(e, t) { let n = ey(e, 1); e.bytes[n] = t } function ay(e) { let t = ty(e, 8), n = e.bytes; return Jv[0] = n[t++], Jv[1] = n[t++], Jv[2] = n[t++], Jv[3] = n[t++], Jv[4] = n[t++], Jv[5] = n[t++], Jv[6] = n[t++], Jv[7] = n[t++], Kv[0] } function cy(e, t) { let n = ey(e, 8), i = e.bytes; Kv[0] = t, i[n++] = Jv[0], i[n++] = Jv[1], i[n++] = Jv[2], i[n++] = Jv[3], i[n++] = Jv[4], i[n++] = Jv[5], i[n++] = Jv[6], i[n++] = Jv[7] } function Ey(e) { let t, n = 0, i = 0; do { t = oy(e), n < 32 && (i |= (127 & t) << n), n += 7 } while (128 & t); return i } function _y(e, t) { for (t >>>= 0; t >= 128;)sy(e, 127 & t | 128), t >>>= 7; sy(e, t) } function dy(e, t) { let n = t.low >>> 0, i = (t.low >>> 28 | t.high << 4) >>> 0, r = t.high >>> 24, o = 0 === r ? 0 === i ? n < 16384 ? n < 128 ? 1 : 2 : n < 1 << 21 ? 3 : 4 : i < 16384 ? i < 128 ? 5 : 6 : i < 1 << 21 ? 7 : 8 : r < 128 ? 9 : 10, s = ey(e, o), a = e.bytes; switch (o) { case 10: a[s + 9] = r >>> 7 & 1; case 9: a[s + 8] = 9 !== o ? 128 | r : 127 & r; case 8: a[s + 7] = 8 !== o ? i >>> 21 | 128 : i >>> 21 & 127; case 7: a[s + 6] = 7 !== o ? i >>> 14 | 128 : i >>> 14 & 127; case 6: a[s + 5] = 6 !== o ? i >>> 7 | 128 : i >>> 7 & 127; case 5: a[s + 4] = 5 !== o ? 128 | i : 127 & i; case 4: a[s + 3] = 4 !== o ? n >>> 21 | 128 : n >>> 21 & 127; case 3: a[s + 2] = 3 !== o ? n >>> 14 | 128 : n >>> 14 & 127; case 2: a[s + 1] = 2 !== o ? n >>> 7 | 128 : n >>> 7 & 127; case 1: a[s] = 1 !== o ? 128 | n : 127 & n } } const uy = async (e, t, n) => { const i = function (e) { const t = []; for (let n = 0; n < e.length; n += 2)t.push(parseInt(e.slice(n, n + 2), 16)); return Uint8Array.from(t) }(function (e) { const t = "0123456789abcdef"; function n(e) { let n, i = ""; for (n = 0; n <= 3; n++)i += t.charAt(e >> 8 * n + 4 & 15) + t.charAt(e >> 8 * n & 15); return i } function i(e, t) { const n = (65535 & e) + (65535 & t); return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n } function r(e, t, n, r, o, s) { return i(function (e, t) { return e << t | e >>> 32 - t }(i(i(t, e), i(r, s)), o), n) } function o(e, t, n, i, o, s, a) { return r(t & n | ~t & i, e, t, o, s, a) } function s(e, t, n, i, o, s, a) { return r(t & i | n & ~i, e, t, o, s, a) } function a(e, t, n, i, o, s, a) { return r(t ^ n ^ i, e, t, o, s, a) } function c(e, t, n, i, o, s, a) { return r(n ^ (t | ~i), e, t, o, s, a) } const E = function (e) { let t; const n = 1 + (e.length + 8 >> 6), i = new Array(16 * n); for (t = 0; t < 16 * n; t++)i[t] = 0; for (t = 0; t < e.length; t++)i[t >> 2] |= e.charCodeAt(t) << t % 4 * 8; return i[t >> 2] |= 128 << t % 4 * 8, i[16 * n - 2] = 8 * e.length, i }(e); let _, d, u, l, R, h = 1732584193, p = -271733879, T = -1732584194, O = 271733878; for (_ = 0; _ < E.length; _ += 16)d = h, u = p, l = T, R = O, h = o(h, p, T, O, E[_ + 0], 7, -680876936), O = o(O, h, p, T, E[_ + 1], 12, -389564586), T = o(T, O, h, p, E[_ + 2], 17, 606105819), p = o(p, T, O, h, E[_ + 3], 22, -1044525330), h = o(h, p, T, O, E[_ + 4], 7, -176418897), O = o(O, h, p, T, E[_ + 5], 12, 1200080426), T = o(T, O, h, p, E[_ + 6], 17, -1473231341), p = o(p, T, O, h, E[_ + 7], 22, -45705983), h = o(h, p, T, O, E[_ + 8], 7, 1770035416), O = o(O, h, p, T, E[_ + 9], 12, -1958414417), T = o(T, O, h, p, E[_ + 10], 17, -42063), p = o(p, T, O, h, E[_ + 11], 22, -1990404162), h = o(h, p, T, O, E[_ + 12], 7, 1804603682), O = o(O, h, p, T, E[_ + 13], 12, -40341101), T = o(T, O, h, p, E[_ + 14], 17, -1502002290), p = o(p, T, O, h, E[_ + 15], 22, 1236535329), h = s(h, p, T, O, E[_ + 1], 5, -165796510), O = s(O, h, p, T, E[_ + 6], 9, -1069501632), T = s(T, O, h, p, E[_ + 11], 14, 643717713), p = s(p, T, O, h, E[_ + 0], 20, -373897302), h = s(h, p, T, O, E[_ + 5], 5, -701558691), O = s(O, h, p, T, E[_ + 10], 9, 38016083), T = s(T, O, h, p, E[_ + 15], 14, -660478335), p = s(p, T, O, h, E[_ + 4], 20, -405537848), h = s(h, p, T, O, E[_ + 9], 5, 568446438), O = s(O, h, p, T, E[_ + 14], 9, -1019803690), T = s(T, O, h, p, E[_ + 3], 14, -187363961), p = s(p, T, O, h, E[_ + 8], 20, 1163531501), h = s(h, p, T, O, E[_ + 13], 5, -1444681467), O = s(O, h, p, T, E[_ + 2], 9, -51403784), T = s(T, O, h, p, E[_ + 7], 14, 1735328473), p = s(p, T, O, h, E[_ + 12], 20, -1926607734), h = a(h, p, T, O, E[_ + 5], 4, -378558), O = a(O, h, p, T, E[_ + 8], 11, -2022574463), T = a(T, O, h, p, E[_ + 11], 16, 1839030562), p = a(p, T, O, h, E[_ + 14], 23, -35309556), h = a(h, p, T, O, E[_ + 1], 4, -1530992060), O = a(O, h, p, T, E[_ + 4], 11, 1272893353), T = a(T, O, h, p, E[_ + 7], 16, -155497632), p = a(p, T, O, h, E[_ + 10], 23, -1094730640), h = a(h, p, T, O, E[_ + 13], 4, 681279174), O = a(O, h, p, T, E[_ + 0], 11, -358537222), T = a(T, O, h, p, E[_ + 3], 16, -722521979), p = a(p, T, O, h, E[_ + 6], 23, 76029189), h = a(h, p, T, O, E[_ + 9], 4, -640364487), O = a(O, h, p, T, E[_ + 12], 11, -421815835), T = a(T, O, h, p, E[_ + 15], 16, 530742520), p = a(p, T, O, h, E[_ + 2], 23, -995338651), h = c(h, p, T, O, E[_ + 0], 6, -198630844), O = c(O, h, p, T, E[_ + 7], 10, 1126891415), T = c(T, O, h, p, E[_ + 14], 15, -1416354905), p = c(p, T, O, h, E[_ + 5], 21, -57434055), h = c(h, p, T, O, E[_ + 12], 6, 1700485571), O = c(O, h, p, T, E[_ + 3], 10, -1894986606), T = c(T, O, h, p, E[_ + 10], 15, -1051523), p = c(p, T, O, h, E[_ + 1], 21, -2054922799), h = c(h, p, T, O, E[_ + 8], 6, 1873313359), O = c(O, h, p, T, E[_ + 15], 10, -30611744), T = c(T, O, h, p, E[_ + 6], 15, -1560198380), p = c(p, T, O, h, E[_ + 13], 21, 1309151649), h = c(h, p, T, O, E[_ + 4], 6, -145523070), O = c(O, h, p, T, E[_ + 11], 10, -1120210379), T = c(T, O, h, p, E[_ + 2], 15, 718787259), p = c(p, T, O, h, E[_ + 9], 21, -343485551), h = i(h, d), p = i(p, u), T = i(T, l), O = i(O, R); return n(h) + n(p) + n(T) + n(O) }("" + t + n)).slice(0, 16), r = i.slice(0, 12), o = await window.crypto.subtle.importKey("raw", i, "AES-GCM", !0, ["encrypt"]); return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r }, o, e)) }, ly = async (e, t, n) => await uy(e.buffer, t, n); function Ry(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } const hy = new Map([["moderation", 1], ["supervise", 2]]); class py extends ph { get connectionState() { return this._connectionState } set connectionState(e) { if (this._connectionState === e) return; const t = this._connectionState; this._connectionState = e, this.emit(xO.CONNECTION_STATE_CHANGE, t, e) } get inspectType() { return this._inspectType } set inspectType(e) { var t; this._inspectMode = Zn(t = e.map((e => hy.get(e) || 0))).call(t, ((e, t) => e + t)), this._inspectType = e } get quality() { return this._quality } set quality(e) { this._quality = e > 1 ? 1 : e < .1 ? .1 : e, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout((() => { this.quality = this._quality / this.qualityRatio }), 6e4)) } constructor(e) { super(), hl(this, "name", "AgoraRTCVideoContentInspect"), hl(this, "_connectionState", kO.CONNECTING), hl(this, "_innerConnectionState", void 0), hl(this, "sequence", 0), hl(this, "inspectStartTime", void 0), hl(this, "workerManagerConnection", void 0), hl(this, "workerConnection", void 0), hl(this, "workerMessageLengthLimit", void 0), hl(this, "inspectIntervalMinimum", void 0), hl(this, "qualityRatio", void 0), hl(this, "_connectInfo", void 0), hl(this, "_cancelTokenSource", Rh.CancelToken.source()), hl(this, "_retryConfig", void 0), hl(this, "wmSequence", 0), hl(this, "inspectInterval", void 0), hl(this, "inspectTimer", null), hl(this, "ossFilePrefix", void 0), hl(this, "extraInfo", void 0), hl(this, "_inspectType", void 0), hl(this, "_inspectMode", void 0), hl(this, "_quality", 1), hl(this, "qualityTimer", null), hl(this, "_inspectId", void 0), hl(this, "_needWorkUrlOnly", !1), hl(this, "inspectImage", (() => { if (this.connectionState !== kO.CONNECTED) throw new Ch(Oh.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState)); this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval((() => { this.connectionState === kO.CONNECTED ? this.requestToInspectImage() : Dh.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState) }), this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage() })), this._inspectId = Zg(5, "inspect-"), this.workerMessageLengthLimit = jh("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = jh("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = jh("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e.interval, this.ossFilePrefix = e.ossFilePrefix, this.extraInfo = e.extraInfo, this.inspectType = e.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new Im("worker-manager-" + this._inspectId, Ah), this.on(xO.STATE_CHANGE, ((e, t) => { this._innerConnectionState = e, Dh.debug("[".concat(this._inspectId, "] Inspect operation :").concat(VO[e], " ").concat(t || "")) })), this.handleWorkerManagerEvents(), this.workerConnection = new Im("worker-" + this._inspectId, Ah), this.handleWorkerEvents() } async init(e, t) { this.emit(xO.STATE_CHANGE, VO.CONNECT_AP), this._connectInfo = e; const n = this._cancelTokenSource.token; return this._retryConfig = t, new Cd(((i, r) => { this.on(xO.CONNECTION_STATE_CHANGE, ((e, t) => { t === kO.CONNECTED && i() })), this.requestAP(e, n, t).then((e => { this.connectWorkerManager(e) })).catch((e => { r(e) })) })) } async requestAP(e, t, n) { const i = jh("WEBCS_DOMAIN").map((e => "https://".concat(e, "/api/v1"))), r = await function (e, t, n, i) { let { appId: r, areaCode: o, cname: s, sid: a, token: c, uid: E } = t; sI++; const _ = "image_moderation_api", d = { service_name: _, json_body: JSON.stringify({ appId: r, areaCode: o, cname: s, command: "allocateEdge", requestId: sI, seq: sI, sid: a, token: c, ts: Date.now(), uid: E + "" }) }; let u, l, R = e[0]; return gh((async () => { u = Date.now(); const e = await AA(R, { data: d, cancelToken: n, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } }); if (l = Date.now() - u, 0 !== e.code) { const t = new Ch(Oh.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e.code, { retry: !0, responseTime: l }); throw Dh.error(t.toString()), t } const t = JSON.parse(e.json_body); if (200 !== t.code) { const e = new Ch(Oh.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t.code, ", reason: ").concat(t.reason), { code: t.code, responseTime: l }); throw Dh.error(e.toString()), e } if (!t.servers || !Array.isArray(t.servers) || 0 === t.servers.length) { const e = new Ch(Oh.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: t.code, responseTime: l }); throw Dh.error(e.toString()), e } const i = jh("VIDEO_INSPECT_WORKER_MANAGER_HOST"), r = jh("VIDEO_INSPECT_WORKER_MANAGER_PORT"); return { addressList: t.servers.map((e => { let { address: t, wss: n } = e; if (t && n) return "wss://".concat(t.replace(/\./g, "-"), ".").concat(i, ":").concat(r || n) })).filter((e => !!e)), workerToken: t.workerToken, vid: t.vid, responseTime: l } }), ((t, n) => (wA.apworkerEvent(a, { success: !0, sc: 200, serviceName: _, responseDetail: JSON.stringify(t.addressList), firstSuccess: 0 === n, responseTime: l, serverIp: e[n % e.length] }), !1)), ((t, n) => (wA.apworkerEvent(a, { success: !1, sc: t.data && t.data.code || 200, serviceName: _, responseTime: l, serverIp: e[n % e.length] }), !!(t.code !== Oh.OPERATION_ABORTED && t.code !== Oh.UNEXPECTED_RESPONSE || t.data && t.data.retry) && (R = e[(n + 1) % e.length], !0))), i) }(i, e, t, n); this.emit(xO.STATE_CHANGE, VO.AP_CONNECTED); const { addressList: o } = r; return this.wmSequence++, o } async connectWorkerManager(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; this._needWorkUrlOnly = t, this.emit(xO.STATE_CHANGE, VO.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e, 1e4) } async connectWorker(e) { await this.workerConnection.init([e]) } handleWorkerManagerEvents() { this.workerManagerConnection.on(HT.CONNECTED, (async () => { this.emit(xO.STATE_CHANGE, VO.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.18.2", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: !0, clientRequest: { command: "join" } }, !0) })), this.workerManagerConnection.on(HT.CLOSED, (() => { this._innerConnectionState < VO.GET_WORKER_MANAGER_RESPONSE && Dh.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker")) })), this.workerManagerConnection.on(HT.FAILED, (() => { this._innerConnectionState < VO.GET_WORKER_MANAGER_RESPONSE && Dh.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker")) })), this.workerManagerConnection.on(HT.RECONNECTING, (() => { this._innerConnectionState < VO.GET_WORKER_MANAGER_RESPONSE && Dh.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker")) })), this.workerManagerConnection.on(HT.ON_MESSAGE, (async e => { this.emit(xO.STATE_CHANGE, VO.GET_WORKER_MANAGER_RESPONSE); const t = this.workerManagerConnection.url; this.workerManagerConnection.close(); const n = JSON.parse(e.data); if (200 !== n.code) throw Dh.error("[".concat(this._inspectId, "] Unexpected code ").concat(n.code, " from worker manager")), new Ch(Oh.UNEXPECTED_RESPONSE, "response code of worker is unexpected", n); if (!(n.serverResponse && n.serverResponse.portWss && t)) throw Dh.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(n))), new Ch(Oh.UNEXPECTED_RESPONSE, "response content of worker is unexpected", n); { const e = jh("VIDEO_INSPECT_WORKER_PORT") || n.serverResponse.portWss, i = t.replace(/:\d+\/?$/, ":".concat(e)); this.emit(xO.STATE_CHANGE, VO.CONNECT_WORKER, i), this._needWorkUrlOnly ? this.emit(xO.REQUEST_NEW_WORKER_URL, i) : await this.connectWorker(i) } })), this.workerManagerConnection.on(HT.WILL_RECONNECT, ((e, t) => { t(e) })), this.workerManagerConnection.on(HT.REQUEST_NEW_URLS, ((e, t) => { this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e).catch(t) })) } handleWorkerEvents() { this.workerConnection.on(HT.CONNECTED, (async () => { this.emit(xO.STATE_CHANGE, VO.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = kO.CONNECTED })), this.workerConnection.on(HT.ON_MESSAGE, (async e => { if (e.data instanceof ArrayBuffer) { const n = Yv(new Uint8Array(e.data)); if (jh("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && Dh.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(n)), 200 === n.code) { if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0]) return void this.emit(xO.INSPECT_RESULT, void 0, void 0); if (n.data && n.data.scorePorn && n.data.scoreSexy && n.data.scoreNeutral) { var t; const e = { porn: n.data.scorePorn, sexy: n.data.scoreSexy, neutral: n.data.scoreNeutral }, i = Zn(t = Object.keys(e)).call(t, ((t, n) => e[t] > e[n] ? t : n), "porn"), r = Object.keys(e).find((e => e === i)); this.emit(xO.INSPECT_RESULT, r) } else this.emit(xO.INSPECT_RESULT, void 0, new Ch(Oh.UNEXPECTED_RESPONSE, n.code + "", "There is an unexpected data on message")) } else this.emit(xO.INSPECT_RESULT, void 0, new Ch(Oh.UNEXPECTED_RESPONSE, n.code + "", n.msg)) } else Dh.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(xO.INSPECT_RESULT, void 0, new Ch(Oh.UNEXPECTED_RESPONSE, "invalid worker message type")) })), this.workerConnection.on(HT.CLOSED, (() => { this.connectionState = kO.CLOSED })), this.workerConnection.on(HT.FAILED, (() => { this.connectionState = kO.CLOSED })), this.workerConnection.on(HT.RECONNECTING, (() => { this.connectionState = this.connectionState === kO.CONNECTED ? kO.RECONNECTING : kO.CONNECTING })), this.workerConnection.on(HT.WILL_RECONNECT, ((e, t) => { "recover" === e && t(e), t("tryNext") })), this.workerConnection.on(HT.REQUEST_NEW_URLS, ((e, t) => { this.workerManagerConnection.close(), this.once(xO.REQUEST_NEW_WORKER_URL, (t => { e([t]) })), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then((e => { this.connectWorkerManager(e, !0) })).catch((e => { t(e) })) })) } static intToLong(e) { return { low: e |= 0, high: e >> 31, unsigned: e >= 0 } } async requestToInspectImage() { this.sequence++; const e = om(this, xO.CLIENT_LOCAL_VIDEO_TRACK), t = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid }; if (e) { if (!e.isPlaying) return void this.emit(xO.INSPECT_RESULT, void 0, new Ch(Oh.INVALID_OPERATION, "Only the track being played can be inspected")); const n = await this.generateRequestData(e, t); this.workerConnection.sendMessage(n, !0, !0) } else this.emit(xO.INSPECT_RESULT, void 0, new Ch(Oh.INVALID_OPERATION, "Only the track being published can be inspected")) } async generateRequestData(e, t) { let { appId: n, cname: i, cid: r, vid: o, sid: s, uid: a } = t; const c = Date.now(), E = await e.getCurrentFrameImage("image/jpeg", this.quality), _ = await ly(E, n, i), d = this.sequence + "-" + r + "-" + a + "-" + c + "-" + Zg(12, ""), u = { appId: n, cid: r, cname: i, deviceId: "", elapse: py.intToLong(Number(c - this.inspectStartTime)), fileSize: _.byteLength, jpgEncryption: 2, height: E.height, width: E.width, jpg: _, networkType: 6, osType: 7, requestId: d, sdkVersion: "4.18.2", sequence: this.sequence, sid: s, timestamp: py.intToLong(c), uid: a, vid: o, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix }; void 0 === this.extraInfo && delete u.callbackData, void 0 === this.ossFilePrefix && delete u.ossFilePrefix; const l = Fv(u); if (l.byteLength < this.workerMessageLengthLimit) { if (jh("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) { const e = function (e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? Ry(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ry(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e }({}, u); delete e.jpg, Dh.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e)) } return l } { const t = this.quality * this.qualityRatio; return this.quality = t, await this.generateRequestData(e, { appId: n, cname: i, cid: r, vid: o, sid: s, uid: a }) } } close() { this._cancelTokenSource.cancel(), this._cancelTokenSource = Rh.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = kO.CLOSED, this.emit(xO.STATE_CHANGE, VO.CLOSED) } } function Ty(e) { let t = function () { const e = Sy.pop(); return e ? (e.offset = e.limit = 0, e) : { bytes: new Uint8Array(64), offset: 0, limit: 0 } }(); return function (e, t) { let n = e.appId; void 0 !== n && (wy(t, 10), Dy(t, n)); let i = e.cid; void 0 !== i && (wy(t, 16), wy(t, i)); let r = e.cname; void 0 !== r && (wy(t, 26), Dy(t, r)); let o = e.deviceId; void 0 !== o && (wy(t, 34), Dy(t, o)); let s = e.elapse; void 0 !== s && (wy(t, 40), Uy(t, s)); let a = e.fileSize; void 0 !== a && (wy(t, 48), Uy(t, Ay(a))); let c = e.height; void 0 !== c && (wy(t, 56), Uy(t, Ay(c))); let E = e.jpg; void 0 !== E && (wy(t, 66), wy(t, E.length), Py(t, E)); let _ = e.networkType; void 0 !== _ && (wy(t, 72), Uy(t, Ay(_))); let d = e.osType; void 0 !== d && (wy(t, 80), Uy(t, Ay(d))); let u = e.requestId; void 0 !== u && (wy(t, 90), Dy(t, u)); let l = e.sdkVersion; void 0 !== l && (wy(t, 98), Dy(t, l)); let R = e.sequence; void 0 !== R && (wy(t, 104), Uy(t, Ay(R))); let h = e.sid; void 0 !== h && (wy(t, 114), Dy(t, h)); let p = e.timestamp; void 0 !== p && (wy(t, 120), Uy(t, p)); let T = e.uid; void 0 !== T && (wy(t, 128), wy(t, T)); let O = e.vid; void 0 !== O && (wy(t, 136), wy(t, O)); let C = e.width; void 0 !== C && (wy(t, 144), Uy(t, Ay(C))); let A = e.service; void 0 !== A && (wy(t, 152), wy(t, A)); let S = e.callbackData; void 0 !== S && (wy(t, 162), wy(t, S.length), Py(t, S)); let g = e.ticket; void 0 !== g && (wy(t, 170), Dy(t, g)) }(e, t), function (e) { let t = e.bytes, n = e.limit; return t.length === n ? t : t.subarray(0, n) }(t) } function Oy(e) { return function (e) { let t = {}; e: for (; !my(e);) { let n = Ly(e); switch (n >>> 3) { case 0: break e; case 1: t.code = Ly(e); break; case 2: t.msg = Ny(e, Ly(e)); break; case 3: t.requestId = Ny(e, Ly(e)); break; case 4: t.timestamp = by(e, !1); break; default: Cy(e, 7 & n) } } return t }({ bytes: t = e, offset: 0, limit: t.length }); var t } function Cy(e, t) { switch (t) { case 0: for (; 128 & vy(e);); break; case 2: gy(e, Ly(e)); break; case 5: gy(e, 4); break; case 1: gy(e, 8); break; default: throw new Error("Unimplemented type: " + t) } } function Ay(e) { return { low: e |= 0, high: e >> 31, unsigned: e >= 0 } } let Sy = []; function gy(e, t) { if (e.offset + t > e.limit) throw new Error("Skip past limit"); e.offset += t } function my(e) { return e.offset >= e.limit } function Iy(e, t) { let n = e.bytes, i = e.offset, r = e.limit, o = i + t; if (o > n.length) { let t = new Uint8Array(2 * o); t.set(n), e.bytes = t } return e.offset = o, o > r && (e.limit = o), i } function fy(e, t) { let n = e.offset; if (n + t > e.limit) throw new Error("Read past limit"); return e.offset += t, n } function Py(e, t) { let n = Iy(e, t.length); e.bytes.set(t, n) } function Ny(e, t) { let n = fy(e, t), i = String.fromCharCode, r = e.bytes, o = "ï¿½", s = ""; for (let a = 0; a < t; a++) { let e, c, E, _, d = r[a + n]; 0 == (128 & d) ? s += i(d) : 192 == (224 & d) ? a + 1 >= t ? s += o : (e = r[a + n + 1], 128 != (192 & e) ? s += o : (_ = (31 & d) << 6 | 63 & e, _ < 128 ? s += o : (s += i(_), a++))) : 224 == (240 & d) ? a + 2 >= t ? s += o : (e = r[a + n + 1], c = r[a + n + 2], 32896 != (49344 & (e | c << 8)) ? s += o : (_ = (15 & d) << 12 | (63 & e) << 6 | 63 & c, _ < 2048 || _ >= 55296 && _ <= 57343 ? s += o : (s += i(_), a += 2))) : 240 == (248 & d) ? a + 3 >= t ? s += o : (e = r[a + n + 1], c = r[a + n + 2], E = r[a + n + 3], 8421504 != (12632256 & (e | c << 8 | E << 16)) ? s += o : (_ = (7 & d) << 18 | (63 & e) << 12 | (63 & c) << 6 | 63 & E, _ < 65536 || _ > 1114111 ? s += o : (_ -= 65536, s += i(55296 + (_ >> 10), 56320 + (1023 & _)), a += 3))) : s += o } return s } function Dy(e, t) { let n = t.length, i = 0; for (let s = 0; s < n; s++) { let e = t.charCodeAt(s); e >= 55296 && e <= 56319 && s + 1 < n && (e = (e << 10) + t.charCodeAt(++s) - 56613888), i += e < 128 ? 1 : e < 2048 ? 2 : e < 65536 ? 3 : 4 } wy(e, i); let r = Iy(e, i), o = e.bytes; for (let s = 0; s < n; s++) { let e = t.charCodeAt(s); e >= 55296 && e <= 56319 && s + 1 < n && (e = (e << 10) + t.charCodeAt(++s) - 56613888), e < 128 ? o[r++] = e : (e < 2048 ? o[r++] = e >> 6 & 31 | 192 : (e < 65536 ? o[r++] = e >> 12 & 15 | 224 : (o[r++] = e >> 18 & 7 | 240, o[r++] = e >> 12 & 63 | 128), o[r++] = e >> 6 & 63 | 128), o[r++] = 63 & e | 128) } } function vy(e) { return e.bytes[fy(e, 1)] } function yy(e, t) { let n = Iy(e, 1); e.bytes[n] = t } function Ly(e) { let t, n = 0, i = 0; do { t = vy(e), n < 32 && (i |= (127 & t) << n), n += 7 } while (128 & t); return i } function wy(e, t) { for (t >>>= 0; t >= 128;)yy(e, 127 & t | 128), t >>>= 7; yy(e, t) } function by(e, t) { let n, i = 0, r = 0, o = 0; return n = vy(e), i = 127 & n, 128 & n && (n = vy(e), i |= (127 & n) << 7, 128 & n && (n = vy(e), i |= (127 & n) << 14, 128 & n && (n = vy(e), i |= (127 & n) << 21, 128 & n && (n = vy(e), r = 127 & n, 128 & n && (n = vy(e), r |= (127 & n) << 7, 128 & n && (n = vy(e), r |= (127 & n) << 14, 128 & n && (n = vy(e), r |= (127 & n) << 21, 128 & n && (n = vy(e), o = 127 & n, 128 & n && (n = vy(e), o |= (127 & n) << 7))))))))), { low: i | r << 28, high: r >>> 4 | o << 24, unsigned: t } } function Uy(e, t) { let n = t.low >>> 0, i = (t.low >>> 28 | t.high << 4) >>> 0, r = t.high >>> 24, o = 0 === r ? 0 === i ? n < 16384 ? n < 128 ? 1 : 2 : n < 1 << 21 ? 3 : 4 : i < 16384 ? i < 128 ? 5 : 6 : i < 1 << 21 ? 7 : 8 : r < 128 ? 9 : 10, s = Iy(e, o), a = e.bytes; switch (o) { case 10: a[s + 9] = r >>> 7 & 1; case 9: a[s + 8] = 9 !== o ? 128 | r : 127 & r; case 8: a[s + 7] = 8 !== o ? i >>> 21 | 128 : i >>> 21 & 127; case 7: a[s + 6] = 7 !== o ? i >>> 14 | 128 : i >>> 14 & 127; case 6: a[s + 5] = 6 !== o ? i >>> 7 | 128 : i >>> 7 & 127; case 5: a[s + 4] = 5 !== o ? 128 | i : 127 & i; case 4: a[s + 3] = 4 !== o ? n >>> 21 | 128 : n >>> 21 & 127; case 3: a[s + 2] = 3 !== o ? n >>> 14 | 128 : n >>> 14 & 127; case 2: a[s + 1] = 2 !== o ? n >>> 7 | 128 : n >>> 7 & 127; case 1: a[s] = 1 !== o ? 128 | n : 127 & n } } const My = {}, ky = {}, Vy = 4294967296, xy = 0x10000000000000000, Fy = xy / 2, Yy = Wy(0, !0), By = Wy(0), Gy = Ky(0, -2147483648, !1), jy = Ky(-1, 2147483647, !1), Hy = Ky(-1, -1, !0); function Wy(e, t) { let n, i, r; return t ? (r = 0 <= (e >>>= 0) && e < 256) && (i = ky[e], i) ? i : (n = Ky(e, 0, !0), r && (ky[e] = n), n) : (r = -128 <= (e |= 0) && e < 128) && (i = My[e], i) ? i : (n = Ky(e, e < 0 ? -1 : 0, !1), r && (My[e] = n), n) } function Ky(e, t, n) { return { low: 0 | e, high: 0 | t, unsigned: !!n } } function Jy(e, t) { if (isNaN(e)) return t ? Yy : By; if (t) { if (e < 0) return Yy; if (e >= xy) return Hy } else { if (e <= -Fy) return Gy; if (e + 1 >= Fy) return jy } return e < 0 ? t ? Yy : By : Ky(e % Vy | 0, e / Vy | 0, t) } function Xy(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } class qy extends ph { get connectionState() { return this._connectionState } set connectionState(e) { if (this._connectionState === e) return; const t = this._connectionState; this._connectionState = e, this.emit(HO.CONNECTION_STATE_CHANGE, e, t) } get quality() { return this._quality } set quality(e) { this._quality = e > 1 ? 1 : e < .1 ? .1 : e, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout((() => { this.quality = this._quality / this._qualityRatio }), 6e4)) } constructor(e) { var t; super(), hl(this, "name", "AgoraRTCImageModeration"), hl(this, "_connectionState", jO.CONNECTING), hl(this, "_sequence", 0), hl(this, "_moderationStartTime", void 0), hl(this, "_workerConnection", void 0), hl(this, "_workerMessageLengthLimit", void 0), hl(this, "_qualityRatio", void 0), hl(this, "_connectInfo", void 0), hl(this, "_cancelTokenSource", Rh.CancelToken.source()), hl(this, "_retryConfig", void 0), hl(this, "_moderationInterval", void 0), hl(this, "_moderationTimer", null), hl(this, "_moderationMode", 1), hl(this, "_quality", 1), hl(this, "_qualityTimer", null), hl(this, "_ticket", void 0), hl(this, "_moderationIntervalMinimum", void 0), hl(this, "_uploadFailedNum", 0), hl(this, "_uploadNum", 0), hl(this, "_uploadTimer", null), hl(this, "_moderationId", void 0), hl(this, "inspectImage", (() => { if (this.connectionState !== jO.CONNECTED) throw new Ch(Oh.OPERATION_ABORTED, "image moderation service connection status is ".concat(this.connectionState)); this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval((() => { this.connectionState === jO.CONNECTED ? this.requestToInspectImage() : Dh.debug("[".concat(this._moderationId, "] Moderation State is not connected , "), this.connectionState) }), this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage() })), this._moderationId = Zg(5, "image-moderation-"), this._workerMessageLengthLimit = jh("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"), this._moderationIntervalMinimum = jh("IMAGE_MODERATION_INTERVAL_MINIMUM"), this._moderationInterval = null !== (t = e.interval) && void 0 !== t ? t : 1e3, this._qualityRatio = jh("IMAGE_MODERATION_QUALITY_RATIO"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new Im("worker-" + this._moderationId, Ah), this.on(HO.STATE_CHANGE, ((e, t) => { Dh.debug("[".concat(this._moderationId, "] Moderation operation :").concat(WO[e], " ").concat(t || "")) })), this.handleWorkerEvents() } async init(e, t) { this.emit(HO.STATE_CHANGE, WO.CONNECT_AP), this._connectInfo = e; const n = this._cancelTokenSource.token; return this._retryConfig = t, new Cd(((i, r) => { this.on(HO.CONNECTION_STATE_CHANGE, ((e, t) => { e === jO.CONNECTED && i() })), this.requestAP(e, n, t).then((e => { this.connectWorker(e) })).catch((e => { r(e) })) })) } updateConfig(e) { var t; this._moderationInterval = null !== (t = e.interval) && void 0 !== t ? t : 1e3, Dh.debug("[".concat(this._moderationId, "] updateConfig: ").concat(JSON.stringify(e))), this.connectionState === jO.CONNECTED && this.inspectImage() } async requestAP(e, t, n) { const i = jh("WEBCS_DOMAIN").map((e => "https://".concat(e, "/api/v1"))), r = await function (e, t, n, i) { let { appId: r, areaCode: o, cname: s, sid: a, token: c, uid: E } = t; sI++; const _ = "moderation_plugin", d = { service_name: _, json_body: JSON.stringify({ appId: r, areaCode: o, cname: s, command: "allocateEdge", requestId: sI, seq: sI, sid: a, appToken: c, ts: Date.now(), uid: E + "" }) }; let u, l, R = e[0]; return gh((async () => { u = Date.now(); const e = await AA(R, { data: d, cancelToken: n, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } }); if (l = Date.now() - u, 0 !== e.code) { const t = new Ch(Oh.UNEXPECTED_RESPONSE, "moderation plugin ap error, code" + e.code, { retry: !0, responseTime: l }); throw Dh.error(t.toString()), t } const t = JSON.parse(e.json_body); if (200 !== t.code) { const e = new Ch(Oh.UNEXPECTED_RESPONSE, "moderation plugin ap error, code: ".concat(t.code, ", reason: ").concat(t.reason), { code: t.code, responseTime: l }); throw Dh.error(e.toString()), e } if (!t.servers || !Array.isArray(t.servers) || 0 === t.servers.length) { const e = new Ch(Oh.UNEXPECTED_RESPONSE, "moderation plugin ap empty server", { code: t.code, responseTime: l }); throw Dh.error(e.toString()), e } if (!t.servers.some((e => !!e.wss))) { const e = new Ch(Oh.UNEXPECTED_RESPONSE, "moderation plugin ap empty port", { code: t.code, responseTime: l }); throw Dh.error(e.toString()), e } const i = jh("IMAGE_MODERATION_WORKER_HOST"); return { addressList: t.servers.map((e => { let { address: t, wss: n } = e; if (t && n) return "wss://".concat(t.replace(/\./g, "-"), ".").concat(i, ":").concat(n, "/moderation") })).filter((e => !!e)), workerToken: t.workerToken, vid: t.vid, ticket: t.appTicket, responseTime: l } }), ((t, n) => (wA.apworkerEvent(a, { success: !0, sc: 200, serviceName: _, responseDetail: JSON.stringify(t.addressList), firstSuccess: 0 === n, responseTime: l, serverIp: e[n % e.length] }), !1)), ((t, n) => (wA.apworkerEvent(a, { success: !1, sc: t.data && t.data.code || 200, serviceName: _, responseTime: l, serverIp: e[n % e.length] }), !!(t.code !== Oh.OPERATION_ABORTED && t.code !== Oh.UNEXPECTED_RESPONSE || t.data && t.data.retry) && (R = e[(n + 1) % e.length], !0))), i) }(i, e, t, n); this.emit(HO.STATE_CHANGE, WO.AP_CONNECTED); const { addressList: o, ticket: s } = r; return this._ticket = s, o } async connectWorker(e) { this.emit(HO.STATE_CHANGE, WO.CONNECT_WORKER), await this._workerConnection.init(e, 1e4) } handleWorkerEvents() { this._workerConnection.on(HT.CONNECTED, (async () => { this.emit(HO.STATE_CHANGE, WO.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = jO.CONNECTED })), this._workerConnection.on(HT.CLOSED, (() => { this.connectionState = jO.CLOSED })), this._workerConnection.on(HT.FAILED, (() => { this.connectionState = jO.CLOSED })), this._workerConnection.on(HT.RECONNECTING, (() => { this.connectionState = this.connectionState === jO.CONNECTED ? jO.RECONNECTING : jO.CONNECTING })), this._workerConnection.on(HT.ON_MESSAGE, (async e => { if (e.data instanceof ArrayBuffer) { const t = Oy(new Uint8Array(e.data)); jh("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && Dh.debug("[".concat(this._moderationId, "] Response message for worker of image moderation "), JSON.stringify(t)), this._uploadNum++, void 0 === t.code || 0 === t.code || (this._uploadFailedNum++, Dh.error("[".concat(this._moderationId, "] Error response from worke, code is ").concat(t.code, ", msg is ").concat(t.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout((() => { wA.reportApiInvoke(this._connectInfo.sid || null, { name: RT.IMAGE_MODERATION_UPLOAD, options: [this._uploadFailedNum, this._uploadNum, t.code], tag: hT.TRACER }).onError(new Ch(Oh.IMAGE_MODERATION_UPLOAD_FAILED, t.msg)), this._uploadTimer = null }), jh("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL")))) } else Dh.error("[".concat(this._moderationId, "] Unexpected message type from worker")) })), this._workerConnection.on(HT.WILL_RECONNECT, ((e, t) => { "recover" === e && t(e), t("tryNext") })), this._workerConnection.on(HT.REQUEST_NEW_URLS, ((e, t) => { this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e).catch(t) })) } static intToLong(e) { return { low: e |= 0, high: e >> 31, unsigned: e >= 0 } } async requestToInspectImage() { const e = om(this, HO.CLIENT_LOCAL_VIDEO_TRACK), t = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid }; if (e) { if (!e.isPlaying) return void (jh("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && Dh.debug("Only the track being played can be inspected")); this._sequence++; const n = await this.generateRequestData(e, t); this._workerConnection.sendMessage(n, !0, !0) } else jh("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && Dh.debug("Only the track being published can be inspected") } async generateRequestData(e, t) { let { appId: n, cname: i, cid: r, vid: o, sid: s, uid: a } = t; const c = Date.now(), E = await e.getCurrentFrameImage("image/jpeg", this.quality), _ = await ly(E, n, i), d = this._sequence + "-" + r + "-" + a + "-" + c + "-" + Zg(12, ""), u = { appId: n, cid: r, cname: i, deviceId: "", elapse: qy.intToLong(Number(c - this._moderationStartTime)), fileSize: E.buffer.byteLength, height: E.height, width: E.width, jpg: _, networkType: 6, osType: 7, requestId: d, sdkVersion: "4.18.2", sequence: this._sequence, sid: s, timestamp: Jy(c), uid: a, vid: o, service: this._moderationMode, ticket: this._ticket }, l = Ty(u); if (l.byteLength < this._workerMessageLengthLimit) { if (jh("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")) { const e = function (e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? Xy(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xy(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e }({}, u); delete e.jpg, Dh.debug("[".concat(this._moderationId, "] Request message for worker of image moderation service: "), JSON.stringify(e)) } return l } { const t = this.quality * this._qualityRatio; return this.quality = t, await this.generateRequestData(e, { appId: n, cname: i, cid: r, vid: o, sid: s, uid: a }) } } close() { this._cancelTokenSource.cancel(), this._cancelTokenSource = Rh.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = jO.CLOSED, this.emit(HO.STATE_CHANGE, WO.CLOSED) } } var Qy, zy, Zy, $y, eL, tL, nL, iL, rL, oL, sL, aL, cL, EL, _L, dL, uL, lL, RL, hL, pL, TL, OL, CL, AL, SL, gL, mL, IL, fL, PL, NL, DL, vL, yL, LL, wL, bL, UL, ML; function kL(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function VL(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? kL(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kL(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } let xL = (Qy = LA(), zy = LA({ argsMap: (e, t) => (Array.isArray(t) || (t = [t]), t.map((e => e ? Object(e).toString() : "null"))) }), Zy = LA({ argsMap: (e, t) => (t || (t = []), Array.isArray(t) || (t = [t]), t.map((e => e.getTrackId()))) }), $y = LA({ argsMap: (e, t, n) => [t.uid, n] }), eL = LA({ argsMap: (e, t) => t.map((e => { let { user: t, mediaType: n } = e; return [null == t ? void 0 : t.uid, n] })) }), tL = LA({ argsMap: (e, t, n) => [t.uid, n] }), nL = LA({ argsMap: (e, t) => t.map((e => { let { user: t, mediaType: n } = e; return { uid: null == t ? void 0 : t.uid, mediaType: n } })) }), iL = LA(), rL = LA(), oL = LA(), sL = LA(), aL = LA(), cL = LA(), EL = LA(), _L = LA(), dL = LA(), uL = LA(), lL = LA(), RL = LA(), hL = LA(), pL = LA(), TL = LA({ argsMap: (e, t) => [t] }), OL = LA(), CL = LA(), AL = LA(), SL = LA(), gL = LA(), mL = LA(), IL = LA(), fL = LA(), PL = LA(), NL = LA(), DL = LA({ argsMap: (e, t) => (Array.isArray(t) || (t = [t]), [JSON.stringify(t)]) }), vL = LA(), yL = LA(), LL = LA(), wL = LA(), bL = LA({ reportResult: !0 }), UL = LA(), aA((ML = class extends ph { get connectionState() { return this._gateway.state } get remoteUsers() { return this._users } get localTracks() { return this._p2pChannel.getAllTracks(!0) } get uid() { return this._uid } get channelName() { return this._channelName } get mode() { return this._config.mode } get role() { var e; return (null === (e = this._config) || void 0 === e ? void 0 : e.role) || "audience" } get codec() { return this._config.codec } get audioCodec() { return this._config.audioCodec || "opus" } get isStringUID() { return !!this._joinInfo && !!this._joinInfo.stringUid } get __className__() { return "Client" } constructor(e) { let t; if (super(), hl(this, "store", void 0), hl(this, "_uid", void 0), hl(this, "_channelName", void 0), hl(this, "_uintUid", void 0), hl(this, "_users", []), hl(this, "_config", void 0), hl(this, "_clientId", void 0), hl(this, "_appId", void 0), hl(this, "_sessionId", null), hl(this, "_key", void 0), hl(this, "_joinInfo", void 0), hl(this, "_gateway", void 0), hl(this, "_statsCollector", void 0), hl(this, "_configDistribute", void 0), hl(this, "_leaveMutex", new kA("client-leave")), hl(this, "_publishMutex", new kA("client-publish")), hl(this, "_renewTokenMutex", new kA("client-renewtoken")), hl(this, "_subscribeMutex", new kA("client-subscribe")), hl(this, "_encryptionMode", "none"), hl(this, "_encryptionSecret", null), hl(this, "_encryptionSalt", null), hl(this, "_proxyServer", void 0), hl(this, "_turnServer", { servers: [], mode: "auto" }), hl(this, "_cloudProxyServerMode", "disabled"), hl(this, "_isDualStreamEnabled", !1), hl(this, "_defaultStreamFallbackType", void 0), hl(this, "_lowStreamParameter", void 0), hl(this, "_streamFallbackTypeCacheMap", new Map), hl(this, "_remoteStreamTypeCacheMap", new Map), hl(this, "_axiosCancelSource", Rh.CancelToken.source()), hl(this, "_audioVolumeIndicationInterval", void 0), hl(this, "_networkQualityInterval", void 0), hl(this, "_userOfflineTimeout", void 0), hl(this, "_streamRemovedTimeout", void 0), hl(this, "_injectStreamingClient", void 0), hl(this, "_liveTranscodeStreamingClient", void 0), hl(this, "_liveRawStreamingClient", void 0), hl(this, "_channelMediaRelayClient", void 0), hl(this, "_networkQualitySensitivity", "normal"), hl(this, "_p2pChannel", void 0), hl(this, "_useLocalAccessPoint", !1), hl(this, "_setLocalAPVersion", void 0), hl(this, "_joinAndNotLeaveYet", !1), hl(this, "_numberOfJoinCount", 0), hl(this, "_remoteDefaultVideoStreamType", void 0), hl(this, "_inspect", void 0), hl(this, "_moderation", void 0), hl(this, "_license", void 0), hl(this, "_handleLocalTrackEnable", ((e, t, n) => { this.publish(e, !1).then(t).catch(n) })), hl(this, "_handleLocalTrackDisable", ((e, t, n) => { this.unpublish(e).then(t).catch(n) })), hl(this, "_handleUserOnline", (e => { if (jh("BLOCK_LOCAL_CLIENT") && $h(e.uid, this.channelName)) return void Dh.debug("[".concat(e.uid, "] will be ignored in local")); this.isStringUID && "string" != typeof e.uid && Dh.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID")); const t = this._users.find((t => t.uid === e.uid)); if (t) t._trust_in_room_ = !0; else { const t = new Pf(e.uid, e.uint_id || e.uid); this._users.push(t), Dh.debug("[".concat(this._clientId, "] user online"), e.uid), this.safeEmit(fT.USER_JOINED, t) } })), hl(this, "_handleUserOffline", (e => { if (jh("BLOCK_LOCAL_CLIENT") && $h(e.uid, this.channelName)) return; const t = this._users.find((t => t.uid === e.uid)); t && (this._handleRemoveStream(e), am(this._users, t), this._remoteStreamTypeCacheMap.delete(t.uid), this._streamFallbackTypeCacheMap.delete(t.uid), Dh.debug("[".concat(this._clientId, "] user offline"), e.uid, "reason:", e.reason), this.safeEmit(fT.USER_LEAVED, t, e.reason)) })), hl(this, "_handleAddAudioOrVideoStream", ((e, t, n, i, r, o, s) => { if (jh("BLOCK_LOCAL_CLIENT") && $h(t, this.channelName)) return; const a = this._users.find((e => e.uid === t)); if (!a) return void Dh.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)")); Dh.debug("[".concat(this._clientId, "] stream added with uid ").concat(t, ", type ").concat(e)), this.store.subscribe(a.uid, e, void 0, void 0, void 0, Date.now()); const c = "audio" === e ? a.hasAudio : a.hasVideo; a._uintid || (a._uintid = r || t), "audio" === e ? a._trust_audio_stream_added_state_ = !0 : a._trust_video_stream_added_state_ = !0, "audio" === e ? (a._audio_added_ = !0, void 0 !== n && (a._audioSSRC = n), void 0 !== i && (a._cname = i), o && (a._audioOrtc = o)) : (a._video_added_ = !0, void 0 !== n && (a._videoSSRC = n), void 0 !== i && (a._cname = i), void 0 !== s && (a._rtxSsrcId = s), o && (a._videoOrtc = o)), ("audio" === e ? a.hasAudio : a.hasVideo) && !c && (Dh.info("[".concat(this._clientId, "] remote user ").concat(a.uid, " published ").concat(e)), this.safeEmit(fT.USER_PUBLISHED, a, e)), "video" === e ? wA.onGatewayStream(this._sessionId, _T.ON_ADD_VIDEO_STREAM, dT.ON_ADD_VIDEO_STREAM, { peer: r || t }) : wA.onGatewayStream(this._sessionId, _T.ON_ADD_AUDIO_STREAM, dT.ON_ADD_AUDIO_STREAM, { peer: r || t }), this._p2pChannel.remoteMediaSsrcChanged(a, e, n).then((t => { if (t) return Dh.debug("[".concat(this._clientId, "] resubscribe ").concat(e, " for user ").concat(a.uid, " after rejoin because SSRC id changed.")), this._p2pChannel.unsubscribe(a, e, !0).then((() => this._subscribe(a, e, !0).catch((e => { Dh.error("[".concat(this._clientId, "] resubscribe error"), e.toString()) })))) })), this._p2pChannel.hasPendingRemoteMedia(a, e) && (Dh.debug("[".concat(this._clientId, "] resubscribe ").concat(e, " for user ").concat(a.uid, " after reconnect.")), this._subscribe(a, e, !0).catch((e => { Dh.error("[".concat(this._clientId, "] resubscribe error"), e.toString()) }))) })), hl(this, "_handleRemoveStream", (e => { if (jh("BLOCK_LOCAL_CLIENT") && $h(e.uid, this.channelName)) return; const t = this._users.find((t => t.uid === e.uid)); if (!t) return void Dh.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)")); Dh.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e.uid)); let n = () => { }; t.hasAudio && t.hasVideo ? n = () => { Dh.info("[".concat(this._clientId, "] remote user ").concat(t.uid, " unpublished audio track")), this.safeEmit(fT.USER_UNPUBLISHED, t, "audio"), Dh.info("[".concat(this._clientId, "] remote user ").concat(t.uid, " unpublished video track")), this.safeEmit(fT.USER_UNPUBLISHED, t, "video") } : t.hasVideo ? n = () => { Dh.info("[".concat(this._clientId, "] remote user ").concat(t.uid, " unpublished video track")), this.safeEmit(fT.USER_UNPUBLISHED, t, "video") } : t.hasAudio && (n = () => { Dh.info("[".concat(this._clientId, "] remote user ").concat(t.uid, " unpublished audio track")), this.safeEmit(fT.USER_UNPUBLISHED, t, "audio") }), t._trust_audio_stream_added_state_ = !0, t._trust_video_stream_added_state_ = !0, t._audio_added_ = !1, t._video_added_ = !1, this._p2pChannel.unsubscribe(t).then((e => { if (e) return this._gateway.unsubscribe(e, t.uid) })), t._audioSSRC = void 0, t._videoSSRC = void 0, t._audioOrtc = void 0, t._videoOrtc = void 0, t._rtxSsrcId = void 0, wA.onGatewayStream(this._sessionId, _T.ON_REMOVE_STREAM, dT.ON_REMOVE_STREAM, { peer: e.uint_id || e.uid }), n() })), hl(this, "_handleSetStreamLocalEnable", ((e, t, n) => { if (jh("BLOCK_LOCAL_CLIENT") && $h(t, this.channelName)) return; const i = this._users.find((e => e.uid === t)); if (!i) return void Dh.error("[".concat(this._clientId, "] can not find target user!(disable_local)")); Dh.debug("[".concat(this._clientId, "] local ").concat(e, " ").concat(n ? "enabled" : "disabled", " with uid ").concat(t)); const r = "audio" === e ? i.hasAudio : i.hasVideo; if ("audio" === e) { i._trust_audio_enabled_state_ = !0; const e = i._audio_enabled_; if (i._audio_enabled_ = n, i._audio_enabled_ === e) return; { const e = i._audio_enabled_ ? "enable-local-audio" : "disable-local-audio"; Dh.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t, ", msg: ").concat(e)), this.safeEmit(fT.USER_INFO_UPDATED, t, e) } } else { i._trust_video_enabled_state_ = !0; const e = i._video_enabled_; if (i._video_enabled_ = n, i._video_enabled_ === e) return; { const e = i._video_enabled_ ? "enable-local-video" : "disable-local-video"; Dh.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t, ", msg: ").concat(e)), this.safeEmit(fT.USER_INFO_UPDATED, t, e) } } const o = "audio" === e ? i.hasAudio : i.hasVideo; return r !== o ? !r && o ? (Dh.info("[".concat(this._clientId, "] remote user ").concat(t, " published ").concat(e)), void this.safeEmit(fT.USER_PUBLISHED, i, e)) : ("video" === e && i._videoTrack && i._videoTrack._destroy(), "audio" === e && i._audioTrack, this._p2pChannel.muteRemote(i, e), Dh.info("[".concat(this._clientId, "] remote user ").concat(t, " unpublished ").concat(e)), void this.safeEmit(fT.USER_UNPUBLISHED, i, e)) : void 0 })), hl(this, "_handleMuteStream", ((e, t, n) => { if (jh("BLOCK_LOCAL_CLIENT") && $h(e, this.channelName)) return; Dh.debug("[".concat(this._clientId, "] receive mute message"), e, t, n); const i = this._users.find((t => t.uid === e)); if (!i) return void Dh.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e)); const r = "audio" === t ? i.hasAudio : i.hasVideo; if ("audio" === t) { i._trust_audio_mute_state_ = !0; const t = i._audio_muted_; if (i._audio_muted_ = n, i._audio_muted_ === t) return; { const t = i._audio_muted_ ? "mute-audio" : "unmute-audio"; Dh.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e, ", msg: ").concat(t)), this.safeEmit(fT.USER_INFO_UPDATED, e, t) } } else { i._trust_video_mute_state_ = !0; const t = i._video_muted_; if (i._video_muted_ = n, i._video_muted_ === t) return; { const t = i._video_muted_ ? "mute-video" : "unmute-video"; Dh.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e, ", msg: ").concat(t)), this.safeEmit(fT.USER_INFO_UPDATED, e, t) } } const o = "audio" === t ? i.hasAudio : i.hasVideo; if (r !== o) { if (!r && o) return ("audio" === t ? i._audioSSRC : i._videoSSRC) ? (Dh.info("[".concat(this._clientId, "] remote user ").concat(e, " published ").concat(t)), void this.safeEmit(fT.USER_PUBLISHED, i, t)) : void Dh.warning("[".concat(this._clientId, "] remote user ").concat(e, " receive ").concat(t, " unmute message  before add stream message, ").concat(t, " SSRC doesn't exist yet.")); "video" === t && i._videoTrack && i._videoTrack._destroy(), "audio" === t && i._audioTrack, this._p2pChannel.muteRemote(i, t), Dh.info("[".concat(this._clientId, "] remote user ").concat(e, " unpublished ").concat(t)), this.safeEmit(fT.USER_UNPUBLISHED, i, t) } })), hl(this, "_handleP2PLost", (async e => { Dh.debug("[".concat(this._clientId, "] receive p2p lost"), e), parseInt(e.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : Dh.warning("[".concat(this._clientId, "] P2PLost stream not found"), e) })), hl(this, "_handleTokenWillExpire", (() => { Dh.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.safeEmit(fT.ON_TOKEN_PRIVILEGE_WILL_EXPIRE) })), hl(this, "_handleBeforeUnload", (e => { "beforeunload" === e.type && void 0 !== e.returnValue && "" !== e.returnValue || (this.leave(), Dh.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide"))) })), hl(this, "_handleUpdateNetworkQuality", (() => { if ("normal" === this._networkQualitySensitivity) return; if (navigator && void 0 !== navigator.onLine && !navigator.onLine) return void this.safeEmit(fT.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }); const e = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 }; e.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(fT.NETWORK_QUALITY, e) })), this._config = e, this._clientId = Zg(5, "client-"), this.store = new Mv(e.codec, e.audioCodec, e.mode, this._clientId), this.store.clientCreated(), e.proxyServer && this.setProxyServer(e.proxyServer, !0), e.turnServer && this.setTurnServer(e.turnServer, !0), Dh.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(yh, " build: ").concat(vh, ", mode: ").concat(this.mode, ", codec: ").concat(this.codec)), e.clientRoleOptions) try { xT(e.clientRoleOptions), t = Object.assign({}, e.clientRoleOptions) } catch (e) { Dh.warning("[".concat(this._clientId, "] ").concat(e.toString())) } this._statsCollector = new Ug(this.store), this._statsCollector.onStatsException = (e, t, n) => { Dh.debug("[".concat(this._clientId, "] receive exception msg, code: ").concat(e, ", msg: ").concat(t, ", uid: ").concat(n)), this.safeEmit(fT.EXCEPTION, { code: e, msg: t, uid: n }) }, this._statsCollector.onUploadPublishDuration = (e, t, n, i) => { const r = this._users.find((t => t.uid === e)); r && wA.peerPublishStatus(this._sessionId, { subscribeElapse: i, audioPublishDuration: t, videoPublishDuration: n, peer: r._uintid }) }, this.store.useDataChannel = XO().supportDataChannel && jh("SIGNAL_CHANNEL"), this._gateway = new xm(this.store, { clientId: this._clientId, mode: this.mode, codec: this.codec, websocketRetryConfig: e.websocketRetryConfig || Ah, httpRetryConfig: e.httpRetryConfig || Ah, forceWaitGatewayResponse: void 0 === e.forceWaitGatewayResponse || e.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e.role, clientRoleOptions: t }), this._configDistribute = new TI, this._p2pChannel = new yv(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents() } async join(e, t, n, i, r) { const o = ++this._numberOfJoinCount; this.store.joinStart(), i && (this.store.uid = i); const s = Vv(), a = xv() ? window.isSecureContext : "Browser Not Support"; if (!xv() && !s || !window.isSecureContext) { const e = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser"; Dh.warning(e) } const c = $g(); "DISCONNECTED" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), Dh.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart))); const E = wA.reportApiInvoke(c, { name: RT.JOIN, options: [e, t, n, i], states: { isHttps: s, isSecureContext: a }, tag: hT.TRACER }); wA.setAppId(e); try { if (!n && null !== n) throw new Ch(Oh.INVALID_PARAMS, "Invalid token: ".concat(n, ". If you don not use token, set it to null")); n && Qp(n, "token", 1, 2047), Qp(e, "appid", 1, 2047), Zp(t), i && $p(i), r && Qp(r, "optionalInfo", 1, 2047) } catch (e) { throw E.onError(e), e } if (Dh.info("[".concat(this._clientId, "] start join channel ").concat(t, ", join number: ").concat(o)), this._leaveMutex.isLocked && (Dh.debug("[".concat(this._clientId, "] join: waiting leave operation")), (await this._leaveMutex.lock())(), Dh.debug("[".concat(this._clientId, "] join: continue"))), this._joinAndNotLeaveYet = !0, "DISCONNECTED" !== this.connectionState) { const e = new Ch(Oh.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state")); throw E.onError(e), e } this._sessionId || (this._sessionId = c, this.store.sessionId = this._sessionId), this._gateway.state = "CONNECTING"; const _ = VL({ clientId: this._clientId, appId: e, sid: this._sessionId, cname: t, uid: "string" != typeof i ? i : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: n || e, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: r, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint }, void 0 !== this._remoteDefaultVideoStreamType && { defaultVideoStream: this._remoteDefaultVideoStreamType }); if (this._useLocalAccessPoint && (_.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof i && (_.stringUid = i, this._uintUid ? (_.uid = this._uintUid, this._uintUid = void 0) : _.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) { if (_.aesmode = this._encryptionMode, _.aespassword = await (async e => { const t = lm("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), n = await window.crypto.subtle.importKey("spki", t, { name: "RSA-OAEP", hash: "SHA-256" }, !0, ["encrypt"]), i = PA(e), r = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, n, i); return Rm(new Uint8Array(r)) })(this._encryptionSecret), !this._joinAndNotLeaveYet) throw new Ch(Oh.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left")); this._encryptionSalt && (_.aessalt = this._encryptionSalt) } this._startSession(this._sessionId, { channel: t, appId: e }); const d = this._sessionId; setTimeout((() => { "CONNECTING" === this.connectionState && d === this._sessionId && wA.joinChannelTimeout(this._sessionId, 5) }), 5e3); try { let i; const r = _.cloudProxyServer; if (["proxy3", "proxy4", "proxy5"].includes(r)) { const e = jh("PROXY_SERVER_TYPE3"); Array.isArray(e) ? _.proxyServer = e[0] : _.proxyServer = e } if (wA.setProxyServer(_.proxyServer), Dh.setProxyServer(_.proxyServer), this.store.requestAPStart(), _.stringUid && !_.uid) { const e = await EI(_.stringUid, _, this._axiosCancelSource.token, this._config.httpRetryConfig || Ah, this.store); Dh.debug("[".concat(this._clientId, "] getUserAccount Success ").concat(_.stringUid, " => ").concat(e)), _.uid = e, i = await cI(_, this._axiosCancelSource.token, this._config.httpRetryConfig || Ah, !0, this.store) } else i = await cI(_, this._axiosCancelSource.token, this._config.httpRetryConfig || Ah, !0, this.store); if (!this._joinAndNotLeaveYet) throw new Ch(Oh.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left")); this.store.requestAPEnd(), setTimeout((() => { this._configDistribute.startGetConfigDistribute(_, this._axiosCancelSource.token), this._configDistribute.on(IO.UPDATE_BITRATE_LIMIT, (e => { this._p2pChannel.updateBitrateLimit(e) })) }), 0), this._key = n || e; const o = i.gatewayInfo; this._joinInfo = VL(VL({}, _), {}, { cid: o.cid, uid: _.uid ? _.uid : o.uid, vid: o.vid, apResponse: o.res, uni_lbs_ip: o.uni_lbs_ip, gatewayAddrs: o.gatewayAddrs }); const s = await this._joinGateway(); if (!this._joinAndNotLeaveYet) throw new Ch(Oh.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left")); E.onSuccess(s), this._appId = e, this._channelName = _.cname, this._uid = s, this.store.uid = s, setTimeout((() => { this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(Wu() ? "beforeunload" : "pagehide", this._handleBeforeUnload) }), 0); const a = _.stringUid ? "string uid: ".concat(_.stringUid, ",uid: ").concat(_.uid) : "uid: ".concat(this._uid); return Dh.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(t, ",").concat(a)), setTimeout((() => { Dh.startUpload() }), 5e3), this.store.joinEnd(), u = this, zh.includes(u) || zh.push(u), s } catch (e) { const t = Array.isArray(e) ? e[0] : e; throw t && t.code === Oh.OPERATION_ABORTED ? Dh.warning("[".concat(this._clientId, "] join number: ").concat(o, ", Joining channel failed, rollback"), t) : Dh.error("[".concat(this._clientId, "] join number: ").concat(o, ", Joining channel failed, rollback"), t), t.code !== Oh.OPERATION_ABORTED && this._numberOfJoinCount === o && (this._gateway.state = "DISCONNECTED", this._reset()), E.onError(t), t } var u } _joinGateway() { if (!this._joinInfo || !this._key) throw new Ch(Oh.INVALID_OPERATION); return this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !jh("JOIN_WITH_FALLBACK_SIGNAL_PROXY"))).then((e => e)).catch((e => { if (e.code === Oh.INIT_WEBSOCKET_TIMEOUT) return this._gateway.leave(!0, IT.FALLBACK), e; if (e.code === Oh.INIT_DATACHANNEL_TIMEOUT) return this._gateway.leave(!0, IT.FALLBACK), e; throw e })).then((e => { if (e instanceof Ch) { if (e.code === Oh.INIT_WEBSOCKET_TIMEOUT) { if (Dh.info("[".concat(this._clientId, "] join timeout, fallback to proxy")), !this._joinInfo || !this._key) throw new Ch(Oh.INVALID_OPERATION); this._joinInfo.cloudProxyServer = "fallback", this._cloudProxyServerMode = "fallback", this.store.cloudProxyServerMode = "fallback"; const e = jh("PROXY_SERVER_TYPE3"); if (Array.isArray(e)) if (this._joinInfo.apUrl) { const t = /^https?:\/\/(.+?)(\/.*)?$/.exec(this._joinInfo.apUrl)[1].split("."), n = t.slice(t.length - 2).join("."); e.forEach((e => { this._joinInfo && e.includes(n) && (this._joinInfo.proxyServer = e) })), this._joinInfo.proxyServer || (this._joinInfo.proxyServer = e[0]) } else this._joinInfo.proxyServer = e[0]; else this._joinInfo.proxyServer = e; const t = jh("LOG_UPLOAD_SERVER").match(/.+:(\d{1,5})$/); return t && t[1] && "443" !== t[1] && Dh.setProxyServer(this._joinInfo.proxyServer), "443" !== jh("STATS_COLLECTOR_PORT").toString() && wA.setProxyServer(this._joinInfo.proxyServer), wA.reportApiInvoke(this._sessionId, { name: RT.JOIN_FALLBACK_TO_PROXY, options: [this._joinInfo.proxyServer], tag: hT.TRACER }).onSuccess(), this.safeEmit(fT.JOIN_FALLBACK_TO_PROXY, this._joinInfo.proxyServer), jh("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && this._joinInfo.turnServer.servers.forEach((e => { "forceturn" in e && (e.forceturn = !0) })), this._gateway.join(this._joinInfo, this._key) } if (Dh.info("[".concat(this._clientId, "] join by datachannel timeout, fallback to websocket")), !this._joinInfo || !this._key) throw new Ch(Oh.INVALID_OPERATION); return wA.reportApiInvoke(this._sessionId, { name: RT.DATACHANNEL_FAILBACK, options: [this.store.clientId], tag: hT.TRACER }).onSuccess(), this._joinGateway() } return e })).then((e => e)) } async leave() { Dh.info("[".concat(this._clientId, "] Leaving channel")), window.removeEventListener(Wu() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function (e) { const t = zh.indexOf(e); -1 !== t && zh.splice(t, 1) }(this); const e = await this._leaveMutex.lock(); if ("DISCONNECTED" === this.connectionState) return Dh.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void e(); await this._gateway.leave("CONNECTED" !== this.connectionState), Dh.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = !1, this.store.resetJoinChannelServiceRecords(), e() } async publish(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; if (Array.isArray(e) || (e = [e]), 0 === e.length) throw new Ch(Oh.INVALID_PARAMS, "track list is empty"); if ("audience" === this._gateway.role) throw new Ch(Oh.INVALID_OPERATION, "audience can not publish stream"); for (const i of e) { if (!(i instanceof xA)) throw new Ch(Oh.INVALID_PARAMS, "parameter is not local track"); if (!i._enabled && t) throw new Ch(Oh.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(i.getTrackId())) } Dh.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(e.map((e => "".concat(e.getTrackId(), " "))))); const n = await this._publishMutex.lock(); await this._configDistribute.awaitConfigDistributeComplete(), t && e.forEach((e => { const t = this._configDistribute.getBitrateLimit(); e instanceof If && t && e.setBitrateLimit(t.uplink) })); try { await this._publishHighStream(e), Dh.info("[".concat(this._clientId, "] Publish success, id ").concat(e.map((e => "".concat(e.getTrackId(), " "))))) } catch (e) { throw Dh.error("[".concat(this._clientId, "] publish error"), e.toString()), e } finally { n() } } async unpublish(e) { if (!this._joinInfo || void 0 === this._uid) throw new Ch(Oh.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!"); e ? Array.isArray(e) || (e = [e]) : e = this._p2pChannel.getAllTracks(!0), Dh.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(e.map((e => "".concat(e.getTrackId(), " "))), " ")); const t = await this._publishMutex.lock(); try { const t = await this._p2pChannel.unpublish(e); t && await this._gateway.unpublish(t, this._uid), Dh.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(e.map((e => "".concat(e.getTrackId()))))) } catch (e) { throw Dh.error("[".concat(this._clientId, "] unpublish error"), e.toString()), e } finally { t && t() } } async subscribe(e, t) { return this._subscribe(e, t) } async _subscribe(e, t, n) { if (Jp(t, "mediaType", ["audio", "video"]), !this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "Can't subscribe stream, not joined"); if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new Ch(Oh.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state")); if (!this._users.find((t => t === e))) { const t = new Ch(Oh.INVALID_REMOTE_USER, "user is not in the channel"); throw Dh.error("[".concat(this._clientId, "] can not subscribe ").concat(e.uid, ", this user is not in the channel")), t } if (!e.hasAudio && !e.hasVideo) { const t = new Ch(Oh.INVALID_REMOTE_USER, "user is not published"); throw Dh.error("[".concat(this._clientId, "] can not subscribe ").concat(e.uid, ", user is not published")), t } if (!(n || ("audio" !== t || e.hasAudio && void 0 !== e._audioSSRC) && ("video" !== t || e.hasVideo && void 0 !== e._videoSSRC))) { const n = new Ch(Oh.REMOTE_USER_IS_NOT_PUBLISHED); throw Dh.error("[".concat(this._clientId, "] can not subscribe ").concat(e.uid, " with mediaType ").concat(t, ", remote track is not published")), n } const i = "audio" === t ? e._audioSSRC : e._videoSSRC, r = "audio" === t ? e._audioOrtc : e._videoOrtc, o = "video" === t ? e._rtxSsrcId : void 0, s = { stream_type: "audio" === t ? PO.AUDIO : PO.VIDEO, ssrcId: i }, a = await this._subscribeMutex.lock(); Dh.info("[".concat(this._clientId, "] subscribe user ").concat(e.uid, ", mediaType: ").concat(t)); try { if (await this._p2pChannel.hasRemoteMediaWithLock(e, t)) await this._p2pChannel.unmuteRemote(e, t); else try { Lg.markSubscribeStart(this.store.clientId, i), this.store.subscribe(e.uid, t, Date.now()), await this._p2pChannel.subscribe(e, t, i, o, r); try { await this._gateway.subscribe(e.uid, s, !0) } catch (n) { if ((null == n ? void 0 : n.code) !== Oh.WS_ABORT) throw await this._p2pChannel.unsubscribe(e, t), n; await this._p2pChannel.unsubscribe(e, t, !0), this._p2pChannel.setPendingRemoteMedia(e, t) } this.store.subscribe(e.uid, t, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(!0, null, e, t) } catch (n) { throw this._p2pChannel.reportSubscribeEvent(!1, null == n ? void 0 : n.code, e, t), n } Dh.info("[".concat(this._clientId, "] subscribe success user ").concat(e.uid, ", mediaType: ").concat(t)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e.uid, this._defaultStreamFallbackType).catch((e => { Dh.warning("[".concat(this._clientId, "] auto set fallback failed"), e) })); const a = "audio" === t ? e._audioTrack : e._videoTrack; if (!a) throw new Ch(Oh.UNEXPECTED_ERROR, "can not find remote track in user object"); return a } catch (t) { throw Dh.error("[".concat(this._clientId, "] subscribe user ").concat(e.uid, " error"), t), t } finally { a() } } async massSubscribe(e) { if (zp(e, "subscribeList"), !this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "Can't subscribe stream, not joined"); if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new Ch(Oh.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state")); const t = Date.now(), n = new Map, i = await this._subscribeMutex.lock(); Dh.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e.map((e => { let { user: t, mediaType: n } = e; return "user: ".concat(null == t ? void 0 : t.uid, ", mediaType: ").concat(n) })).join("; "))); const r = (e = [...e]).map((e => { let { user: t, mediaType: n } = e; return { user: t, mediaType: n } })), o = await this._p2pChannel.globalLock(); try { var s; for (let t = e.length - 1; t >= 0; t--) { const i = e[t], { user: o, mediaType: s } = i; if (Jp(s, "mediaType", ["audio", "video"]), !o) { const e = new Ch(Oh.INVALID_PARAMS, "user property does not exist in subscribeList item"); throw Dh.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), e } if (!this._users.find((e => e === o))) { const n = new Ch(Oh.INVALID_REMOTE_USER, "user is not in the channel"); Dh.error("[".concat(this._clientId, "] can not massSubscribe ").concat(o.uid, ", this user is not in the channel")), r[t].error = n, e.splice(t, 1); continue } if ("audio" === s && (!o.hasAudio || void 0 === o._audioSSRC) || "video" === s && (!o.hasVideo || void 0 === o._videoSSRC)) { const n = new Ch(Oh.REMOTE_USER_IS_NOT_PUBLISHED); Dh.error("[".concat(this._clientId, "] can not subscribe ").concat(o.uid, " with mediaType ").concat(s, ", remote user is not published")), r[t].error = n, e.splice(t, 1); continue } const a = cO.Video | cO.LwoVideo, c = n.get(o); if (c) { if ("video" === s ? c & a : c & cO.Audio) { e.splice(t, 1), Dh.warning("[".concat(this._clientId, "] repeat massSubscribe user:").concat(o.uid, ", mediaType:").concat(s, " twice")); continue } n.set(o, c | ("video" === s ? a : cO.Audio)) } else n.set(o, "video" === s ? a : cO.Audio) } for (let t = e.length - 1; t >= 0; t--) { const i = e[t], { user: r, mediaType: o } = i, s = cO.Video | cO.LwoVideo; if (this._p2pChannel.hasRemoteMedia(r, o)) { await this._p2pChannel.unmuteRemoteNoLock(r, o); const i = n.get(r); n.set(r, "video" === o ? i ^ s : i ^ cO.Audio), e.splice(t, 1) } } this.store.massSubscribe(e.map((e => ({ userId: e.user.uid, type: e.mediaType }))), t); const i = Zn(s = Array.from(n.entries())).call(s, ((e, t) => { let [n, i] = t; if (0 === i) return e; const r = { stream_id: n.uid, stream_type: i }; return i & cO.Audio && (r.audio_ssrc = n._audioSSRC), i & cO.Video && (r.video_ssrc = n._videoSSRC), e.push(r), e }), []); try { e.length > 0 && await this._p2pChannel.massSubscribeNoLock(e.map((e => { let { user: t, mediaType: n } = e; return { user: t, mediaType: n, ssrcId: n === PO.VIDEO ? t._videoSSRC : t._audioSSRC, rtxSsrcId: n === PO.VIDEO ? t._rtxSsrcId : void 0 } }))); const n = new Map; if (i.length > 0) { const e = await this._gateway.subscribeAll(i, !0); ((null == e ? void 0 : e.users) || []).forEach((e => { let { stream_id: t, video_error_code: i, audio_error_code: r, error_code: o } = e; (i || r || o) && n.set(t, { video_error_code: i, audio_error_code: r, error_code: o }) })) } if (Array.from(n.entries()).length > 0) { const e = Array.from(n.entries()).map((e => { let t, [n, i] = e; return i.error_code || i.video_error_code && i.audio_error_code ? t = void 0 : i.video_error_code ? t = PO.VIDEO : i.audio_error_code && (t = PO.AUDIO), { user: this.remoteUsers.find((e => e.uid === n)), mediaType: t } })); await this._p2pChannel.massUnsubscribeNoLock(e) } for (const e of r) { const t = n.get(e.user.uid); if (t) { const n = t.error_code || "audio" === e.mediaType && t.audio_error_code || "video" === e.mediaType && t.video_error_code; if (n) { const t = gm(n); Dh.error("user:".concat(e.user.uid, " mediaType:").concat(e.mediaType, " has massSubscribe error ").concat(t.desc)), e.error = new Ch(Oh.SUBSCRIBE_FAILED, "code ".concat(n, ": ").concat(t.desc)) } } e.error || ("video" === e.mediaType ? e.track = e.user.videoTrack : e.track = e.user.audioTrack) } return this.store.massSubscribe(r.filter((e => !e.error)).map((e => ({ userId: e.user.uid, type: e.mediaType }))), void 0, Date.now()), r.forEach((e => { var n; wA.subscribe(this.store.sessionId, { succ: !!e.error, ec: (null === (n = e.error) || void 0 === n ? void 0 : n.code) || null, video: e.mediaType === PO.VIDEO, audio: e.mediaType === PO.AUDIO, peerid: e.user.uid, subscribeRequestid: e.mediaType === PO.VIDEO ? e.user._videoSSRC : e.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - t) }, !0) })), Dh.info("[".concat(this._clientId, "] massSubscribe success ").concat(e.map((e => { let { user: t, mediaType: n } = e; return "user: ".concat(null == t ? void 0 : t.uid, ", mediaType: ").concat(n) })).join("; "))), r } catch (t) { throw await this._p2pChannel.massUnsubscribeNoLock(e), t } } finally { o(), i() } } async unsubscribe(e, t) { if (t && Jp(t, "mediaType", ["audio", "video"]), !this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!"); if (!this._users.find((t => t === e))) { const t = new Ch(Oh.INVALID_REMOTE_USER, "user is not in the channel"); throw Dh.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e.uid, ", user is not in the channel")), t } Dh.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e.uid, ", mediaType: ").concat(t)); const n = await this._subscribeMutex.lock(); try { const n = await this._p2pChannel.unsubscribe(e, t); n && await this._gateway.unsubscribe(n, e.uid), Dh.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e.uid, ", mediaType: ").concat(t)) } catch (t) { if (t.code === Oh.DISCONNECT_P2P) return void Dh.warning("disconnecting p2p, abort unsubscribe request."); throw Dh.error("[".concat(this._clientId, "] unsubscribe user ").concat(e.uid, " error"), t.toString()), t } finally { n() } } async massUnsubscribe(e) { if (zp(e, "unsubscribeList"), !this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!"); Dh.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e.map((e => { let { user: t, mediaType: n } = e; return "user: ".concat(null == t ? void 0 : t.uid, ", mediaType: ").concat(n, ";") })).join())), e = [...e]; const t = new Map; for (let n = e.length - 1; n >= 0; n--) { const { user: i, mediaType: r } = e[n]; if (!i) { const e = new Ch(Oh.INVALID_PARAMS, "user property does not exist in unsubscribeList item"); throw Dh.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), e } if (Jp(r, "mediaType", ["video", "audio", void 0]), !this._users.find((e => e === i))) { Dh.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(i.uid, ", user is not in the channel")), e.splice(n, 1); continue } const o = cO.Video | cO.LwoVideo; if (t.has(i)) { const s = t.get(i); let a; switch (r) { case "video": a = s & o; break; case "audio": a = s & cO.Audio; break; default: a = s & (cO.Audio | o) }if (a) { Dh.warning("[".concat(this._clientId, "] repeat massUnsubscribe user:").concat(i.uid, ",mediaType:").concat(r, " twice.")), e.splice(n, 1); continue } r ? "audio" === r ? t.set(i, s | cO.Audio) : "video" === r && t.set(i, s | o) : t.set(i, s | cO.Audio | o) } else r ? "audio" === r ? t.set(i, cO.Audio) : "video" === r && t.set(i, o) : t.set(i, cO.Audio | o) } try { const t = await this._p2pChannel.massUnsubscribe(e); t && await this._gateway.massUnsubscribe(t), Dh.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e.map((e => { let { user: t, mediaType: n } = e; return "user: ".concat(null == t ? void 0 : t.uid, ", mediaType: ").concat(n, ";") })).join())) } catch (e) { if (e.code === Oh.DISCONNECT_P2P) return void Dh.warning("[".concat(this._clientId, "] disconnecting p2p, abort unsubscribe request.")); throw Dh.error("[".concat(this._clientId, "] massUnsubscribe error"), e.toString()), e } } setLowStreamParameter(e) { !function (e) { if (!e) throw new Ch(Oh.INVALID_PARAMS); eT(e.width) || qp(e.width, "streamParameter.width"), eT(e.height) || qp(e.height, "streamParameter.height"), eT(e.framerate) || qp(e.framerate, "streamParameter.framerate"), eT(e.bitrate) || Xp(e.bitrate, "streamParameter.bitrate") }(e), (!e.width && e.height || e.width && !e.height) && Dh.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), Dh.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e)); const t = this._configDistribute.getLowStreamConfigDistribute(); t && t.bitrate && e.bitrate && t.bitrate < e.bitrate && (e.bitrate = t.bitrate), this._lowStreamParameter = e } async enableDualStream() { if (!XO().supportDualStream) throw wA.streamSwitch(this._sessionId, { lts: Date.now(), isdual: !0, succ: !1 }), new Ch(Oh.NOT_SUPPORTED, "Your browser is not support dual stream"); if (this._isDualStreamEnabled) throw new Ch(Oh.INVALID_OPERATION, "Dual stream is already enabled"); if (this._p2pChannel.canPublishLowStream()) try { await this._publishLowStream() } catch (e) { throw wA.streamSwitch(this._sessionId, { lts: Date.now(), isdual: !0, succ: !1 }), e } this._isDualStreamEnabled = !0, wA.streamSwitch(this._sessionId, { lts: Date.now(), isdual: !0, succ: !0 }), Dh.info("[".concat(this._clientId, "] enable dual stream")) } async disableDualStream() { if (this._isDualStreamEnabled) { if (!this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "Can't publish stream, haven't joined yet!"); if (this._p2pChannel.getLocalMedia(vO.LocalVideoLowTrack)) try { const e = await this._p2pChannel.unpublishLowStream(); e && await this._gateway.unpublish(e, this._joinInfo.stringUid || this._joinInfo.uid) } catch (e) { throw wA.streamSwitch(this._sessionId, { lts: Date.now(), isdual: !1, succ: !1 }), e } this._isDualStreamEnabled = !1, wA.streamSwitch(this._sessionId, { lts: Date.now(), isdual: !1, succ: !0 }), Dh.info("[".concat(this._clientId, "] disable dual stream")) } } async setClientRole(e, t) { if (function (e) { Jp(e, "role", ["audience", "host"]) }(e), t && xT(t), "rtc" === this.mode) throw Dh.warning("[".concat(this._clientId, "]rtc mode can not use setClientRole")), new Ch(Oh.INVALID_OPERATION, "rtc mode can not use setClientRole"); if (t && t.level && "host" === e) throw new Ch(Oh.INVALID_OPERATION, "host mode can not set audience latency level"); if ("audience" === e && this._p2pChannel.hasLocalMedia()) throw new Ch(Oh.INVALID_OPERATION, "can not set client role to audience when publishing stream"); await this._gateway.setClientRole(e, t), this._config.role = e, Dh.info("[".concat(this._clientId, "] set client role to ").concat(e, ", level: ").concat(t && t.level)) } setProxyServer(e, t) { if (Qp(e, "proxyServer"), !t) { if ("DISCONNECTED" !== this.connectionState) throw new Ch(Oh.INVALID_OPERATION, "Set proxy server before join channel"); if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new Ch(Oh.INVALID_OPERATION, "You have already set the proxy") } this._proxyServer = e, wA.setProxyServer(this._proxyServer), Dh.setProxyServer(this._proxyServer), Dh.info("[".concat(this._clientId, "] Set proxy server ").concat(t ? "by initialize call" : "", " success.")) } setTurnServer(e, t) { if (Array.isArray(e) || (e = [e]), !t) { if ("DISCONNECTED" !== this.connectionState) throw new Ch(Oh.INVALID_OPERATION, "Set turn server before join channel"); if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new Ch(Oh.INVALID_OPERATION, "You have already set the proxy") } if (kT(e)) return this._turnServer = { servers: e, mode: "original-manual" }, void Dh.info("[".concat(this._clientId, "] Set original turnserver ").concat(t ? "by initialize call" : "", " success: ").concat(e.map((e => e.urls)).join(","), ".")); e.forEach((e => VT(e))), this._turnServer = { servers: e, mode: "manual" }, Dh.info("[".concat(this._clientId, "] Set turnserver ").concat(t ? "by initialize call" : "", " success.")) } setLicense(e) { if ("DISCONNECTED" !== this.connectionState) throw new Ch(Oh.INVALID_OPERATION, "you should set license before join channel"); if (Qp(e, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e)) throw new Ch(Oh.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9"); this._license = e, Dh.info("[".concat(this._clientId, "] set license success"), e) } startProxyServer(e) { if ("DISCONNECTED" !== this.connectionState) throw new Ch(Oh.INVALID_OPERATION, "Start proxy server before join channel"); if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint) throw new Ch(Oh.INVALID_OPERATION, "You have already set the proxy"); const t = [3, 4, 5]; let n; switch (void 0 === e && (e = 3), e) { case 1: case 2: throw new Ch(Oh.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported."); case 3: n = "proxy3"; break; case 4: n = "proxy4"; break; case 5: n = "proxy5"; break; default: throw new Ch(Oh.INVALID_PARAMS, "proxy server mode must be ".concat(t.join("|"))) }this._cloudProxyServerMode = n, this.store.cloudProxyServerMode = n, Dh.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode) } stopProxyServer() { if ("DISCONNECTED" !== this.connectionState) throw new Ch(Oh.INVALID_OPERATION, "Stop proxy server after leave channel"); wA.setProxyServer(), Dh.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", Dh.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] } } setLocalAccessPointsV2(e) { if (!e.accessPoints) throw new Ch(Oh.INVALID_PARAMS, "accessPoints is required."); zp(e.accessPoints.serverList, "accessPoints.serverList"), Qp(e.accessPoints.domain, "accessPoints.domain"); const t = (e, t) => { Xp(e, t, 0, 65535, !0) }; let n = 443; if (e.accessPoints.port && (t(e.accessPoints.port, "accessPoints.port"), n = e.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new Ch(Oh.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy"); jh("CLOSE_AFB_FOR_LOCAL_AP") && (Gh("JOIN_WITH_FALLBACK_SIGNAL_PROXY", !1), Gh("JOIN_WITH_FALLBACK_MEDIA_PROXY", !1)); const i = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, r = e.accessPoints.domain, o = e.accessPoints.serverList.map((e => i.test(e) ? "".concat(e.replace(/\./g, "-"), ".").concat(r) : e)), s = o.map((e => "".concat(e, ":").concat(n))); this._useLocalAccessPoint = !0, this._setLocalAPVersion = 2, Gh("WEBCS_DOMAIN", s), Gh("WEBCS_DOMAIN_BACKUP_LIST", s), Gh("GATEWAY_DOMAINS", [r]), e.report && e.report.hostname && Array.isArray(e.report.hostname) && e.report.hostname.length ? (zp(e.report.hostname, "report.hostname"), Gh("EVENT_REPORT_DOMAIN", e.report.hostname[0]), Gh("EVENT_REPORT_BACKUP_DOMAIN", e.report.hostname[1] || e.report.hostname[0])) : (Gh("EVENT_REPORT_DOMAIN", o[0]), Gh("EVENT_REPORT_BACKUP_DOMAIN", o[1] || o[0])); let a = 6443; e.report && e.report.port && (t(e.report.port, "report.port"), a = e.report.port), Gh("STATS_COLLECTOR_PORT", a), e.report ? Gh("ENABLE_EVENT_REPORT", !0) : Gh("ENABLE_EVENT_REPORT", !1); let c = ""; e.log && e.log.hostname && Array.isArray(e.log.hostname) && e.log.hostname.length ? (zp(e.log.hostname, "log.hostname"), c = e.log.hostname[0]) : c = o[0]; let E = 6444; e.log && e.log.port && (t(e.log.port, "log.port"), E = e.log.port), Gh("LOG_UPLOAD_SERVER", "".concat(c, ":").concat(E)); let _ = []; e.cds && e.cds.hostname && Array.isArray(e.cds.hostname) && e.cds.hostname.length ? (zp(e.cds.hostname, "cds.hostname"), _ = e.cds.hostname) : _ = o; let d = 443; e.cds && e.cds.port && (t(e.cds.port, "cds.port"), d = e.cds.port), Gh("CDS_AP", _.map((e => "".concat(e, ":").concat(d)))), e.cds ? Gh("ENABLE_CONFIG_DISTRIBUTE", !0) : Gh("ENABLE_CONFIG_DISTRIBUTE", !1), Dh.info("set local access point v2 success") } setLocalAccessPoints(e, t) { if (zp(e, "serverList"), Qp(t, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new Ch(Oh.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy"); const n = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/; e = e.map((e => n.test(e) ? "".concat(e.replace(/\./g, "-"), ".").concat(t) : e)), this._useLocalAccessPoint = !0, this._setLocalAPVersion = 1, Gh("WEBCS_DOMAIN", e), Gh("WEBCS_DOMAIN_BACKUP_LIST", e), Gh("GATEWAY_DOMAINS", [t]), Gh("EVENT_REPORT_DOMAIN", e[0]), Gh("EVENT_REPORT_BACKUP_DOMAIN", e[1] || e[0]), Gh("LOG_UPLOAD_SERVER", "".concat(e[0], ":6444")), Dh.info("[".concat(this._clientId, "] set local access point success")) } async setRemoteDefaultVideoStreamType(e) { if (Jp(e, "streamType", [0, 1]), this._remoteDefaultVideoStreamType = e, this._joinInfo) try { await this._gateway.setDefaultRemoteVideoStreamType(e), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType } catch (e) { throw Dh.error("[".concat(this._clientId, "] set default remote video stream type error"), e.toString()), e } else Dh.debug("[".concat(this._clientId, "] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e)) } async setRemoteVideoStreamType(e, t) { Jp(t, "streamType", [0, 1]); try { await this._gateway.setRemoteVideoStreamType(e, t), setTimeout((() => { const t = this._users.find((t => t.uid === e)); t && t.videoTrack && t.videoTrack.updateMediaStreamTrackResolution() }), 2e3) } catch (e) { throw Dh.error("[".concat(this._clientId, "] set remote video stream type error"), e.toString()), e } Dh.info("[".concat(this._clientId, "] set remote ").concat(e, " video stream type to ").concat(t)), this._remoteStreamTypeCacheMap.set(e, t) } async setStreamFallbackOption(e, t) { Jp(t, "fallbackType", [0, 1, 2]); try { await this._gateway.setStreamFallbackOption(e, t) } catch (e) { throw Dh.error("[".concat(this._clientId, "] set stream fallback option"), e.toString()), e } Dh.info("[".concat(this._clientId, "] set remote ").concat(e, " stream fallback type to ").concat(t)), this._streamFallbackTypeCacheMap.set(e, t) } setEncryptionConfig(e, t, n) { if (function (e) { Jp(e, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]) }(e), Qp(t, "secret"), ["aes-128-gcm2", "aes-256-gcm2"].includes(e)) { if (!n || !(n instanceof Uint8Array && 32 === n.length)) throw new Ch(Oh.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes") } else if (n) throw new Ch(Oh.INVALID_PARAMS, "current encrypt mode does not need salt"); new RegExp("^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'\"|{}\\[\\]])(?=.{8,})").test(t) || Dh.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), this._encryptionMode = e, this._encryptionSecret = t, n && (this._encryptionSalt = Rm(n)) } async renewToken(e) { if (Qp(e, "token", 1, 2047), !this._key || !this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "renewToken should not be called before user join"); const t = this._key; this._key = e, this._joinInfo && (this._joinInfo.token = e); const n = await this._renewTokenMutex.lock(); try { if (jh("USE_NEW_TOKEN")) { Dh.debug("[".concat(this._clientId, "] start renew token with ticket from unilbs")); const t = await RI(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || Ah); Dh.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({ token: e, ticket: t }) } else Dh.debug("[".concat(this._clientId, "] start renew token without ticket")), await this._gateway.renewToken({ token: e }); Dh.debug("[".concat(this._clientId, "] renewToken success")) } catch (e) { throw this._key = t, this._joinInfo.token = t, Dh.error("[".concat(this._clientId, "] renewToken failed"), e.toString()), e } finally { n() } } enableAudioVolumeIndicator() { this._audioVolumeIndicationInterval ? Dh.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval((() => { const e = this._p2pChannel.getAudioLevels(); this.safeEmit(fT.VOLUME_INDICATOR, e) }), jh("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3) } getRTCStats() { const e = this._statsCollector.getRTCStats(), t = this._gateway.getInChannelInfo(); return e.Duration = Math.round(t.duration / 1e3), e } async startLiveStreaming(e, t) { if (!t) { if ("h264" !== this.codec) throw new Ch(Oh.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264"); if (!this._p2pChannel.hasLocalMedia()) throw new Ch(Oh.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming") } if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e)) throw new Ch(Oh.LIVE_STREAMING_TASK_CONFLICT); const n = t ? WT.TRANSCODE : WT.RAW; return this._createLiveStreamingClient(n).startLiveStreamingTask(e, n) } setLiveTranscoding(e) { return this._createLiveStreamingClient(WT.TRANSCODE).setTranscodingConfig(e) } async stopLiveStreaming(e) { const t = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((t => t && t.hasUrl(e))); if (!t.length) throw new Ch(Oh.INVALID_PARAMS, "can not find live streaming url to stop"); await Cd.all(t.map((t => t && t.stopLiveStreamingTask(e)))) } async addInjectStreamUrl(e, t) { if (!this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "can not addInjectStreamUrl, no joininfo"); const n = this._createLiveStreamingClient(WT.INJECT); n.setInjectStreamConfig(t, 0), await n.startLiveStreamingTask(e, WT.INJECT) } async removeInjectStreamUrl() { var e; const t = this._createLiveStreamingClient(WT.INJECT), n = Array.from(gS(e = t.streamingTasks).call(e)).find((e => e.mode === WT.INJECT)); if (!this._joinInfo || !n) throw new Ch(Oh.INVALID_OPERATION, "can remove addInjectStreamUrl, no joininfo or inject task"); await t.stopLiveStreamingTask(n.url) } async startChannelMediaRelay(e) { fI(e); const t = this._createChannelMediaRelayClient(); await t.startChannelMediaRelay(e) } async updateChannelMediaRelay(e) { fI(e); const t = this._createChannelMediaRelayClient(); await t.updateChannelMediaRelay(e) } async stopChannelMediaRelay() { const e = this._createChannelMediaRelayClient(); await e.stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0) } sendStreamMessage(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; if (!this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "can not send data stream, not joined"); if ("string" == typeof e && (e = (new TextEncoder).encode(e)), new Blob([e]).size > 1024) throw new Ch(Oh.INVALID_PARAMS, "stream message out of range."); return this._gateway.signal.request(vT.DATA_STREAM, { payload: Rm(e) }, !t) } sendMetadata(e) { if (!this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "can not send metadata, not joined"); if (new Blob([e]).size > 1024) throw new Ch(Oh.METADATA_OUT_OF_RANGE); return this._gateway.signal.request(vT.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: Rm(e) }) } async sendCustomReportMessage(e) { if (Array.isArray(e) || (e = [e]), e.forEach(cT), !this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "can not send custom report, not joined"); await wA.sendCustomReportMessage(this._joinInfo.sid, e) } getLocalAudioStats() { return this._statsCollector.getLocalAudioTrackStats() } getRemoteAudioStats() { return this._statsCollector.getRemoteAudioTrackStats() } getLocalVideoStats() { return this._statsCollector.getLocalVideoTrackStats() } getRemoteVideoStats() { return this._statsCollector.getRemoteVideoTrackStats() } getRemoteNetworkQuality() { return this._statsCollector.getRemoteNetworkQualityStats() } async pickSVCLayer(e, t) { Jp(t.spatialLayer, "spatialLayer", [0, 1, 2, 3]), Jp(t.temporalLayer, "temporalLayer", [0, 1, 2, 3]); try { await this._gateway.pickSVCLayer(e, t) } catch (e) { throw Dh.error("[".concat(this._clientId, "] pick SVC layer failed"), e.toString()), e } } _reset() { if (Dh.debug("[".concat(this._clientId, "] reset client")), this._axiosCancelSource.cancel(), this._axiosCancelSource = Rh.CancelToken.source(), this._streamFallbackTypeCacheMap = new Map, this._remoteStreamTypeCacheMap = new Map, this._configDistribute.stopGetConfigDistribute(), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._users.forEach((e => { e._audioTrack && e._audioTrack._destroy(), e._videoTrack && e._videoTrack._destroy() })), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new kA("client-publish"), this._subscribeMutex = new kA("client-subscribe"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect) try { this._inspect.close(), this._inspect = void 0 } catch (e) { } if (this._moderation) try { this.setImageModeration(!1) } catch (e) { } } _startSession(e, t) { const n = e || $g(); e ? Dh.debug("[".concat(this._clientId, "] new Session ").concat(n)) : Dh.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(n)), this._sessionId = n, this.store.sessionId = n, t ? wA.sessionInit(this._sessionId, { lts: (new Date).getTime(), cname: t.channel, appid: t.appId, mode: this.mode }) : this._joinInfo ? wA.sessionInit(this._sessionId, { lts: (new Date).getTime(), cname: this._joinInfo.cname, appid: this._joinInfo.appId, mode: this.mode }) : this._gateway.joinInfo && wA.sessionInit(this._sessionId, { lts: (new Date).getTime(), cname: this._gateway.joinInfo.cname, appid: this._gateway.joinInfo.appId, mode: this.mode }), this._joinInfo && (this._joinInfo.sid = n), this._gateway.joinInfo && (this._gateway.joinInfo.sid = n) } async _publishHighStream(e) { if (!this._joinInfo || void 0 === this._uid) throw new Ch(Oh.INVALID_OPERATION, "Can't publish stream, haven't joined yet!"); if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new Ch(Oh.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state")); if ("auto" === this._turnServer.mode && jh("FORCE_TURN") && !jh("TURN_ENABLE_TCP") && !jh("TURN_ENABLE_UDP")) throw new Ch(Oh.UNEXPECTED_ERROR, "force TURN With No TURN Configuration"); Dh.debug("[".concat(this._clientId, "] publish high stream")); try { const n = await this._p2pChannel.publish(e, this._isDualStreamEnabled, this._lowStreamParameter), i = (await n.next()).value; if (i) { var t; let r; try { r = await this._gateway.publish(this._uid, i, !0) } catch (e) { if (e.code !== Oh.DISCONNECT_P2P) throw n.throw(e), e } await n.next((null === (t = r) || void 0 === t ? void 0 : t.ortc) || []) } this._p2pChannel.reportPublishEvent(!0, null); for (const t of e) t instanceof If && t._encoderConfig && this._gateway.setVideoProfile(t._encoderConfig), !t.muted && t.enabled || await this._p2pChannel.muteLocalTrack(t) } catch (t) { if (this._p2pChannel.reportPublishEvent(!1, null == t ? void 0 : t.code, e), (null == t ? void 0 : t.code) === Oh.WS_ABORT) return; throw t } } async _publishLowStream() { if (!this._joinInfo || void 0 === this._uid) throw new Ch(Oh.INVALID_OPERATION, "Can't publish stream, haven't joined yet!"); if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new Ch(Oh.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state")); Dh.debug("[".concat(this._clientId, "] publish low stream")); const e = this._configDistribute.getLowStreamConfigDistribute(); e && e.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e.bitrate)); try { const e = await this._p2pChannel.publishLowStream(this._lowStreamParameter), n = (await e.next()).value; if (n) { var t; let i; try { i = await this._gateway.publish(this._uid, n, !0) } catch (t) { if (t.code !== Oh.DISCONNECT_P2P) throw e.throw(t), t } e.next((null === (t = i) || void 0 === t ? void 0 : t.ortc) || []), this._p2pChannel.reportPublishEvent(!0, null, void 0, !0) } } catch (e) { if (this._p2pChannel.reportPublishEvent(!1, null == e ? void 0 : e.code, void 0, !0), (null == e ? void 0 : e.code) === Oh.WS_ABORT) return; throw e } } _createLiveStreamingClient(e) { if (!this._joinInfo || !this._appId) return new Ch(Oh.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw(); const t = () => new mI(this._joinInfo, this._config.websocketRetryConfig || Ah, this._config.httpRetryConfig || Ah), n = e => { e.onLiveStreamError = (e, t) => { wA.reportApiInvoke(this._sessionId, { name: RT.ON_LIVE_STREAM_ERROR, options: [e, t], tag: hT.TRACER }).onSuccess(), this.safeEmit(fT.LIVE_STREAMING_ERROR, e, t) }, e.onLiveStreamWarning = (e, t) => { wA.reportApiInvoke(this._sessionId, { name: RT.ON_LIVE_STREAM_WARNING, options: [e, t], tag: hT.TRACER }).onSuccess(), this.safeEmit(fT.LIVE_STREAMING_WARNING, e, t) }, e.on($T.REQUEST_WORKER_MANAGER_LIST, ((e, t, n) => { if (!this._joinInfo) return n(new Ch(Oh.INVALID_OPERATION, "can not find join info to get worker manager")); uI(e, this._joinInfo, this._axiosCancelSource.token, Ah).then(t).catch(n) })) }; switch (e) { case WT.RAW: return this._liveRawStreamingClient || (this._liveRawStreamingClient = t(), n(this._liveRawStreamingClient)), this._liveRawStreamingClient; case WT.TRANSCODE: return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = t(), n(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient; case WT.INJECT: return this._injectStreamingClient || (this._injectStreamingClient = t(), this._injectStreamingClient.on($T.REQUEST_WORKER_MANAGER_LIST, ((e, t, n) => { if (!this._joinInfo) return n(new Ch(Oh.INVALID_OPERATION, "can not find join info to get worker manager")); uI(e, this._joinInfo, this._axiosCancelSource.token, Ah).then(t).catch(n) })), this._injectStreamingClient.onInjectStatusChange = (e, t, n) => { this.emit(fT.INJECT_STREAM_STATUS, e, t, n) }), this._injectStreamingClient } } _createChannelMediaRelayClient() { if (!this._joinInfo) return new Ch(Oh.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw(); if (!this._channelMediaRelayClient) { const { sendResolutionWidth: e, sendResolutionHeight: t } = this.getLocalVideoStats(), n = { width: e, height: t }; this._channelMediaRelayClient = new NI(this._joinInfo, this._clientId, this._config.websocketRetryConfig || Ah, this._config.httpRetryConfig || Ah, n), this._channelMediaRelayClient.on("state", (e => { e === rO.RELAY_STATE_FAILURE && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose(), this.safeEmit(fT.CHANNEL_MEDIA_RELAY_STATE, e) })), this._channelMediaRelayClient.on("event", (e => { this.safeEmit(fT.CHANNEL_MEDIA_RELAY_EVENT, e) })), this._statsCollector.onStatsChanged = (e, t) => { var n; "resolution" === e && (null === (n = this._channelMediaRelayClient) || void 0 === n || n.setVideoProfile(t)) } } return this._channelMediaRelayClient } _handleGatewayEvents() { this._gateway.on(aO.DISCONNECT_P2P, (async () => { await this._p2pChannel.disconnectForReconnect() })), this._gateway.on(aO.CONNECTION_STATE_CHANGE, ((e, t, n) => { var i; if (n === IT.FALLBACK) return; const r = () => { this.safeEmit(fT.CONNECTION_STATE_CHANGE, e, t, n) }; if (wA.reportApiInvoke(this._sessionId || (null === (i = this._gateway.joinInfo) || void 0 === i ? void 0 : i.sid) || null, { name: RT.CONNECTION_STATE_CHANGE, options: [e, t, n], tag: hT.TRACER }).onSuccess(JSON.stringify({ cur: e, prev: t, reason: n })), Dh.info("[".concat(this._clientId, "] connection state change: ").concat(t, " -> ").concat(e)), "DISCONNECTED" === e) return this._reset(), void r(); if ("RECONNECTING" === e) this._users.forEach((e => { e._trust_in_room_ = !1, e._trust_audio_enabled_state_ = !1, e._trust_video_enabled_state_ = !1, e._trust_audio_mute_state_ = !1, e._trust_video_mute_state_ = !1, e._trust_audio_stream_added_state_ = !1, e._trust_video_stream_added_state_ = !1, e._audioSSRC = void 0, e._videoSSRC = void 0, e._videoOrtc = void 0, e._audioOrtc = void 0, e._cname = void 0, e._rtxSsrcId = void 0 })), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0; else if ("CONNECTED" === e) { var o; this._streamFallbackTypeCacheMap.forEach(((e, t) => { this._gateway.setStreamFallbackOption(t, e).catch((e => { Dh.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e) })) })), this._remoteStreamTypeCacheMap.forEach(((e, t) => { this._gateway.setRemoteVideoStreamType(t, e).catch((e => { Dh.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e) })) })), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o = this._joinInfo) || void 0 === o ? void 0 : o.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then((() => { Dh.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected")) })).catch((e => { Dh.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e)) })), this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout((() => { "CONNECTED" === this.connectionState && (this._userOfflineTimeout = void 0, this._users.filter((e => !e._trust_in_room_)).forEach((e => { Dh.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e.uid)), this._handleUserOffline({ uid: e.uid }) }))) }), 3e3), this._streamRemovedTimeout = window.setTimeout((() => { "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach((e => { e._trust_audio_mute_state_ || (Dh.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e.uid)), this._handleMuteStream(e.uid, "audio", !1)), e._trust_video_mute_state_ || (Dh.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e.uid)), this._handleMuteStream(e.uid, "video", !1)), e._trust_audio_enabled_state_ || (Dh.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e.uid)), this._handleSetStreamLocalEnable("audio", e.uid, !0)), e._trust_video_enabled_state_ || (Dh.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e.uid)), this._handleSetStreamLocalEnable("video", e.uid, !0)), e._trust_video_stream_added_state_ || (Dh.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e.uid)), this._handleResetAddStream(e, "video")), e._trust_audio_stream_added_state_ || (Dh.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e.uid)), this._handleResetAddStream(e, "audio")), e._video_added_ || e._audio_added_ || (Dh.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e.uid)), this._handleRemoveStream({ uid: e.uid, uint_id: e._uintid })) }))) }), 1e3) } r() })), this._gateway.on(aO.REQUEST_NEW_GATEWAY_LIST, ((e, t) => { if (!this._joinInfo) return t(new Ch(Oh.UNEXPECTED_ERROR, "can not recover, no join info")); aI(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || Ah, this.store).then((t => { this._joinInfo && (this._joinInfo.apResponse = t.gatewayInfo.res, this._joinInfo.gatewayAddrs = t.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t.gatewayInfo.uni_lbs_ip), e(t.gatewayInfo.gatewayAddrs.map((e => { if (this._joinInfo && this._joinInfo.proxyServer) { const t = e.address.split(":"); return "wss://".concat(this._joinInfo.proxyServer, "/ws/?h=").concat(t[0], "&p=").concat(t[1]) } return "wss://".concat(e.address) }))) })).catch(t) })), this._gateway.on(aO.NETWORK_QUALITY, (e => { "normal" === this._networkQualitySensitivity && this.safeEmit(fT.NETWORK_QUALITY, e) })), this._gateway.on(aO.STREAM_TYPE_CHANGE, ((e, t) => { this.safeEmit(fT.STREAM_TYPE_CHANGED, e, t), wA.reportApiInvoke(this._sessionId, { name: RT.STREAM_TYPE_CHANGE, options: [e, t], tag: hT.TRACER }).onSuccess(JSON.stringify({ uid: e, streamType: t })) })), this._gateway.on(aO.IS_P2P_DISCONNECTED, (e => { this._p2pChannel.isP2PDisconnected() ? e(!0) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e(!1) : e(!0) })), this._gateway.on(aO.NEED_RENEW_SESSION, (() => { this._startSession() })), this._gateway.on(aO.REQUEST_P2P_CONNECTION_PARAMS, (async (e, t, n) => { try { t(await this._p2pChannel.startP2PConnection(e)) } catch (e) { n(e) } })), this._gateway.on(aO.JOIN_RESPONSE, ((e, t) => { const { dtlsParameters: n, iceParameters: i, candidates: r, rtpCapabilities: o, setup: s, cname: a } = jN(e.ortc, t); this._p2pChannel.connect(i, n, r, o, s, a) })), this._gateway.on(aO.REQUEST_DC_CONNECTION_PARAMS, (e => { e(this._p2pChannel.getEstablishParams()) })), this._gateway.on(aO.RESET_SIGNAL, (e => { this._p2pChannel.resetConnection(e), this._handleGatewaySignalEvents() })), this._gateway.on(aO.DATACHANNEL_FAILBACK, (() => { this._joinGateway() })), this._gateway.on(aO.DATACHANNEL_PRECONNECT, (async (e, t, n, i) => { var r, o, s, a, c, E; await this._p2pChannel.startP2PConnection({ turnServer: null === (r = this._joinInfo) || void 0 === r ? void 0 : r.turnServer }, !0); const _ = function (e, t) { let n; return t && t.ip && "number" == typeof t.port ? (n = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t.ip, port: t.port.toString(), type: "host", extension: {} }], Dh.debug("Using remote candidate from AP ".concat(t.ip, ":").concat(t.port)), t.ip6 && (n.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t.ip6, port: t.port.toString(), type: "host", extension: {} }), Dh.debug("Using IPV6 remote candidate from AP ".concat(t.ip6, ":").concat(t.port)))) : n = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e.ip, port: e.port.toString(), type: "host", extension: {} }], n }(e, t); return this._p2pChannel.preConnect({ iceUfrag: "".concat(null === (o = this._joinInfo) || void 0 === o ? void 0 : o.apResponse.cid, "_").concat(null === (s = this._joinInfo) || void 0 === s ? void 0 : s.apResponse.cert), icePwd: "".concat(null === (a = this._joinInfo) || void 0 === a ? void 0 : a.apResponse.cid, "_").concat(null === (c = this._joinInfo) || void 0 === c ? void 0 : c.apResponse.cert) }, { fingerprints: [{ hashFunction: "sha-256", fingerprint: null !== (E = jh("FINGERPRINT")) && void 0 !== E ? E : e.fingerprint }] }, _, { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, "active", "o/i14u9pJrxRKAsu").then(n).catch(i) })) } _handleGatewaySignalEvents() { this._gateway.signal.on(LT.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(LT.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(LT.ON_ADD_AUDIO_STREAM, (e => this._handleAddAudioOrVideoStream("audio", e.uid, e.ssrcId, e.cname, e.uint_id, e.ortc))), this._gateway.signal.on(LT.ON_ADD_VIDEO_STREAM, (e => this._handleAddAudioOrVideoStream("video", e.uid, e.ssrcId, e.cname, e.uint_id, e.ortc, e.rtxSsrcId))), this._gateway.signal.on(LT.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(LT.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(LT.MUTE_AUDIO, (e => this._handleMuteStream(e.uid, "audio", !0))), this._gateway.signal.on(LT.UNMUTE_AUDIO, (e => this._handleMuteStream(e.uid, "audio", !1))), this._gateway.signal.on(LT.MUTE_VIDEO, (e => this._handleMuteStream(e.uid, "video", !0))), this._gateway.signal.on(LT.UNMUTE_VIDEO, (e => this._handleMuteStream(e.uid, "video", !1))), this._gateway.signal.on(LT.RECEIVE_METADATA, (e => { const t = lm(e.metadata); this.safeEmit(fT.RECEIVE_METADATA, e.uid, t) })), this._gateway.signal.on(LT.ON_DATA_STREAM, (e => { e.seq && delete e.seq, e.payload = lm(e.payload), this.safeEmit(fT.STREAM_MESSAGE, e.uid, e.payload), this.onStreamMessage && this.onStreamMessage(e) })), this._gateway.signal.on(LT.ON_CRYPT_ERROR, (() => { um((() => { Dh.warning("[".concat(this._clientId, "] on crypt error")), this.safeEmit(fT.CRYPT_ERROR) }), this._sessionId) })), this._gateway.signal.on(LT.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(LT.ON_TOKEN_PRIVILEGE_DID_EXPIRE, (() => { Dh.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(!0), this.safeEmit(fT.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset() })), this._gateway.signal.on(LT.ON_STREAM_FALLBACK_UPDATE, (e => { Dh.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e.stream_id, ", attr: ").concat(e.stream_type)), this.safeEmit(fT.STREAM_FALLBACK, e.stream_id, 1 === e.stream_type ? "fallback" : "recover") })), this._gateway.signal.on(LT.ON_PUBLISH_STREAM, (e => { this.uid === this._uid && (this._p2pChannel.reportPublishEvent(!0, null, void 0, !1, JSON.stringify({ proxy: e.proxy })), Dh.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e)))) })), this._gateway.signal.on(LT.ENABLE_LOCAL_VIDEO, (e => { this._handleSetStreamLocalEnable("video", e.uid, !0) })), this._gateway.signal.on(LT.DISABLE_LOCAL_VIDEO, (e => { this._handleSetStreamLocalEnable("video", e.uid, !1) })), this._gateway.signal.on(DT.REQUEST_TIMEOUT, ((e, t) => { if (this._joinInfo) switch (e) { case vT.PUBLISH: { if (!t) return; const e = t.ortc; if (e) { var n, i, r, o; const s = e.some((e => { let { stream_type: t } = e; return t === sO.Audio })), a = e.some((e => { let { stream_type: t } = e; return t !== sO.Audio })), c = e.some((e => { let { stream_type: t } = e; return t === sO.Screen || t === sO.ScreenLow })); "offer" === t.state && wA.publish(this._joinInfo.sid, { eventElapse: Lg.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: !1, ec: Oh.TIMEOUT, audio: s, video: a, p2pid: t.p2p_id, publishRequestid: this.store.pubId, screenshare: c, audioName: s ? null === (n = e.find((e => { let { stream_type: t } = e; return t === sO.Audio }))) || void 0 === n || null === (i = n.ssrcs[0]) || void 0 === i ? void 0 : i.ssrcId.toString() : void 0, videoName: a ? null === (r = e.find((e => { let { stream_type: t } = e; return t !== sO.Audio }))) || void 0 === r || null === (o = r.ssrcs[0]) || void 0 === o ? void 0 : o.ssrcId.toString() : void 0 }) } break } case vT.SUBSCRIBE: t && wA.subscribe(this._joinInfo.sid, { succ: !1, ec: Oh.TIMEOUT, audio: t.stream_type === PO.AUDIO, video: t.stream_type === PO.VIDEO, peerid: t.stream_id, subscribeRequestid: t.ssrcId, p2pid: this.store.p2pId, eventElapse: Lg.measureFromSubscribeStart(this.store.clientId, t.ssrcId) }) } })), this._gateway.signal.on(LT.ON_P2P_OK, (e => { this.uid, this._uid })), this._gateway.signal.on(LT.ON_PUBLISHED_USER_LIST, (e => { if (null == e || !e.users) return; jh("BLOCK_LOCAL_CLIENT") && (e.users = e.users.filter((e => !$h(e.audio_ssrc, this.channelName)))); const t = [], n = []; for (const i of e.users) { let e = this._users.find((e => e.uid === i.stream_id)); e ? e._trust_in_room_ = !0 : (e = new Pf(i.stream_id, i.stream_id), this._users.push(e), 0 === this.getListeners(fT.PUBLISHED_USER_LIST).length && (Dh.debug("[".concat(this._clientId, "] user online"), i.stream_id), this.safeEmit(fT.USER_JOINED, e))); const r = cO.Audio & i.stream_type, o = (cO.Video | cO.LwoVideo) & i.stream_type, s = r && e.hasAudio, a = o && e.hasVideo; o && (e._trust_video_stream_added_state_ = !0, e._video_added_ = !0, e._videoSSRC = i.video_ssrc, e._rtxSsrcId = i.video_rtx), r && (e._trust_audio_stream_added_state_ = !0, e._audio_added_ = !0, e._audioSSRC = i.audio_ssrc), r && !s && 0 === this.getListeners(fT.PUBLISHED_USER_LIST).length && (Dh.info("[".concat(this._clientId, "] remote user ").concat(e.uid, " published audio")), this.safeEmit(fT.USER_PUBLISHED, e, "audio")), o && !a && 0 === this.getListeners(fT.PUBLISHED_USER_LIST).length && (Dh.info("[".concat(this._clientId, "] remote user ").concat(e.uid, " published video")), this.safeEmit(fT.USER_PUBLISHED, e, "video")), (r && !s || o && !a) && t.push(e), o && this._p2pChannel.hasPendingRemoteMedia(e, "video") && n.push({ user: e, mediaType: "video" }), r && this._p2pChannel.hasPendingRemoteMedia(e, "audio") && n.push({ user: e, mediaType: "audio" }) } n.length > 0 && (Dh.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(n.map((e => "user: ".concat(e.user.uid, ", mediaType: ").concat(e.mediaType))).join("; "), " ")), this.massSubscribe(n).catch((e => { Dh.error("[".concat(this._clientId, "] mass resubscribe error"), e.toString()) }))), this.getListeners(fT.PUBLISHED_USER_LIST).length > 0 ? (Dh.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t.map((e => e.uid)).join(", "))), this.safeEmit(fT.PUBLISHED_USER_LIST, t)) : Dh.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t.map((e => e.uid)).join(", "))) })) } _handleP2PChannelEvents() { this._p2pChannel.on(LO.RequestMuteLocal, (async (e, t, n) => { if (this._joinInfo) try { await this._gateway.muteLocal(e, this._joinInfo.stringUid || this._joinInfo.uid), t() } catch (e) { e.code === Oh.DISCONNECT_P2P ? t() : n(e) } else t() })), this._p2pChannel.on(LO.RequestUnmuteLocal, (async (e, t, n) => { if (this._joinInfo) try { await this._gateway.unmuteLocal(e, this._joinInfo.stringUid || this._joinInfo.uid), t() } catch (e) { e.code === Oh.DISCONNECT_P2P ? t() : n(e) } else t() })), this._p2pChannel.on(LO.RequestRePublish, ((e, t, n) => { this.publish(e, !1).then(t).catch(n) })), this._p2pChannel.on(LO.RequestReSubscribe, (async (e, t, n) => { try { for (const { user: t, kind: n } of e) n === PO.VIDEO ? await this.subscribe(t, "video") : await this.subscribe(t, "audio"); t() } catch (e) { n(e) } })), this._p2pChannel.on(LO.RequestUploadStats, ((e, t) => { this._gateway.uploadStats(e, t) })), this._p2pChannel.on(LO.MediaReconnectStart, (e => { this.safeEmit(fT.MEDIA_RECONNECT_START, e) })), this._p2pChannel.on(LO.MediaReconnectEnd, (e => { this.safeEmit(fT.MEDIA_RECONNECT_END, e) })), this._p2pChannel.on(LO.NeedSignalRTT, (e => { e(this._gateway.getSignalRTT()) })), this._p2pChannel.on(LO.RequestRestartICE, (async e => { const t = await this._p2pChannel.restartICE(e), n = await t.next(); if (n.done) return; const i = n.value; let r; try { r = await this._gateway.restartICE({ iceParameters: i }) } catch (e) { return void t.throw(e) } const { iceParameters: o } = function (e) { const t = e.iceParameters; return { iceParameters: { iceUfrag: t.iceUfrag, icePwd: t.icePwd } } }(r); await t.next({ remoteIceParameters: o }) })), this._p2pChannel.on(LO.RequestReconnect, (async () => { this._gateway.reconnect() })), this._p2pChannel.on(LO.RequestReconnectPC, (async () => { var e; const { iceParameters: t, dtlsParameters: n, rtpCapabilities: i } = await this._p2pChannel.startP2PConnection({ turnServer: null === (e = this._joinInfo) || void 0 === e ? void 0 : e.turnServer }), { gatewayEstablishParams: r, gatewayAddress: o } = await this._gateway.reconnectPC({ iceParameters: t, dtlsParameters: n, rtpCapabilities: i }), { dtlsParameters: s, iceParameters: a, candidates: c, rtpCapabilities: E, setup: _, cname: d } = jN(r, o); await this._p2pChannel.connect(a, s, c, E, _, d), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe() })), this._p2pChannel.on(LO.RequestUnpublishForReconnectPC, (async (e, t, n) => { this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e, this._uid), t()) : n() })), this._p2pChannel.on(LO.P2PLost, (() => { this.safeEmit(fT.P2P_LOST, this.store.uid) })), this._p2pChannel.on(LO.UpdateVideoEncoder, (e => { e._encoderConfig && this._gateway.setVideoProfile(e._encoderConfig) })), this._p2pChannel.on(LO.ConnectionTypeChange, (e => { this.safeEmit(fT.IS_USING_CLOUD_PROXY, e) })), this._p2pChannel.on(LO.RequestLowStreamParameter, (e => { e(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 }) })), this._p2pChannel.on(LO.QueryClientConnectionState, (e => { e(this.connectionState) })) } getKeyMetrics() { return this.store.keyMetrics } async enableContentInspect(e) { if ("CONNECTED" !== this.connectionState || !this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "[".concat(this._clientId, "] Client did not join channel")); if (this._inspect) throw new Ch(Oh.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state")); if (!e) throw new Ch(Oh.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig is necessary")); if (!e.inspectType || !Array.isArray(e.inspectType)) throw new Ch(Oh.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.inspectType is necessary and is an instance of Array.")); { const t = [...new Set(e.inspectType)]; t.forEach((e => { if (!["supervise", "moderation"].includes(e)) throw new Ch(Oh.INVALID_PARAMS, "[".concat(this._clientId, "] ").concat(e, " is not a valid inspect type.")) })), e.inspectType = t } if (e && e.extraInfo && e.extraInfo.length > 1024) throw new Ch(Oh.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.extraInfo length cannot exceed 1024 bytes")); try { const t = new py(e); this._inspect = t, this.handleVideoInspectEvents(this._inspect), await t.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, Ah) } catch (e) { throw Array.isArray(e) ? e[0] : e } } async disableContentInspect() { if (!this._inspect) throw new Ch(Oh.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started")); try { this._inspect.close(), this._inspect = void 0 } catch (e) { throw Array.isArray(e) ? e[0] : e } } async setImageModeration(e, t) { if (Kp(e, "enabled"), e) { if (!t) throw new Ch(Oh.INVALID_PARAMS, "[".concat(this._clientId, "] config is necessary")); if (Xp(t.interval, "interval", 1e3, 1 / 0), "CONNECTED" !== this.connectionState || !this._joinInfo) throw new Ch(Oh.INVALID_OPERATION, "[".concat(this._clientId, '] can not enable image moderation, not joined"')); try { if (this._moderation) return void this._moderation.updateConfig(t); const e = new qy(t); this._moderation = e, this.handleImageModerationEvents(this._moderation), await e.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, Ah) } catch (e) { throw Array.isArray(e) ? e[0] : e } } else { if (!this._moderation) throw new Ch(Oh.INVALID_OPERATION, "[".concat(this._clientId, "] image moderation not started")); try { this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0 } catch (e) { throw Array.isArray(e) ? e[0] : e } } } handleImageModerationEvents(e) { e.on(HO.CONNECTION_STATE_CHANGE, ((t, n) => { if (this.emit(fT.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t, n), t === jO.CONNECTED) { if ("CONNECTED" !== this.connectionState) throw this.setImageModeration(!1), new Ch(Oh.OPERATION_ABORTED, "Image moderation was cancelled because it left the channel"); e.inspectImage() } })), e.on(HO.CLIENT_LOCAL_VIDEO_TRACK, (e => { e(this.localTracks.filter((e => "video" === e.trackMediaType))[0]) })) } handleVideoInspectEvents(e) { e.on(xO.CONNECTION_STATE_CHANGE, ((t, n) => { if (this.emit(fT.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t, n), n === kO.CONNECTED) { if ("CONNECTED" !== this.connectionState) return void this.emit(fT.CONTENT_INSPECT_ERROR, new Ch(Oh.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel")); e.inspectImage() } })), e.on(xO.INSPECT_RESULT, ((e, t) => { var n; if ((null == t ? void 0 : t.code) === Oh.INVALID_OPERATION && "DISCONNECTED" === this.connectionState) return Dh.debug("Stop inspect content because that has left channel"), null == this || null === (n = this._inspect) || void 0 === n || n.close(), void (this._inspect = void 0); this.emit(fT.CONTENT_INSPECT_RESULT, e, t) })), e.on(xO.CLIENT_LOCAL_VIDEO_TRACK, (e => { e(this.localTracks.filter((e => "video" === e.trackMediaType))[0]) })) } getJoinChannelServiceRecords() { return Dh.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords } async setPublishAudioFilterEnabled(e) { Kp(e, "enabled"), Gh("ENABLE_PUBLISH_AUDIO_FILTER", e), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e) } _handleResetAddStream(e, t) { switch (t) { case "audio": e._audio_added_ = !1, e._trust_audio_stream_added_state_ = !0; break; case "video": e._video_added_ = !1, e._trust_video_stream_added_state_ = !0 } } }).prototype, "leave", [Qy], Object.getOwnPropertyDescriptor(ML.prototype, "leave"), ML.prototype), aA(ML.prototype, "publish", [zy], Object.getOwnPropertyDescriptor(ML.prototype, "publish"), ML.prototype), aA(ML.prototype, "unpublish", [Zy], Object.getOwnPropertyDescriptor(ML.prototype, "unpublish"), ML.prototype), aA(ML.prototype, "subscribe", [$y], Object.getOwnPropertyDescriptor(ML.prototype, "subscribe"), ML.prototype), aA(ML.prototype, "massSubscribe", [eL], Object.getOwnPropertyDescriptor(ML.prototype, "massSubscribe"), ML.prototype), aA(ML.prototype, "unsubscribe", [tL], Object.getOwnPropertyDescriptor(ML.prototype, "unsubscribe"), ML.prototype), aA(ML.prototype, "massUnsubscribe", [nL], Object.getOwnPropertyDescriptor(ML.prototype, "massUnsubscribe"), ML.prototype), aA(ML.prototype, "setLowStreamParameter", [iL], Object.getOwnPropertyDescriptor(ML.prototype, "setLowStreamParameter"), ML.prototype), aA(ML.prototype, "enableDualStream", [rL], Object.getOwnPropertyDescriptor(ML.prototype, "enableDualStream"), ML.prototype), aA(ML.prototype, "disableDualStream", [oL], Object.getOwnPropertyDescriptor(ML.prototype, "disableDualStream"), ML.prototype), aA(ML.prototype, "setClientRole", [sL], Object.getOwnPropertyDescriptor(ML.prototype, "setClientRole"), ML.prototype), aA(ML.prototype, "setProxyServer", [aL], Object.getOwnPropertyDescriptor(ML.prototype, "setProxyServer"), ML.prototype), aA(ML.prototype, "setTurnServer", [cL], Object.getOwnPropertyDescriptor(ML.prototype, "setTurnServer"), ML.prototype), aA(ML.prototype, "setLicense", [EL], Object.getOwnPropertyDescriptor(ML.prototype, "setLicense"), ML.prototype), aA(ML.prototype, "startProxyServer", [_L], Object.getOwnPropertyDescriptor(ML.prototype, "startProxyServer"), ML.prototype), aA(ML.prototype, "stopProxyServer", [dL], Object.getOwnPropertyDescriptor(ML.prototype, "stopProxyServer"), ML.prototype), aA(ML.prototype, "setLocalAccessPointsV2", [uL], Object.getOwnPropertyDescriptor(ML.prototype, "setLocalAccessPointsV2"), ML.prototype), aA(ML.prototype, "setLocalAccessPoints", [lL], Object.getOwnPropertyDescriptor(ML.prototype, "setLocalAccessPoints"), ML.prototype), aA(ML.prototype, "setRemoteDefaultVideoStreamType", [RL], Object.getOwnPropertyDescriptor(ML.prototype, "setRemoteDefaultVideoStreamType"), ML.prototype), aA(ML.prototype, "setRemoteVideoStreamType", [hL], Object.getOwnPropertyDescriptor(ML.prototype, "setRemoteVideoStreamType"), ML.prototype), aA(ML.prototype, "setStreamFallbackOption", [pL], Object.getOwnPropertyDescriptor(ML.prototype, "setStreamFallbackOption"), ML.prototype), aA(ML.prototype, "setEncryptionConfig", [TL], Object.getOwnPropertyDescriptor(ML.prototype, "setEncryptionConfig"), ML.prototype), aA(ML.prototype, "renewToken", [OL], Object.getOwnPropertyDescriptor(ML.prototype, "renewToken"), ML.prototype), aA(ML.prototype, "enableAudioVolumeIndicator", [CL], Object.getOwnPropertyDescriptor(ML.prototype, "enableAudioVolumeIndicator"), ML.prototype), aA(ML.prototype, "startLiveStreaming", [AL], Object.getOwnPropertyDescriptor(ML.prototype, "startLiveStreaming"), ML.prototype), aA(ML.prototype, "setLiveTranscoding", [SL], Object.getOwnPropertyDescriptor(ML.prototype, "setLiveTranscoding"), ML.prototype), aA(ML.prototype, "stopLiveStreaming", [gL], Object.getOwnPropertyDescriptor(ML.prototype, "stopLiveStreaming"), ML.prototype), aA(ML.prototype, "addInjectStreamUrl", [mL], Object.getOwnPropertyDescriptor(ML.prototype, "addInjectStreamUrl"), ML.prototype), aA(ML.prototype, "removeInjectStreamUrl", [IL], Object.getOwnPropertyDescriptor(ML.prototype, "removeInjectStreamUrl"), ML.prototype), aA(ML.prototype, "startChannelMediaRelay", [fL], Object.getOwnPropertyDescriptor(ML.prototype, "startChannelMediaRelay"), ML.prototype), aA(ML.prototype, "updateChannelMediaRelay", [PL], Object.getOwnPropertyDescriptor(ML.prototype, "updateChannelMediaRelay"), ML.prototype), aA(ML.prototype, "stopChannelMediaRelay", [NL], Object.getOwnPropertyDescriptor(ML.prototype, "stopChannelMediaRelay"), ML.prototype), aA(ML.prototype, "sendCustomReportMessage", [DL], Object.getOwnPropertyDescriptor(ML.prototype, "sendCustomReportMessage"), ML.prototype), aA(ML.prototype, "pickSVCLayer", [vL], Object.getOwnPropertyDescriptor(ML.prototype, "pickSVCLayer"), ML.prototype), aA(ML.prototype, "enableContentInspect", [yL], Object.getOwnPropertyDescriptor(ML.prototype, "enableContentInspect"), ML.prototype), aA(ML.prototype, "disableContentInspect", [LL], Object.getOwnPropertyDescriptor(ML.prototype, "disableContentInspect"), ML.prototype), aA(ML.prototype, "setImageModeration", [wL], Object.getOwnPropertyDescriptor(ML.prototype, "setImageModeration"), ML.prototype), aA(ML.prototype, "getJoinChannelServiceRecords", [bL], Object.getOwnPropertyDescriptor(ML.prototype, "getJoinChannelServiceRecords"), ML.prototype), aA(ML.prototype, "setPublishAudioFilterEnabled", [UL], Object.getOwnPropertyDescriptor(ML.prototype, "setPublishAudioFilterEnabled"), ML.prototype), ML); class FL extends QA { set currentState(e) { e !== this._currentState && (this._currentState = e, this.safeEmit(bT.AUDIO_SOURCE_STATE_CHANGE, this._currentState)) } get currentState() { return this._currentState } constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; super(), hl(this, "audioBuffer", void 0), hl(this, "sourceNode", void 0), hl(this, "startPlayTime", 0), hl(this, "startPlayOffset", 0), hl(this, "pausePlayTime", 0), hl(this, "options", void 0), hl(this, "currentLoopCount", 0), hl(this, "currentPlaybackSpeed", 100), hl(this, "_currentState", "stopped"), this.audioBuffer = e, this.options = t, this.startPlayOffset = this.options.startPlayTime || 0 } createWebAudioDiagram() { return this.context.createGain() } get duration() { return this.audioBuffer.duration } get playbackSpeed() { return this.currentPlaybackSpeed } get currentTime() { return "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration } updateOptions(e) { "stopped" === this.currentState ? (this.options = e, this.startPlayOffset = this.options.startPlayTime || 0) : Dh.warning("can not set audio source options") } startProcessAudioBuffer() { this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing" } pauseProcessAudioBuffer() { this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused") } seekAudioBuffer(e) { this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e)) } resumeProcessAudioBuffer() { "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing") } stopProcessAudioBuffer() { if (this.sourceNode) { this.sourceNode.onended = null; try { this.sourceNode.stop() } catch (e) { } this.reset() } } setAudioBufferPlaybackSpeed(e) { this.sourceNode && ("playing" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e / 100), this.currentPlaybackSpeed = e } startSourceNode() { this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this)) } createSourceNode() { const e = this.context.createBufferSource(); return e.buffer = this.audioBuffer, e.loop = !!this.options.loop, e.connect(this.outputNode), e.playbackRate.value = this.currentPlaybackSpeed / 100, e } handleSourceNodeEnded() { if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer(); this.reset() } reset() { this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0 } } const YL = new Map; async function BL(e, t) { let n = null; if ("string" == typeof e) { const t = YL.get(e); if (t) return Dh.debug("use cached audio resource: ", e), t; try { n = (await gh((() => Rh.get(e, { responseType: "arraybuffer" })), void 0, void 0, { maxRetryCount: 3 })).data } catch (e) { throw new Ch(Oh.FETCH_AUDIO_FILE_FAILED, e.toString()) } } else { const t = new Cd(((t, n) => { const i = new FileReader; i.onload = e => { e.target ? t(e.target.result) : n(new Ch(Oh.READ_LOCAL_AUDIO_FILE_ERROR)) }, i.onerror = () => { n(new Ch(Oh.READ_LOCAL_AUDIO_FILE_ERROR)) }, i.readAsArrayBuffer(e) })); n = await t } const i = await function (e) { const t = HA(); return new Cd(((n, i) => { t.decodeAudioData(e, (e => { n(e) }), (e => { i(new Ch(Oh.DECODE_AUDIO_FILE_FAILED, e.toString())) })) })) }(n); return "string" == typeof e && t && YL.set(e, i), i } function GL(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function jL(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? GL(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GL(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function HL(e, t, n, i) { n.optimizationMode && (i && i.width && i.height ? (n.encoderConfig = jL(jL({}, i), {}, { bitrateMin: i.bitrateMin, bitrateMax: i.bitrateMax }), "motion" !== n.optimizationMode && "detail" !== n.optimizationMode || (t.contentHint = n.optimizationMode, t.contentHint === n.optimizationMode ? Dh.debug("[".concat(e, "] set content hint to"), n.optimizationMode) : Dh.debug("[".concat(e, "] set content hint failed")))) : Dh.warning("[".concat(e, "] can not apply optimization mode bitrate config, no encoderConfig"))) } const WL = xu().name; function KL(e, t, n, i) { let r, o = 0, s = null; return new Cd(((a, c) => { setTimeout((() => { r && (r(), a(o)) }), t), r = XA((() => { !function () { o > i && r && (r(), a(o)); const t = n.getContext("2d"); if (!t) { const e = new Ch(Oh.UNEXPECTED_ERROR, "can not get canvas 2d context."); return Dh.error(e.toString()), void c(e) } t.drawImage(e, 0, 0, 160, 120); const E = t.getImageData(0, 0, n.width, n.height), _ = Math.floor(E.data.length / 3); if (s) { for (let e = 0; e < _; e += 3)if (E.data[e] !== s[e]) return o += 1, void (s = E.data); s = E.data } else s = E.data }() }), 30) })) } class JL { constructor(e, t) { hl(this, "id", 0), hl(this, "element", void 0), hl(this, "peerPair", void 0), hl(this, "context", void 0), hl(this, "audioPlayerElement", void 0), hl(this, "audioTrack", void 0), JL.count += 1, this.id = JL.count, this.element = e, this.context = t } initPeers() { this.peerPair = [new RTCPeerConnection, new RTCPeerConnection], this.peerPair[1].ontrack = e => { const t = document.createElement("audio"); t.srcObject = new MediaStream([e.track]), t.play(), this.audioPlayerElement = t } } async switchSdp() { if (!this.peerPair) return; const e = async (e, t) => { const n = "offer" === t ? await e.createOffer() : await e.createAnswer(); return await e.setLocalDescription(n), "complete" === e.iceGatheringState ? e.localDescription : new Cd((t => { e.onicegatheringstatechange = () => { "complete" === e.iceGatheringState && t(e.localDescription) } })) }, t = async (e, t) => await e.setRemoteDescription(t); try { const n = await e(this.peerPair[0], "offer"); await t(this.peerPair[1], n); const i = await e(this.peerPair[1], "answer"); await t(this.peerPair[0], i) } catch (e) { throw new Ch(Oh.LOCAL_AEC_ERROR, e.toString()).print() } } async getTracksFromMediaElement(e) { if (this.audioTrack) return this.audioTrack; let t; try { e instanceof HTMLVideoElement && (e.captureStream ? e.captureStream() : e.mozCaptureStream()), t = this.context.createMediaStreamDestination(), this.context.createMediaElementSource(e).connect(t) } catch (e) { throw new Ch(Oh.LOCAL_AEC_ERROR, e.toString()).print() } if (!t) throw new Ch(Oh.LOCAL_AEC_ERROR, "no dest node when local aec").print(); const n = t.stream.getAudioTracks()[0]; return this.audioTrack = n, n } getElement() { return this.element } async startEchoCancellation() { this.context.resume(), this.peerPair && this.close(), this.initPeers(); const e = this.element, t = await this.getTracksFromMediaElement(e); this.peerPair && this.peerPair[0].addTrack(t), await this.switchSdp() } close() { Dh.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e => { e.close() })), this.peerPair = void 0, this.audioPlayerElement = void 0 } } var XL, qL; hl(JL, "count", 0); const QL = window.AudioContext || window.webkitAudioContext, zL = new (XL = LA({ report: wA }), aA((qL = class { constructor() { hl(this, "units", []), hl(this, "context", void 0) } processExternalMediaAEC(e) { if (!this._doesEnvironmentNeedAEC()) return Dh.debug("the system does not need to process local aec"), -1; this.context || (this.context = new QL); let t = this.units.find((t => t && t.getElement() === e)); return t || (t = new JL(e, this.context), this.units.push(t)), t.startEchoCancellation(), Dh.debug("start processing local audio echo cancellation, id is", t.id), t.id } _doesEnvironmentNeedAEC() { return xu().name !== Lu.SAFARI } }).prototype, "processExternalMediaAEC", [XL], Object.getOwnPropertyDescriptor(qL.prototype, "processExternalMediaAEC"), qL.prototype), qL); function ZL(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function $L(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? ZL(Object(n), !0).forEach((function (t) { hl(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZL(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } const ew = window || document; function tw(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (!ew) return; const n = nw._cspEventHandlerPointer; if (n && t) return void console.error(n, t); const i = e => { if (!(e && e.blockedURI && (nw.onSecurityPolicyViolation || nw.getListeners(BO.SECURITY_POLICY_VIOLATION).length > 0))) return; const t = e.blockedURI; jh("CSP_DETECTED_HOSTNAME_LIST").some((e => t.includes(e))) && (nw.onSecurityPolicyViolation && "function" == typeof nw.onSecurityPolicyViolation && nw.onSecurityPolicyViolation(e), nw.getListeners(BO.SECURITY_POLICY_VIOLATION).length > 0 && nw.safeEmit(BO.SECURITY_POLICY_VIOLATION, e)) }; n && ew.removeEventListener("securitypolicyviolation", n), (t || e && "function" == typeof e || nw.getListeners(BO.SECURITY_POLICY_VIOLATION).length > 0) && ew.addEventListener("securitypolicyviolation", i), nw._cspEventHandlerPointer = i } Gh("PROCESS_ID", "process-".concat(Zg(8, ""), "-").concat(Zg(4, ""), "-").concat(Zg(4, ""), "-").concat(Zg(4, ""), "-").concat(Zg(12, ""))), function () { const e = xu(); JO.getDisplayMedia = !(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia), JO.getStreamFromExtension = e.name === Lu.CHROME && Number(e.version) > 34, JO.supportUnifiedPlan = function () { if (!window.RTCRtpTransceiver) return !1; if (!("currentDirection" in RTCRtpTransceiver.prototype)) return !1; const e = new RTCPeerConnection; let t = !1; try { e.addTransceiver("audio"), t = !0 } catch (e) { } return e.close(), t }(), JO.supportMinBitrate = e.name === Lu.CHROME || e.name === Lu.EDGE, JO.supportSetRtpSenderParameters = function () { const e = xu(); return !!(window.RTCRtpSender && window.RTCRtpSender.prototype.setParameters && window.RTCRtpSender.prototype.getParameters) && (!!ol() || !(!Wu() && !Bu()) || e.name === Lu.FIREFOX && Number(e.version) >= 64) }(), e.name === Lu.SAFARI && (Number(e.version) >= 14 ? JO.supportDualStream = !0 : JO.supportDualStream = !1), JO.webAudioMediaStreamDest = function () { const e = xu(); return !(e.name === Lu.SAFARI && Number(e.version) < 12) }(), JO.supportReplaceTrack = !!window.RTCRtpSender && "function" == typeof RTCRtpSender.prototype.replaceTrack, JO.supportWebGL = "undefined" != typeof WebGLRenderingContext, JO.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, ol() || (JO.webAudioWithAEC = !0), JO.supportShareAudio = function () { const e = xu(); return (e.os === yu.WIN_10 || e.os === yu.WIN_81 || e.os === yu.WIN_7 || e.os === yu.LINUX || e.os === yu.MAC_OS) && e.name === Lu.CHROME && Number(e.version) >= 74 }(), JO.supportDualStreamEncoding = function () { const e = xu(); return !!jh("DISABLE_WEBAUDIO") || "Safari" === e.name && Number(e.version) >= 14 || !!("Chrome" === e.name && /Windows/i.test(e.os || "") && Number(e.version) >= 100 && jh("CHROME_DUAL_STREAM_USE_ENCODING")) }(), JO.supportDataChannel = !!(Xu(76) || function (e) { const t = xu(); return !(t.name !== Lu.FIREFOX || !t.osVersion) && Number(t.version) >= e }(68) || function (e) { const t = xu(); return !(t.name !== Lu.SAFARI || !t.osVersion) && Number(t.version) >= e }(14)), JO.supportPCSetConfiguration = function () { const e = window.RTCPeerConnection; return !Ku() && !!e && e.prototype.setConfiguration instanceof Function }(), JO.supportWebRTCEncodedTransform = function () { const e = xu(); return "Chrome" === e.name && Number(e.version) >= 86 }(), Dh.info("browser compatibility", JSON.stringify(JO), JSON.stringify(e)) }(), function () { let e; try { e = window.localStorage.getItem("websdk_ng_global_parameter") } catch (e) { return void Dh.error("Error loading sdk config", e.message) } if (e) try { const t = JSON.parse(window.atob(e)), n = Date.now(); Dh.debug("Loading global parameters from cache", t), Object.keys(t).forEach((e => { if (Object.prototype.hasOwnProperty.call(Hh, e)) { const { value: i, expires: r } = t[e]; if (r && r <= n) return; Wh[e] = i, Hh[e] = i } })) } catch (t) { Dh.error("Error loading mutableParamsCache: ".concat(e), t.message) } }(), Array.isArray(Wh.AREAS) && Wh.AREAS.length > 0 && Jm(Wh.AREAS, !0); const nw = function (e) { const t = new ph, n = e, i = { getListeners: t.getListeners.bind(t), on: (e, n) => (function (e, t) { e === BO.SECURITY_POLICY_VIOLATION && tw(t, !0) }(e, n), t.on.bind(t)(e, n)), addListener: t.addListener.bind(t), once: t.once.bind(t), off: t.off.bind(t), removeAllListeners: t.removeAllListeners.bind(t), emit: t.emit.bind(t), safeEmit: t.safeEmit.bind(t) }; return $L($L({}, n), i) }({ __CLIENT_LIST__: zh, __TRACK_LIST__: Zh, VERSION: yh, BUILD: vh, setParameter: (e, t, n) => { Dh.debug("setParameter key:".concat(e, ", value:").concat(JSON.stringify(t))), Gh(e, t, n) }, getParameter: jh, getSupportedCodec: async function () { let e = { audio: [], video: [] }; try { let t = new RTCPeerConnection; t.addTransceiver("video", { direction: "recvonly" }), t.addTransceiver("audio", { direction: "recvonly" }); const n = (await t.createOffer()).sdp; if (!n) return e; t.close(), t = null, e = function (e) { const t = { video: [], audio: [] }; return e.match(/ VP8/i) && t.video.push("VP8"), e.match(/ VP9/i) && t.video.push("VP9"), e.match(/ AV1/i) && t.video.push("AV1"), e.match(/ H264/i) && t.video.push("H264"), e.match(/ H265/i) && t.video.push("H265"), e.match(/ opus/i) && t.audio.push("OPUS"), e.match(/ PCMU/i) && t.audio.push("PCMU"), e.match(/ PCMA/i) && t.audio.push("PCMA"), e.match(/ G722/i) && t.audio.push("G722"), t }(n) } catch (e) { throw new Ch(Oh.CREATE_OFFER_FAILED, e.toString && e.toString()).print() } return e }, checkSystemRequirements: function () { const e = wA.reportApiInvoke(null, { name: RT.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: hT.TRACER }); let t = !1; try { const e = window.RTCPeerConnection, n = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, i = window.WebSocket; t = !!(e && n && i) } catch (e) { return Dh.error("check system requirement failed: ", e), !1 } let n = !1; const i = xu(); i.name === Lu.CHROME && Number(i.version) >= 58 && (!ju() || Gu()) && (n = !0), i.name === Lu.FIREFOX && Number(i.version) >= 56 && (n = !0), i.name === Lu.OPERA && Number(i.version) >= 45 && (n = !0), i.name === Lu.SAFARI && Number(i.version) >= 11 && (n = !0), (il() || xu().name === Lu.QQ) && (n = !0), Dh.debug("checkSystemRequirements, api:", t, "browser", n); const r = t && n; return e.onSuccess(r), r }, getDevices: function (e) { return dS.enumerateDevices(!0, !0, e) }, getMicrophones: function (e) { return dS.getRecordingDevices(e) }, getCameras: function (e) { return dS.getCamerasDevices(e) }, getElectronScreenSources: eS, getPlaybackDevices: function (e) { return dS.getSpeakers(e) }, createClient: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" }; const t = wA.reportApiInvoke(null, { name: RT.CREATE_CLIENT, options: [e], tag: hT.TRACER }); try { MT(e) } catch (e) { throw t.onError(e), e } return void 0 === e.audioCodec && (e.audioCodec = "opus"), t.onSuccess(), new xL(VL(VL({ forceWaitGatewayResponse: !0 }, e), {}, { role: "rtc" === e.mode ? "host" : e.role || "audience" })) }, createCameraVideoTrack: async function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.CREATE_CAM_VIDEO_TRACK, options: [jL({}, e)] }), n = MI(e), i = Zg(8, "track-cam-"); let r = null; Dh.info("start create camera video track with config", JSON.stringify(e), "trackId", i); try { r = (await aS({ video: n }, i)).getVideoTracks()[0] || null } catch (e) { throw t.onError(e), e } if (!r) { const e = new Ch(Oh.UNEXPECTED_ERROR, "can not find track in media stream"); return t.onError(e), e.throw() } e.optimizationMode && HL(i, r, e, Vh(e.encoderConfig)); const o = new ff(r, e, n, e.scalabiltyMode ? Fh(e.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e.optimizationMode, i); return t.onSuccess(o.getTrackId()), Dh.info("create camera video success, trackId:", i), o }, createCustomVideoTrack: function (e) { const t = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.CREATE_CUSTOM_VIDEO_TRACK, options: [e] }), n = new If(e.mediaStreamTrack, { width: e.width, height: e.height, frameRate: e.frameRate, bitrateMax: e.bitrateMax, bitrateMin: e.bitrateMin }, e.scalabiltyMode ? Fh(e.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e.optimizationMode, Zg(8, "track-cus-"), [dO.CUSTOM_TRACK]); return t.onSuccess(n.getTrackId()), Dh.info("create custom video track success with config", e, "trackId", n.getTrackId()), n }, createScreenVideoTrack: async function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable"; const n = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.CREATE_SCREEN_VIDEO_TRACK, options: [jL({}, e), t] }); e.encoderConfig ? "string" == typeof e.encoderConfig || e.encoderConfig.width && e.encoderConfig.height || (e.encoderConfig.width = { max: 1920 }, e.encoderConfig.height = { max: 1080 }) : e.encoderConfig = "1080p_2"; const i = kI(e), r = Zg(8, "track-scr-v-"); let o = null, s = null; const a = XO(); if (!a.supportShareAudio && "enable" === t) { const e = new Ch(Oh.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio"); return n.onError(e), e.throw() } Dh.info("start create screen video track with config", e, "withAudio", t, "trackId", r); try { const e = await aS({ screen: i, screenAudio: "auto" === t ? a.supportShareAudio : "enable" === t }, r); o = e.getVideoTracks()[0] || null, s = e.getAudioTracks()[0] || null } catch (e) { throw n.onError(e), e } if (!o) { const e = new Ch(Oh.UNEXPECTED_ERROR, "can not find track in media stream"); return n.onError(e), e.throw() } if (!s && "enable" === t) { o && o.stop(); const e = new Ch(Oh.SHARE_AUDIO_NOT_ALLOWED); return n.onError(e), e.throw() } e.optimizationMode || (e.optimizationMode = "detail"), e.optimizationMode && (HL(r, o, e, e.encoderConfig && xh(e.encoderConfig)), e.encoderConfig && "string" != typeof e.encoderConfig && (e.encoderConfig.bitrateMin = e.encoderConfig.bitrateMax)); const c = new If(o, e.encoderConfig ? xh(e.encoderConfig) : {}, e.scalabiltyMode ? Fh(e.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e.optimizationMode, r, [dO.SCREEN_TRACK]); if (!s) return n.onSuccess(c.getTrackId()), Dh.info("create screen video track success", "video:", c.getTrackId()), c; const E = new fg(s, void 0, Zg(8, "track-scr-a-"), !1, !0); return n.onSuccess([c.getTrackId(), E.getTrackId()]), Dh.info("create screen video track success", "video:", c.getTrackId(), "audio:", E.getTrackId()), [c, E] }, createMicrophoneAndCameraTracks: async function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.CREATE_MIC_AND_CAM_TRACKS, options: [e, t] }), i = MI(t), r = VI(e), o = Zg(8, "track-mic-"), s = Zg(8, "track-cam-"); let a = null, c = null; Dh.info("start create camera video track(".concat(s, ") and microphone audio track(").concat(o, ") with config, audio: ").concat(JSON.stringify(e), ", video: ").concat(JSON.stringify(t))); try { const e = await aS({ audio: r, video: i }, "".concat(o, "-").concat(s)); a = e.getAudioTracks()[0], c = e.getVideoTracks()[0] } catch (e) { throw n.onError(e), e } if (!a || !c) { const e = new Ch(Oh.UNEXPECTED_ERROR, "can not find tracks in media stream"); return n.onError(e), e.throw() } t.optimizationMode && HL(s, c, t, Vh(t.encoderConfig)); const E = new Pg(a, e, r, o), _ = new ff(c, t, i, t.scalabiltyMode ? Fh(t.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t.optimizationMode, s); return n.onSuccess([E.getTrackId(), _.getTrackId()]), Dh.info("create camera video track(".concat(s, ") and microphone audio track(").concat(o, ") success")), [E, _] }, createMicrophoneAudioTrack: async function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.CREATE_MIC_AUDIO_TRACK, options: [e] }), n = VI(e), i = Zg(8, "track-mic-"); let r = null; Dh.info("start create microphone audio track with config", JSON.stringify(e), "trackId", i); try { r = (await aS({ audio: n }, i)).getAudioTracks()[0] || null } catch (e) { throw t.onError(e), e } if (!r) { const e = new Ch(Oh.UNEXPECTED_ERROR, "can not find track in media stream"); return t.onError(e), e.throw() } const o = new Pg(r, e, n, i); return t.onSuccess(o.getTrackId()), Dh.info("create microphone audio track success, trackId:", i), o }, createCustomAudioTrack: function (e) { const t = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.CREATE_CUSTOM_AUDIO_TRACK, options: [e] }), n = new fg(e.mediaStreamTrack, e.encoderConfig ? Bh(e.encoderConfig) : {}, Zg(8, "track-cus-"), !1, !0); return Dh.info("create custom audio track success with config", e, "trackId", n.getTrackId()), t.onSuccess(n.getTrackId()), n }, createBufferSourceAudioTrack: async function (e) { const t = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.CREATE_BUFFER_AUDIO_TRACK, options: [e] }); if (jh("DISABLE_WEBAUDIO")) throw new Ch(Oh.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled"); const n = Zg(8, "track-buf-"); Dh.info("start create buffer source audio track with config", JSON.stringify(e), "trackId", n); const i = e.source; if (!(e.source instanceof AudioBuffer)) try { e.source = await BL(e.source, e.cacheOnlineFile) } catch (e) { return t.onError(e), e.throw() } const r = new FL(e.source), o = new Ng(i, r, e.encoderConfig ? Bh(e.encoderConfig) : {}, n); return Dh.info("create buffer source audio track success, trackId:", n), t.onSuccess(o.getTrackId()), o }, setAppType: function (e) { if (Dh.debug("setAppType: ".concat(e)), !(Number.isInteger(e) && e >= 0)) throw Dh.debug("Invalid appType"), new Ch(Oh.INVALID_PARAMS, "invalid app type", e); Gh("APP_TYPE", Math.floor(e)) }, setLogLevel: function (e) { Dh.setLogLevel(e) }, enableLogUpload: function () { jh("USE_NEW_LOG") ? Gh("UPLOAD_LOG", !0) : Dh.enableLogUpload() }, disableLogUpload: function () { jh("USE_NEW_LOG") ? Gh("UPLOAD_LOG", !1) : Dh.disableLogUpload() }, createChannelMediaRelayConfiguration: function () { return new II }, checkAudioTrackIsActive: async function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3; const n = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t] }); if (!(e instanceof fg || e instanceof rv)) { const e = new Ch(Oh.INVALID_TRACK, "the parameter is not a audio track"); return n.onError(e), e.throw() } t && t < 1e3 && (t = 1e3); const i = e instanceof fg ? e.getTrackLabel() : "remote_track", r = e.getVolumeLevel(); let o = r, s = r; const a = Date.now(); return new Cd((r => { const c = setInterval((() => { const E = e.getVolumeLevel(); o = E > o ? E : o, s = E < s ? E : s; const _ = o - s > 1e-4, d = Date.now() - a; if (_ || d > t) { clearInterval(c); const t = _, s = { duration: d, deviceLabel: i, maxVolumeLevel: o, result: t }; Dh.info("[track-".concat(e.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(s))), n.onSuccess(s), r(t) } }), 200) })) }, checkVideoTrackIsActive: async function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3; const n = wA.reportApiInvoke(null, { tag: hT.TRACER, name: RT.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t] }); if (!(e instanceof If || e instanceof iv)) { const e = new Ch(Oh.INVALID_TRACK, "the parameter is not a video track"); return n.onError(e), e.throw() } const i = 4; t && t < 1e3 && (t = 1e3); const r = e instanceof If ? e.getTrackLabel() : "remote_track", o = e.getMediaStreamTrack(!0), s = document.createElement("video"); s.style.width = "1px", s.style.height = "1px", s.setAttribute("muted", ""), s.muted = !0, s.setAttribute("playsinline", ""), s.controls = !1, (Wu() || Bu()) && (s.style.opacity = "0.01", s.style.position = "fixed", s.style.left = "0", s.style.top = "0", document.body.appendChild(s)), s.srcObject = new MediaStream([o]), s.play(); const a = document.createElement("canvas"); a.width = 160, a.height = 120; let c = 0, E = 0; try { const e = Date.now(); c = await KL(s, t, a, i), E = Date.now() - e } catch (e) { throw n.onError(e), e } WL === Lu.SAFARI && (s.pause(), s.remove()), s.srcObject = null; const _ = c > i, d = { duration: E, changedPicNum: c, deviceLabel: r, result: _ }; return Dh.info("[track-".concat(e.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(d))), n.onSuccess(d), _ }, setArea: Jm, audioElementPlayCenter: lS, processExternalMediaAEC: function (e) { zL.processExternalMediaAEC(e) }, registerExtensions: function (e) { e.forEach((e => { const t = e; t.__registered__ = !0, t.logger.hookLog = Dh.extLog, t.reporter.hookApiInvoke = wA.extApiInvoke, t.parameters && Object.keys(t.parameters).forEach((e => { t.parameters[e] = jh(e) })) })) }, ChannelMediaRelayError: oO, ChannelMediaRelayEvent: iO, ChannelMediaRelayState: rO, RemoteStreamFallbackType: RO, RemoteStreamType: lO, ConnectionDisconnectedReason: IT, AudienceLatencyLevelType: mT, AREAS: OO }); return Object.defineProperties(nw, { onAudioAutoplayFailed: { get: () => IA.onAudioAutoplayFailed, set: e => { IA.onAudioAutoplayFailed = e } }, onAutoplayFailed: { get: () => IA.onAutoplayFailed, set: e => { IA.onAutoplayFailed = e } }, _onSecurityPolicyViolation: { value: void 0, writable: !0 }, _cspEventHandlerPointer: { value: void 0, writable: !0 }, onSecurityPolicyViolation: { get: () => nw._onSecurityPolicyViolation, set(e) { nw._onSecurityPolicyViolation = e, tw(e) } } }), dS.on(TT.CAMERA_DEVICE_CHANGED, (e => { Dh.info("camera device changed", JSON.stringify(e)), nw.onCameraChanged && nw.onCameraChanged(e), nw.safeEmit(BO.CAMERA_CHANGED, e) })), dS.on(TT.RECORDING_DEVICE_CHANGED, (e => { Dh.info("microphone device changed", JSON.stringify(e)), nw.onMicrophoneChanged && nw.onMicrophoneChanged(e), nw.safeEmit(BO.MICROPHONE_CHANGED, e) })), dS.on(TT.PLAYOUT_DEVICE_CHANGED, (e => { Dh.debug("playout device changed", JSON.stringify(e)), nw.onPlaybackDeviceChanged && nw.onPlaybackDeviceChanged(e), nw.safeEmit(BO.PLAYBACK_DEVICE_CHANGED, e) })), lS.onAutoplayFailed = () => { Dh.info("detect audio element autoplay failed"), IA.onAudioAutoplayFailed && IA.onAudioAutoplayFailed() }, GA.on("autoplay-failed", (() => { Dh.info("detect webaudio autoplay failed"), IA.onAudioAutoplayFailed && IA.onAudioAutoplayFailed(), nw.safeEmit(BO.AUTOPLAY_FAILED) })), window && (window.__ARTC__ = nw), nw
                }()
            }, 2964: function (e, t) { "use strict"; var n, i, r, o, s, a, c, E, _, d, u, l, R, h, p, T, O, C, A, S, g, m, I, f, P, N, D, v, y, L, w, b, U, M, k, V, x, F, Y, B, G, j, H, W, K, J, X, q, Q, z, Z, $, ee, te, ne, ie, re, oe, se, ae, ce, Ee, _e, de, ue, le, Re, he, pe, Te, Oe, Ce, Ae, Se, ge, me, Ie, fe, Pe, Ne, De, ve, ye, Le, we, be, Ue, Me, ke, Ve, xe, Fe, Ye, Be, Ge, je, He, We, Ke, Je, Xe; Object.defineProperty(t, "__esModule", { value: !0 }), t.AUDIENCE_LATENCY_LEVEL_TYPE = t.QUALITY_ADAPT_INDICATION = t.CLIENT_ROLE_TYPE = t.RtcStats = t.WatermarkOptions = t.WatermarkRatio = t.Rectangle = t.SimulcastStreamConfig = t.SIMULCAST_STREAM_MODE = t.DataStreamConfig = t.VideoEncoderConfiguration = t.CodecCapInfo = t.CodecCapLevels = t.CODEC_CAP_MASK = t.VIDEO_MIRROR_MODE_TYPE = t.AdvanceOptions = t.ENCODING_PREFERENCE = t.COMPRESSION_PREFERENCE = t.EncodedVideoFrameInfo = t.VideoSubscriptionOptions = t.VIDEO_STREAM_TYPE = t.H264PacketizeMode = t.AudioPcmDataInfo = t.EncodedAudioFrameInfo = t.EncodedAudioFrameAdvancedSettings = t.WATERMARK_FIT_MODE = t.AUDIO_ENCODING_TYPE = t.AUDIO_CODEC_TYPE = t.SenderOptions = t.TCcMode = t.VIDEO_CODEC_TYPE = t.VIDEO_CODEC_CAPABILITY_LEVEL = t.SCREEN_CAPTURE_FRAMERATE_CAPABILITY = t.VideoDimensions = t.DEGRADATION_PREFERENCE = t.ORIENTATION_MODE = t.VIDEO_FRAME_TYPE = t.FRAME_HEIGHT = t.FRAME_WIDTH = t.FRAME_RATE = t.VIDEO_ORIENTATION = t.FIT_MODE_TYPE = t.QUALITY_TYPE = t.INTERFACE_ID_TYPE = t.USER_OFFLINE_REASON_TYPE = t.AUDIO_SESSION_OPERATION_RESTRICTION = t.LICENSE_ERROR_TYPE = t.ERROR_CODE_TYPE = t.WARN_CODE_TYPE = t.CHANNEL_PROFILE_TYPE = void 0, t.WlAccStats = t.WLACC_SUGGEST_ACTION = t.WLACC_MESSAGE_REASON = t.CLIENT_ROLE_CHANGE_FAILED_REASON = t.CONNECTION_CHANGED_REASON_TYPE = t.LastmileProbeResult = t.LastmileProbeOneWayResult = t.LASTMILE_PROBE_RESULT_STATE = t.LastmileProbeConfig = t.VIDEO_TRANSCODER_ERROR = t.LocalTranscoderConfiguration = t.TranscodingVideoStream = t.LiveTranscoding = t.TranscodingUser = t.CONNECTION_STATE_TYPE = t.LiveStreamAdvancedFeature = t.RtcImage = t.RTMP_STREAMING_EVENT = t.RTMP_STREAM_PUBLISH_ERROR_TYPE = t.RTMP_STREAM_PUBLISH_STATE = t.LocalAudioStats = t.AUDIO_CODEC_PROFILE_TYPE = t.VIDEO_CODEC_PROFILE_TYPE = t.VIDEO_CODEC_TYPE_FOR_STREAM = t.AUDIO_SAMPLE_RATE_TYPE = t.Packet = t.DeviceInfo = t.AudioVolumeInfo = t.REMOTE_VIDEO_DOWNSCALE_LEVEL = t.VideoTrackInfo = t.REMOTE_USER_STATE = t.REMOTE_VIDEO_STATE_REASON = t.REMOTE_VIDEO_STATE = t.REMOTE_AUDIO_STATE_REASON = t.REMOTE_AUDIO_STATE = t.LOCAL_VIDEO_STREAM_ERROR = t.LOCAL_VIDEO_STREAM_STATE = t.LOCAL_AUDIO_STREAM_ERROR = t.LOCAL_AUDIO_STREAM_STATE = t.CAPTURE_BRIGHTNESS_LEVEL_TYPE = t.VIDEO_APPLICATION_SCENARIO_TYPE = t.SCREEN_SCENARIO_TYPE = t.VIDEO_CONTENT_HINT = t.VideoFormat = t.AUDIO_SCENARIO_TYPE = t.AUDIO_PROFILE_TYPE = t.AUDIO_AINS_MODE = t.EXPERIENCE_POOR_REASON = t.EXPERIENCE_QUALITY_TYPE = t.ClientRoleOptions = void 0, t.EAR_MONITORING_FILTER_TYPE = t.UserInfo = t.EchoTestConfiguration = t.STREAM_PUBLISH_STATE = t.STREAM_SUBSCRIBE_STATE = t.MAX_USER_ACCOUNT_LENGTH_TYPE = t.PERMISSION_TYPE = t.UPLOAD_ERROR_REASON = t.ENCRYPTION_ERROR_TYPE = t.EncryptionConfig = t.ENCRYPTION_MODE = t.DownlinkNetworkInfo = t.PeerDownlinkInfo = t.UplinkNetworkInfo = t.ChannelMediaRelayConfiguration = t.ChannelMediaInfo = t.CHANNEL_MEDIA_RELAY_STATE = t.CHANNEL_MEDIA_RELAY_EVENT = t.CHANNEL_MEDIA_RELAY_ERROR = t.AREA_CODE_EX = t.AREA_CODE = t.AudioEncodedFrameObserverConfig = t.AudioRecordingConfiguration = t.AUDIO_ENCODED_FRAME_OBSERVER_POSITION = t.AUDIO_FILE_RECORDING_TYPE = t.AUDIO_RECORDING_QUALITY_TYPE = t.ScreenCaptureParameters = t.HEADPHONE_EQUALIZER_PRESET = t.VOICE_CONVERSION_PRESET = t.AUDIO_EFFECT_PRESET = t.VOICE_BEAUTIFIER_PRESET = t.AudioTrackConfig = t.AUDIO_TRACK_TYPE = t.SegmentationProperty = t.SEG_MODEL_TYPE = t.VirtualBackgroundSource = t.BACKGROUND_BLUR_DEGREE = t.BACKGROUND_SOURCE_TYPE = t.ColorEnhanceOptions = t.VideoDenoiserOptions = t.VIDEO_DENOISER_LEVEL = t.VIDEO_DENOISER_MODE = t.LowlightEnhanceOptions = t.LOW_LIGHT_ENHANCE_LEVEL = t.LOW_LIGHT_ENHANCE_MODE = t.BeautyOptions = t.LIGHTENING_CONTRAST_LEVEL = t.VideoCanvas = t.VIDEO_VIEW_SETUP_MODE = t.NETWORK_TYPE = void 0, t.SpatialAudioParams = t.LocalAccessPointConfiguration = t.AdvancedConfigInfo = t.LogUploadServerInfo = t.LOCAL_PROXY_MODE = t.RecorderStreamInfo = t.CONFIG_FETCH_TYPE = t.VideoRenderingTracingInfo = t.MEDIA_TRACE_EVENT = t.ScreenCaptureParameters2 = t.ScreenAudioParameters = t.ScreenVideoParameters = t.THREAD_PRIORITY_TYPE = void 0, function (e) { e[e.CHANNEL_PROFILE_COMMUNICATION = 0] = "CHANNEL_PROFILE_COMMUNICATION", e[e.CHANNEL_PROFILE_LIVE_BROADCASTING = 1] = "CHANNEL_PROFILE_LIVE_BROADCASTING", e[e.CHANNEL_PROFILE_GAME = 2] = "CHANNEL_PROFILE_GAME", e[e.CHANNEL_PROFILE_CLOUD_GAMING = 3] = "CHANNEL_PROFILE_CLOUD_GAMING", e[e.CHANNEL_PROFILE_COMMUNICATION_1v1 = 4] = "CHANNEL_PROFILE_COMMUNICATION_1v1" }(n || (t.CHANNEL_PROFILE_TYPE = n = {})), function (e) { e[e.WARN_INVALID_VIEW = 8] = "WARN_INVALID_VIEW", e[e.WARN_INIT_VIDEO = 16] = "WARN_INIT_VIDEO", e[e.WARN_PENDING = 20] = "WARN_PENDING", e[e.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e[e.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e[e.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e[e.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e[e.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e[e.WARN_SWITCH_LIVE_VIDEO_TIMEOUT = 111] = "WARN_SWITCH_LIVE_VIDEO_TIMEOUT", e[e.WARN_SET_CLIENT_ROLE_TIMEOUT = 118] = "WARN_SET_CLIENT_ROLE_TIMEOUT", e[e.WARN_OPEN_CHANNEL_INVALID_TICKET = 121] = "WARN_OPEN_CHANNEL_INVALID_TICKET", e[e.WARN_OPEN_CHANNEL_TRY_NEXT_VOS = 122] = "WARN_OPEN_CHANNEL_TRY_NEXT_VOS", e[e.WARN_CHANNEL_CONNECTION_UNRECOVERABLE = 131] = "WARN_CHANNEL_CONNECTION_UNRECOVERABLE", e[e.WARN_CHANNEL_CONNECTION_IP_CHANGED = 132] = "WARN_CHANNEL_CONNECTION_IP_CHANGED", e[e.WARN_CHANNEL_CONNECTION_PORT_CHANGED = 133] = "WARN_CHANNEL_CONNECTION_PORT_CHANGED", e[e.WARN_CHANNEL_SOCKET_ERROR = 134] = "WARN_CHANNEL_SOCKET_ERROR", e[e.WARN_AUDIO_MIXING_OPEN_ERROR = 701] = "WARN_AUDIO_MIXING_OPEN_ERROR", e[e.WARN_ADM_RUNTIME_PLAYOUT_WARNING = 1014] = "WARN_ADM_RUNTIME_PLAYOUT_WARNING", e[e.WARN_ADM_RUNTIME_RECORDING_WARNING = 1016] = "WARN_ADM_RUNTIME_RECORDING_WARNING", e[e.WARN_ADM_RECORD_AUDIO_SILENCE = 1019] = "WARN_ADM_RECORD_AUDIO_SILENCE", e[e.WARN_ADM_PLAYOUT_MALFUNCTION = 1020] = "WARN_ADM_PLAYOUT_MALFUNCTION", e[e.WARN_ADM_RECORD_MALFUNCTION = 1021] = "WARN_ADM_RECORD_MALFUNCTION", e[e.WARN_ADM_RECORD_AUDIO_LOWLEVEL = 1031] = "WARN_ADM_RECORD_AUDIO_LOWLEVEL", e[e.WARN_ADM_PLAYOUT_AUDIO_LOWLEVEL = 1032] = "WARN_ADM_PLAYOUT_AUDIO_LOWLEVEL", e[e.WARN_ADM_WINDOWS_NO_DATA_READY_EVENT = 1040] = "WARN_ADM_WINDOWS_NO_DATA_READY_EVENT", e[e.WARN_APM_HOWLING = 1051] = "WARN_APM_HOWLING", e[e.WARN_ADM_GLITCH_STATE = 1052] = "WARN_ADM_GLITCH_STATE", e[e.WARN_ADM_IMPROPER_SETTINGS = 1053] = "WARN_ADM_IMPROPER_SETTINGS", e[e.WARN_ADM_WIN_CORE_NO_RECORDING_DEVICE = 1322] = "WARN_ADM_WIN_CORE_NO_RECORDING_DEVICE", e[e.WARN_ADM_WIN_CORE_NO_PLAYOUT_DEVICE = 1323] = "WARN_ADM_WIN_CORE_NO_PLAYOUT_DEVICE", e[e.WARN_ADM_WIN_CORE_IMPROPER_CAPTURE_RELEASE = 1324] = "WARN_ADM_WIN_CORE_IMPROPER_CAPTURE_RELEASE" }(i || (t.WARN_CODE_TYPE = i = {})), function (e) { e[e.ERR_OK = 0] = "ERR_OK", e[e.ERR_FAILED = 1] = "ERR_FAILED", e[e.ERR_INVALID_ARGUMENT = 2] = "ERR_INVALID_ARGUMENT", e[e.ERR_NOT_READY = 3] = "ERR_NOT_READY", e[e.ERR_NOT_SUPPORTED = 4] = "ERR_NOT_SUPPORTED", e[e.ERR_REFUSED = 5] = "ERR_REFUSED", e[e.ERR_BUFFER_TOO_SMALL = 6] = "ERR_BUFFER_TOO_SMALL", e[e.ERR_NOT_INITIALIZED = 7] = "ERR_NOT_INITIALIZED", e[e.ERR_INVALID_STATE = 8] = "ERR_INVALID_STATE", e[e.ERR_NO_PERMISSION = 9] = "ERR_NO_PERMISSION", e[e.ERR_TIMEDOUT = 10] = "ERR_TIMEDOUT", e[e.ERR_CANCELED = 11] = "ERR_CANCELED", e[e.ERR_TOO_OFTEN = 12] = "ERR_TOO_OFTEN", e[e.ERR_BIND_SOCKET = 13] = "ERR_BIND_SOCKET", e[e.ERR_NET_DOWN = 14] = "ERR_NET_DOWN", e[e.ERR_JOIN_CHANNEL_REJECTED = 17] = "ERR_JOIN_CHANNEL_REJECTED", e[e.ERR_LEAVE_CHANNEL_REJECTED = 18] = "ERR_LEAVE_CHANNEL_REJECTED", e[e.ERR_ALREADY_IN_USE = 19] = "ERR_ALREADY_IN_USE", e[e.ERR_ABORTED = 20] = "ERR_ABORTED", e[e.ERR_INIT_NET_ENGINE = 21] = "ERR_INIT_NET_ENGINE", e[e.ERR_RESOURCE_LIMITED = 22] = "ERR_RESOURCE_LIMITED", e[e.ERR_INVALID_APP_ID = 101] = "ERR_INVALID_APP_ID", e[e.ERR_INVALID_CHANNEL_NAME = 102] = "ERR_INVALID_CHANNEL_NAME", e[e.ERR_NO_SERVER_RESOURCES = 103] = "ERR_NO_SERVER_RESOURCES", e[e.ERR_TOKEN_EXPIRED = 109] = "ERR_TOKEN_EXPIRED", e[e.ERR_INVALID_TOKEN = 110] = "ERR_INVALID_TOKEN", e[e.ERR_CONNECTION_INTERRUPTED = 111] = "ERR_CONNECTION_INTERRUPTED", e[e.ERR_CONNECTION_LOST = 112] = "ERR_CONNECTION_LOST", e[e.ERR_NOT_IN_CHANNEL = 113] = "ERR_NOT_IN_CHANNEL", e[e.ERR_SIZE_TOO_LARGE = 114] = "ERR_SIZE_TOO_LARGE", e[e.ERR_BITRATE_LIMIT = 115] = "ERR_BITRATE_LIMIT", e[e.ERR_TOO_MANY_DATA_STREAMS = 116] = "ERR_TOO_MANY_DATA_STREAMS", e[e.ERR_STREAM_MESSAGE_TIMEOUT = 117] = "ERR_STREAM_MESSAGE_TIMEOUT", e[e.ERR_SET_CLIENT_ROLE_NOT_AUTHORIZED = 119] = "ERR_SET_CLIENT_ROLE_NOT_AUTHORIZED", e[e.ERR_DECRYPTION_FAILED = 120] = "ERR_DECRYPTION_FAILED", e[e.ERR_INVALID_USER_ID = 121] = "ERR_INVALID_USER_ID", e[e.ERR_CLIENT_IS_BANNED_BY_SERVER = 123] = "ERR_CLIENT_IS_BANNED_BY_SERVER", e[e.ERR_ENCRYPTED_STREAM_NOT_ALLOWED_PUBLISH = 130] = "ERR_ENCRYPTED_STREAM_NOT_ALLOWED_PUBLISH", e[e.ERR_LICENSE_CREDENTIAL_INVALID = 131] = "ERR_LICENSE_CREDENTIAL_INVALID", e[e.ERR_INVALID_USER_ACCOUNT = 134] = "ERR_INVALID_USER_ACCOUNT", e[e.ERR_MODULE_NOT_FOUND = 157] = "ERR_MODULE_NOT_FOUND", e[e.ERR_CERT_RAW = 157] = "ERR_CERT_RAW", e[e.ERR_CERT_JSON_PART = 158] = "ERR_CERT_JSON_PART", e[e.ERR_CERT_JSON_INVAL = 159] = "ERR_CERT_JSON_INVAL", e[e.ERR_CERT_JSON_NOMEM = 160] = "ERR_CERT_JSON_NOMEM", e[e.ERR_CERT_CUSTOM = 161] = "ERR_CERT_CUSTOM", e[e.ERR_CERT_CREDENTIAL = 162] = "ERR_CERT_CREDENTIAL", e[e.ERR_CERT_SIGN = 163] = "ERR_CERT_SIGN", e[e.ERR_CERT_FAIL = 164] = "ERR_CERT_FAIL", e[e.ERR_CERT_BUF = 165] = "ERR_CERT_BUF", e[e.ERR_CERT_NULL = 166] = "ERR_CERT_NULL", e[e.ERR_CERT_DUEDATE = 167] = "ERR_CERT_DUEDATE", e[e.ERR_CERT_REQUEST = 168] = "ERR_CERT_REQUEST", e[e.ERR_PCMSEND_FORMAT = 200] = "ERR_PCMSEND_FORMAT", e[e.ERR_PCMSEND_BUFFEROVERFLOW = 201] = "ERR_PCMSEND_BUFFEROVERFLOW", e[e.ERR_LOGIN_ALREADY_LOGIN = 428] = "ERR_LOGIN_ALREADY_LOGIN", e[e.ERR_LOAD_MEDIA_ENGINE = 1001] = "ERR_LOAD_MEDIA_ENGINE", e[e.ERR_ADM_GENERAL_ERROR = 1005] = "ERR_ADM_GENERAL_ERROR", e[e.ERR_ADM_INIT_PLAYOUT = 1008] = "ERR_ADM_INIT_PLAYOUT", e[e.ERR_ADM_START_PLAYOUT = 1009] = "ERR_ADM_START_PLAYOUT", e[e.ERR_ADM_STOP_PLAYOUT = 1010] = "ERR_ADM_STOP_PLAYOUT", e[e.ERR_ADM_INIT_RECORDING = 1011] = "ERR_ADM_INIT_RECORDING", e[e.ERR_ADM_START_RECORDING = 1012] = "ERR_ADM_START_RECORDING", e[e.ERR_ADM_STOP_RECORDING = 1013] = "ERR_ADM_STOP_RECORDING", e[e.ERR_VDM_CAMERA_NOT_AUTHORIZED = 1501] = "ERR_VDM_CAMERA_NOT_AUTHORIZED", e[e.ERR_ADM_APPLICATION_LOOPBACK = 2007] = "ERR_ADM_APPLICATION_LOOPBACK" }(r || (t.ERROR_CODE_TYPE = r = {})), function (e) { e[e.LICENSE_ERR_INVALID = 1] = "LICENSE_ERR_INVALID", e[e.LICENSE_ERR_EXPIRE = 2] = "LICENSE_ERR_EXPIRE", e[e.LICENSE_ERR_MINUTES_EXCEED = 3] = "LICENSE_ERR_MINUTES_EXCEED", e[e.LICENSE_ERR_LIMITED_PERIOD = 4] = "LICENSE_ERR_LIMITED_PERIOD", e[e.LICENSE_ERR_DIFF_DEVICES = 5] = "LICENSE_ERR_DIFF_DEVICES", e[e.LICENSE_ERR_INTERNAL = 99] = "LICENSE_ERR_INTERNAL" }(o || (t.LICENSE_ERROR_TYPE = o = {})), function (e) { e[e.AUDIO_SESSION_OPERATION_RESTRICTION_NONE = 0] = "AUDIO_SESSION_OPERATION_RESTRICTION_NONE", e[e.AUDIO_SESSION_OPERATION_RESTRICTION_SET_CATEGORY = 1] = "AUDIO_SESSION_OPERATION_RESTRICTION_SET_CATEGORY", e[e.AUDIO_SESSION_OPERATION_RESTRICTION_CONFIGURE_SESSION = 1] = "AUDIO_SESSION_OPERATION_RESTRICTION_CONFIGURE_SESSION", e[e.AUDIO_SESSION_OPERATION_RESTRICTION_DEACTIVATE_SESSION = 1] = "AUDIO_SESSION_OPERATION_RESTRICTION_DEACTIVATE_SESSION", e[e.AUDIO_SESSION_OPERATION_RESTRICTION_ALL = 1] = "AUDIO_SESSION_OPERATION_RESTRICTION_ALL" }(s || (t.AUDIO_SESSION_OPERATION_RESTRICTION = s = {})), function (e) { e[e.USER_OFFLINE_QUIT = 0] = "USER_OFFLINE_QUIT", e[e.USER_OFFLINE_DROPPED = 1] = "USER_OFFLINE_DROPPED", e[e.USER_OFFLINE_BECOME_AUDIENCE = 2] = "USER_OFFLINE_BECOME_AUDIENCE" }(a || (t.USER_OFFLINE_REASON_TYPE = a = {})), function (e) { e[e.AGORA_IID_AUDIO_DEVICE_MANAGER = 1] = "AGORA_IID_AUDIO_DEVICE_MANAGER", e[e.AGORA_IID_VIDEO_DEVICE_MANAGER = 2] = "AGORA_IID_VIDEO_DEVICE_MANAGER", e[e.AGORA_IID_PARAMETER_ENGINE = 3] = "AGORA_IID_PARAMETER_ENGINE", e[e.AGORA_IID_MEDIA_ENGINE = 4] = "AGORA_IID_MEDIA_ENGINE", e[e.AGORA_IID_AUDIO_ENGINE = 5] = "AGORA_IID_AUDIO_ENGINE", e[e.AGORA_IID_VIDEO_ENGINE = 6] = "AGORA_IID_VIDEO_ENGINE", e[e.AGORA_IID_RTC_CONNECTION = 7] = "AGORA_IID_RTC_CONNECTION", e[e.AGORA_IID_SIGNALING_ENGINE = 8] = "AGORA_IID_SIGNALING_ENGINE", e[e.AGORA_IID_MEDIA_ENGINE_REGULATOR = 9] = "AGORA_IID_MEDIA_ENGINE_REGULATOR", e[e.AGORA_IID_CLOUD_SPATIAL_AUDIO = 10] = "AGORA_IID_CLOUD_SPATIAL_AUDIO", e[e.AGORA_IID_LOCAL_SPATIAL_AUDIO = 11] = "AGORA_IID_LOCAL_SPATIAL_AUDIO", e[e.AGORA_IID_STATE_SYNC = 13] = "AGORA_IID_STATE_SYNC", e[e.AGORA_IID_METACHAT_SERVICE = 14] = "AGORA_IID_METACHAT_SERVICE", e[e.AGORA_IID_MUSIC_CONTENT_CENTER = 15] = "AGORA_IID_MUSIC_CONTENT_CENTER", e[e.AGORA_IID_H265_TRANSCODER = 16] = "AGORA_IID_H265_TRANSCODER" }(c || (t.INTERFACE_ID_TYPE = c = {})), function (e) { e[e.QUALITY_UNKNOWN = 0] = "QUALITY_UNKNOWN", e[e.QUALITY_EXCELLENT = 1] = "QUALITY_EXCELLENT", e[e.QUALITY_GOOD = 2] = "QUALITY_GOOD", e[e.QUALITY_POOR = 3] = "QUALITY_POOR", e[e.QUALITY_BAD = 4] = "QUALITY_BAD", e[e.QUALITY_VBAD = 5] = "QUALITY_VBAD", e[e.QUALITY_DOWN = 6] = "QUALITY_DOWN", e[e.QUALITY_UNSUPPORTED = 7] = "QUALITY_UNSUPPORTED", e[e.QUALITY_DETECTING = 8] = "QUALITY_DETECTING" }(E || (t.QUALITY_TYPE = E = {})), function (e) { e[e.MODE_COVER = 1] = "MODE_COVER", e[e.MODE_CONTAIN = 2] = "MODE_CONTAIN" }(_ || (t.FIT_MODE_TYPE = _ = {})), function (e) { e[e.VIDEO_ORIENTATION_0 = 0] = "VIDEO_ORIENTATION_0", e[e.VIDEO_ORIENTATION_90 = 90] = "VIDEO_ORIENTATION_90", e[e.VIDEO_ORIENTATION_180 = 180] = "VIDEO_ORIENTATION_180", e[e.VIDEO_ORIENTATION_270 = 270] = "VIDEO_ORIENTATION_270" }(d || (t.VIDEO_ORIENTATION = d = {})), function (e) { e[e.FRAME_RATE_FPS_1 = 1] = "FRAME_RATE_FPS_1", e[e.FRAME_RATE_FPS_7 = 7] = "FRAME_RATE_FPS_7", e[e.FRAME_RATE_FPS_10 = 10] = "FRAME_RATE_FPS_10", e[e.FRAME_RATE_FPS_15 = 15] = "FRAME_RATE_FPS_15", e[e.FRAME_RATE_FPS_24 = 24] = "FRAME_RATE_FPS_24", e[e.FRAME_RATE_FPS_30 = 30] = "FRAME_RATE_FPS_30", e[e.FRAME_RATE_FPS_60 = 60] = "FRAME_RATE_FPS_60" }(u || (t.FRAME_RATE = u = {})), function (e) { e[e.FRAME_WIDTH_960 = 960] = "FRAME_WIDTH_960" }(l || (t.FRAME_WIDTH = l = {})), function (e) { e[e.FRAME_HEIGHT_540 = 540] = "FRAME_HEIGHT_540" }(R || (t.FRAME_HEIGHT = R = {})), function (e) { e[e.VIDEO_FRAME_TYPE_BLANK_FRAME = 0] = "VIDEO_FRAME_TYPE_BLANK_FRAME", e[e.VIDEO_FRAME_TYPE_KEY_FRAME = 3] = "VIDEO_FRAME_TYPE_KEY_FRAME", e[e.VIDEO_FRAME_TYPE_DELTA_FRAME = 4] = "VIDEO_FRAME_TYPE_DELTA_FRAME", e[e.VIDEO_FRAME_TYPE_B_FRAME = 5] = "VIDEO_FRAME_TYPE_B_FRAME", e[e.VIDEO_FRAME_TYPE_DROPPABLE_FRAME = 6] = "VIDEO_FRAME_TYPE_DROPPABLE_FRAME", e[e.VIDEO_FRAME_TYPE_UNKNOW = 7] = "VIDEO_FRAME_TYPE_UNKNOW" }(h || (t.VIDEO_FRAME_TYPE = h = {})), function (e) { e[e.ORIENTATION_MODE_ADAPTIVE = 0] = "ORIENTATION_MODE_ADAPTIVE", e[e.ORIENTATION_MODE_FIXED_LANDSCAPE = 1] = "ORIENTATION_MODE_FIXED_LANDSCAPE", e[e.ORIENTATION_MODE_FIXED_PORTRAIT = 2] = "ORIENTATION_MODE_FIXED_PORTRAIT" }(p || (t.ORIENTATION_MODE = p = {})), function (e) { e[e.MAINTAIN_QUALITY = 0] = "MAINTAIN_QUALITY", e[e.MAINTAIN_FRAMERATE = 1] = "MAINTAIN_FRAMERATE", e[e.MAINTAIN_BALANCED = 2] = "MAINTAIN_BALANCED", e[e.MAINTAIN_RESOLUTION = 3] = "MAINTAIN_RESOLUTION", e[e.DISABLED = 100] = "DISABLED" }(T || (t.DEGRADATION_PREFERENCE = T = {})); t.VideoDimensions = class { }, function (e) { e[e.SCREEN_CAPTURE_FRAMERATE_CAPABILITY_15_FPS = 0] = "SCREEN_CAPTURE_FRAMERATE_CAPABILITY_15_FPS", e[e.SCREEN_CAPTURE_FRAMERATE_CAPABILITY_30_FPS = 1] = "SCREEN_CAPTURE_FRAMERATE_CAPABILITY_30_FPS", e[e.SCREEN_CAPTURE_FRAMERATE_CAPABILITY_60_FPS = 2] = "SCREEN_CAPTURE_FRAMERATE_CAPABILITY_60_FPS" }(O || (t.SCREEN_CAPTURE_FRAMERATE_CAPABILITY = O = {})), function (e) { e[e.CODEC_CAPABILITY_LEVEL_UNSPECIFIED = -1] = "CODEC_CAPABILITY_LEVEL_UNSPECIFIED", e[e.CODEC_CAPABILITY_LEVEL_BASIC_SUPPORT = 5] = "CODEC_CAPABILITY_LEVEL_BASIC_SUPPORT", e[e.CODEC_CAPABILITY_LEVEL_1080P30FPS = 10] = "CODEC_CAPABILITY_LEVEL_1080P30FPS", e[e.CODEC_CAPABILITY_LEVEL_1080P60FPS = 20] = "CODEC_CAPABILITY_LEVEL_1080P60FPS", e[e.CODEC_CAPABILITY_LEVEL_4K60FPS = 30] = "CODEC_CAPABILITY_LEVEL_4K60FPS" }(C || (t.VIDEO_CODEC_CAPABILITY_LEVEL = C = {})), function (e) { e[e.VIDEO_CODEC_NONE = 0] = "VIDEO_CODEC_NONE", e[e.VIDEO_CODEC_VP8 = 1] = "VIDEO_CODEC_VP8", e[e.VIDEO_CODEC_H264 = 2] = "VIDEO_CODEC_H264", e[e.VIDEO_CODEC_H265 = 3] = "VIDEO_CODEC_H265", e[e.VIDEO_CODEC_GENERIC = 6] = "VIDEO_CODEC_GENERIC", e[e.VIDEO_CODEC_GENERIC_H264 = 7] = "VIDEO_CODEC_GENERIC_H264", e[e.VIDEO_CODEC_AV1 = 12] = "VIDEO_CODEC_AV1", e[e.VIDEO_CODEC_VP9 = 13] = "VIDEO_CODEC_VP9", e[e.VIDEO_CODEC_GENERIC_JPEG = 20] = "VIDEO_CODEC_GENERIC_JPEG" }(A || (t.VIDEO_CODEC_TYPE = A = {})), function (e) { e[e.CC_ENABLED = 0] = "CC_ENABLED", e[e.CC_DISABLED = 1] = "CC_DISABLED" }(S || (t.TCcMode = S = {})); t.SenderOptions = class { }, function (e) { e[e.AUDIO_CODEC_OPUS = 1] = "AUDIO_CODEC_OPUS", e[e.AUDIO_CODEC_PCMA = 3] = "AUDIO_CODEC_PCMA", e[e.AUDIO_CODEC_PCMU = 4] = "AUDIO_CODEC_PCMU", e[e.AUDIO_CODEC_G722 = 5] = "AUDIO_CODEC_G722", e[e.AUDIO_CODEC_AACLC = 8] = "AUDIO_CODEC_AACLC", e[e.AUDIO_CODEC_HEAAC = 9] = "AUDIO_CODEC_HEAAC", e[e.AUDIO_CODEC_JC1 = 10] = "AUDIO_CODEC_JC1", e[e.AUDIO_CODEC_HEAAC2 = 11] = "AUDIO_CODEC_HEAAC2", e[e.AUDIO_CODEC_LPCNET = 12] = "AUDIO_CODEC_LPCNET" }(g || (t.AUDIO_CODEC_TYPE = g = {})), function (e) { e[e.AUDIO_ENCODING_TYPE_AAC_16000_LOW = 65793] = "AUDIO_ENCODING_TYPE_AAC_16000_LOW", e[e.AUDIO_ENCODING_TYPE_AAC_16000_MEDIUM = 65794] = "AUDIO_ENCODING_TYPE_AAC_16000_MEDIUM", e[e.AUDIO_ENCODING_TYPE_AAC_32000_LOW = 66049] = "AUDIO_ENCODING_TYPE_AAC_32000_LOW", e[e.AUDIO_ENCODING_TYPE_AAC_32000_MEDIUM = 66050] = "AUDIO_ENCODING_TYPE_AAC_32000_MEDIUM", e[e.AUDIO_ENCODING_TYPE_AAC_32000_HIGH = 66051] = "AUDIO_ENCODING_TYPE_AAC_32000_HIGH", e[e.AUDIO_ENCODING_TYPE_AAC_48000_MEDIUM = 66306] = "AUDIO_ENCODING_TYPE_AAC_48000_MEDIUM", e[e.AUDIO_ENCODING_TYPE_AAC_48000_HIGH = 66307] = "AUDIO_ENCODING_TYPE_AAC_48000_HIGH", e[e.AUDIO_ENCODING_TYPE_OPUS_16000_LOW = 131329] = "AUDIO_ENCODING_TYPE_OPUS_16000_LOW", e[e.AUDIO_ENCODING_TYPE_OPUS_16000_MEDIUM = 131330] = "AUDIO_ENCODING_TYPE_OPUS_16000_MEDIUM", e[e.AUDIO_ENCODING_TYPE_OPUS_48000_MEDIUM = 131842] = "AUDIO_ENCODING_TYPE_OPUS_48000_MEDIUM", e[e.AUDIO_ENCODING_TYPE_OPUS_48000_HIGH = 131843] = "AUDIO_ENCODING_TYPE_OPUS_48000_HIGH" }(m || (t.AUDIO_ENCODING_TYPE = m = {})), function (e) { e[e.FIT_MODE_COVER_POSITION = 0] = "FIT_MODE_COVER_POSITION", e[e.FIT_MODE_USE_IMAGE_RATIO = 1] = "FIT_MODE_USE_IMAGE_RATIO" }(I || (t.WATERMARK_FIT_MODE = I = {})); t.EncodedAudioFrameAdvancedSettings = class { }; t.EncodedAudioFrameInfo = class { }; t.AudioPcmDataInfo = class { }, function (e) { e[e.NonInterleaved = 0] = "NonInterleaved", e[e.SingleNalUnit = 1] = "SingleNalUnit" }(f || (t.H264PacketizeMode = f = {})), function (e) { e[e.VIDEO_STREAM_HIGH = 0] = "VIDEO_STREAM_HIGH", e[e.VIDEO_STREAM_LOW = 1] = "VIDEO_STREAM_LOW" }(P || (t.VIDEO_STREAM_TYPE = P = {})); t.VideoSubscriptionOptions = class { }; t.EncodedVideoFrameInfo = class { }, function (e) { e[e.PREFER_LOW_LATENCY = 0] = "PREFER_LOW_LATENCY", e[e.PREFER_QUALITY = 1] = "PREFER_QUALITY" }(N || (t.COMPRESSION_PREFERENCE = N = {})), function (e) { e[e.PREFER_AUTO = -1] = "PREFER_AUTO", e[e.PREFER_SOFTWARE = 0] = "PREFER_SOFTWARE", e[e.PREFER_HARDWARE = 1] = "PREFER_HARDWARE" }(D || (t.ENCODING_PREFERENCE = D = {})); t.AdvanceOptions = class { }, function (e) { e[e.VIDEO_MIRROR_MODE_AUTO = 0] = "VIDEO_MIRROR_MODE_AUTO", e[e.VIDEO_MIRROR_MODE_ENABLED = 1] = "VIDEO_MIRROR_MODE_ENABLED", e[e.VIDEO_MIRROR_MODE_DISABLED = 2] = "VIDEO_MIRROR_MODE_DISABLED" }(v || (t.VIDEO_MIRROR_MODE_TYPE = v = {})), function (e) { e[e.CODEC_CAP_MASK_NONE = 0] = "CODEC_CAP_MASK_NONE", e[e.CODEC_CAP_MASK_HW_DEC = 1] = "CODEC_CAP_MASK_HW_DEC", e[e.CODEC_CAP_MASK_HW_ENC = 1] = "CODEC_CAP_MASK_HW_ENC", e[e.CODEC_CAP_MASK_SW_DEC = 1] = "CODEC_CAP_MASK_SW_DEC", e[e.CODEC_CAP_MASK_SW_ENC = 1] = "CODEC_CAP_MASK_SW_ENC" }(y || (t.CODEC_CAP_MASK = y = {})); t.CodecCapLevels = class { }; t.CodecCapInfo = class { }; t.VideoEncoderConfiguration = class { }; t.DataStreamConfig = class { }, function (e) { e[e.AUTO_SIMULCAST_STREAM = -1] = "AUTO_SIMULCAST_STREAM", e[e.DISABLE_SIMULCAST_STREAM = 0] = "DISABLE_SIMULCAST_STREAM", e[e.ENABLE_SIMULCAST_STREAM = 1] = "ENABLE_SIMULCAST_STREAM" }(L || (t.SIMULCAST_STREAM_MODE = L = {})); t.SimulcastStreamConfig = class { }; t.Rectangle = class { }; t.WatermarkRatio = class { }; t.WatermarkOptions = class { }; t.RtcStats = class { }, function (e) { e[e.CLIENT_ROLE_BROADCASTER = 1] = "CLIENT_ROLE_BROADCASTER", e[e.CLIENT_ROLE_AUDIENCE = 2] = "CLIENT_ROLE_AUDIENCE" }(w || (t.CLIENT_ROLE_TYPE = w = {})), function (e) { e[e.ADAPT_NONE = 0] = "ADAPT_NONE", e[e.ADAPT_UP_BANDWIDTH = 1] = "ADAPT_UP_BANDWIDTH", e[e.ADAPT_DOWN_BANDWIDTH = 2] = "ADAPT_DOWN_BANDWIDTH" }(b || (t.QUALITY_ADAPT_INDICATION = b = {})), function (e) { e[e.AUDIENCE_LATENCY_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LATENCY_LEVEL_LOW_LATENCY", e[e.AUDIENCE_LATENCY_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LATENCY_LEVEL_ULTRA_LOW_LATENCY" }(U || (t.AUDIENCE_LATENCY_LEVEL_TYPE = U = {})); t.ClientRoleOptions = class { }, function (e) { e[e.EXPERIENCE_QUALITY_GOOD = 0] = "EXPERIENCE_QUALITY_GOOD", e[e.EXPERIENCE_QUALITY_BAD = 1] = "EXPERIENCE_QUALITY_BAD" }(M || (t.EXPERIENCE_QUALITY_TYPE = M = {})), function (e) { e[e.EXPERIENCE_REASON_NONE = 0] = "EXPERIENCE_REASON_NONE", e[e.REMOTE_NETWORK_QUALITY_POOR = 1] = "REMOTE_NETWORK_QUALITY_POOR", e[e.LOCAL_NETWORK_QUALITY_POOR = 2] = "LOCAL_NETWORK_QUALITY_POOR", e[e.WIRELESS_SIGNAL_POOR = 4] = "WIRELESS_SIGNAL_POOR", e[e.WIFI_BLUETOOTH_COEXIST = 8] = "WIFI_BLUETOOTH_COEXIST" }(k || (t.EXPERIENCE_POOR_REASON = k = {})), function (e) { e[e.AINS_MODE_BALANCED = 0] = "AINS_MODE_BALANCED", e[e.AINS_MODE_AGGRESSIVE = 1] = "AINS_MODE_AGGRESSIVE", e[e.AINS_MODE_ULTRALOWLATENCY = 2] = "AINS_MODE_ULTRALOWLATENCY" }(V || (t.AUDIO_AINS_MODE = V = {})), function (e) { e[e.AUDIO_PROFILE_DEFAULT = 0] = "AUDIO_PROFILE_DEFAULT", e[e.AUDIO_PROFILE_SPEECH_STANDARD = 1] = "AUDIO_PROFILE_SPEECH_STANDARD", e[e.AUDIO_PROFILE_MUSIC_STANDARD = 2] = "AUDIO_PROFILE_MUSIC_STANDARD", e[e.AUDIO_PROFILE_MUSIC_STANDARD_STEREO = 3] = "AUDIO_PROFILE_MUSIC_STANDARD_STEREO", e[e.AUDIO_PROFILE_MUSIC_HIGH_QUALITY = 4] = "AUDIO_PROFILE_MUSIC_HIGH_QUALITY", e[e.AUDIO_PROFILE_MUSIC_HIGH_QUALITY_STEREO = 5] = "AUDIO_PROFILE_MUSIC_HIGH_QUALITY_STEREO", e[e.AUDIO_PROFILE_IOT = 6] = "AUDIO_PROFILE_IOT", e[e.AUDIO_PROFILE_NUM = 7] = "AUDIO_PROFILE_NUM" }(x || (t.AUDIO_PROFILE_TYPE = x = {})), function (e) { e[e.AUDIO_SCENARIO_DEFAULT = 0] = "AUDIO_SCENARIO_DEFAULT", e[e.AUDIO_SCENARIO_GAME_STREAMING = 3] = "AUDIO_SCENARIO_GAME_STREAMING", e[e.AUDIO_SCENARIO_CHATROOM = 5] = "AUDIO_SCENARIO_CHATROOM", e[e.AUDIO_SCENARIO_CHORUS = 7] = "AUDIO_SCENARIO_CHORUS", e[e.AUDIO_SCENARIO_MEETING = 8] = "AUDIO_SCENARIO_MEETING", e[e.AUDIO_SCENARIO_NUM = 9] = "AUDIO_SCENARIO_NUM" }(F || (t.AUDIO_SCENARIO_TYPE = F = {})); t.VideoFormat = class { }, function (e) { e[e.CONTENT_HINT_NONE = 0] = "CONTENT_HINT_NONE", e[e.CONTENT_HINT_MOTION = 1] = "CONTENT_HINT_MOTION", e[e.CONTENT_HINT_DETAILS = 2] = "CONTENT_HINT_DETAILS" }(Y || (t.VIDEO_CONTENT_HINT = Y = {})), function (e) { e[e.SCREEN_SCENARIO_DOCUMENT = 1] = "SCREEN_SCENARIO_DOCUMENT", e[e.SCREEN_SCENARIO_GAMING = 2] = "SCREEN_SCENARIO_GAMING", e[e.SCREEN_SCENARIO_VIDEO = 3] = "SCREEN_SCENARIO_VIDEO", e[e.SCREEN_SCENARIO_RDC = 4] = "SCREEN_SCENARIO_RDC" }(B || (t.SCREEN_SCENARIO_TYPE = B = {})), function (e) { e[e.APPLICATION_SCENARIO_GENERAL = 0] = "APPLICATION_SCENARIO_GENERAL", e[e.APPLICATION_SCENARIO_MEETING = 1] = "APPLICATION_SCENARIO_MEETING" }(G || (t.VIDEO_APPLICATION_SCENARIO_TYPE = G = {})), function (e) { e[e.CAPTURE_BRIGHTNESS_LEVEL_INVALID = -1] = "CAPTURE_BRIGHTNESS_LEVEL_INVALID", e[e.CAPTURE_BRIGHTNESS_LEVEL_NORMAL = 0] = "CAPTURE_BRIGHTNESS_LEVEL_NORMAL", e[e.CAPTURE_BRIGHTNESS_LEVEL_BRIGHT = 1] = "CAPTURE_BRIGHTNESS_LEVEL_BRIGHT", e[e.CAPTURE_BRIGHTNESS_LEVEL_DARK = 2] = "CAPTURE_BRIGHTNESS_LEVEL_DARK" }(j || (t.CAPTURE_BRIGHTNESS_LEVEL_TYPE = j = {})), function (e) { e[e.LOCAL_AUDIO_STREAM_STATE_STOPPED = 0] = "LOCAL_AUDIO_STREAM_STATE_STOPPED", e[e.LOCAL_AUDIO_STREAM_STATE_RECORDING = 1] = "LOCAL_AUDIO_STREAM_STATE_RECORDING", e[e.LOCAL_AUDIO_STREAM_STATE_ENCODING = 2] = "LOCAL_AUDIO_STREAM_STATE_ENCODING", e[e.LOCAL_AUDIO_STREAM_STATE_FAILED = 3] = "LOCAL_AUDIO_STREAM_STATE_FAILED" }(H || (t.LOCAL_AUDIO_STREAM_STATE = H = {})), function (e) { e[e.LOCAL_AUDIO_STREAM_ERROR_OK = 0] = "LOCAL_AUDIO_STREAM_ERROR_OK", e[e.LOCAL_AUDIO_STREAM_ERROR_FAILURE = 1] = "LOCAL_AUDIO_STREAM_ERROR_FAILURE", e[e.LOCAL_AUDIO_STREAM_ERROR_DEVICE_NO_PERMISSION = 2] = "LOCAL_AUDIO_STREAM_ERROR_DEVICE_NO_PERMISSION", e[e.LOCAL_AUDIO_STREAM_ERROR_DEVICE_BUSY = 3] = "LOCAL_AUDIO_STREAM_ERROR_DEVICE_BUSY", e[e.LOCAL_AUDIO_STREAM_ERROR_RECORD_FAILURE = 4] = "LOCAL_AUDIO_STREAM_ERROR_RECORD_FAILURE", e[e.LOCAL_AUDIO_STREAM_ERROR_ENCODE_FAILURE = 5] = "LOCAL_AUDIO_STREAM_ERROR_ENCODE_FAILURE", e[e.LOCAL_AUDIO_STREAM_ERROR_NO_RECORDING_DEVICE = 6] = "LOCAL_AUDIO_STREAM_ERROR_NO_RECORDING_DEVICE", e[e.LOCAL_AUDIO_STREAM_ERROR_NO_PLAYOUT_DEVICE = 7] = "LOCAL_AUDIO_STREAM_ERROR_NO_PLAYOUT_DEVICE", e[e.LOCAL_AUDIO_STREAM_ERROR_INTERRUPTED = 8] = "LOCAL_AUDIO_STREAM_ERROR_INTERRUPTED", e[e.LOCAL_AUDIO_STREAM_ERROR_RECORD_INVALID_ID = 9] = "LOCAL_AUDIO_STREAM_ERROR_RECORD_INVALID_ID", e[e.LOCAL_AUDIO_STREAM_ERROR_PLAYOUT_INVALID_ID = 10] = "LOCAL_AUDIO_STREAM_ERROR_PLAYOUT_INVALID_ID" }(W || (t.LOCAL_AUDIO_STREAM_ERROR = W = {})), function (e) { e[e.LOCAL_VIDEO_STREAM_STATE_STOPPED = 0] = "LOCAL_VIDEO_STREAM_STATE_STOPPED", e[e.LOCAL_VIDEO_STREAM_STATE_CAPTURING = 1] = "LOCAL_VIDEO_STREAM_STATE_CAPTURING", e[e.LOCAL_VIDEO_STREAM_STATE_ENCODING = 2] = "LOCAL_VIDEO_STREAM_STATE_ENCODING", e[e.LOCAL_VIDEO_STREAM_STATE_FAILED = 3] = "LOCAL_VIDEO_STREAM_STATE_FAILED" }(K || (t.LOCAL_VIDEO_STREAM_STATE = K = {})), function (e) { e[e.LOCAL_VIDEO_STREAM_ERROR_OK = 0] = "LOCAL_VIDEO_STREAM_ERROR_OK", e[e.LOCAL_VIDEO_STREAM_ERROR_FAILURE = 1] = "LOCAL_VIDEO_STREAM_ERROR_FAILURE", e[e.LOCAL_VIDEO_STREAM_ERROR_DEVICE_NO_PERMISSION = 2] = "LOCAL_VIDEO_STREAM_ERROR_DEVICE_NO_PERMISSION", e[e.LOCAL_VIDEO_STREAM_ERROR_DEVICE_BUSY = 3] = "LOCAL_VIDEO_STREAM_ERROR_DEVICE_BUSY", e[e.LOCAL_VIDEO_STREAM_ERROR_CAPTURE_FAILURE = 4] = "LOCAL_VIDEO_STREAM_ERROR_CAPTURE_FAILURE", e[e.LOCAL_VIDEO_STREAM_ERROR_ENCODE_FAILURE = 5] = "LOCAL_VIDEO_STREAM_ERROR_ENCODE_FAILURE", e[e.LOCAL_VIDEO_STREAM_ERROR_CAPTURE_INBACKGROUND = 6] = "LOCAL_VIDEO_STREAM_ERROR_CAPTURE_INBACKGROUND", e[e.LOCAL_VIDEO_STREAM_ERROR_CAPTURE_MULTIPLE_FOREGROUND_APPS = 7] = "LOCAL_VIDEO_STREAM_ERROR_CAPTURE_MULTIPLE_FOREGROUND_APPS", e[e.LOCAL_VIDEO_STREAM_ERROR_DEVICE_NOT_FOUND = 8] = "LOCAL_VIDEO_STREAM_ERROR_DEVICE_NOT_FOUND", e[e.LOCAL_VIDEO_STREAM_ERROR_DEVICE_DISCONNECTED = 9] = "LOCAL_VIDEO_STREAM_ERROR_DEVICE_DISCONNECTED", e[e.LOCAL_VIDEO_STREAM_ERROR_DEVICE_INVALID_ID = 10] = "LOCAL_VIDEO_STREAM_ERROR_DEVICE_INVALID_ID", e[e.LOCAL_VIDEO_STREAM_ERROR_DEVICE_SYSTEM_PRESSURE = 101] = "LOCAL_VIDEO_STREAM_ERROR_DEVICE_SYSTEM_PRESSURE", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_MINIMIZED = 11] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_MINIMIZED", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_CLOSED = 12] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_CLOSED", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_OCCLUDED = 13] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_OCCLUDED", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_NOT_SUPPORTED = 20] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_NOT_SUPPORTED", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_FAILURE = 21] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_FAILURE", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_NO_PERMISSION = 22] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_NO_PERMISSION", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_PAUSED = 23] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_PAUSED", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_RESUMED = 24] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_RESUMED", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_HIDDEN = 25] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_HIDDEN", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_RECOVER_FROM_HIDDEN = 26] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_RECOVER_FROM_HIDDEN", e[e.LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_RECOVER_FROM_MINIMIZED = 27] = "LOCAL_VIDEO_STREAM_ERROR_SCREEN_CAPTURE_WINDOW_RECOVER_FROM_MINIMIZED" }(J || (t.LOCAL_VIDEO_STREAM_ERROR = J = {})), function (e) { e[e.REMOTE_AUDIO_STATE_STOPPED = 0] = "REMOTE_AUDIO_STATE_STOPPED", e[e.REMOTE_AUDIO_STATE_STARTING = 1] = "REMOTE_AUDIO_STATE_STARTING", e[e.REMOTE_AUDIO_STATE_DECODING = 2] = "REMOTE_AUDIO_STATE_DECODING", e[e.REMOTE_AUDIO_STATE_FROZEN = 3] = "REMOTE_AUDIO_STATE_FROZEN", e[e.REMOTE_AUDIO_STATE_FAILED = 4] = "REMOTE_AUDIO_STATE_FAILED" }(X || (t.REMOTE_AUDIO_STATE = X = {})), function (e) { e[e.REMOTE_AUDIO_REASON_INTERNAL = 0] = "REMOTE_AUDIO_REASON_INTERNAL", e[e.REMOTE_AUDIO_REASON_NETWORK_CONGESTION = 1] = "REMOTE_AUDIO_REASON_NETWORK_CONGESTION", e[e.REMOTE_AUDIO_REASON_NETWORK_RECOVERY = 2] = "REMOTE_AUDIO_REASON_NETWORK_RECOVERY", e[e.REMOTE_AUDIO_REASON_LOCAL_MUTED = 3] = "REMOTE_AUDIO_REASON_LOCAL_MUTED", e[e.REMOTE_AUDIO_REASON_LOCAL_UNMUTED = 4] = "REMOTE_AUDIO_REASON_LOCAL_UNMUTED", e[e.REMOTE_AUDIO_REASON_REMOTE_MUTED = 5] = "REMOTE_AUDIO_REASON_REMOTE_MUTED", e[e.REMOTE_AUDIO_REASON_REMOTE_UNMUTED = 6] = "REMOTE_AUDIO_REASON_REMOTE_UNMUTED", e[e.REMOTE_AUDIO_REASON_REMOTE_OFFLINE = 7] = "REMOTE_AUDIO_REASON_REMOTE_OFFLINE" }(q || (t.REMOTE_AUDIO_STATE_REASON = q = {})), function (e) { e[e.REMOTE_VIDEO_STATE_STOPPED = 0] = "REMOTE_VIDEO_STATE_STOPPED", e[e.REMOTE_VIDEO_STATE_STARTING = 1] = "REMOTE_VIDEO_STATE_STARTING", e[e.REMOTE_VIDEO_STATE_DECODING = 2] = "REMOTE_VIDEO_STATE_DECODING", e[e.REMOTE_VIDEO_STATE_FROZEN = 3] = "REMOTE_VIDEO_STATE_FROZEN", e[e.REMOTE_VIDEO_STATE_FAILED = 4] = "REMOTE_VIDEO_STATE_FAILED" }(Q || (t.REMOTE_VIDEO_STATE = Q = {})), function (e) { e[e.REMOTE_VIDEO_STATE_REASON_INTERNAL = 0] = "REMOTE_VIDEO_STATE_REASON_INTERNAL", e[e.REMOTE_VIDEO_STATE_REASON_NETWORK_CONGESTION = 1] = "REMOTE_VIDEO_STATE_REASON_NETWORK_CONGESTION", e[e.REMOTE_VIDEO_STATE_REASON_NETWORK_RECOVERY = 2] = "REMOTE_VIDEO_STATE_REASON_NETWORK_RECOVERY", e[e.REMOTE_VIDEO_STATE_REASON_LOCAL_MUTED = 3] = "REMOTE_VIDEO_STATE_REASON_LOCAL_MUTED", e[e.REMOTE_VIDEO_STATE_REASON_LOCAL_UNMUTED = 4] = "REMOTE_VIDEO_STATE_REASON_LOCAL_UNMUTED", e[e.REMOTE_VIDEO_STATE_REASON_REMOTE_MUTED = 5] = "REMOTE_VIDEO_STATE_REASON_REMOTE_MUTED", e[e.REMOTE_VIDEO_STATE_REASON_REMOTE_UNMUTED = 6] = "REMOTE_VIDEO_STATE_REASON_REMOTE_UNMUTED", e[e.REMOTE_VIDEO_STATE_REASON_REMOTE_OFFLINE = 7] = "REMOTE_VIDEO_STATE_REASON_REMOTE_OFFLINE", e[e.REMOTE_VIDEO_STATE_REASON_AUDIO_FALLBACK = 8] = "REMOTE_VIDEO_STATE_REASON_AUDIO_FALLBACK", e[e.REMOTE_VIDEO_STATE_REASON_AUDIO_FALLBACK_RECOVERY = 9] = "REMOTE_VIDEO_STATE_REASON_AUDIO_FALLBACK_RECOVERY", e[e.REMOTE_VIDEO_STATE_REASON_VIDEO_STREAM_TYPE_CHANGE_TO_LOW = 10] = "REMOTE_VIDEO_STATE_REASON_VIDEO_STREAM_TYPE_CHANGE_TO_LOW", e[e.REMOTE_VIDEO_STATE_REASON_VIDEO_STREAM_TYPE_CHANGE_TO_HIGH = 11] = "REMOTE_VIDEO_STATE_REASON_VIDEO_STREAM_TYPE_CHANGE_TO_HIGH", e[e.REMOTE_VIDEO_STATE_REASON_SDK_IN_BACKGROUND = 12] = "REMOTE_VIDEO_STATE_REASON_SDK_IN_BACKGROUND", e[e.REMOTE_VIDEO_STATE_REASON_CODEC_NOT_SUPPORT = 13] = "REMOTE_VIDEO_STATE_REASON_CODEC_NOT_SUPPORT" }(z || (t.REMOTE_VIDEO_STATE_REASON = z = {})), function (e) { e[e.USER_STATE_MUTE_AUDIO = 1] = "USER_STATE_MUTE_AUDIO", e[e.USER_STATE_MUTE_VIDEO = 2] = "USER_STATE_MUTE_VIDEO", e[e.USER_STATE_ENABLE_VIDEO = 16] = "USER_STATE_ENABLE_VIDEO", e[e.USER_STATE_ENABLE_LOCAL_VIDEO = 256] = "USER_STATE_ENABLE_LOCAL_VIDEO" }(Z || (t.REMOTE_USER_STATE = Z = {})); t.VideoTrackInfo = class { }, function (e) { e[e.REMOTE_VIDEO_DOWNSCALE_LEVEL_NONE = 0] = "REMOTE_VIDEO_DOWNSCALE_LEVEL_NONE", e[e.REMOTE_VIDEO_DOWNSCALE_LEVEL_1 = 1] = "REMOTE_VIDEO_DOWNSCALE_LEVEL_1", e[e.REMOTE_VIDEO_DOWNSCALE_LEVEL_2 = 2] = "REMOTE_VIDEO_DOWNSCALE_LEVEL_2", e[e.REMOTE_VIDEO_DOWNSCALE_LEVEL_3 = 3] = "REMOTE_VIDEO_DOWNSCALE_LEVEL_3", e[e.REMOTE_VIDEO_DOWNSCALE_LEVEL_4 = 4] = "REMOTE_VIDEO_DOWNSCALE_LEVEL_4" }($ || (t.REMOTE_VIDEO_DOWNSCALE_LEVEL = $ = {})); t.AudioVolumeInfo = class { }; t.DeviceInfo = class { }; t.Packet = class { }, function (e) { e[e.AUDIO_SAMPLE_RATE_32000 = 32e3] = "AUDIO_SAMPLE_RATE_32000", e[e.AUDIO_SAMPLE_RATE_44100 = 44100] = "AUDIO_SAMPLE_RATE_44100", e[e.AUDIO_SAMPLE_RATE_48000 = 48e3] = "AUDIO_SAMPLE_RATE_48000" }(ee || (t.AUDIO_SAMPLE_RATE_TYPE = ee = {})), function (e) { e[e.VIDEO_CODEC_H264_FOR_STREAM = 1] = "VIDEO_CODEC_H264_FOR_STREAM", e[e.VIDEO_CODEC_H265_FOR_STREAM = 2] = "VIDEO_CODEC_H265_FOR_STREAM" }(te || (t.VIDEO_CODEC_TYPE_FOR_STREAM = te = {})), function (e) { e[e.VIDEO_CODEC_PROFILE_BASELINE = 66] = "VIDEO_CODEC_PROFILE_BASELINE", e[e.VIDEO_CODEC_PROFILE_MAIN = 77] = "VIDEO_CODEC_PROFILE_MAIN", e[e.VIDEO_CODEC_PROFILE_HIGH = 100] = "VIDEO_CODEC_PROFILE_HIGH" }(ne || (t.VIDEO_CODEC_PROFILE_TYPE = ne = {})), function (e) { e[e.AUDIO_CODEC_PROFILE_LC_AAC = 0] = "AUDIO_CODEC_PROFILE_LC_AAC", e[e.AUDIO_CODEC_PROFILE_HE_AAC = 1] = "AUDIO_CODEC_PROFILE_HE_AAC", e[e.AUDIO_CODEC_PROFILE_HE_AAC_V2 = 2] = "AUDIO_CODEC_PROFILE_HE_AAC_V2" }(ie || (t.AUDIO_CODEC_PROFILE_TYPE = ie = {})); t.LocalAudioStats = class { }, function (e) { e[e.RTMP_STREAM_PUBLISH_STATE_IDLE = 0] = "RTMP_STREAM_PUBLISH_STATE_IDLE", e[e.RTMP_STREAM_PUBLISH_STATE_CONNECTING = 1] = "RTMP_STREAM_PUBLISH_STATE_CONNECTING", e[e.RTMP_STREAM_PUBLISH_STATE_RUNNING = 2] = "RTMP_STREAM_PUBLISH_STATE_RUNNING", e[e.RTMP_STREAM_PUBLISH_STATE_RECOVERING = 3] = "RTMP_STREAM_PUBLISH_STATE_RECOVERING", e[e.RTMP_STREAM_PUBLISH_STATE_FAILURE = 4] = "RTMP_STREAM_PUBLISH_STATE_FAILURE", e[e.RTMP_STREAM_PUBLISH_STATE_DISCONNECTING = 5] = "RTMP_STREAM_PUBLISH_STATE_DISCONNECTING" }(re || (t.RTMP_STREAM_PUBLISH_STATE = re = {})), function (e) { e[e.RTMP_STREAM_PUBLISH_ERROR_OK = 0] = "RTMP_STREAM_PUBLISH_ERROR_OK", e[e.RTMP_STREAM_PUBLISH_ERROR_INVALID_ARGUMENT = 1] = "RTMP_STREAM_PUBLISH_ERROR_INVALID_ARGUMENT", e[e.RTMP_STREAM_PUBLISH_ERROR_ENCRYPTED_STREAM_NOT_ALLOWED = 2] = "RTMP_STREAM_PUBLISH_ERROR_ENCRYPTED_STREAM_NOT_ALLOWED", e[e.RTMP_STREAM_PUBLISH_ERROR_CONNECTION_TIMEOUT = 3] = "RTMP_STREAM_PUBLISH_ERROR_CONNECTION_TIMEOUT", e[e.RTMP_STREAM_PUBLISH_ERROR_INTERNAL_SERVER_ERROR = 4] = "RTMP_STREAM_PUBLISH_ERROR_INTERNAL_SERVER_ERROR", e[e.RTMP_STREAM_PUBLISH_ERROR_RTMP_SERVER_ERROR = 5] = "RTMP_STREAM_PUBLISH_ERROR_RTMP_SERVER_ERROR", e[e.RTMP_STREAM_PUBLISH_ERROR_TOO_OFTEN = 6] = "RTMP_STREAM_PUBLISH_ERROR_TOO_OFTEN", e[e.RTMP_STREAM_PUBLISH_ERROR_REACH_LIMIT = 7] = "RTMP_STREAM_PUBLISH_ERROR_REACH_LIMIT", e[e.RTMP_STREAM_PUBLISH_ERROR_NOT_AUTHORIZED = 8] = "RTMP_STREAM_PUBLISH_ERROR_NOT_AUTHORIZED", e[e.RTMP_STREAM_PUBLISH_ERROR_STREAM_NOT_FOUND = 9] = "RTMP_STREAM_PUBLISH_ERROR_STREAM_NOT_FOUND", e[e.RTMP_STREAM_PUBLISH_ERROR_FORMAT_NOT_SUPPORTED = 10] = "RTMP_STREAM_PUBLISH_ERROR_FORMAT_NOT_SUPPORTED", e[e.RTMP_STREAM_PUBLISH_ERROR_NOT_BROADCASTER = 11] = "RTMP_STREAM_PUBLISH_ERROR_NOT_BROADCASTER", e[e.RTMP_STREAM_PUBLISH_ERROR_TRANSCODING_NO_MIX_STREAM = 13] = "RTMP_STREAM_PUBLISH_ERROR_TRANSCODING_NO_MIX_STREAM", e[e.RTMP_STREAM_PUBLISH_ERROR_NET_DOWN = 14] = "RTMP_STREAM_PUBLISH_ERROR_NET_DOWN", e[e.RTMP_STREAM_PUBLISH_ERROR_INVALID_APPID = 15] = "RTMP_STREAM_PUBLISH_ERROR_INVALID_APPID", e[e.RTMP_STREAM_PUBLISH_ERROR_INVALID_PRIVILEGE = 16] = "RTMP_STREAM_PUBLISH_ERROR_INVALID_PRIVILEGE", e[e.RTMP_STREAM_UNPUBLISH_ERROR_OK = 100] = "RTMP_STREAM_UNPUBLISH_ERROR_OK" }(oe || (t.RTMP_STREAM_PUBLISH_ERROR_TYPE = oe = {})), function (e) { e[e.RTMP_STREAMING_EVENT_FAILED_LOAD_IMAGE = 1] = "RTMP_STREAMING_EVENT_FAILED_LOAD_IMAGE", e[e.RTMP_STREAMING_EVENT_URL_ALREADY_IN_USE = 2] = "RTMP_STREAMING_EVENT_URL_ALREADY_IN_USE", e[e.RTMP_STREAMING_EVENT_ADVANCED_FEATURE_NOT_SUPPORT = 3] = "RTMP_STREAMING_EVENT_ADVANCED_FEATURE_NOT_SUPPORT", e[e.RTMP_STREAMING_EVENT_REQUEST_TOO_OFTEN = 4] = "RTMP_STREAMING_EVENT_REQUEST_TOO_OFTEN" }(se || (t.RTMP_STREAMING_EVENT = se = {})); t.RtcImage = class { }; t.LiveStreamAdvancedFeature = class { }, function (e) { e[e.CONNECTION_STATE_DISCONNECTED = 1] = "CONNECTION_STATE_DISCONNECTED", e[e.CONNECTION_STATE_CONNECTING = 2] = "CONNECTION_STATE_CONNECTING", e[e.CONNECTION_STATE_CONNECTED = 3] = "CONNECTION_STATE_CONNECTED", e[e.CONNECTION_STATE_RECONNECTING = 4] = "CONNECTION_STATE_RECONNECTING", e[e.CONNECTION_STATE_FAILED = 5] = "CONNECTION_STATE_FAILED" }(ae || (t.CONNECTION_STATE_TYPE = ae = {})); t.TranscodingUser = class { }; t.LiveTranscoding = class { }; t.TranscodingVideoStream = class { }; t.LocalTranscoderConfiguration = class { }, function (e) { e[e.VT_ERR_OK = 0] = "VT_ERR_OK", e[e.VT_ERR_VIDEO_SOURCE_NOT_READY = 1] = "VT_ERR_VIDEO_SOURCE_NOT_READY", e[e.VT_ERR_INVALID_VIDEO_SOURCE_TYPE = 2] = "VT_ERR_INVALID_VIDEO_SOURCE_TYPE", e[e.VT_ERR_INVALID_IMAGE_PATH = 3] = "VT_ERR_INVALID_IMAGE_PATH", e[e.VT_ERR_UNSUPPORT_IMAGE_FORMAT = 4] = "VT_ERR_UNSUPPORT_IMAGE_FORMAT", e[e.VT_ERR_INVALID_LAYOUT = 5] = "VT_ERR_INVALID_LAYOUT", e[e.VT_ERR_INTERNAL = 20] = "VT_ERR_INTERNAL" }(ce || (t.VIDEO_TRANSCODER_ERROR = ce = {})); t.LastmileProbeConfig = class { }, function (e) { e[e.LASTMILE_PROBE_RESULT_COMPLETE = 1] = "LASTMILE_PROBE_RESULT_COMPLETE", e[e.LASTMILE_PROBE_RESULT_INCOMPLETE_NO_BWE = 2] = "LASTMILE_PROBE_RESULT_INCOMPLETE_NO_BWE", e[e.LASTMILE_PROBE_RESULT_UNAVAILABLE = 3] = "LASTMILE_PROBE_RESULT_UNAVAILABLE" }(Ee || (t.LASTMILE_PROBE_RESULT_STATE = Ee = {})); t.LastmileProbeOneWayResult = class { }; t.LastmileProbeResult = class { }, function (e) { e[e.CONNECTION_CHANGED_CONNECTING = 0] = "CONNECTION_CHANGED_CONNECTING", e[e.CONNECTION_CHANGED_JOIN_SUCCESS = 1] = "CONNECTION_CHANGED_JOIN_SUCCESS", e[e.CONNECTION_CHANGED_INTERRUPTED = 2] = "CONNECTION_CHANGED_INTERRUPTED", e[e.CONNECTION_CHANGED_BANNED_BY_SERVER = 3] = "CONNECTION_CHANGED_BANNED_BY_SERVER", e[e.CONNECTION_CHANGED_JOIN_FAILED = 4] = "CONNECTION_CHANGED_JOIN_FAILED", e[e.CONNECTION_CHANGED_LEAVE_CHANNEL = 5] = "CONNECTION_CHANGED_LEAVE_CHANNEL", e[e.CONNECTION_CHANGED_INVALID_APP_ID = 6] = "CONNECTION_CHANGED_INVALID_APP_ID", e[e.CONNECTION_CHANGED_INVALID_CHANNEL_NAME = 7] = "CONNECTION_CHANGED_INVALID_CHANNEL_NAME", e[e.CONNECTION_CHANGED_INVALID_TOKEN = 8] = "CONNECTION_CHANGED_INVALID_TOKEN", e[e.CONNECTION_CHANGED_TOKEN_EXPIRED = 9] = "CONNECTION_CHANGED_TOKEN_EXPIRED", e[e.CONNECTION_CHANGED_REJECTED_BY_SERVER = 10] = "CONNECTION_CHANGED_REJECTED_BY_SERVER", e[e.CONNECTION_CHANGED_SETTING_PROXY_SERVER = 11] = "CONNECTION_CHANGED_SETTING_PROXY_SERVER", e[e.CONNECTION_CHANGED_RENEW_TOKEN = 12] = "CONNECTION_CHANGED_RENEW_TOKEN", e[e.CONNECTION_CHANGED_CLIENT_IP_ADDRESS_CHANGED = 13] = "CONNECTION_CHANGED_CLIENT_IP_ADDRESS_CHANGED", e[e.CONNECTION_CHANGED_KEEP_ALIVE_TIMEOUT = 14] = "CONNECTION_CHANGED_KEEP_ALIVE_TIMEOUT", e[e.CONNECTION_CHANGED_REJOIN_SUCCESS = 15] = "CONNECTION_CHANGED_REJOIN_SUCCESS", e[e.CONNECTION_CHANGED_LOST = 16] = "CONNECTION_CHANGED_LOST", e[e.CONNECTION_CHANGED_ECHO_TEST = 17] = "CONNECTION_CHANGED_ECHO_TEST", e[e.CONNECTION_CHANGED_CLIENT_IP_ADDRESS_CHANGED_BY_USER = 18] = "CONNECTION_CHANGED_CLIENT_IP_ADDRESS_CHANGED_BY_USER", e[e.CONNECTION_CHANGED_SAME_UID_LOGIN = 19] = "CONNECTION_CHANGED_SAME_UID_LOGIN", e[e.CONNECTION_CHANGED_TOO_MANY_BROADCASTERS = 20] = "CONNECTION_CHANGED_TOO_MANY_BROADCASTERS", e[e.CONNECTION_CHANGED_LICENSE_VALIDATION_FAILURE = 21] = "CONNECTION_CHANGED_LICENSE_VALIDATION_FAILURE", e[e.CONNECTION_CHANGED_CERTIFICATION_VERYFY_FAILURE = 22] = "CONNECTION_CHANGED_CERTIFICATION_VERYFY_FAILURE" }(_e || (t.CONNECTION_CHANGED_REASON_TYPE = _e = {})), function (e) { e[e.CLIENT_ROLE_CHANGE_FAILED_TOO_MANY_BROADCASTERS = 1] = "CLIENT_ROLE_CHANGE_FAILED_TOO_MANY_BROADCASTERS", e[e.CLIENT_ROLE_CHANGE_FAILED_NOT_AUTHORIZED = 2] = "CLIENT_ROLE_CHANGE_FAILED_NOT_AUTHORIZED", e[e.CLIENT_ROLE_CHANGE_FAILED_REQUEST_TIME_OUT = 3] = "CLIENT_ROLE_CHANGE_FAILED_REQUEST_TIME_OUT", e[e.CLIENT_ROLE_CHANGE_FAILED_CONNECTION_FAILED = 4] = "CLIENT_ROLE_CHANGE_FAILED_CONNECTION_FAILED" }(de || (t.CLIENT_ROLE_CHANGE_FAILED_REASON = de = {})), function (e) { e[e.WLACC_MESSAGE_REASON_WEAK_SIGNAL = 0] = "WLACC_MESSAGE_REASON_WEAK_SIGNAL", e[e.WLACC_MESSAGE_REASON_CHANNEL_CONGESTION = 1] = "WLACC_MESSAGE_REASON_CHANNEL_CONGESTION" }(ue || (t.WLACC_MESSAGE_REASON = ue = {})), function (e) { e[e.WLACC_SUGGEST_ACTION_CLOSE_TO_WIFI = 0] = "WLACC_SUGGEST_ACTION_CLOSE_TO_WIFI", e[e.WLACC_SUGGEST_ACTION_CONNECT_SSID = 1] = "WLACC_SUGGEST_ACTION_CONNECT_SSID", e[e.WLACC_SUGGEST_ACTION_CHECK_5G = 2] = "WLACC_SUGGEST_ACTION_CHECK_5G", e[e.WLACC_SUGGEST_ACTION_MODIFY_SSID = 3] = "WLACC_SUGGEST_ACTION_MODIFY_SSID" }(le || (t.WLACC_SUGGEST_ACTION = le = {})); t.WlAccStats = class { }, function (e) { e[e.NETWORK_TYPE_UNKNOWN = -1] = "NETWORK_TYPE_UNKNOWN", e[e.NETWORK_TYPE_DISCONNECTED = 0] = "NETWORK_TYPE_DISCONNECTED", e[e.NETWORK_TYPE_LAN = 1] = "NETWORK_TYPE_LAN", e[e.NETWORK_TYPE_WIFI = 2] = "NETWORK_TYPE_WIFI", e[e.NETWORK_TYPE_MOBILE_2G = 3] = "NETWORK_TYPE_MOBILE_2G", e[e.NETWORK_TYPE_MOBILE_3G = 4] = "NETWORK_TYPE_MOBILE_3G", e[e.NETWORK_TYPE_MOBILE_4G = 5] = "NETWORK_TYPE_MOBILE_4G", e[e.NETWORK_TYPE_MOBILE_5G = 6] = "NETWORK_TYPE_MOBILE_5G" }(Re || (t.NETWORK_TYPE = Re = {})), function (e) { e[e.VIDEO_VIEW_SETUP_REPLACE = 0] = "VIDEO_VIEW_SETUP_REPLACE", e[e.VIDEO_VIEW_SETUP_ADD = 1] = "VIDEO_VIEW_SETUP_ADD", e[e.VIDEO_VIEW_SETUP_REMOVE = 2] = "VIDEO_VIEW_SETUP_REMOVE" }(he || (t.VIDEO_VIEW_SETUP_MODE = he = {})); t.VideoCanvas = class { }, function (e) { e[e.LIGHTENING_CONTRAST_LOW = 0] = "LIGHTENING_CONTRAST_LOW", e[e.LIGHTENING_CONTRAST_NORMAL = 1] = "LIGHTENING_CONTRAST_NORMAL", e[e.LIGHTENING_CONTRAST_HIGH = 2] = "LIGHTENING_CONTRAST_HIGH" }(pe || (t.LIGHTENING_CONTRAST_LEVEL = pe = {})); t.BeautyOptions = class { }, function (e) { e[e.LOW_LIGHT_ENHANCE_AUTO = 0] = "LOW_LIGHT_ENHANCE_AUTO", e[e.LOW_LIGHT_ENHANCE_MANUAL = 1] = "LOW_LIGHT_ENHANCE_MANUAL" }(Te || (t.LOW_LIGHT_ENHANCE_MODE = Te = {})), function (e) { e[e.LOW_LIGHT_ENHANCE_LEVEL_HIGH_QUALITY = 0] = "LOW_LIGHT_ENHANCE_LEVEL_HIGH_QUALITY", e[e.LOW_LIGHT_ENHANCE_LEVEL_FAST = 1] = "LOW_LIGHT_ENHANCE_LEVEL_FAST" }(Oe || (t.LOW_LIGHT_ENHANCE_LEVEL = Oe = {})); t.LowlightEnhanceOptions = class { }, function (e) { e[e.VIDEO_DENOISER_AUTO = 0] = "VIDEO_DENOISER_AUTO", e[e.VIDEO_DENOISER_MANUAL = 1] = "VIDEO_DENOISER_MANUAL" }(Ce || (t.VIDEO_DENOISER_MODE = Ce = {})), function (e) { e[e.VIDEO_DENOISER_LEVEL_HIGH_QUALITY = 0] = "VIDEO_DENOISER_LEVEL_HIGH_QUALITY", e[e.VIDEO_DENOISER_LEVEL_FAST = 1] = "VIDEO_DENOISER_LEVEL_FAST", e[e.VIDEO_DENOISER_LEVEL_STRENGTH = 2] = "VIDEO_DENOISER_LEVEL_STRENGTH" }(Ae || (t.VIDEO_DENOISER_LEVEL = Ae = {})); t.VideoDenoiserOptions = class { }; t.ColorEnhanceOptions = class { }, function (e) { e[e.BACKGROUND_NONE = 0] = "BACKGROUND_NONE", e[e.BACKGROUND_COLOR = 1] = "BACKGROUND_COLOR", e[e.BACKGROUND_IMG = 2] = "BACKGROUND_IMG", e[e.BACKGROUND_BLUR = 3] = "BACKGROUND_BLUR", e[e.BACKGROUND_VIDEO = 4] = "BACKGROUND_VIDEO" }(Se || (t.BACKGROUND_SOURCE_TYPE = Se = {})), function (e) { e[e.BLUR_DEGREE_LOW = 1] = "BLUR_DEGREE_LOW", e[e.BLUR_DEGREE_MEDIUM = 2] = "BLUR_DEGREE_MEDIUM", e[e.BLUR_DEGREE_HIGH = 3] = "BLUR_DEGREE_HIGH" }(ge || (t.BACKGROUND_BLUR_DEGREE = ge = {})); t.VirtualBackgroundSource = class { }, function (e) { e[e.SEG_MODEL_AI = 1] = "SEG_MODEL_AI", e[e.SEG_MODEL_GREEN = 2] = "SEG_MODEL_GREEN" }(me || (t.SEG_MODEL_TYPE = me = {})); t.SegmentationProperty = class { }, function (e) { e[e.AUDIO_TRACK_INVALID = -1] = "AUDIO_TRACK_INVALID", e[e.AUDIO_TRACK_MIXABLE = 0] = "AUDIO_TRACK_MIXABLE", e[e.AUDIO_TRACK_DIRECT = 1] = "AUDIO_TRACK_DIRECT" }(Ie || (t.AUDIO_TRACK_TYPE = Ie = {})); t.AudioTrackConfig = class { }, function (e) { e[e.VOICE_BEAUTIFIER_OFF = 0] = "VOICE_BEAUTIFIER_OFF", e[e.CHAT_BEAUTIFIER_MAGNETIC = 16843008] = "CHAT_BEAUTIFIER_MAGNETIC", e[e.CHAT_BEAUTIFIER_FRESH = 16843264] = "CHAT_BEAUTIFIER_FRESH", e[e.CHAT_BEAUTIFIER_VITALITY = 16843520] = "CHAT_BEAUTIFIER_VITALITY", e[e.SINGING_BEAUTIFIER = 16908544] = "SINGING_BEAUTIFIER", e[e.TIMBRE_TRANSFORMATION_VIGOROUS = 16974080] = "TIMBRE_TRANSFORMATION_VIGOROUS", e[e.TIMBRE_TRANSFORMATION_DEEP = 16974336] = "TIMBRE_TRANSFORMATION_DEEP", e[e.TIMBRE_TRANSFORMATION_MELLOW = 16974592] = "TIMBRE_TRANSFORMATION_MELLOW", e[e.TIMBRE_TRANSFORMATION_FALSETTO = 16974848] = "TIMBRE_TRANSFORMATION_FALSETTO", e[e.TIMBRE_TRANSFORMATION_FULL = 16975104] = "TIMBRE_TRANSFORMATION_FULL", e[e.TIMBRE_TRANSFORMATION_CLEAR = 16975360] = "TIMBRE_TRANSFORMATION_CLEAR", e[e.TIMBRE_TRANSFORMATION_RESOUNDING = 16975616] = "TIMBRE_TRANSFORMATION_RESOUNDING", e[e.TIMBRE_TRANSFORMATION_RINGING = 16975872] = "TIMBRE_TRANSFORMATION_RINGING", e[e.ULTRA_HIGH_QUALITY_VOICE = 17039616] = "ULTRA_HIGH_QUALITY_VOICE" }(fe || (t.VOICE_BEAUTIFIER_PRESET = fe = {})), function (e) { e[e.AUDIO_EFFECT_OFF = 0] = "AUDIO_EFFECT_OFF", e[e.ROOM_ACOUSTICS_KTV = 33620224] = "ROOM_ACOUSTICS_KTV", e[e.ROOM_ACOUSTICS_VOCAL_CONCERT = 33620480] = "ROOM_ACOUSTICS_VOCAL_CONCERT", e[e.ROOM_ACOUSTICS_STUDIO = 33620736] = "ROOM_ACOUSTICS_STUDIO", e[e.ROOM_ACOUSTICS_PHONOGRAPH = 33620992] = "ROOM_ACOUSTICS_PHONOGRAPH", e[e.ROOM_ACOUSTICS_VIRTUAL_STEREO = 33621248] = "ROOM_ACOUSTICS_VIRTUAL_STEREO", e[e.ROOM_ACOUSTICS_SPACIAL = 33621504] = "ROOM_ACOUSTICS_SPACIAL", e[e.ROOM_ACOUSTICS_ETHEREAL = 33621760] = "ROOM_ACOUSTICS_ETHEREAL", e[e.ROOM_ACOUSTICS_3D_VOICE = 33622016] = "ROOM_ACOUSTICS_3D_VOICE", e[e.ROOM_ACOUSTICS_VIRTUAL_SURROUND_SOUND = 33622272] = "ROOM_ACOUSTICS_VIRTUAL_SURROUND_SOUND", e[e.VOICE_CHANGER_EFFECT_UNCLE = 33685760] = "VOICE_CHANGER_EFFECT_UNCLE", e[e.VOICE_CHANGER_EFFECT_OLDMAN = 33686016] = "VOICE_CHANGER_EFFECT_OLDMAN", e[e.VOICE_CHANGER_EFFECT_BOY = 33686272] = "VOICE_CHANGER_EFFECT_BOY", e[e.VOICE_CHANGER_EFFECT_SISTER = 33686528] = "VOICE_CHANGER_EFFECT_SISTER", e[e.VOICE_CHANGER_EFFECT_GIRL = 33686784] = "VOICE_CHANGER_EFFECT_GIRL", e[e.VOICE_CHANGER_EFFECT_PIGKING = 33687040] = "VOICE_CHANGER_EFFECT_PIGKING", e[e.VOICE_CHANGER_EFFECT_HULK = 33687296] = "VOICE_CHANGER_EFFECT_HULK", e[e.STYLE_TRANSFORMATION_RNB = 33751296] = "STYLE_TRANSFORMATION_RNB", e[e.STYLE_TRANSFORMATION_POPULAR = 33751552] = "STYLE_TRANSFORMATION_POPULAR", e[e.PITCH_CORRECTION = 33816832] = "PITCH_CORRECTION" }(Pe || (t.AUDIO_EFFECT_PRESET = Pe = {})), function (e) { e[e.VOICE_CONVERSION_OFF = 0] = "VOICE_CONVERSION_OFF", e[e.VOICE_CHANGER_NEUTRAL = 50397440] = "VOICE_CHANGER_NEUTRAL", e[e.VOICE_CHANGER_SWEET = 50397696] = "VOICE_CHANGER_SWEET", e[e.VOICE_CHANGER_SOLID = 50397952] = "VOICE_CHANGER_SOLID", e[e.VOICE_CHANGER_BASS = 50398208] = "VOICE_CHANGER_BASS", e[e.VOICE_CHANGER_CARTOON = 50398464] = "VOICE_CHANGER_CARTOON", e[e.VOICE_CHANGER_CHILDLIKE = 50398720] = "VOICE_CHANGER_CHILDLIKE", e[e.VOICE_CHANGER_PHONE_OPERATOR = 50398976] = "VOICE_CHANGER_PHONE_OPERATOR", e[e.VOICE_CHANGER_MONSTER = 50399232] = "VOICE_CHANGER_MONSTER", e[e.VOICE_CHANGER_TRANSFORMERS = 50399488] = "VOICE_CHANGER_TRANSFORMERS", e[e.VOICE_CHANGER_GROOT = 50399744] = "VOICE_CHANGER_GROOT", e[e.VOICE_CHANGER_DARTH_VADER = 504e5] = "VOICE_CHANGER_DARTH_VADER", e[e.VOICE_CHANGER_IRON_LADY = 50400256] = "VOICE_CHANGER_IRON_LADY", e[e.VOICE_CHANGER_SHIN_CHAN = 50400512] = "VOICE_CHANGER_SHIN_CHAN", e[e.VOICE_CHANGER_GIRLISH_MAN = 50400768] = "VOICE_CHANGER_GIRLISH_MAN", e[e.VOICE_CHANGER_CHIPMUNK = 50401024] = "VOICE_CHANGER_CHIPMUNK" }(Ne || (t.VOICE_CONVERSION_PRESET = Ne = {})), function (e) { e[e.HEADPHONE_EQUALIZER_OFF = 0] = "HEADPHONE_EQUALIZER_OFF", e[e.HEADPHONE_EQUALIZER_OVEREAR = 67108865] = "HEADPHONE_EQUALIZER_OVEREAR", e[e.HEADPHONE_EQUALIZER_INEAR = 67108866] = "HEADPHONE_EQUALIZER_INEAR" }(De || (t.HEADPHONE_EQUALIZER_PRESET = De = {})); t.ScreenCaptureParameters = class { }, function (e) { e[e.AUDIO_RECORDING_QUALITY_LOW = 0] = "AUDIO_RECORDING_QUALITY_LOW", e[e.AUDIO_RECORDING_QUALITY_MEDIUM = 1] = "AUDIO_RECORDING_QUALITY_MEDIUM", e[e.AUDIO_RECORDING_QUALITY_HIGH = 2] = "AUDIO_RECORDING_QUALITY_HIGH", e[e.AUDIO_RECORDING_QUALITY_ULTRA_HIGH = 3] = "AUDIO_RECORDING_QUALITY_ULTRA_HIGH" }(ve || (t.AUDIO_RECORDING_QUALITY_TYPE = ve = {})), function (e) { e[e.AUDIO_FILE_RECORDING_MIC = 1] = "AUDIO_FILE_RECORDING_MIC", e[e.AUDIO_FILE_RECORDING_PLAYBACK = 2] = "AUDIO_FILE_RECORDING_PLAYBACK", e[e.AUDIO_FILE_RECORDING_MIXED = 3] = "AUDIO_FILE_RECORDING_MIXED" }(ye || (t.AUDIO_FILE_RECORDING_TYPE = ye = {})), function (e) { e[e.AUDIO_ENCODED_FRAME_OBSERVER_POSITION_RECORD = 1] = "AUDIO_ENCODED_FRAME_OBSERVER_POSITION_RECORD", e[e.AUDIO_ENCODED_FRAME_OBSERVER_POSITION_PLAYBACK = 2] = "AUDIO_ENCODED_FRAME_OBSERVER_POSITION_PLAYBACK", e[e.AUDIO_ENCODED_FRAME_OBSERVER_POSITION_MIXED = 3] = "AUDIO_ENCODED_FRAME_OBSERVER_POSITION_MIXED" }(Le || (t.AUDIO_ENCODED_FRAME_OBSERVER_POSITION = Le = {})); t.AudioRecordingConfiguration = class { }; t.AudioEncodedFrameObserverConfig = class { }, function (e) { e[e.AREA_CODE_CN = 1] = "AREA_CODE_CN", e[e.AREA_CODE_NA = 2] = "AREA_CODE_NA", e[e.AREA_CODE_EU = 4] = "AREA_CODE_EU", e[e.AREA_CODE_AS = 8] = "AREA_CODE_AS", e[e.AREA_CODE_JP = 16] = "AREA_CODE_JP", e[e.AREA_CODE_IN = 32] = "AREA_CODE_IN", e[e.AREA_CODE_GLOB = 4294967295] = "AREA_CODE_GLOB" }(we || (t.AREA_CODE = we = {})), function (e) { e[e.AREA_CODE_OC = 64] = "AREA_CODE_OC", e[e.AREA_CODE_SA = 128] = "AREA_CODE_SA", e[e.AREA_CODE_AF = 256] = "AREA_CODE_AF", e[e.AREA_CODE_KR = 512] = "AREA_CODE_KR", e[e.AREA_CODE_HKMC = 1024] = "AREA_CODE_HKMC", e[e.AREA_CODE_US = 2048] = "AREA_CODE_US", e[e.AREA_CODE_OVS = 4294967294] = "AREA_CODE_OVS" }(be || (t.AREA_CODE_EX = be = {})), function (e) { e[e.RELAY_OK = 0] = "RELAY_OK", e[e.RELAY_ERROR_SERVER_ERROR_RESPONSE = 1] = "RELAY_ERROR_SERVER_ERROR_RESPONSE", e[e.RELAY_ERROR_SERVER_NO_RESPONSE = 2] = "RELAY_ERROR_SERVER_NO_RESPONSE", e[e.RELAY_ERROR_NO_RESOURCE_AVAILABLE = 3] = "RELAY_ERROR_NO_RESOURCE_AVAILABLE", e[e.RELAY_ERROR_FAILED_JOIN_SRC = 4] = "RELAY_ERROR_FAILED_JOIN_SRC", e[e.RELAY_ERROR_FAILED_JOIN_DEST = 5] = "RELAY_ERROR_FAILED_JOIN_DEST", e[e.RELAY_ERROR_FAILED_PACKET_RECEIVED_FROM_SRC = 6] = "RELAY_ERROR_FAILED_PACKET_RECEIVED_FROM_SRC", e[e.RELAY_ERROR_FAILED_PACKET_SENT_TO_DEST = 7] = "RELAY_ERROR_FAILED_PACKET_SENT_TO_DEST", e[e.RELAY_ERROR_SERVER_CONNECTION_LOST = 8] = "RELAY_ERROR_SERVER_CONNECTION_LOST", e[e.RELAY_ERROR_INTERNAL_ERROR = 9] = "RELAY_ERROR_INTERNAL_ERROR", e[e.RELAY_ERROR_SRC_TOKEN_EXPIRED = 10] = "RELAY_ERROR_SRC_TOKEN_EXPIRED", e[e.RELAY_ERROR_DEST_TOKEN_EXPIRED = 11] = "RELAY_ERROR_DEST_TOKEN_EXPIRED" }(Ue || (t.CHANNEL_MEDIA_RELAY_ERROR = Ue = {})), function (e) { e[e.RELAY_EVENT_NETWORK_DISCONNECTED = 0] = "RELAY_EVENT_NETWORK_DISCONNECTED", e[e.RELAY_EVENT_NETWORK_CONNECTED = 1] = "RELAY_EVENT_NETWORK_CONNECTED", e[e.RELAY_EVENT_PACKET_JOINED_SRC_CHANNEL = 2] = "RELAY_EVENT_PACKET_JOINED_SRC_CHANNEL", e[e.RELAY_EVENT_PACKET_JOINED_DEST_CHANNEL = 3] = "RELAY_EVENT_PACKET_JOINED_DEST_CHANNEL", e[e.RELAY_EVENT_PACKET_SENT_TO_DEST_CHANNEL = 4] = "RELAY_EVENT_PACKET_SENT_TO_DEST_CHANNEL", e[e.RELAY_EVENT_PACKET_RECEIVED_VIDEO_FROM_SRC = 5] = "RELAY_EVENT_PACKET_RECEIVED_VIDEO_FROM_SRC", e[e.RELAY_EVENT_PACKET_RECEIVED_AUDIO_FROM_SRC = 6] = "RELAY_EVENT_PACKET_RECEIVED_AUDIO_FROM_SRC", e[e.RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL = 7] = "RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL", e[e.RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_REFUSED = 8] = "RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_REFUSED", e[e.RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = 9] = "RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE", e[e.RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_IS_NULL = 10] = "RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_IS_NULL", e[e.RELAY_EVENT_VIDEO_PROFILE_UPDATE = 11] = "RELAY_EVENT_VIDEO_PROFILE_UPDATE", e[e.RELAY_EVENT_PAUSE_SEND_PACKET_TO_DEST_CHANNEL_SUCCESS = 12] = "RELAY_EVENT_PAUSE_SEND_PACKET_TO_DEST_CHANNEL_SUCCESS", e[e.RELAY_EVENT_PAUSE_SEND_PACKET_TO_DEST_CHANNEL_FAILED = 13] = "RELAY_EVENT_PAUSE_SEND_PACKET_TO_DEST_CHANNEL_FAILED", e[e.RELAY_EVENT_RESUME_SEND_PACKET_TO_DEST_CHANNEL_SUCCESS = 14] = "RELAY_EVENT_RESUME_SEND_PACKET_TO_DEST_CHANNEL_SUCCESS", e[e.RELAY_EVENT_RESUME_SEND_PACKET_TO_DEST_CHANNEL_FAILED = 15] = "RELAY_EVENT_RESUME_SEND_PACKET_TO_DEST_CHANNEL_FAILED" }(Me || (t.CHANNEL_MEDIA_RELAY_EVENT = Me = {})), function (e) { e[e.RELAY_STATE_IDLE = 0] = "RELAY_STATE_IDLE", e[e.RELAY_STATE_CONNECTING = 1] = "RELAY_STATE_CONNECTING", e[e.RELAY_STATE_RUNNING = 2] = "RELAY_STATE_RUNNING", e[e.RELAY_STATE_FAILURE = 3] = "RELAY_STATE_FAILURE" }(ke || (t.CHANNEL_MEDIA_RELAY_STATE = ke = {})); t.ChannelMediaInfo = class { }; t.ChannelMediaRelayConfiguration = class { }; t.UplinkNetworkInfo = class { }; t.PeerDownlinkInfo = class { }; t.DownlinkNetworkInfo = class { }, function (e) { e[e.AES_128_XTS = 1] = "AES_128_XTS", e[e.AES_128_ECB = 2] = "AES_128_ECB", e[e.AES_256_XTS = 3] = "AES_256_XTS", e[e.SM4_128_ECB = 4] = "SM4_128_ECB", e[e.AES_128_GCM = 5] = "AES_128_GCM", e[e.AES_256_GCM = 6] = "AES_256_GCM", e[e.AES_128_GCM2 = 7] = "AES_128_GCM2", e[e.AES_256_GCM2 = 8] = "AES_256_GCM2", e[e.MODE_END = 9] = "MODE_END" }(Ve || (t.ENCRYPTION_MODE = Ve = {})); t.EncryptionConfig = class { }, function (e) { e[e.ENCRYPTION_ERROR_INTERNAL_FAILURE = 0] = "ENCRYPTION_ERROR_INTERNAL_FAILURE", e[e.ENCRYPTION_ERROR_DECRYPTION_FAILURE = 1] = "ENCRYPTION_ERROR_DECRYPTION_FAILURE", e[e.ENCRYPTION_ERROR_ENCRYPTION_FAILURE = 2] = "ENCRYPTION_ERROR_ENCRYPTION_FAILURE" }(xe || (t.ENCRYPTION_ERROR_TYPE = xe = {})), function (e) { e[e.UPLOAD_SUCCESS = 0] = "UPLOAD_SUCCESS", e[e.UPLOAD_NET_ERROR = 1] = "UPLOAD_NET_ERROR", e[e.UPLOAD_SERVER_ERROR = 2] = "UPLOAD_SERVER_ERROR" }(Fe || (t.UPLOAD_ERROR_REASON = Fe = {})), function (e) { e[e.RECORD_AUDIO = 0] = "RECORD_AUDIO", e[e.CAMERA = 1] = "CAMERA", e[e.SCREEN_CAPTURE = 2] = "SCREEN_CAPTURE" }(Ye || (t.PERMISSION_TYPE = Ye = {})), function (e) { e[e.MAX_USER_ACCOUNT_LENGTH = 256] = "MAX_USER_ACCOUNT_LENGTH" }(Be || (t.MAX_USER_ACCOUNT_LENGTH_TYPE = Be = {})), function (e) { e[e.SUB_STATE_IDLE = 0] = "SUB_STATE_IDLE", e[e.SUB_STATE_NO_SUBSCRIBED = 1] = "SUB_STATE_NO_SUBSCRIBED", e[e.SUB_STATE_SUBSCRIBING = 2] = "SUB_STATE_SUBSCRIBING", e[e.SUB_STATE_SUBSCRIBED = 3] = "SUB_STATE_SUBSCRIBED" }(Ge || (t.STREAM_SUBSCRIBE_STATE = Ge = {})), function (e) { e[e.PUB_STATE_IDLE = 0] = "PUB_STATE_IDLE", e[e.PUB_STATE_NO_PUBLISHED = 1] = "PUB_STATE_NO_PUBLISHED", e[e.PUB_STATE_PUBLISHING = 2] = "PUB_STATE_PUBLISHING", e[e.PUB_STATE_PUBLISHED = 3] = "PUB_STATE_PUBLISHED" }(je || (t.STREAM_PUBLISH_STATE = je = {})); t.EchoTestConfiguration = class { }; t.UserInfo = class { }, function (e) { e[e.EAR_MONITORING_FILTER_NONE = 1] = "EAR_MONITORING_FILTER_NONE", e[e.EAR_MONITORING_FILTER_BUILT_IN_AUDIO_FILTERS = 2] = "EAR_MONITORING_FILTER_BUILT_IN_AUDIO_FILTERS", e[e.EAR_MONITORING_FILTER_NOISE_SUPPRESSION = 4] = "EAR_MONITORING_FILTER_NOISE_SUPPRESSION" }(He || (t.EAR_MONITORING_FILTER_TYPE = He = {})), function (e) { e[e.LOWEST = 0] = "LOWEST", e[e.LOW = 1] = "LOW", e[e.NORMAL = 2] = "NORMAL", e[e.HIGH = 3] = "HIGH", e[e.HIGHEST = 4] = "HIGHEST", e[e.CRITICAL = 5] = "CRITICAL" }(We || (t.THREAD_PRIORITY_TYPE = We = {})); t.ScreenVideoParameters = class { }; t.ScreenAudioParameters = class { }; t.ScreenCaptureParameters2 = class { }, function (e) { e[e.MEDIA_TRACE_EVENT_VIDEO_RENDERED = 0] = "MEDIA_TRACE_EVENT_VIDEO_RENDERED", e[e.MEDIA_TRACE_EVENT_VIDEO_DECODED = 1] = "MEDIA_TRACE_EVENT_VIDEO_DECODED" }(Ke || (t.MEDIA_TRACE_EVENT = Ke = {})); t.VideoRenderingTracingInfo = class { }, function (e) { e[e.CONFIG_FETCH_TYPE_INITIALIZE = 1] = "CONFIG_FETCH_TYPE_INITIALIZE", e[e.CONFIG_FETCH_TYPE_JOIN_CHANNEL = 2] = "CONFIG_FETCH_TYPE_JOIN_CHANNEL" }(Je || (t.CONFIG_FETCH_TYPE = Je = {})); t.RecorderStreamInfo = class { }, function (e) { e[e.ConnectivityFirst = 0] = "ConnectivityFirst", e[e.LocalOnly = 1] = "LocalOnly" }(Xe || (t.LOCAL_PROXY_MODE = Xe = {})); t.LogUploadServerInfo = class { }; t.AdvancedConfigInfo = class { }; t.LocalAccessPointConfiguration = class { }; t.SpatialAudioParams = class { } }, 6153: function (e, t) { "use strict"; var n, i, r, o, s, a, c, E, _, d, u, l, R, h, p, T, O, C, A, S, g, m, I; Object.defineProperty(t, "__esModule", { value: !0 }), t.RecorderInfo = t.MediaRecorderConfiguration = t.RecorderErrorCode = t.RecorderState = t.MediaRecorderStreamType = t.MediaRecorderContainerFormat = t.EXTERNAL_VIDEO_SOURCE_TYPE = t.VIDEO_FRAME_PROCESS_MODE = t.UserAudioSpectrumInfo = t.AudioSpectrumData = t.AudioParams = t.AUDIO_FRAME_POSITION = t.AudioFrame = t.AUDIO_FRAME_TYPE = t.VIDEO_MODULE_POSITION = t.MEDIA_PLAYER_SOURCE_TYPE = t.VideoFrame = t.ExternalVideoFrame = t.VIDEO_BUFFER_TYPE = t.EGL_CONTEXT_TYPE = t.CAMERA_VIDEO_SOURCE_TYPE = t.RENDER_MODE_TYPE = t.VIDEO_PIXEL_FORMAT = t.AUDIO_DUAL_MONO_MODE = t.AudioPcmFrame = t.AudioEncodedFrameInfo = t.PacketOptions = t.ContentInspectConfig = t.ContentInspectModule = t.CONTENT_INSPECT_TYPE = t.CONTENT_INSPECT_RESULT = t.MEDIA_SOURCE_TYPE = t.RAW_AUDIO_FRAME_OP_MODE_TYPE = t.AudioParameters = t.BYTES_PER_SAMPLE = t.AudioRoute = t.VIDEO_SOURCE_TYPE = void 0, function (e) { e[e.VIDEO_SOURCE_CAMERA_PRIMARY = 0] = "VIDEO_SOURCE_CAMERA_PRIMARY", e[e.VIDEO_SOURCE_CAMERA = 0] = "VIDEO_SOURCE_CAMERA", e[e.VIDEO_SOURCE_CAMERA_SECONDARY = 1] = "VIDEO_SOURCE_CAMERA_SECONDARY", e[e.VIDEO_SOURCE_SCREEN_PRIMARY = 2] = "VIDEO_SOURCE_SCREEN_PRIMARY", e[e.VIDEO_SOURCE_SCREEN = 2] = "VIDEO_SOURCE_SCREEN", e[e.VIDEO_SOURCE_SCREEN_SECONDARY = 3] = "VIDEO_SOURCE_SCREEN_SECONDARY", e[e.VIDEO_SOURCE_CUSTOM = 4] = "VIDEO_SOURCE_CUSTOM", e[e.VIDEO_SOURCE_MEDIA_PLAYER = 5] = "VIDEO_SOURCE_MEDIA_PLAYER", e[e.VIDEO_SOURCE_RTC_IMAGE_PNG = 6] = "VIDEO_SOURCE_RTC_IMAGE_PNG", e[e.VIDEO_SOURCE_RTC_IMAGE_JPEG = 7] = "VIDEO_SOURCE_RTC_IMAGE_JPEG", e[e.VIDEO_SOURCE_RTC_IMAGE_GIF = 8] = "VIDEO_SOURCE_RTC_IMAGE_GIF", e[e.VIDEO_SOURCE_REMOTE = 9] = "VIDEO_SOURCE_REMOTE", e[e.VIDEO_SOURCE_TRANSCODED = 10] = "VIDEO_SOURCE_TRANSCODED", e[e.VIDEO_SOURCE_CAMERA_THIRD = 11] = "VIDEO_SOURCE_CAMERA_THIRD", e[e.VIDEO_SOURCE_CAMERA_FOURTH = 12] = "VIDEO_SOURCE_CAMERA_FOURTH", e[e.VIDEO_SOURCE_SCREEN_THIRD = 13] = "VIDEO_SOURCE_SCREEN_THIRD", e[e.VIDEO_SOURCE_SCREEN_FOURTH = 14] = "VIDEO_SOURCE_SCREEN_FOURTH", e[e.VIDEO_SOURCE_UNKNOWN = 100] = "VIDEO_SOURCE_UNKNOWN" }(n || (t.VIDEO_SOURCE_TYPE = n = {})), function (e) { e[e.ROUTE_DEFAULT = -1] = "ROUTE_DEFAULT", e[e.ROUTE_HEADSET = 0] = "ROUTE_HEADSET", e[e.ROUTE_EARPIECE = 1] = "ROUTE_EARPIECE", e[e.ROUTE_HEADSETNOMIC = 2] = "ROUTE_HEADSETNOMIC", e[e.ROUTE_SPEAKERPHONE = 3] = "ROUTE_SPEAKERPHONE", e[e.ROUTE_LOUDSPEAKER = 4] = "ROUTE_LOUDSPEAKER", e[e.ROUTE_HEADSETBLUETOOTH = 5] = "ROUTE_HEADSETBLUETOOTH", e[e.ROUTE_USB = 6] = "ROUTE_USB", e[e.ROUTE_HDMI = 7] = "ROUTE_HDMI", e[e.ROUTE_DISPLAYPORT = 8] = "ROUTE_DISPLAYPORT", e[e.ROUTE_AIRPLAY = 9] = "ROUTE_AIRPLAY" }(i || (t.AudioRoute = i = {})), function (e) { e[e.TWO_BYTES_PER_SAMPLE = 2] = "TWO_BYTES_PER_SAMPLE" }(r || (t.BYTES_PER_SAMPLE = r = {})); t.AudioParameters = class { }, function (e) { e[e.RAW_AUDIO_FRAME_OP_MODE_READ_ONLY = 0] = "RAW_AUDIO_FRAME_OP_MODE_READ_ONLY", e[e.RAW_AUDIO_FRAME_OP_MODE_READ_WRITE = 2] = "RAW_AUDIO_FRAME_OP_MODE_READ_WRITE" }(o || (t.RAW_AUDIO_FRAME_OP_MODE_TYPE = o = {})), function (e) { e[e.AUDIO_PLAYOUT_SOURCE = 0] = "AUDIO_PLAYOUT_SOURCE", e[e.AUDIO_RECORDING_SOURCE = 1] = "AUDIO_RECORDING_SOURCE", e[e.PRIMARY_CAMERA_SOURCE = 2] = "PRIMARY_CAMERA_SOURCE", e[e.SECONDARY_CAMERA_SOURCE = 3] = "SECONDARY_CAMERA_SOURCE", e[e.PRIMARY_SCREEN_SOURCE = 4] = "PRIMARY_SCREEN_SOURCE", e[e.SECONDARY_SCREEN_SOURCE = 5] = "SECONDARY_SCREEN_SOURCE", e[e.CUSTOM_VIDEO_SOURCE = 6] = "CUSTOM_VIDEO_SOURCE", e[e.MEDIA_PLAYER_SOURCE = 7] = "MEDIA_PLAYER_SOURCE", e[e.RTC_IMAGE_PNG_SOURCE = 8] = "RTC_IMAGE_PNG_SOURCE", e[e.RTC_IMAGE_JPEG_SOURCE = 9] = "RTC_IMAGE_JPEG_SOURCE", e[e.RTC_IMAGE_GIF_SOURCE = 10] = "RTC_IMAGE_GIF_SOURCE", e[e.REMOTE_VIDEO_SOURCE = 11] = "REMOTE_VIDEO_SOURCE", e[e.TRANSCODED_VIDEO_SOURCE = 12] = "TRANSCODED_VIDEO_SOURCE", e[e.UNKNOWN_MEDIA_SOURCE = 100] = "UNKNOWN_MEDIA_SOURCE" }(s || (t.MEDIA_SOURCE_TYPE = s = {})), function (e) { e[e.CONTENT_INSPECT_NEUTRAL = 1] = "CONTENT_INSPECT_NEUTRAL", e[e.CONTENT_INSPECT_SEXY = 2] = "CONTENT_INSPECT_SEXY", e[e.CONTENT_INSPECT_PORN = 3] = "CONTENT_INSPECT_PORN" }(a || (t.CONTENT_INSPECT_RESULT = a = {})), function (e) { e[e.CONTENT_INSPECT_INVALID = 0] = "CONTENT_INSPECT_INVALID", e[e.CONTENT_INSPECT_MODERATION = 1] = "CONTENT_INSPECT_MODERATION", e[e.CONTENT_INSPECT_SUPERVISION = 2] = "CONTENT_INSPECT_SUPERVISION", e[e.CONTENT_INSPECT_IMAGE_MODERATION = 3] = "CONTENT_INSPECT_IMAGE_MODERATION" }(c || (t.CONTENT_INSPECT_TYPE = c = {})); t.ContentInspectModule = class { }; t.ContentInspectConfig = class { }; t.PacketOptions = class { }; t.AudioEncodedFrameInfo = class { }; t.AudioPcmFrame = class { }, function (e) { e[e.AUDIO_DUAL_MONO_STEREO = 0] = "AUDIO_DUAL_MONO_STEREO", e[e.AUDIO_DUAL_MONO_L = 1] = "AUDIO_DUAL_MONO_L", e[e.AUDIO_DUAL_MONO_R = 2] = "AUDIO_DUAL_MONO_R", e[e.AUDIO_DUAL_MONO_MIX = 3] = "AUDIO_DUAL_MONO_MIX" }(E || (t.AUDIO_DUAL_MONO_MODE = E = {})), function (e) { e[e.VIDEO_PIXEL_DEFAULT = 0] = "VIDEO_PIXEL_DEFAULT", e[e.VIDEO_PIXEL_I420 = 1] = "VIDEO_PIXEL_I420", e[e.VIDEO_PIXEL_BGRA = 2] = "VIDEO_PIXEL_BGRA", e[e.VIDEO_PIXEL_NV21 = 3] = "VIDEO_PIXEL_NV21", e[e.VIDEO_PIXEL_RGBA = 4] = "VIDEO_PIXEL_RGBA", e[e.VIDEO_PIXEL_NV12 = 8] = "VIDEO_PIXEL_NV12", e[e.VIDEO_TEXTURE_2D = 10] = "VIDEO_TEXTURE_2D", e[e.VIDEO_TEXTURE_OES = 11] = "VIDEO_TEXTURE_OES", e[e.VIDEO_CVPIXEL_NV12 = 12] = "VIDEO_CVPIXEL_NV12", e[e.VIDEO_CVPIXEL_I420 = 13] = "VIDEO_CVPIXEL_I420", e[e.VIDEO_CVPIXEL_BGRA = 14] = "VIDEO_CVPIXEL_BGRA", e[e.VIDEO_PIXEL_I422 = 16] = "VIDEO_PIXEL_I422", e[e.VIDEO_TEXTURE_ID3D11TEXTURE2D = 17] = "VIDEO_TEXTURE_ID3D11TEXTURE2D" }(_ || (t.VIDEO_PIXEL_FORMAT = _ = {})), function (e) { e[e.RENDER_MODE_HIDDEN = 1] = "RENDER_MODE_HIDDEN", e[e.RENDER_MODE_FIT = 2] = "RENDER_MODE_FIT", e[e.RENDER_MODE_ADAPTIVE = 3] = "RENDER_MODE_ADAPTIVE" }(d || (t.RENDER_MODE_TYPE = d = {})), function (e) { e[e.CAMERA_SOURCE_FRONT = 0] = "CAMERA_SOURCE_FRONT", e[e.CAMERA_SOURCE_BACK = 1] = "CAMERA_SOURCE_BACK", e[e.VIDEO_SOURCE_UNSPECIFIED = 2] = "VIDEO_SOURCE_UNSPECIFIED" }(u || (t.CAMERA_VIDEO_SOURCE_TYPE = u = {})), function (e) { e[e.EGL_CONTEXT10 = 0] = "EGL_CONTEXT10", e[e.EGL_CONTEXT14 = 1] = "EGL_CONTEXT14" }(l || (t.EGL_CONTEXT_TYPE = l = {})), function (e) { e[e.VIDEO_BUFFER_RAW_DATA = 1] = "VIDEO_BUFFER_RAW_DATA", e[e.VIDEO_BUFFER_ARRAY = 2] = "VIDEO_BUFFER_ARRAY", e[e.VIDEO_BUFFER_TEXTURE = 3] = "VIDEO_BUFFER_TEXTURE" }(R || (t.VIDEO_BUFFER_TYPE = R = {})); t.ExternalVideoFrame = class { }; t.VideoFrame = class { }, function (e) { e[e.MEDIA_PLAYER_SOURCE_DEFAULT = 0] = "MEDIA_PLAYER_SOURCE_DEFAULT", e[e.MEDIA_PLAYER_SOURCE_FULL_FEATURED = 1] = "MEDIA_PLAYER_SOURCE_FULL_FEATURED", e[e.MEDIA_PLAYER_SOURCE_SIMPLE = 2] = "MEDIA_PLAYER_SOURCE_SIMPLE" }(h || (t.MEDIA_PLAYER_SOURCE_TYPE = h = {})), function (e) { e[e.POSITION_POST_CAPTURER = 1] = "POSITION_POST_CAPTURER", e[e.POSITION_PRE_RENDERER = 1] = "POSITION_PRE_RENDERER", e[e.POSITION_PRE_ENCODER = 1] = "POSITION_PRE_ENCODER" }(p || (t.VIDEO_MODULE_POSITION = p = {})), function (e) { e[e.FRAME_TYPE_PCM16 = 0] = "FRAME_TYPE_PCM16" }(T || (t.AUDIO_FRAME_TYPE = T = {})); t.AudioFrame = class { }, function (e) { e[e.AUDIO_FRAME_POSITION_NONE = 0] = "AUDIO_FRAME_POSITION_NONE", e[e.AUDIO_FRAME_POSITION_PLAYBACK = 1] = "AUDIO_FRAME_POSITION_PLAYBACK", e[e.AUDIO_FRAME_POSITION_RECORD = 2] = "AUDIO_FRAME_POSITION_RECORD", e[e.AUDIO_FRAME_POSITION_MIXED = 4] = "AUDIO_FRAME_POSITION_MIXED", e[e.AUDIO_FRAME_POSITION_BEFORE_MIXING = 8] = "AUDIO_FRAME_POSITION_BEFORE_MIXING", e[e.AUDIO_FRAME_POSITION_EAR_MONITORING = 16] = "AUDIO_FRAME_POSITION_EAR_MONITORING" }(O || (t.AUDIO_FRAME_POSITION = O = {})); t.AudioParams = class { }; t.AudioSpectrumData = class { }; t.UserAudioSpectrumInfo = class { }, function (e) { e[e.PROCESS_MODE_READ_ONLY = 0] = "PROCESS_MODE_READ_ONLY", e[e.PROCESS_MODE_READ_WRITE = 1] = "PROCESS_MODE_READ_WRITE" }(C || (t.VIDEO_FRAME_PROCESS_MODE = C = {})), function (e) { e[e.VIDEO_FRAME = 0] = "VIDEO_FRAME", e[e.ENCODED_VIDEO_FRAME = 1] = "ENCODED_VIDEO_FRAME" }(A || (t.EXTERNAL_VIDEO_SOURCE_TYPE = A = {})), function (e) { e[e.FORMAT_MP4 = 1] = "FORMAT_MP4" }(S || (t.MediaRecorderContainerFormat = S = {})), function (e) { e[e.STREAM_TYPE_AUDIO = 1] = "STREAM_TYPE_AUDIO", e[e.STREAM_TYPE_VIDEO = 2] = "STREAM_TYPE_VIDEO", e[e.STREAM_TYPE_BOTH = 3] = "STREAM_TYPE_BOTH" }(g || (t.MediaRecorderStreamType = g = {})), function (e) { e[e.RECORDER_STATE_ERROR = -1] = "RECORDER_STATE_ERROR", e[e.RECORDER_STATE_START = 2] = "RECORDER_STATE_START", e[e.RECORDER_STATE_STOP = 3] = "RECORDER_STATE_STOP" }(m || (t.RecorderState = m = {})), function (e) { e[e.RECORDER_ERROR_NONE = 0] = "RECORDER_ERROR_NONE", e[e.RECORDER_ERROR_WRITE_FAILED = 1] = "RECORDER_ERROR_WRITE_FAILED", e[e.RECORDER_ERROR_NO_STREAM = 2] = "RECORDER_ERROR_NO_STREAM", e[e.RECORDER_ERROR_OVER_MAX_DURATION = 3] = "RECORDER_ERROR_OVER_MAX_DURATION", e[e.RECORDER_ERROR_CONFIG_CHANGED = 4] = "RECORDER_ERROR_CONFIG_CHANGED" }(I || (t.RecorderErrorCode = I = {})); t.MediaRecorderConfiguration = class { }; t.RecorderInfo = class { } }, 6183: function (e, t) { "use strict"; var n, i, r, o, s, a; Object.defineProperty(t, "__esModule", { value: !0 }), t.MediaSource = t.PlayerUpdatedInfo = t.CacheStatistics = t.MEDIA_PLAYER_METADATA_TYPE = t.SrcInfo = t.PlayerStreamInfo = t.PLAYER_PRELOAD_EVENT = t.MEDIA_PLAYER_EVENT = t.MEDIA_STREAM_TYPE = t.MEDIA_PLAYER_ERROR = t.MEDIA_PLAYER_STATE = void 0, function (e) { e[e.PLAYER_STATE_IDLE = 0] = "PLAYER_STATE_IDLE", e[e.PLAYER_STATE_OPENING = 1] = "PLAYER_STATE_OPENING", e[e.PLAYER_STATE_OPEN_COMPLETED = 2] = "PLAYER_STATE_OPEN_COMPLETED", e[e.PLAYER_STATE_PLAYING = 3] = "PLAYER_STATE_PLAYING", e[e.PLAYER_STATE_PAUSED = 4] = "PLAYER_STATE_PAUSED", e[e.PLAYER_STATE_PLAYBACK_COMPLETED = 5] = "PLAYER_STATE_PLAYBACK_COMPLETED", e[e.PLAYER_STATE_PLAYBACK_ALL_LOOPS_COMPLETED = 6] = "PLAYER_STATE_PLAYBACK_ALL_LOOPS_COMPLETED", e[e.PLAYER_STATE_STOPPED = 7] = "PLAYER_STATE_STOPPED", e[e.PLAYER_STATE_PAUSING_INTERNAL = 50] = "PLAYER_STATE_PAUSING_INTERNAL", e[e.PLAYER_STATE_STOPPING_INTERNAL = 51] = "PLAYER_STATE_STOPPING_INTERNAL", e[e.PLAYER_STATE_SEEKING_INTERNAL = 52] = "PLAYER_STATE_SEEKING_INTERNAL", e[e.PLAYER_STATE_GETTING_INTERNAL = 53] = "PLAYER_STATE_GETTING_INTERNAL", e[e.PLAYER_STATE_NONE_INTERNAL = 54] = "PLAYER_STATE_NONE_INTERNAL", e[e.PLAYER_STATE_DO_NOTHING_INTERNAL = 55] = "PLAYER_STATE_DO_NOTHING_INTERNAL", e[e.PLAYER_STATE_SET_TRACK_INTERNAL = 56] = "PLAYER_STATE_SET_TRACK_INTERNAL", e[e.PLAYER_STATE_FAILED = 100] = "PLAYER_STATE_FAILED" }(n || (t.MEDIA_PLAYER_STATE = n = {})), function (e) { e[e.PLAYER_ERROR_NONE = 0] = "PLAYER_ERROR_NONE", e[e.PLAYER_ERROR_INVALID_ARGUMENTS = -1] = "PLAYER_ERROR_INVALID_ARGUMENTS", e[e.PLAYER_ERROR_INTERNAL = -2] = "PLAYER_ERROR_INTERNAL", e[e.PLAYER_ERROR_NO_RESOURCE = -3] = "PLAYER_ERROR_NO_RESOURCE", e[e.PLAYER_ERROR_INVALID_MEDIA_SOURCE = -4] = "PLAYER_ERROR_INVALID_MEDIA_SOURCE", e[e.PLAYER_ERROR_UNKNOWN_STREAM_TYPE = -5] = "PLAYER_ERROR_UNKNOWN_STREAM_TYPE", e[e.PLAYER_ERROR_OBJ_NOT_INITIALIZED = -6] = "PLAYER_ERROR_OBJ_NOT_INITIALIZED", e[e.PLAYER_ERROR_CODEC_NOT_SUPPORTED = -7] = "PLAYER_ERROR_CODEC_NOT_SUPPORTED", e[e.PLAYER_ERROR_VIDEO_RENDER_FAILED = -8] = "PLAYER_ERROR_VIDEO_RENDER_FAILED", e[e.PLAYER_ERROR_INVALID_STATE = -9] = "PLAYER_ERROR_INVALID_STATE", e[e.PLAYER_ERROR_URL_NOT_FOUND = -10] = "PLAYER_ERROR_URL_NOT_FOUND", e[e.PLAYER_ERROR_INVALID_CONNECTION_STATE = -11] = "PLAYER_ERROR_INVALID_CONNECTION_STATE", e[e.PLAYER_ERROR_SRC_BUFFER_UNDERFLOW = -12] = "PLAYER_ERROR_SRC_BUFFER_UNDERFLOW", e[e.PLAYER_ERROR_INTERRUPTED = -13] = "PLAYER_ERROR_INTERRUPTED", e[e.PLAYER_ERROR_NOT_SUPPORTED = -14] = "PLAYER_ERROR_NOT_SUPPORTED", e[e.PLAYER_ERROR_TOKEN_EXPIRED = -15] = "PLAYER_ERROR_TOKEN_EXPIRED", e[e.PLAYER_ERROR_IP_EXPIRED = -16] = "PLAYER_ERROR_IP_EXPIRED", e[e.PLAYER_ERROR_UNKNOWN = -17] = "PLAYER_ERROR_UNKNOWN" }(i || (t.MEDIA_PLAYER_ERROR = i = {})), function (e) { e[e.STREAM_TYPE_UNKNOWN = 0] = "STREAM_TYPE_UNKNOWN", e[e.STREAM_TYPE_VIDEO = 1] = "STREAM_TYPE_VIDEO", e[e.STREAM_TYPE_AUDIO = 2] = "STREAM_TYPE_AUDIO", e[e.STREAM_TYPE_SUBTITLE = 3] = "STREAM_TYPE_SUBTITLE" }(r || (t.MEDIA_STREAM_TYPE = r = {})), function (e) { e[e.PLAYER_EVENT_SEEK_BEGIN = 0] = "PLAYER_EVENT_SEEK_BEGIN", e[e.PLAYER_EVENT_SEEK_COMPLETE = 1] = "PLAYER_EVENT_SEEK_COMPLETE", e[e.PLAYER_EVENT_SEEK_ERROR = 2] = "PLAYER_EVENT_SEEK_ERROR", e[e.PLAYER_EVENT_AUDIO_TRACK_CHANGED = 5] = "PLAYER_EVENT_AUDIO_TRACK_CHANGED", e[e.PLAYER_EVENT_BUFFER_LOW = 6] = "PLAYER_EVENT_BUFFER_LOW", e[e.PLAYER_EVENT_BUFFER_RECOVER = 7] = "PLAYER_EVENT_BUFFER_RECOVER", e[e.PLAYER_EVENT_FREEZE_START = 8] = "PLAYER_EVENT_FREEZE_START", e[e.PLAYER_EVENT_FREEZE_STOP = 9] = "PLAYER_EVENT_FREEZE_STOP", e[e.PLAYER_EVENT_SWITCH_BEGIN = 10] = "PLAYER_EVENT_SWITCH_BEGIN", e[e.PLAYER_EVENT_SWITCH_COMPLETE = 11] = "PLAYER_EVENT_SWITCH_COMPLETE", e[e.PLAYER_EVENT_SWITCH_ERROR = 12] = "PLAYER_EVENT_SWITCH_ERROR", e[e.PLAYER_EVENT_FIRST_DISPLAYED = 13] = "PLAYER_EVENT_FIRST_DISPLAYED", e[e.PLAYER_EVENT_REACH_CACHE_FILE_MAX_COUNT = 14] = "PLAYER_EVENT_REACH_CACHE_FILE_MAX_COUNT", e[e.PLAYER_EVENT_REACH_CACHE_FILE_MAX_SIZE = 15] = "PLAYER_EVENT_REACH_CACHE_FILE_MAX_SIZE", e[e.PLAYER_EVENT_TRY_OPEN_START = 16] = "PLAYER_EVENT_TRY_OPEN_START", e[e.PLAYER_EVENT_TRY_OPEN_SUCCEED = 17] = "PLAYER_EVENT_TRY_OPEN_SUCCEED", e[e.PLAYER_EVENT_TRY_OPEN_FAILED = 18] = "PLAYER_EVENT_TRY_OPEN_FAILED" }(o || (t.MEDIA_PLAYER_EVENT = o = {})), function (e) { e[e.PLAYER_PRELOAD_EVENT_BEGIN = 0] = "PLAYER_PRELOAD_EVENT_BEGIN", e[e.PLAYER_PRELOAD_EVENT_COMPLETE = 1] = "PLAYER_PRELOAD_EVENT_COMPLETE", e[e.PLAYER_PRELOAD_EVENT_ERROR = 2] = "PLAYER_PRELOAD_EVENT_ERROR" }(s || (t.PLAYER_PRELOAD_EVENT = s = {})); t.PlayerStreamInfo = class { }; t.SrcInfo = class { }, function (e) { e[e.PLAYER_METADATA_TYPE_UNKNOWN = 0] = "PLAYER_METADATA_TYPE_UNKNOWN", e[e.PLAYER_METADATA_TYPE_SEI = 1] = "PLAYER_METADATA_TYPE_SEI" }(a || (t.MEDIA_PLAYER_METADATA_TYPE = a = {})); t.CacheStatistics = class { }; t.PlayerUpdatedInfo = class { }; t.MediaSource = class { } }, 1539: function (e, t) { "use strict"; var n, i; Object.defineProperty(t, "__esModule", { value: !0 }), t.LogConfig = t.LOG_FILTER_TYPE = t.LOG_LEVEL = void 0, function (e) { e[e.LOG_LEVEL_NONE = 0] = "LOG_LEVEL_NONE", e[e.LOG_LEVEL_INFO = 1] = "LOG_LEVEL_INFO", e[e.LOG_LEVEL_WARN = 2] = "LOG_LEVEL_WARN", e[e.LOG_LEVEL_ERROR = 4] = "LOG_LEVEL_ERROR", e[e.LOG_LEVEL_FATAL = 8] = "LOG_LEVEL_FATAL", e[e.LOG_LEVEL_API_CALL = 16] = "LOG_LEVEL_API_CALL" }(n || (t.LOG_LEVEL = n = {})), function (e) { e[e.LOG_FILTER_OFF = 0] = "LOG_FILTER_OFF", e[e.LOG_FILTER_DEBUG = 2063] = "LOG_FILTER_DEBUG", e[e.LOG_FILTER_INFO = 15] = "LOG_FILTER_INFO", e[e.LOG_FILTER_WARN = 14] = "LOG_FILTER_WARN", e[e.LOG_FILTER_ERROR = 12] = "LOG_FILTER_ERROR", e[e.LOG_FILTER_CRITICAL = 8] = "LOG_FILTER_CRITICAL", e[e.LOG_FILTER_MASK = 2063] = "LOG_FILTER_MASK" }(i || (t.LOG_FILTER_TYPE = i = {})); t.LogConfig = class { } }, 8773: function (e, t) { "use strict"; var n; Object.defineProperty(t, "__esModule", { value: !0 }), t.AUDIO_MIXING_DUAL_MONO_MODE = void 0, function (e) { e[e.AUDIO_MIXING_DUAL_MONO_AUTO = 0] = "AUDIO_MIXING_DUAL_MONO_AUTO", e[e.AUDIO_MIXING_DUAL_MONO_L = 1] = "AUDIO_MIXING_DUAL_MONO_L", e[e.AUDIO_MIXING_DUAL_MONO_R = 2] = "AUDIO_MIXING_DUAL_MONO_R", e[e.AUDIO_MIXING_DUAL_MONO_MIX = 3] = "AUDIO_MIXING_DUAL_MONO_MIX" }(n || (t.AUDIO_MIXING_DUAL_MONO_MODE = n = {})) }, 9855: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }) }, 2879: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }) }, 9415: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }) }, 258: function (e, t) { "use strict"; var n, i; Object.defineProperty(t, "__esModule", { value: !0 }), t.InputSeiData = t.STREAMING_SRC_STATE = t.STREAMING_SRC_ERR = void 0, function (e) { e[e.STREAMING_SRC_ERR_NONE = 0] = "STREAMING_SRC_ERR_NONE", e[e.STREAMING_SRC_ERR_UNKNOWN = 1] = "STREAMING_SRC_ERR_UNKNOWN", e[e.STREAMING_SRC_ERR_INVALID_PARAM = 2] = "STREAMING_SRC_ERR_INVALID_PARAM", e[e.STREAMING_SRC_ERR_BAD_STATE = 3] = "STREAMING_SRC_ERR_BAD_STATE", e[e.STREAMING_SRC_ERR_NO_MEM = 4] = "STREAMING_SRC_ERR_NO_MEM", e[e.STREAMING_SRC_ERR_BUFFER_OVERFLOW = 5] = "STREAMING_SRC_ERR_BUFFER_OVERFLOW", e[e.STREAMING_SRC_ERR_BUFFER_UNDERFLOW = 6] = "STREAMING_SRC_ERR_BUFFER_UNDERFLOW", e[e.STREAMING_SRC_ERR_NOT_FOUND = 7] = "STREAMING_SRC_ERR_NOT_FOUND", e[e.STREAMING_SRC_ERR_TIMEOUT = 8] = "STREAMING_SRC_ERR_TIMEOUT", e[e.STREAMING_SRC_ERR_EXPIRED = 9] = "STREAMING_SRC_ERR_EXPIRED", e[e.STREAMING_SRC_ERR_UNSUPPORTED = 10] = "STREAMING_SRC_ERR_UNSUPPORTED", e[e.STREAMING_SRC_ERR_NOT_EXIST = 11] = "STREAMING_SRC_ERR_NOT_EXIST", e[e.STREAMING_SRC_ERR_EXIST = 12] = "STREAMING_SRC_ERR_EXIST", e[e.STREAMING_SRC_ERR_OPEN = 13] = "STREAMING_SRC_ERR_OPEN", e[e.STREAMING_SRC_ERR_CLOSE = 14] = "STREAMING_SRC_ERR_CLOSE", e[e.STREAMING_SRC_ERR_READ = 15] = "STREAMING_SRC_ERR_READ", e[e.STREAMING_SRC_ERR_WRITE = 16] = "STREAMING_SRC_ERR_WRITE", e[e.STREAMING_SRC_ERR_SEEK = 17] = "STREAMING_SRC_ERR_SEEK", e[e.STREAMING_SRC_ERR_EOF = 18] = "STREAMING_SRC_ERR_EOF", e[e.STREAMING_SRC_ERR_CODECOPEN = 19] = "STREAMING_SRC_ERR_CODECOPEN", e[e.STREAMING_SRC_ERR_CODECCLOSE = 20] = "STREAMING_SRC_ERR_CODECCLOSE", e[e.STREAMING_SRC_ERR_CODECPROC = 21] = "STREAMING_SRC_ERR_CODECPROC" }(n || (t.STREAMING_SRC_ERR = n = {})), function (e) { e[e.STREAMING_SRC_STATE_CLOSED = 0] = "STREAMING_SRC_STATE_CLOSED", e[e.STREAMING_SRC_STATE_OPENING = 1] = "STREAMING_SRC_STATE_OPENING", e[e.STREAMING_SRC_STATE_IDLE = 2] = "STREAMING_SRC_STATE_IDLE", e[e.STREAMING_SRC_STATE_PLAYING = 3] = "STREAMING_SRC_STATE_PLAYING", e[e.STREAMING_SRC_STATE_SEEKING = 4] = "STREAMING_SRC_STATE_SEEKING", e[e.STREAMING_SRC_STATE_EOF = 5] = "STREAMING_SRC_STATE_EOF", e[e.STREAMING_SRC_STATE_ERROR = 6] = "STREAMING_SRC_STATE_ERROR" }(i || (t.STREAMING_SRC_STATE = i = {})); t.InputSeiData = class { } }, 6182: function (e, t) { "use strict"; var n, i, r; Object.defineProperty(t, "__esModule", { value: !0 }), t.MusicContentCenterConfiguration = t.Music = t.ClimaxSegment = t.MvProperty = t.MusicCacheInfo = t.MUSIC_CACHE_STATUS_TYPE = t.MusicChartInfo = t.MusicContentCenterStatusCode = t.PreloadStatusCode = void 0, function (e) { e[e.kPreloadStatusCompleted = 0] = "kPreloadStatusCompleted", e[e.kPreloadStatusFailed = 1] = "kPreloadStatusFailed", e[e.kPreloadStatusPreloading = 2] = "kPreloadStatusPreloading", e[e.kPreloadStatusRemoved = 3] = "kPreloadStatusRemoved" }(n || (t.PreloadStatusCode = n = {})), function (e) { e[e.kMusicContentCenterStatusOk = 0] = "kMusicContentCenterStatusOk", e[e.kMusicContentCenterStatusErr = 1] = "kMusicContentCenterStatusErr", e[e.kMusicContentCenterStatusErrGateway = 2] = "kMusicContentCenterStatusErrGateway", e[e.kMusicContentCenterStatusErrPermissionAndResource = 3] = "kMusicContentCenterStatusErrPermissionAndResource", e[e.kMusicContentCenterStatusErrInternalDataParse = 4] = "kMusicContentCenterStatusErrInternalDataParse", e[e.kMusicContentCenterStatusErrMusicLoading = 5] = "kMusicContentCenterStatusErrMusicLoading", e[e.kMusicContentCenterStatusErrMusicDecryption = 6] = "kMusicContentCenterStatusErrMusicDecryption", e[e.kMusicContentCenterStatusErrHttpInternalError = 7] = "kMusicContentCenterStatusErrHttpInternalError" }(i || (t.MusicContentCenterStatusCode = i = {})); t.MusicChartInfo = class { }, function (e) { e[e.MUSIC_CACHE_STATUS_TYPE_CACHED = 0] = "MUSIC_CACHE_STATUS_TYPE_CACHED", e[e.MUSIC_CACHE_STATUS_TYPE_CACHING = 1] = "MUSIC_CACHE_STATUS_TYPE_CACHING" }(r || (t.MUSIC_CACHE_STATUS_TYPE = r = {})); t.MusicCacheInfo = class { }; t.MvProperty = class { }; t.ClimaxSegment = class { }; t.Music = class { }; t.MusicContentCenterConfiguration = class { } }, 4692: function (e, t) { "use strict"; var n, i; Object.defineProperty(t, "__esModule", { value: !0 }), t.AgoraRhythmPlayerConfig = t.RHYTHM_PLAYER_ERROR_TYPE = t.RHYTHM_PLAYER_STATE_TYPE = void 0, function (e) { e[e.RHYTHM_PLAYER_STATE_IDLE = 810] = "RHYTHM_PLAYER_STATE_IDLE", e[e.RHYTHM_PLAYER_STATE_OPENING = 811] = "RHYTHM_PLAYER_STATE_OPENING", e[e.RHYTHM_PLAYER_STATE_DECODING = 812] = "RHYTHM_PLAYER_STATE_DECODING", e[e.RHYTHM_PLAYER_STATE_PLAYING = 813] = "RHYTHM_PLAYER_STATE_PLAYING", e[e.RHYTHM_PLAYER_STATE_FAILED = 814] = "RHYTHM_PLAYER_STATE_FAILED" }(n || (t.RHYTHM_PLAYER_STATE_TYPE = n = {})), function (e) { e[e.RHYTHM_PLAYER_ERROR_OK = 0] = "RHYTHM_PLAYER_ERROR_OK", e[e.RHYTHM_PLAYER_ERROR_FAILED = 1] = "RHYTHM_PLAYER_ERROR_FAILED", e[e.RHYTHM_PLAYER_ERROR_CAN_NOT_OPEN = 801] = "RHYTHM_PLAYER_ERROR_CAN_NOT_OPEN", e[e.RHYTHM_PLAYER_ERROR_CAN_NOT_PLAY = 802] = "RHYTHM_PLAYER_ERROR_CAN_NOT_PLAY", e[e.RHYTHM_PLAYER_ERROR_FILE_OVER_DURATION_LIMIT = 803] = "RHYTHM_PLAYER_ERROR_FILE_OVER_DURATION_LIMIT" }(i || (t.RHYTHM_PLAYER_ERROR_TYPE = i = {})); t.AgoraRhythmPlayerConfig = class { } }, 9972: function (e, t) { "use strict"; var n, i, r, o, s, a, c, E, _, d, u, l, R, h, p, T, O, C, A, S, g; Object.defineProperty(t, "__esModule", { value: !0 }), t.VIDEO_PROFILE_TYPE = t.MEDIA_DEVICE_STATE_TYPE = t.QUALITY_REPORT_FORMAT_TYPE = t.ExtensionInfo = t.DirectCdnStreamingMediaOptions = t.DirectCdnStreamingStats = t.DIRECT_CDN_STREAMING_STATE = t.DIRECT_CDN_STREAMING_ERROR = t.Metadata = t.MAX_METADATA_SIZE_TYPE = t.METADATA_TYPE = t.RtcEngineContext = t.LeaveChannelOptions = t.FeatureType = t.PROXY_TYPE = t.ChannelMediaOptions = t.ImageTrackOptions = t.AdvancedAudioOptions = t.ScreenCaptureSourceInfo = t.ScreenCaptureSourceType = t.ThumbImageBuffer = t.SIZE = t.ScreenCaptureConfiguration = t.CameraCapturerConfiguration = t.CLOUD_PROXY_TYPE = t.CAMERA_DIRECTION = t.PublisherConfiguration = t.RTMP_STREAM_LIFE_CYCLE_TYPE = t.InjectStreamConfig = t.VideoCompositingLayout = t.Region = t.RemoteVideoStats = t.RemoteAudioStats = t.LocalVideoStats = t.PRIORITY_TYPE = t.STREAM_FALLBACK_OPTIONS = t.AUDIO_REVERB_TYPE = t.AUDIO_EQUALIZATION_BAND_FREQUENCY = t.INJECT_STREAM_STATUS = t.AUDIO_MIXING_REASON_TYPE = t.AUDIO_MIXING_STATE_TYPE = t.MEDIA_DEVICE_TYPE = void 0, function (e) { e[e.UNKNOWN_AUDIO_DEVICE = -1] = "UNKNOWN_AUDIO_DEVICE", e[e.AUDIO_PLAYOUT_DEVICE = 0] = "AUDIO_PLAYOUT_DEVICE", e[e.AUDIO_RECORDING_DEVICE = 1] = "AUDIO_RECORDING_DEVICE", e[e.VIDEO_RENDER_DEVICE = 2] = "VIDEO_RENDER_DEVICE", e[e.VIDEO_CAPTURE_DEVICE = 3] = "VIDEO_CAPTURE_DEVICE", e[e.AUDIO_APPLICATION_PLAYOUT_DEVICE = 4] = "AUDIO_APPLICATION_PLAYOUT_DEVICE", e[e.AUDIO_VIRTUAL_PLAYOUT_DEVICE = 5] = "AUDIO_VIRTUAL_PLAYOUT_DEVICE", e[e.AUDIO_VIRTUAL_RECORDING_DEVICE = 6] = "AUDIO_VIRTUAL_RECORDING_DEVICE" }(n || (t.MEDIA_DEVICE_TYPE = n = {})), function (e) { e[e.AUDIO_MIXING_STATE_PLAYING = 710] = "AUDIO_MIXING_STATE_PLAYING", e[e.AUDIO_MIXING_STATE_PAUSED = 711] = "AUDIO_MIXING_STATE_PAUSED", e[e.AUDIO_MIXING_STATE_STOPPED = 713] = "AUDIO_MIXING_STATE_STOPPED", e[e.AUDIO_MIXING_STATE_FAILED = 714] = "AUDIO_MIXING_STATE_FAILED" }(i || (t.AUDIO_MIXING_STATE_TYPE = i = {})), function (e) { e[e.AUDIO_MIXING_REASON_CAN_NOT_OPEN = 701] = "AUDIO_MIXING_REASON_CAN_NOT_OPEN", e[e.AUDIO_MIXING_REASON_TOO_FREQUENT_CALL = 702] = "AUDIO_MIXING_REASON_TOO_FREQUENT_CALL", e[e.AUDIO_MIXING_REASON_INTERRUPTED_EOF = 703] = "AUDIO_MIXING_REASON_INTERRUPTED_EOF", e[e.AUDIO_MIXING_REASON_ONE_LOOP_COMPLETED = 721] = "AUDIO_MIXING_REASON_ONE_LOOP_COMPLETED", e[e.AUDIO_MIXING_REASON_ALL_LOOPS_COMPLETED = 723] = "AUDIO_MIXING_REASON_ALL_LOOPS_COMPLETED", e[e.AUDIO_MIXING_REASON_STOPPED_BY_USER = 724] = "AUDIO_MIXING_REASON_STOPPED_BY_USER", e[e.AUDIO_MIXING_REASON_OK = 0] = "AUDIO_MIXING_REASON_OK" }(r || (t.AUDIO_MIXING_REASON_TYPE = r = {})), function (e) { e[e.INJECT_STREAM_STATUS_START_SUCCESS = 0] = "INJECT_STREAM_STATUS_START_SUCCESS", e[e.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = "INJECT_STREAM_STATUS_START_ALREADY_EXISTS", e[e.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = "INJECT_STREAM_STATUS_START_UNAUTHORIZED", e[e.INJECT_STREAM_STATUS_START_TIMEDOUT = 3] = "INJECT_STREAM_STATUS_START_TIMEDOUT", e[e.INJECT_STREAM_STATUS_START_FAILED = 4] = "INJECT_STREAM_STATUS_START_FAILED", e[e.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = "INJECT_STREAM_STATUS_STOP_SUCCESS", e[e.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = "INJECT_STREAM_STATUS_STOP_NOT_FOUND", e[e.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = "INJECT_STREAM_STATUS_STOP_UNAUTHORIZED", e[e.INJECT_STREAM_STATUS_STOP_TIMEDOUT = 8] = "INJECT_STREAM_STATUS_STOP_TIMEDOUT", e[e.INJECT_STREAM_STATUS_STOP_FAILED = 9] = "INJECT_STREAM_STATUS_STOP_FAILED", e[e.INJECT_STREAM_STATUS_BROKEN = 10] = "INJECT_STREAM_STATUS_BROKEN" }(o || (t.INJECT_STREAM_STATUS = o = {})), function (e) { e[e.AUDIO_EQUALIZATION_BAND_31 = 0] = "AUDIO_EQUALIZATION_BAND_31", e[e.AUDIO_EQUALIZATION_BAND_62 = 1] = "AUDIO_EQUALIZATION_BAND_62", e[e.AUDIO_EQUALIZATION_BAND_125 = 2] = "AUDIO_EQUALIZATION_BAND_125", e[e.AUDIO_EQUALIZATION_BAND_250 = 3] = "AUDIO_EQUALIZATION_BAND_250", e[e.AUDIO_EQUALIZATION_BAND_500 = 4] = "AUDIO_EQUALIZATION_BAND_500", e[e.AUDIO_EQUALIZATION_BAND_1K = 5] = "AUDIO_EQUALIZATION_BAND_1K", e[e.AUDIO_EQUALIZATION_BAND_2K = 6] = "AUDIO_EQUALIZATION_BAND_2K", e[e.AUDIO_EQUALIZATION_BAND_4K = 7] = "AUDIO_EQUALIZATION_BAND_4K", e[e.AUDIO_EQUALIZATION_BAND_8K = 8] = "AUDIO_EQUALIZATION_BAND_8K", e[e.AUDIO_EQUALIZATION_BAND_16K = 9] = "AUDIO_EQUALIZATION_BAND_16K" }(s || (t.AUDIO_EQUALIZATION_BAND_FREQUENCY = s = {})), function (e) { e[e.AUDIO_REVERB_DRY_LEVEL = 0] = "AUDIO_REVERB_DRY_LEVEL", e[e.AUDIO_REVERB_WET_LEVEL = 1] = "AUDIO_REVERB_WET_LEVEL", e[e.AUDIO_REVERB_ROOM_SIZE = 2] = "AUDIO_REVERB_ROOM_SIZE", e[e.AUDIO_REVERB_WET_DELAY = 3] = "AUDIO_REVERB_WET_DELAY", e[e.AUDIO_REVERB_STRENGTH = 4] = "AUDIO_REVERB_STRENGTH" }(a || (t.AUDIO_REVERB_TYPE = a = {})), function (e) { e[e.STREAM_FALLBACK_OPTION_DISABLED = 0] = "STREAM_FALLBACK_OPTION_DISABLED", e[e.STREAM_FALLBACK_OPTION_VIDEO_STREAM_LOW = 1] = "STREAM_FALLBACK_OPTION_VIDEO_STREAM_LOW", e[e.STREAM_FALLBACK_OPTION_AUDIO_ONLY = 2] = "STREAM_FALLBACK_OPTION_AUDIO_ONLY" }(c || (t.STREAM_FALLBACK_OPTIONS = c = {})), function (e) { e[e.PRIORITY_HIGH = 50] = "PRIORITY_HIGH", e[e.PRIORITY_NORMAL = 100] = "PRIORITY_NORMAL" }(E || (t.PRIORITY_TYPE = E = {})); t.LocalVideoStats = class { }; t.RemoteAudioStats = class { }; t.RemoteVideoStats = class { }; t.Region = class { }; t.VideoCompositingLayout = class { }; t.InjectStreamConfig = class { }, function (e) { e[e.RTMP_STREAM_LIFE_CYCLE_BIND2CHANNEL = 1] = "RTMP_STREAM_LIFE_CYCLE_BIND2CHANNEL", e[e.RTMP_STREAM_LIFE_CYCLE_BIND2OWNER = 2] = "RTMP_STREAM_LIFE_CYCLE_BIND2OWNER" }(_ || (t.RTMP_STREAM_LIFE_CYCLE_TYPE = _ = {})); t.PublisherConfiguration = class { }, function (e) { e[e.CAMERA_REAR = 0] = "CAMERA_REAR", e[e.CAMERA_FRONT = 1] = "CAMERA_FRONT" }(d || (t.CAMERA_DIRECTION = d = {})), function (e) { e[e.NONE_PROXY = 0] = "NONE_PROXY", e[e.UDP_PROXY = 1] = "UDP_PROXY", e[e.TCP_PROXY = 2] = "TCP_PROXY" }(u || (t.CLOUD_PROXY_TYPE = u = {})); t.CameraCapturerConfiguration = class { }; t.ScreenCaptureConfiguration = class { }; t.SIZE = class { }; t.ThumbImageBuffer = class { }, function (e) { e[e.ScreenCaptureSourceType_Unknown = -1] = "ScreenCaptureSourceType_Unknown", e[e.ScreenCaptureSourceType_Window = 0] = "ScreenCaptureSourceType_Window", e[e.ScreenCaptureSourceType_Screen = 1] = "ScreenCaptureSourceType_Screen", e[e.ScreenCaptureSourceType_Custom = 2] = "ScreenCaptureSourceType_Custom" }(l || (t.ScreenCaptureSourceType = l = {})); t.ScreenCaptureSourceInfo = class { }; t.AdvancedAudioOptions = class { }; t.ImageTrackOptions = class { }; t.ChannelMediaOptions = class { }, function (e) { e[e.NONE_PROXY_TYPE = 0] = "NONE_PROXY_TYPE", e[e.UDP_PROXY_TYPE = 1] = "UDP_PROXY_TYPE", e[e.TCP_PROXY_TYPE = 2] = "TCP_PROXY_TYPE", e[e.LOCAL_PROXY_TYPE = 3] = "LOCAL_PROXY_TYPE", e[e.TCP_PROXY_AUTO_FALLBACK_TYPE = 4] = "TCP_PROXY_AUTO_FALLBACK_TYPE", e[e.HTTP_PROXY_TYPE = 5] = "HTTP_PROXY_TYPE", e[e.HTTPS_PROXY_TYPE = 6] = "HTTPS_PROXY_TYPE" }(R || (t.PROXY_TYPE = R = {})), function (e) { e[e.VIDEO_VIRTUAL_BACKGROUND = 1] = "VIDEO_VIRTUAL_BACKGROUND", e[e.VIDEO_BEAUTY_EFFECT = 2] = "VIDEO_BEAUTY_EFFECT" }(h || (t.FeatureType = h = {})); t.LeaveChannelOptions = class { }; t.RtcEngineContext = class { }, function (e) { e[e.UNKNOWN_METADATA = -1] = "UNKNOWN_METADATA", e[e.VIDEO_METADATA = 0] = "VIDEO_METADATA" }(p || (t.METADATA_TYPE = p = {})), function (e) { e[e.INVALID_METADATA_SIZE_IN_BYTE = -1] = "INVALID_METADATA_SIZE_IN_BYTE", e[e.DEFAULT_METADATA_SIZE_IN_BYTE = 512] = "DEFAULT_METADATA_SIZE_IN_BYTE", e[e.MAX_METADATA_SIZE_IN_BYTE = 1024] = "MAX_METADATA_SIZE_IN_BYTE" }(T || (t.MAX_METADATA_SIZE_TYPE = T = {})); t.Metadata = class { }, function (e) { e[e.DIRECT_CDN_STREAMING_ERROR_OK = 0] = "DIRECT_CDN_STREAMING_ERROR_OK", e[e.DIRECT_CDN_STREAMING_ERROR_FAILED = 1] = "DIRECT_CDN_STREAMING_ERROR_FAILED", e[e.DIRECT_CDN_STREAMING_ERROR_AUDIO_PUBLICATION = 2] = "DIRECT_CDN_STREAMING_ERROR_AUDIO_PUBLICATION", e[e.DIRECT_CDN_STREAMING_ERROR_VIDEO_PUBLICATION = 3] = "DIRECT_CDN_STREAMING_ERROR_VIDEO_PUBLICATION", e[e.DIRECT_CDN_STREAMING_ERROR_NET_CONNECT = 4] = "DIRECT_CDN_STREAMING_ERROR_NET_CONNECT", e[e.DIRECT_CDN_STREAMING_ERROR_BAD_NAME = 5] = "DIRECT_CDN_STREAMING_ERROR_BAD_NAME" }(O || (t.DIRECT_CDN_STREAMING_ERROR = O = {})), function (e) { e[e.DIRECT_CDN_STREAMING_STATE_IDLE = 0] = "DIRECT_CDN_STREAMING_STATE_IDLE", e[e.DIRECT_CDN_STREAMING_STATE_RUNNING = 1] = "DIRECT_CDN_STREAMING_STATE_RUNNING", e[e.DIRECT_CDN_STREAMING_STATE_STOPPED = 2] = "DIRECT_CDN_STREAMING_STATE_STOPPED", e[e.DIRECT_CDN_STREAMING_STATE_FAILED = 3] = "DIRECT_CDN_STREAMING_STATE_FAILED", e[e.DIRECT_CDN_STREAMING_STATE_RECOVERING = 4] = "DIRECT_CDN_STREAMING_STATE_RECOVERING" }(C || (t.DIRECT_CDN_STREAMING_STATE = C = {})); t.DirectCdnStreamingStats = class { }; t.DirectCdnStreamingMediaOptions = class { }; t.ExtensionInfo = class { }, function (e) { e[e.QUALITY_REPORT_JSON = 0] = "QUALITY_REPORT_JSON", e[e.QUALITY_REPORT_HTML = 1] = "QUALITY_REPORT_HTML" }(A || (t.QUALITY_REPORT_FORMAT_TYPE = A = {})), function (e) { e[e.MEDIA_DEVICE_STATE_IDLE = 0] = "MEDIA_DEVICE_STATE_IDLE", e[e.MEDIA_DEVICE_STATE_ACTIVE = 1] = "MEDIA_DEVICE_STATE_ACTIVE", e[e.MEDIA_DEVICE_STATE_DISABLED = 2] = "MEDIA_DEVICE_STATE_DISABLED", e[e.MEDIA_DEVICE_STATE_NOT_PRESENT = 4] = "MEDIA_DEVICE_STATE_NOT_PRESENT", e[e.MEDIA_DEVICE_STATE_UNPLUGGED = 8] = "MEDIA_DEVICE_STATE_UNPLUGGED" }(S || (t.MEDIA_DEVICE_STATE_TYPE = S = {})), function (e) { e[e.VIDEO_PROFILE_LANDSCAPE_120P = 0] = "VIDEO_PROFILE_LANDSCAPE_120P", e[e.VIDEO_PROFILE_LANDSCAPE_120P_3 = 2] = "VIDEO_PROFILE_LANDSCAPE_120P_3", e[e.VIDEO_PROFILE_LANDSCAPE_180P = 10] = "VIDEO_PROFILE_LANDSCAPE_180P", e[e.VIDEO_PROFILE_LANDSCAPE_180P_3 = 12] = "VIDEO_PROFILE_LANDSCAPE_180P_3", e[e.VIDEO_PROFILE_LANDSCAPE_180P_4 = 13] = "VIDEO_PROFILE_LANDSCAPE_180P_4", e[e.VIDEO_PROFILE_LANDSCAPE_240P = 20] = "VIDEO_PROFILE_LANDSCAPE_240P", e[e.VIDEO_PROFILE_LANDSCAPE_240P_3 = 22] = "VIDEO_PROFILE_LANDSCAPE_240P_3", e[e.VIDEO_PROFILE_LANDSCAPE_240P_4 = 23] = "VIDEO_PROFILE_LANDSCAPE_240P_4", e[e.VIDEO_PROFILE_LANDSCAPE_360P = 30] = "VIDEO_PROFILE_LANDSCAPE_360P", e[e.VIDEO_PROFILE_LANDSCAPE_360P_3 = 32] = "VIDEO_PROFILE_LANDSCAPE_360P_3", e[e.VIDEO_PROFILE_LANDSCAPE_360P_4 = 33] = "VIDEO_PROFILE_LANDSCAPE_360P_4", e[e.VIDEO_PROFILE_LANDSCAPE_360P_6 = 35] = "VIDEO_PROFILE_LANDSCAPE_360P_6", e[e.VIDEO_PROFILE_LANDSCAPE_360P_7 = 36] = "VIDEO_PROFILE_LANDSCAPE_360P_7", e[e.VIDEO_PROFILE_LANDSCAPE_360P_8 = 37] = "VIDEO_PROFILE_LANDSCAPE_360P_8", e[e.VIDEO_PROFILE_LANDSCAPE_360P_9 = 38] = "VIDEO_PROFILE_LANDSCAPE_360P_9", e[e.VIDEO_PROFILE_LANDSCAPE_360P_10 = 39] = "VIDEO_PROFILE_LANDSCAPE_360P_10", e[e.VIDEO_PROFILE_LANDSCAPE_360P_11 = 100] = "VIDEO_PROFILE_LANDSCAPE_360P_11", e[e.VIDEO_PROFILE_LANDSCAPE_480P = 40] = "VIDEO_PROFILE_LANDSCAPE_480P", e[e.VIDEO_PROFILE_LANDSCAPE_480P_3 = 42] = "VIDEO_PROFILE_LANDSCAPE_480P_3", e[e.VIDEO_PROFILE_LANDSCAPE_480P_4 = 43] = "VIDEO_PROFILE_LANDSCAPE_480P_4", e[e.VIDEO_PROFILE_LANDSCAPE_480P_6 = 45] = "VIDEO_PROFILE_LANDSCAPE_480P_6", e[e.VIDEO_PROFILE_LANDSCAPE_480P_8 = 47] = "VIDEO_PROFILE_LANDSCAPE_480P_8", e[e.VIDEO_PROFILE_LANDSCAPE_480P_9 = 48] = "VIDEO_PROFILE_LANDSCAPE_480P_9", e[e.VIDEO_PROFILE_LANDSCAPE_480P_10 = 49] = "VIDEO_PROFILE_LANDSCAPE_480P_10", e[e.VIDEO_PROFILE_LANDSCAPE_720P = 50] = "VIDEO_PROFILE_LANDSCAPE_720P", e[e.VIDEO_PROFILE_LANDSCAPE_720P_3 = 52] = "VIDEO_PROFILE_LANDSCAPE_720P_3", e[e.VIDEO_PROFILE_LANDSCAPE_720P_5 = 54] = "VIDEO_PROFILE_LANDSCAPE_720P_5", e[e.VIDEO_PROFILE_LANDSCAPE_720P_6 = 55] = "VIDEO_PROFILE_LANDSCAPE_720P_6", e[e.VIDEO_PROFILE_LANDSCAPE_1080P = 60] = "VIDEO_PROFILE_LANDSCAPE_1080P", e[e.VIDEO_PROFILE_LANDSCAPE_1080P_3 = 62] = "VIDEO_PROFILE_LANDSCAPE_1080P_3", e[e.VIDEO_PROFILE_LANDSCAPE_1080P_5 = 64] = "VIDEO_PROFILE_LANDSCAPE_1080P_5", e[e.VIDEO_PROFILE_LANDSCAPE_1440P = 66] = "VIDEO_PROFILE_LANDSCAPE_1440P", e[e.VIDEO_PROFILE_LANDSCAPE_1440P_2 = 67] = "VIDEO_PROFILE_LANDSCAPE_1440P_2", e[e.VIDEO_PROFILE_LANDSCAPE_4K = 70] = "VIDEO_PROFILE_LANDSCAPE_4K", e[e.VIDEO_PROFILE_LANDSCAPE_4K_3 = 72] = "VIDEO_PROFILE_LANDSCAPE_4K_3", e[e.VIDEO_PROFILE_PORTRAIT_120P = 1e3] = "VIDEO_PROFILE_PORTRAIT_120P", e[e.VIDEO_PROFILE_PORTRAIT_120P_3 = 1002] = "VIDEO_PROFILE_PORTRAIT_120P_3", e[e.VIDEO_PROFILE_PORTRAIT_180P = 1010] = "VIDEO_PROFILE_PORTRAIT_180P", e[e.VIDEO_PROFILE_PORTRAIT_180P_3 = 1012] = "VIDEO_PROFILE_PORTRAIT_180P_3", e[e.VIDEO_PROFILE_PORTRAIT_180P_4 = 1013] = "VIDEO_PROFILE_PORTRAIT_180P_4", e[e.VIDEO_PROFILE_PORTRAIT_240P = 1020] = "VIDEO_PROFILE_PORTRAIT_240P", e[e.VIDEO_PROFILE_PORTRAIT_240P_3 = 1022] = "VIDEO_PROFILE_PORTRAIT_240P_3", e[e.VIDEO_PROFILE_PORTRAIT_240P_4 = 1023] = "VIDEO_PROFILE_PORTRAIT_240P_4", e[e.VIDEO_PROFILE_PORTRAIT_360P = 1030] = "VIDEO_PROFILE_PORTRAIT_360P", e[e.VIDEO_PROFILE_PORTRAIT_360P_3 = 1032] = "VIDEO_PROFILE_PORTRAIT_360P_3", e[e.VIDEO_PROFILE_PORTRAIT_360P_4 = 1033] = "VIDEO_PROFILE_PORTRAIT_360P_4", e[e.VIDEO_PROFILE_PORTRAIT_360P_6 = 1035] = "VIDEO_PROFILE_PORTRAIT_360P_6", e[e.VIDEO_PROFILE_PORTRAIT_360P_7 = 1036] = "VIDEO_PROFILE_PORTRAIT_360P_7", e[e.VIDEO_PROFILE_PORTRAIT_360P_8 = 1037] = "VIDEO_PROFILE_PORTRAIT_360P_8", e[e.VIDEO_PROFILE_PORTRAIT_360P_9 = 1038] = "VIDEO_PROFILE_PORTRAIT_360P_9", e[e.VIDEO_PROFILE_PORTRAIT_360P_10 = 1039] = "VIDEO_PROFILE_PORTRAIT_360P_10", e[e.VIDEO_PROFILE_PORTRAIT_360P_11 = 1100] = "VIDEO_PROFILE_PORTRAIT_360P_11", e[e.VIDEO_PROFILE_PORTRAIT_480P = 1040] = "VIDEO_PROFILE_PORTRAIT_480P", e[e.VIDEO_PROFILE_PORTRAIT_480P_3 = 1042] = "VIDEO_PROFILE_PORTRAIT_480P_3", e[e.VIDEO_PROFILE_PORTRAIT_480P_4 = 1043] = "VIDEO_PROFILE_PORTRAIT_480P_4", e[e.VIDEO_PROFILE_PORTRAIT_480P_6 = 1045] = "VIDEO_PROFILE_PORTRAIT_480P_6", e[e.VIDEO_PROFILE_PORTRAIT_480P_8 = 1047] = "VIDEO_PROFILE_PORTRAIT_480P_8", e[e.VIDEO_PROFILE_PORTRAIT_480P_9 = 1048] = "VIDEO_PROFILE_PORTRAIT_480P_9", e[e.VIDEO_PROFILE_PORTRAIT_480P_10 = 1049] = "VIDEO_PROFILE_PORTRAIT_480P_10", e[e.VIDEO_PROFILE_PORTRAIT_720P = 1050] = "VIDEO_PROFILE_PORTRAIT_720P", e[e.VIDEO_PROFILE_PORTRAIT_720P_3 = 1052] = "VIDEO_PROFILE_PORTRAIT_720P_3", e[e.VIDEO_PROFILE_PORTRAIT_720P_5 = 1054] = "VIDEO_PROFILE_PORTRAIT_720P_5", e[e.VIDEO_PROFILE_PORTRAIT_720P_6 = 1055] = "VIDEO_PROFILE_PORTRAIT_720P_6", e[e.VIDEO_PROFILE_PORTRAIT_1080P = 1060] = "VIDEO_PROFILE_PORTRAIT_1080P", e[e.VIDEO_PROFILE_PORTRAIT_1080P_3 = 1062] = "VIDEO_PROFILE_PORTRAIT_1080P_3", e[e.VIDEO_PROFILE_PORTRAIT_1080P_5 = 1064] = "VIDEO_PROFILE_PORTRAIT_1080P_5", e[e.VIDEO_PROFILE_PORTRAIT_1440P = 1066] = "VIDEO_PROFILE_PORTRAIT_1440P", e[e.VIDEO_PROFILE_PORTRAIT_1440P_2 = 1067] = "VIDEO_PROFILE_PORTRAIT_1440P_2", e[e.VIDEO_PROFILE_PORTRAIT_4K = 1070] = "VIDEO_PROFILE_PORTRAIT_4K", e[e.VIDEO_PROFILE_PORTRAIT_4K_3 = 1072] = "VIDEO_PROFILE_PORTRAIT_4K_3", e[e.VIDEO_PROFILE_DEFAULT = 30] = "VIDEO_PROFILE_DEFAULT" }(g || (t.VIDEO_PROFILE_TYPE = g = {})) }, 8515: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.RtcConnection = void 0; t.RtcConnection = class { } }, 2600: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.SpatialAudioZone = t.RemoteVoicePositionInfo = void 0; t.RemoteVoicePositionInfo = class { }; t.SpatialAudioZone = class { } }, 3551: function (e, t) { "use strict"; var n; Object.defineProperty(t, "__esModule", { value: !0 }), t.MAX_DEVICE_ID_LENGTH_TYPE = void 0, function (e) { e[e.MAX_DEVICE_ID_LENGTH = 512] = "MAX_DEVICE_ID_LENGTH" }(n || (t.MAX_DEVICE_ID_LENGTH_TYPE = n = {})) }, 5844: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__exportStar || function (e, t) { for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || i(t, e, n) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.NATIVE_RTC_VERSION = void 0, r(n(2964), t), r(n(6153), t), r(n(6183), t), r(n(1539), t), r(n(8773), t), r(n(9855), t), r(n(2879), t), r(n(9415), t), r(n(258), t), r(n(6182), t), r(n(4692), t), r(n(9972), t), r(n(8515), t), r(n(2600), t), r(n(3551), t), t.NATIVE_RTC_VERSION = "4.2.3" }, 8322: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisCore = t.CallIrisApiResult = void 0; const i = n(213); class r { constructor(e, t) { this.code = e, this.data = t } static success(e = 0, t = 0, n) { let i; return i = n || `{"result": ${t}}`, new r(e, i) } static failed(e, t = 0, n) { let i; return i = n || `{"result": ${t}}`, new r(e, i) } } t.CallIrisApiResult = r; t.IrisCore = { createIrisApiEngine: function () { return new i.IrisApiEngineImpl }, disposeIrisApiEngine: function (e) { return e.dispose(), 0 }, callIrisApi: function (e, t) { return e.callIrisApi(t) }, createIrisEventHandler: function (e) { return i.IrisEventHandlerImpl.create(e) }, CallIrisApiResult: r, EventParam: class { constructor(e, t, n, i, r, o, s, a = "0") { this.event = e, this.data = t, this.data_size = n, this.result = i, this.buffer = r, this.length = o, this.buffer_count = s, this.eventHandle = a } } } }, 213: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisApiEngineImpl = t.IrisEventHandlerImpl = void 0; const i = n(8322), r = n(8158); class o { static create(e) { let t = o.nextEventId++; return new o(t, e) } constructor(e, t) { this.eventId = e, this._eventHandler = t } onEvent(e) { e.eventHandle = this.eventId.toString(); let t = new i.IrisCore.EventParam(e.event, e.data, e.data_size, e.result, e.buffer, e.length, e.buffer_count, this.eventId.toString()); this._eventHandler && this._eventHandler(t) } } t.IrisEventHandlerImpl = o, o.nextEventId = 1; t.IrisApiEngineImpl = class { constructor() { this.apiInterceptors = [], this.irisEventHandlerManager = new r.IrisEventHandlerManagerImpl } getIrisEventHandlerManager() { return this.irisEventHandlerManager } addApiInterceptor(e) { this.apiInterceptors.find((t => t === e)) || this.apiInterceptors.push(e) } removeApiInterceptor(e) { this.apiInterceptors.forEach(((t, n) => { t === e && this.apiInterceptors.splice(n, 1) })) } callIrisApi(e) { for (let t of this.apiInterceptors) { let n = t.intercept(e); if (n) return n } return Promise.resolve(i.CallIrisApiResult.failed(-1e4, 0)) } dispose() { return this.apiInterceptors = [], Promise.resolve() } } }, 8158: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisEventHandlerManagerImpl = void 0; t.IrisEventHandlerManagerImpl = class { constructor() { this.eventHandlersMap = new Map } notifyEvent(e, t) { let n = this.eventHandlersMap.get(e); n && n.forEach((e => { e.onEvent(t) })) } addEventHandler(e, t) { let n = this.eventHandlersMap.get(e); if (!n) return n = [], n.push(t), void this.eventHandlersMap.set(e, n); n.find((e => e === t)) || n.push(t) } removeEventHandler(e, t) { let n = this.eventHandlersMap.get(e); n && n.forEach(((e, i) => { e === t && (null == n || n.splice(i, 1)) })) } } }, 2648: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.isPromise = t.CallApiExecutor = void 0; class n { constructor() { this.queue = Promise.resolve() } enqueue(e) { return new Promise(((t, n) => { this.queue = this.queue.then(e).then(t).catch(n) })) } cancel() { } } t.CallApiExecutor = class { constructor(e) { this.isAsyncCall = e, this.queue = new n } execute(e) { if (!this.isAsyncCall) return this.queue.enqueue(e), 0; return e() } }, t.isPromise = function (e) { return null != e && "function" == typeof e.then } }, 7481: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__exportStar || function (e, t) { for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || i(t, e, n) }; Object.defineProperty(t, "__esModule", { value: !0 }), r(n(8322), t), r(n(2648), t) }, 2100: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisWebRtc = void 0; const i = n(7275), r = n(2223); t.IrisWebRtc = { IrisRtcEngine: i.IrisRtcEngine, AgoraConsole: r.AgoraConsole, initIrisRtc: function (e, t) { var n; e.addApiInterceptor(null !== (n = null == t ? void 0 : t.irisRtcEngine) && void 0 !== n ? n : new i.IrisRtcEngine(e.getIrisEventHandlerManager(), t)) } } }, 4473: function (e, t) { "use strict"; var n, i; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisAudioSourceType = t.IRIS_VIDEO_PROCESS_ERR = void 0, function (e) { e[e.ERR_OK = 0] = "ERR_OK", e[e.ERR_NULL_POINTER = 1] = "ERR_NULL_POINTER", e[e.ERR_SIZE_NOT_MATCHING = 2] = "ERR_SIZE_NOT_MATCHING", e[e.ERR_BUFFER_EMPTY = 5] = "ERR_BUFFER_EMPTY" }(n || (t.IRIS_VIDEO_PROCESS_ERR = n = {})), function (e) { e[e.kAudioSourceTypeMicrophonePrimary = 2001] = "kAudioSourceTypeMicrophonePrimary", e[e.kAudioSourceTypeMicrophoneSecondary = 2002] = "kAudioSourceTypeMicrophoneSecondary", e[e.kAudioSourceTypeScreenCapture = 2003] = "kAudioSourceTypeScreenCapture", e[e.kAudioSourceTypeCustom = 2004] = "kAudioSourceTypeCustom", e[e.kAudioSourceTypeBufferSourceAudio = 2005] = "kAudioSourceTypeBufferSourceAudio", e[e.kAudioSourceTypeRemote = 2006] = "kAudioSourceTypeRemote", e[e.kAudioSourceTypeUnknown = 2007] = "kAudioSourceTypeUnknown" }(i || (t.IrisAudioSourceType = i = {})) }, 9217: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IMediaEngineDispatch = void 0; const i = n(5844), r = n(5762), o = n(1356), s = n(4482); t.IMediaEngineDispatch = class { constructor(e) { this._engine = null, this._impl = new o.IMediaEngineImpl(e), this._engine = e } registerAudioFrameObserver(e) { return s.AgoraConsole.warn("registerAudioFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerVideoFrameObserver(e) { return s.AgoraConsole.warn("registerVideoFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerVideoEncodedFrameObserver(e) { return s.AgoraConsole.warn("registerVideoEncodedFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pushAudioFrame(e) { return s.AgoraConsole.warn("pushAudioFrame not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pullAudioFrame(e) { return s.AgoraConsole.warn("pullAudioFrame not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExternalVideoSource(e) { let t = JSON.parse(e.data), n = t.enabled; if (void 0 === n) throw "enabled is undefined"; let i = t.useTexture; if (void 0 === i) throw "useTexture is undefined"; let r = t.sourceType; if (void 0 === r) throw "sourceType is undefined"; let o = t.encodedVideoOption; if (void 0 === o) throw "encodedVideoOption is undefined"; return this._impl.setExternalVideoSource(n, i, r, o) } setExternalAudioSource(e) { return s.AgoraConsole.warn("setExternalAudioSource not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createCustomAudioTrack(e) { return s.AgoraConsole.warn("createCustomAudioTrack not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } destroyCustomAudioTrack(e) { return s.AgoraConsole.warn("destroyCustomAudioTrack not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExternalAudioSink(e) { return s.AgoraConsole.warn("setExternalAudioSink not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableCustomAudioLocalPlayback(e) { return s.AgoraConsole.warn("enableCustomAudioLocalPlayback not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pushVideoFrame(e) { let t = JSON.parse(e.data); t = (0, r.callApiBufferExtension)(e.event, t, e.buffer); let n = t.frame; if (void 0 === n) throw "frame is undefined"; let i = t.videoTrackId; if (void 0 === i) throw "videoTrackId is undefined"; return this._impl.pushVideoFrame(n, i) } pushEncodedVideoImage(e) { return s.AgoraConsole.warn("pushEncodedVideoImage not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } release() { return s.AgoraConsole.warn("release not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 2343: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IMediaPlayerCacheManagerDispatch = t.IMediaPlayerDispatch = void 0; const i = n(5844), r = n(619), o = n(4482); t.IMediaPlayerDispatch = class { constructor(e) { this._engine = null, this._impl = new r.IMediaPlayerImpl(e), this._engine = e } getMediaPlayerId() { return o.AgoraConsole.warn("getMediaPlayerId not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } open(e) { return o.AgoraConsole.warn("open not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } openWithMediaSource(e) { return o.AgoraConsole.warn("openWithMediaSource not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } play() { return o.AgoraConsole.warn("play not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pause() { return o.AgoraConsole.warn("pause not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stop() { return o.AgoraConsole.warn("stop not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resume() { return o.AgoraConsole.warn("resume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } seek(e) { return o.AgoraConsole.warn("seek not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioPitch(e) { return o.AgoraConsole.warn("setAudioPitch not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getDuration(e) { return o.AgoraConsole.warn("getDuration not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlayPosition(e) { return o.AgoraConsole.warn("getPlayPosition not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getStreamCount(e) { return o.AgoraConsole.warn("getStreamCount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getStreamInfo(e) { return o.AgoraConsole.warn("getStreamInfo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLoopCount(e) { return o.AgoraConsole.warn("setLoopCount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackSpeed(e) { return o.AgoraConsole.warn("setPlaybackSpeed not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } selectAudioTrack(e) { return o.AgoraConsole.warn("selectAudioTrack not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlayerOption(e) { return o.AgoraConsole.warn("setPlayerOption not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlayerOption2(e) { return o.AgoraConsole.warn("setPlayerOption2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } takeScreenshot(e) { return o.AgoraConsole.warn("takeScreenshot not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } selectInternalSubtitle(e) { return o.AgoraConsole.warn("selectInternalSubtitle not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExternalSubtitle(e) { return o.AgoraConsole.warn("setExternalSubtitle not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getState() { return o.AgoraConsole.warn("getState not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } mute(e) { return o.AgoraConsole.warn("mute not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMute(e) { return o.AgoraConsole.warn("getMute not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustPlayoutVolume(e) { return o.AgoraConsole.warn("adjustPlayoutVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlayoutVolume(e) { return o.AgoraConsole.warn("getPlayoutVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustPublishSignalVolume(e) { return o.AgoraConsole.warn("adjustPublishSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPublishSignalVolume(e) { return o.AgoraConsole.warn("getPublishSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setView(e) { return o.AgoraConsole.warn("setView not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRenderMode(e) { return o.AgoraConsole.warn("setRenderMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerPlayerSourceObserver(e) { return o.AgoraConsole.warn("registerPlayerSourceObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterPlayerSourceObserver(e) { return o.AgoraConsole.warn("unregisterPlayerSourceObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerAudioFrameObserver(e) { return o.AgoraConsole.warn("registerAudioFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerAudioFrameObserver2(e) { return o.AgoraConsole.warn("registerAudioFrameObserver2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterAudioFrameObserver(e) { return o.AgoraConsole.warn("unregisterAudioFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerVideoFrameObserver(e) { return o.AgoraConsole.warn("registerVideoFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterVideoFrameObserver(e) { return o.AgoraConsole.warn("unregisterVideoFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerMediaPlayerAudioSpectrumObserver(e) { return o.AgoraConsole.warn("registerMediaPlayerAudioSpectrumObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterMediaPlayerAudioSpectrumObserver(e) { return o.AgoraConsole.warn("unregisterMediaPlayerAudioSpectrumObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioDualMonoMode(e) { return o.AgoraConsole.warn("setAudioDualMonoMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlayerSdkVersion() { return o.AgoraConsole.warn("getPlayerSdkVersion not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlaySrc() { return o.AgoraConsole.warn("getPlaySrc not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } openWithAgoraCDNSrc(e) { return o.AgoraConsole.warn("openWithAgoraCDNSrc not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAgoraCDNLineCount() { return o.AgoraConsole.warn("getAgoraCDNLineCount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } switchAgoraCDNLineByIndex(e) { return o.AgoraConsole.warn("switchAgoraCDNLineByIndex not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCurrentAgoraCDNIndex() { return o.AgoraConsole.warn("getCurrentAgoraCDNIndex not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAutoSwitchAgoraCDN(e) { return o.AgoraConsole.warn("enableAutoSwitchAgoraCDN not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } renewAgoraCDNSrcToken(e) { return o.AgoraConsole.warn("renewAgoraCDNSrcToken not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } switchAgoraCDNSrc(e) { return o.AgoraConsole.warn("switchAgoraCDNSrc not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } switchSrc(e) { return o.AgoraConsole.warn("switchSrc not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preloadSrc(e) { return o.AgoraConsole.warn("preloadSrc not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } playPreloadedSrc(e) { return o.AgoraConsole.warn("playPreloadedSrc not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unloadSrc(e) { return o.AgoraConsole.warn("unloadSrc not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSpatialAudioParams(e) { return o.AgoraConsole.warn("setSpatialAudioParams not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSoundPositionParams(e) { return o.AgoraConsole.warn("setSoundPositionParams not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.IMediaPlayerCacheManagerDispatch = class { constructor(e) { this._engine = null, this._impl = new r.IMediaPlayerCacheManagerImpl(e), this._engine = e } removeAllCaches() { return o.AgoraConsole.warn("removeAllCaches not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeOldCache() { return o.AgoraConsole.warn("removeOldCache not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeCacheByUri(e) { return o.AgoraConsole.warn("removeCacheByUri not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCacheDir(e) { return o.AgoraConsole.warn("setCacheDir not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setMaxCacheFileCount(e) { return o.AgoraConsole.warn("setMaxCacheFileCount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setMaxCacheFileSize(e) { return o.AgoraConsole.warn("setMaxCacheFileSize not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAutoRemoveCache(e) { return o.AgoraConsole.warn("enableAutoRemoveCache not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCacheDir(e) { return o.AgoraConsole.warn("getCacheDir not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMaxCacheFileCount() { return o.AgoraConsole.warn("getMaxCacheFileCount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMaxCacheFileSize() { return o.AgoraConsole.warn("getMaxCacheFileSize not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCacheFileCount() { return o.AgoraConsole.warn("getCacheFileCount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 1146: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IMediaRecorderDispatch = void 0; const i = n(5844), r = n(8767), o = n(4482); t.IMediaRecorderDispatch = class { constructor(e) { this._engine = null, this._impl = new r.IMediaRecorderImpl(e), this._engine = e } setMediaRecorderObserver(e) { return o.AgoraConsole.warn("setMediaRecorderObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRecording(e) { return o.AgoraConsole.warn("startRecording not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopRecording() { return o.AgoraConsole.warn("stopRecording not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 7513: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IMusicContentCenterDispatch = t.IMusicPlayerDispatch = t.IMusicContentCenterEventHandler = t.MusicCollectionDispatch = t.MusicChartCollectionDispatch = void 0; const i = n(5844), r = n(2215), o = n(4482); t.MusicChartCollectionDispatch = class { constructor(e) { this._engine = null, this._impl = new r.MusicChartCollectionImpl(e), this._engine = e } getCount() { return o.AgoraConsole.warn("getCount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } get(e) { return o.AgoraConsole.warn("get not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.MusicCollectionDispatch = class { constructor(e) { this._engine = null, this._impl = new r.MusicCollectionImpl(e), this._engine = e } getCount() { return o.AgoraConsole.warn("getCount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getTotal() { return o.AgoraConsole.warn("getTotal not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPage() { return o.AgoraConsole.warn("getPage not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPageSize() { return o.AgoraConsole.warn("getPageSize not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMusic(e) { return o.AgoraConsole.warn("getMusic not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.IMusicContentCenterEventHandler = class { constructor(e) { this.classPrefix = "MusicContentCenterEventHandler_", this._engine = null, this._engine = e } eventKey(e) { return `${this.classPrefix}${e}` } notifyEvent(e) { this._engine.irisEventHandlerManager.notifyEvent("RtcEngine", e) } onMusicChartsResult(e, t, n) { o.AgoraConsole.warn("onMusicChartsResult not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onMusicCollectionResult(e, t, n) { o.AgoraConsole.warn("onMusicCollectionResult not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLyricResult(e, t, n, r) { o.AgoraConsole.warn("onLyricResult not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onSongSimpleInfoResult(e, t, n, r) { o.AgoraConsole.warn("onSongSimpleInfoResult not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onPreLoadEvent(e, t, n, r, s, a) { o.AgoraConsole.warn("onPreLoadEvent not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.IMusicPlayerDispatch = class { constructor(e) { this._engine = null, this._impl = new r.IMusicPlayerImpl(e), this._engine = e } }; t.IMusicContentCenterDispatch = class { constructor(e) { this._engine = null, this._impl = new r.IMusicContentCenterImpl(e), this._engine = e } initialize(e) { return o.AgoraConsole.warn("initialize not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } renewToken(e) { return o.AgoraConsole.warn("renewToken not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } release() { return o.AgoraConsole.warn("release not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerEventHandler(e) { return o.AgoraConsole.warn("registerEventHandler not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterEventHandler(e) { return o.AgoraConsole.warn("unregisterEventHandler not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createMusicPlayer() { return o.AgoraConsole.warn("createMusicPlayer not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMusicCharts(e) { return o.AgoraConsole.warn("getMusicCharts not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMusicCollectionByMusicChartId(e) { return o.AgoraConsole.warn("getMusicCollectionByMusicChartId not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } searchMusic(e) { return o.AgoraConsole.warn("searchMusic not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preload(e) { return o.AgoraConsole.warn("preload not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preload2(e) { return o.AgoraConsole.warn("preload2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeCache(e) { return o.AgoraConsole.warn("removeCache not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCaches(e) { return o.AgoraConsole.warn("getCaches not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isPreloaded(e) { return o.AgoraConsole.warn("isPreloaded not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getLyric(e) { return o.AgoraConsole.warn("getLyric not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getSongSimpleInfo(e) { return o.AgoraConsole.warn("getSongSimpleInfo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getInternalSongCode(e) { return o.AgoraConsole.warn("getInternalSongCode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 3386: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IRtcEngineDispatch = t.IDirectCdnStreamingEventHandler = t.IMetadataObserver = t.IVideoDeviceManagerDispatch = t.IRtcEngineEventHandler = void 0; const i = n(5844), r = n(7481), o = n(9209), s = n(4482); t.IRtcEngineEventHandler = class { constructor(e) { this.classPrefix = "RtcEngineEventHandler_", this._engine = null, this._engine = e } eventKey(e) { return `${this.classPrefix}${e}` } notifyEvent(e) { this._engine.irisEventHandlerManager.notifyEvent("RtcEngine", e) } onJoinChannelSuccess(e, t, n) { s.AgoraConsole.warn("onJoinChannelSuccess not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRejoinChannelSuccess(e, t, n) { s.AgoraConsole.warn("onRejoinChannelSuccess not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onProxyConnected(e, t, n, r, o) { s.AgoraConsole.warn("onProxyConnected not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onError(e, t) { let n = { err: e, msg: t }, i = JSON.stringify(n), o = this.eventKey("onError"), a = new r.IrisCore.EventParam(o, i, 0, "", [], [], 0); s.AgoraConsole.log(`onError eventParam ${JSON.stringify(a)}`), this.notifyEvent(a) } onAudioQuality(e, t, n, r) { s.AgoraConsole.warn("onAudioQuality not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLastmileProbeResult(e) { s.AgoraConsole.warn("onLastmileProbeResult not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioVolumeIndication(e, t, n) { s.AgoraConsole.warn("onAudioVolumeIndication not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLeaveChannel(e) { s.AgoraConsole.warn("onLeaveChannel not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRtcStats(e) { s.AgoraConsole.warn("onRtcStats not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioDeviceStateChanged(e, t, n) { let i = { deviceId: e, deviceType: t, deviceState: n }, o = JSON.stringify(i), a = this.eventKey("onAudioDeviceStateChanged"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onAudioDeviceStateChanged eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onAudioMixingPositionChanged(e) { s.AgoraConsole.warn("onAudioMixingPositionChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioMixingFinished() { s.AgoraConsole.warn("onAudioMixingFinished not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioEffectFinished(e) { let t = { soundId: e }, n = JSON.stringify(t), i = this.eventKey("onAudioEffectFinished"), o = new r.IrisCore.EventParam(i, n, 0, "", [], [], 0); s.AgoraConsole.log(`onAudioEffectFinished eventParam ${JSON.stringify(o)}`), this.notifyEvent(o) } onVideoDeviceStateChanged(e, t, n) { let i = { deviceId: e, deviceType: t, deviceState: n }, o = JSON.stringify(i), a = this.eventKey("onVideoDeviceStateChanged"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onVideoDeviceStateChanged eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onNetworkQuality(e, t, n) { let i = { uid: e, txQuality: t, rxQuality: n }, o = JSON.stringify(i), a = this.eventKey("onNetworkQuality"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onNetworkQuality eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onIntraRequestReceived() { s.AgoraConsole.warn("onIntraRequestReceived not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUplinkNetworkInfoUpdated(e) { s.AgoraConsole.warn("onUplinkNetworkInfoUpdated not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onDownlinkNetworkInfoUpdated(e) { s.AgoraConsole.warn("onDownlinkNetworkInfoUpdated not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLastmileQuality(e) { s.AgoraConsole.warn("onLastmileQuality not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onFirstLocalVideoFrame(e, t, n, i) { let o = { source: e, width: t, height: n, elapsed: i }, a = JSON.stringify(o), c = this.eventKey("onFirstLocalVideoFrame"), E = new r.IrisCore.EventParam(c, a, 0, "", [], [], 0); s.AgoraConsole.log(`onFirstLocalVideoFrame eventParam ${JSON.stringify(E)}`), this.notifyEvent(E) } onFirstLocalVideoFramePublished(e, t) { s.AgoraConsole.warn("onFirstLocalVideoFramePublished not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onFirstRemoteVideoDecoded(e, t, n, r) { s.AgoraConsole.warn("onFirstRemoteVideoDecoded not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onVideoSizeChanged(e, t, n, r, o) { s.AgoraConsole.warn("onVideoSizeChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLocalVideoStateChanged(e, t, n) { let i = { source: e, state: t, error: n }, o = JSON.stringify(i), a = this.eventKey("onLocalVideoStateChanged"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onLocalVideoStateChanged eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onRemoteVideoStateChanged(e, t, n, r) { s.AgoraConsole.warn("onRemoteVideoStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onFirstRemoteVideoFrame(e, t, n, r) { s.AgoraConsole.warn("onFirstRemoteVideoFrame not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserJoined(e, t) { s.AgoraConsole.warn("onUserJoined not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserOffline(e, t) { s.AgoraConsole.warn("onUserOffline not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserMuteAudio(e, t) { s.AgoraConsole.warn("onUserMuteAudio not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserMuteVideo(e, t) { s.AgoraConsole.warn("onUserMuteVideo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserEnableVideo(e, t) { s.AgoraConsole.warn("onUserEnableVideo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserStateChanged(e, t) { s.AgoraConsole.warn("onUserStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserEnableLocalVideo(e, t) { s.AgoraConsole.warn("onUserEnableLocalVideo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLocalAudioStats(e) { s.AgoraConsole.warn("onLocalAudioStats not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRemoteAudioStats(e) { s.AgoraConsole.warn("onRemoteAudioStats not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLocalVideoStats(e, t) { s.AgoraConsole.warn("onLocalVideoStats not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRemoteVideoStats(e) { s.AgoraConsole.warn("onRemoteVideoStats not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onCameraReady() { s.AgoraConsole.warn("onCameraReady not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onCameraFocusAreaChanged(e, t, n, r) { s.AgoraConsole.warn("onCameraFocusAreaChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onCameraExposureAreaChanged(e, t, n, r) { s.AgoraConsole.warn("onCameraExposureAreaChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onFacePositionChanged(e, t, n, r, o) { s.AgoraConsole.warn("onFacePositionChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onVideoStopped() { s.AgoraConsole.warn("onVideoStopped not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioMixingStateChanged(e, t) { s.AgoraConsole.warn("onAudioMixingStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRhythmPlayerStateChanged(e, t) { s.AgoraConsole.warn("onRhythmPlayerStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onConnectionLost() { s.AgoraConsole.warn("onConnectionLost not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onConnectionInterrupted() { s.AgoraConsole.warn("onConnectionInterrupted not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onConnectionBanned() { s.AgoraConsole.warn("onConnectionBanned not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onStreamMessage(e, t, n, r, o) { s.AgoraConsole.warn("onStreamMessage not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onStreamMessageError(e, t, n, r, o) { s.AgoraConsole.warn("onStreamMessageError not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRequestToken() { s.AgoraConsole.warn("onRequestToken not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onTokenPrivilegeWillExpire(e) { s.AgoraConsole.warn("onTokenPrivilegeWillExpire not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLicenseValidationFailure(e) { s.AgoraConsole.warn("onLicenseValidationFailure not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onFirstLocalAudioFramePublished(e) { s.AgoraConsole.warn("onFirstLocalAudioFramePublished not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onFirstRemoteAudioFrame(e, t) { s.AgoraConsole.warn("onFirstRemoteAudioFrame not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onFirstRemoteAudioDecoded(e, t) { s.AgoraConsole.warn("onFirstRemoteAudioDecoded not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLocalAudioStateChanged(e, t) { let n = { state: e, error: t }, i = JSON.stringify(n), o = this.eventKey("onLocalAudioStateChanged"), a = new r.IrisCore.EventParam(o, i, 0, "", [], [], 0); s.AgoraConsole.log(`onLocalAudioStateChanged eventParam ${JSON.stringify(a)}`), this.notifyEvent(a) } onRemoteAudioStateChanged(e, t, n, r) { s.AgoraConsole.warn("onRemoteAudioStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onActiveSpeaker(e) { s.AgoraConsole.warn("onActiveSpeaker not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onContentInspectResult(e) { let t = { result: e }, n = JSON.stringify(t), i = this.eventKey("onContentInspectResult"), o = new r.IrisCore.EventParam(i, n, 0, "", [], [], 0); s.AgoraConsole.log(`onContentInspectResult eventParam ${JSON.stringify(o)}`), this.notifyEvent(o) } onSnapshotTaken(e, t, n, r, o) { s.AgoraConsole.warn("onSnapshotTaken not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onClientRoleChanged(e, t, n) { s.AgoraConsole.warn("onClientRoleChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onClientRoleChangeFailed(e, t) { s.AgoraConsole.warn("onClientRoleChangeFailed not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioDeviceVolumeChanged(e, t, n) { s.AgoraConsole.warn("onAudioDeviceVolumeChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRtmpStreamingStateChanged(e, t, n) { s.AgoraConsole.warn("onRtmpStreamingStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRtmpStreamingEvent(e, t) { s.AgoraConsole.warn("onRtmpStreamingEvent not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onTranscodingUpdated() { s.AgoraConsole.warn("onTranscodingUpdated not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioRoutingChanged(e) { s.AgoraConsole.warn("onAudioRoutingChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onChannelMediaRelayStateChanged(e, t) { let n = { state: e, code: t }, i = JSON.stringify(n), o = this.eventKey("onChannelMediaRelayStateChanged"), a = new r.IrisCore.EventParam(o, i, 0, "", [], [], 0); s.AgoraConsole.log(`onChannelMediaRelayStateChanged eventParam ${JSON.stringify(a)}`), this.notifyEvent(a) } onChannelMediaRelayEvent(e) { let t = { code: e }, n = JSON.stringify(t), i = this.eventKey("onChannelMediaRelayEvent"), o = new r.IrisCore.EventParam(i, n, 0, "", [], [], 0); s.AgoraConsole.log(`onChannelMediaRelayEvent eventParam ${JSON.stringify(o)}`), this.notifyEvent(o) } onLocalPublishFallbackToAudioOnly(e) { s.AgoraConsole.warn("onLocalPublishFallbackToAudioOnly not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRemoteSubscribeFallbackToAudioOnly(e, t) { let n = { uid: e, isFallbackOrRecover: t }, i = JSON.stringify(n), o = this.eventKey("onRemoteSubscribeFallbackToAudioOnly"), a = new r.IrisCore.EventParam(o, i, 0, "", [], [], 0); s.AgoraConsole.log(`onRemoteSubscribeFallbackToAudioOnly eventParam ${JSON.stringify(a)}`), this.notifyEvent(a) } onRemoteAudioTransportStats(e, t, n, r) { s.AgoraConsole.warn("onRemoteAudioTransportStats not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRemoteVideoTransportStats(e, t, n, r) { s.AgoraConsole.warn("onRemoteVideoTransportStats not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onConnectionStateChanged(e, t) { s.AgoraConsole.warn("onConnectionStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onWlAccMessage(e, t, n) { s.AgoraConsole.warn("onWlAccMessage not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onWlAccStats(e, t) { s.AgoraConsole.warn("onWlAccStats not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onNetworkTypeChanged(e) { s.AgoraConsole.warn("onNetworkTypeChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onEncryptionError(e) { s.AgoraConsole.warn("onEncryptionError not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onPermissionError(e) { s.AgoraConsole.warn("onPermissionError not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLocalUserRegistered(e, t) { s.AgoraConsole.warn("onLocalUserRegistered not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserInfoUpdated(e, t) { s.AgoraConsole.warn("onUserInfoUpdated not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUploadLogResult(e, t, n) { s.AgoraConsole.warn("onUploadLogResult not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioSubscribeStateChanged(e, t, n, r, o) { s.AgoraConsole.warn("onAudioSubscribeStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onVideoSubscribeStateChanged(e, t, n, r, o) { s.AgoraConsole.warn("onVideoSubscribeStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioPublishStateChanged(e, t, n, r) { s.AgoraConsole.warn("onAudioPublishStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onVideoPublishStateChanged(e, t, n, r, o) { s.AgoraConsole.warn("onVideoPublishStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onExtensionEvent(e, t, n, r) { s.AgoraConsole.warn("onExtensionEvent not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onExtensionStarted(e, t) { s.AgoraConsole.warn("onExtensionStarted not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onExtensionStopped(e, t) { s.AgoraConsole.warn("onExtensionStopped not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onExtensionError(e, t, n, r) { s.AgoraConsole.warn("onExtensionError not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserAccountUpdated(e, t) { s.AgoraConsole.warn("onUserAccountUpdated not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onLocalVideoTranscoderError(e, t) { s.AgoraConsole.warn("onLocalVideoTranscoderError not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onVideoRenderingTracingResult(e, t, n) { s.AgoraConsole.warn("onVideoRenderingTracingResult not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.IVideoDeviceManagerDispatch = class { constructor(e) { this._engine = null, this._impl = new o.IVideoDeviceManagerImpl(e), this._engine = e } enumerateVideoDevices() { return this._impl.enumerateVideoDevices() } setDevice(e) { let t = JSON.parse(e.data).deviceIdUTF8; if (void 0 === t) throw "deviceIdUTF8 is undefined"; return this._impl.setDevice(t) } getDevice() { return this._impl.getDevice() } numberOfCapabilities(e) { return s.AgoraConsole.warn("numberOfCapabilities not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCapability(e) { return s.AgoraConsole.warn("getCapability not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startDeviceTest(e) { return s.AgoraConsole.warn("startDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopDeviceTest() { return s.AgoraConsole.warn("stopDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } release() { return this._impl.release() } }; t.IMetadataObserver = class { constructor(e) { this.classPrefix = "MetadataObserver_", this._engine = null, this._engine = e } eventKey(e) { return `${this.classPrefix}${e}` } notifyEvent(e) { this._engine.irisEventHandlerManager.notifyEvent("RtcEngine", e) } onMetadataReceived(e) { s.AgoraConsole.warn("onMetadataReceived not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.IDirectCdnStreamingEventHandler = class { constructor(e) { this.classPrefix = "DirectCdnStreamingEventHandler_", this._engine = null, this._engine = e } eventKey(e) { return `${this.classPrefix}${e}` } notifyEvent(e) { this._engine.irisEventHandlerManager.notifyEvent("RtcEngine", e) } onDirectCdnStreamingStateChanged(e, t, n) { s.AgoraConsole.warn("onDirectCdnStreamingStateChanged not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onDirectCdnStreamingStats(e) { s.AgoraConsole.warn("onDirectCdnStreamingStats not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.IRtcEngineDispatch = class { constructor(e) { this._engine = null, this._impl = new o.IRtcEngineImpl(e), this._engine = e } release(e) { let t = JSON.parse(e.data).sync; if (void 0 === t) throw "sync is undefined"; return this._impl.release(t) } initialize(e) { let t = JSON.parse(e.data).context; if (void 0 === t) throw "context is undefined"; return this._impl.initialize(t) } getVersion() { return s.AgoraConsole.warn("getVersion not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getErrorDescription(e) { return s.AgoraConsole.warn("getErrorDescription not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } queryCodecCapability(e) { return s.AgoraConsole.warn("queryCodecCapability not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preloadChannel(e) { return s.AgoraConsole.warn("preloadChannel not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preloadChannel2(e) { return s.AgoraConsole.warn("preloadChannel2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updatePreloadChannelToken(e) { return s.AgoraConsole.warn("updatePreloadChannelToken not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } joinChannel(e) { let t = JSON.parse(e.data), n = t.token; if (void 0 === n) throw "token is undefined"; let i = t.channelId; if (void 0 === i) throw "channelId is undefined"; let r = t.info; if (void 0 === r) throw "info is undefined"; let o = t.uid; if (void 0 === o) throw "uid is undefined"; return this._impl.joinChannel(n, i, r, o) } joinChannel2(e) { let t = JSON.parse(e.data), n = t.token; if (void 0 === n) throw "token is undefined"; let i = t.channelId; if (void 0 === i) throw "channelId is undefined"; let r = t.uid; if (void 0 === r) throw "uid is undefined"; let o = t.options; if (void 0 === o) throw "options is undefined"; return this._impl.joinChannel2(n, i, r, o) } updateChannelMediaOptions(e) { let t = JSON.parse(e.data).options; if (void 0 === t) throw "options is undefined"; return this._impl.updateChannelMediaOptions(t) } leaveChannel() { return this._impl.leaveChannel() } leaveChannel2(e) { let t = JSON.parse(e.data).options; if (void 0 === t) throw "options is undefined"; return this._impl.leaveChannel2(t) } renewToken(e) { return s.AgoraConsole.warn("renewToken not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setChannelProfile(e) { return s.AgoraConsole.warn("setChannelProfile not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setClientRole(e) { let t = JSON.parse(e.data).role; if (void 0 === t) throw "role is undefined"; return this._impl.setClientRole(t) } setClientRole2(e) { let t = JSON.parse(e.data), n = t.role; if (void 0 === n) throw "role is undefined"; let i = t.options; if (void 0 === i) throw "options is undefined"; return this._impl.setClientRole2(n, i) } startEchoTest() { return s.AgoraConsole.warn("startEchoTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startEchoTest2(e) { return s.AgoraConsole.warn("startEchoTest2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startEchoTest3(e) { return s.AgoraConsole.warn("startEchoTest3 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopEchoTest() { return s.AgoraConsole.warn("stopEchoTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableMultiCamera(e) { return s.AgoraConsole.warn("enableMultiCamera not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableVideo() { return this._impl.enableVideo() } disableVideo() { return this._impl.disableVideo() } startPreview() { return this._impl.startPreview() } startPreview2(e) { let t = JSON.parse(e.data).sourceType; if (void 0 === t) throw "sourceType is undefined"; return this._impl.startPreview2(t) } stopPreview() { return this._impl.stopPreview() } stopPreview2(e) { let t = JSON.parse(e.data).sourceType; if (void 0 === t) throw "sourceType is undefined"; return this._impl.stopPreview2(t) } startLastmileProbeTest(e) { return s.AgoraConsole.warn("startLastmileProbeTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopLastmileProbeTest() { return s.AgoraConsole.warn("stopLastmileProbeTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVideoEncoderConfiguration(e) { let t = JSON.parse(e.data).config; if (void 0 === t) throw "config is undefined"; return this._impl.setVideoEncoderConfiguration(t) } setBeautyEffectOptions(e) { return s.AgoraConsole.warn("setBeautyEffectOptions not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLowlightEnhanceOptions(e) { return s.AgoraConsole.warn("setLowlightEnhanceOptions not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVideoDenoiserOptions(e) { return s.AgoraConsole.warn("setVideoDenoiserOptions not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setColorEnhanceOptions(e) { return s.AgoraConsole.warn("setColorEnhanceOptions not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableVirtualBackground(e) { return s.AgoraConsole.warn("enableVirtualBackground not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setupRemoteVideo(e) { return s.AgoraConsole.warn("setupRemoteVideo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setupLocalVideo(e) { let t = JSON.parse(e.data).canvas; if (void 0 === t) throw "canvas is undefined"; return this._impl.setupLocalVideo(t) } setVideoScenario(e) { return s.AgoraConsole.warn("setVideoScenario not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAudio() { return this._impl.enableAudio() } disableAudio() { return this._impl.disableAudio() } setAudioProfile(e) { let t = JSON.parse(e.data), n = t.profile; if (void 0 === n) throw "profile is undefined"; let i = t.scenario; if (void 0 === i) throw "scenario is undefined"; return this._impl.setAudioProfile(n, i) } setAudioProfile2(e) { let t = JSON.parse(e.data).profile; if (void 0 === t) throw "profile is undefined"; return this._impl.setAudioProfile2(t) } setAudioScenario(e) { return s.AgoraConsole.warn("setAudioScenario not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableLocalAudio(e) { let t = JSON.parse(e.data).enabled; if (void 0 === t) throw "enabled is undefined"; return this._impl.enableLocalAudio(t) } muteLocalAudioStream(e) { return s.AgoraConsole.warn("muteLocalAudioStream not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteAudioStreams(e) { return s.AgoraConsole.warn("muteAllRemoteAudioStreams not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDefaultMuteAllRemoteAudioStreams(e) { return s.AgoraConsole.warn("setDefaultMuteAllRemoteAudioStreams not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRemoteAudioStream(e) { return s.AgoraConsole.warn("muteRemoteAudioStream not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteLocalVideoStream(e) { return s.AgoraConsole.warn("muteLocalVideoStream not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableLocalVideo(e) { return s.AgoraConsole.warn("enableLocalVideo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteVideoStreams(e) { return s.AgoraConsole.warn("muteAllRemoteVideoStreams not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDefaultMuteAllRemoteVideoStreams(e) { return s.AgoraConsole.warn("setDefaultMuteAllRemoteVideoStreams not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRemoteVideoStream(e) { return s.AgoraConsole.warn("muteRemoteVideoStream not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVideoStreamType(e) { return s.AgoraConsole.warn("setRemoteVideoStreamType not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVideoSubscriptionOptions(e) { return s.AgoraConsole.warn("setRemoteVideoSubscriptionOptions not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteDefaultVideoStreamType(e) { return s.AgoraConsole.warn("setRemoteDefaultVideoStreamType not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeAudioBlocklist(e) { return s.AgoraConsole.warn("setSubscribeAudioBlocklist not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeAudioAllowlist(e) { return s.AgoraConsole.warn("setSubscribeAudioAllowlist not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeVideoBlocklist(e) { return s.AgoraConsole.warn("setSubscribeVideoBlocklist not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeVideoAllowlist(e) { return s.AgoraConsole.warn("setSubscribeVideoAllowlist not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAudioVolumeIndication(e) { let t = JSON.parse(e.data), n = t.interval; if (void 0 === n) throw "interval is undefined"; let i = t.smooth; if (void 0 === i) throw "smooth is undefined"; let r = t.reportVad; if (void 0 === r) throw "reportVad is undefined"; return this._impl.enableAudioVolumeIndication(n, i, r) } startAudioRecording(e) { return s.AgoraConsole.warn("startAudioRecording not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioRecording2(e) { return s.AgoraConsole.warn("startAudioRecording2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioRecording3(e) { return s.AgoraConsole.warn("startAudioRecording3 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerAudioEncodedFrameObserver(e) { return s.AgoraConsole.warn("registerAudioEncodedFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopAudioRecording() { return s.AgoraConsole.warn("stopAudioRecording not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createMediaPlayer() { return s.AgoraConsole.warn("createMediaPlayer not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } destroyMediaPlayer(e) { return s.AgoraConsole.warn("destroyMediaPlayer not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createMediaRecorder(e) { return s.AgoraConsole.warn("createMediaRecorder not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } destroyMediaRecorder(e) { return s.AgoraConsole.warn("destroyMediaRecorder not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioMixing(e) { return s.AgoraConsole.warn("startAudioMixing not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioMixing2(e) { return s.AgoraConsole.warn("startAudioMixing2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopAudioMixing() { return s.AgoraConsole.warn("stopAudioMixing not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseAudioMixing() { return s.AgoraConsole.warn("pauseAudioMixing not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeAudioMixing() { return s.AgoraConsole.warn("resumeAudioMixing not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } selectAudioTrack(e) { return s.AgoraConsole.warn("selectAudioTrack not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioTrackCount() { return s.AgoraConsole.warn("getAudioTrackCount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustAudioMixingVolume(e) { return s.AgoraConsole.warn("adjustAudioMixingVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustAudioMixingPublishVolume(e) { return s.AgoraConsole.warn("adjustAudioMixingPublishVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioMixingPublishVolume() { return s.AgoraConsole.warn("getAudioMixingPublishVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustAudioMixingPlayoutVolume(e) { return s.AgoraConsole.warn("adjustAudioMixingPlayoutVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioMixingPlayoutVolume() { return s.AgoraConsole.warn("getAudioMixingPlayoutVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioMixingDuration() { return s.AgoraConsole.warn("getAudioMixingDuration not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioMixingCurrentPosition() { return s.AgoraConsole.warn("getAudioMixingCurrentPosition not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioMixingPosition(e) { return s.AgoraConsole.warn("setAudioMixingPosition not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioMixingDualMonoMode(e) { return s.AgoraConsole.warn("setAudioMixingDualMonoMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioMixingPitch(e) { return s.AgoraConsole.warn("setAudioMixingPitch not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getEffectsVolume() { return s.AgoraConsole.warn("getEffectsVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEffectsVolume(e) { return s.AgoraConsole.warn("setEffectsVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preloadEffect(e) { return s.AgoraConsole.warn("preloadEffect not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } playEffect(e) { let t = JSON.parse(e.data), n = t.soundId; if (void 0 === n) throw "soundId is undefined"; let i = t.filePath; if (void 0 === i) throw "filePath is undefined"; let r = t.loopCount; if (void 0 === r) throw "loopCount is undefined"; let o = t.pitch; if (void 0 === o) throw "pitch is undefined"; let s = t.pan; if (void 0 === s) throw "pan is undefined"; let a = t.gain; if (void 0 === a) throw "gain is undefined"; let c = t.publish; if (void 0 === c) throw "publish is undefined"; let E = t.startPos; if (void 0 === E) throw "startPos is undefined"; return this._impl.playEffect(n, i, r, o, s, a, c, E) } playAllEffects(e) { return s.AgoraConsole.warn("playAllEffects not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getVolumeOfEffect(e) { return s.AgoraConsole.warn("getVolumeOfEffect not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVolumeOfEffect(e) { return s.AgoraConsole.warn("setVolumeOfEffect not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseEffect(e) { return s.AgoraConsole.warn("pauseEffect not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseAllEffects() { return s.AgoraConsole.warn("pauseAllEffects not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeEffect(e) { return s.AgoraConsole.warn("resumeEffect not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeAllEffects() { return s.AgoraConsole.warn("resumeAllEffects not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopEffect(e) { let t = JSON.parse(e.data).soundId; if (void 0 === t) throw "soundId is undefined"; return this._impl.stopEffect(t) } stopAllEffects() { return this._impl.stopAllEffects() } unloadEffect(e) { return s.AgoraConsole.warn("unloadEffect not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unloadAllEffects() { return s.AgoraConsole.warn("unloadAllEffects not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getEffectDuration(e) { return s.AgoraConsole.warn("getEffectDuration not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEffectPosition(e) { return s.AgoraConsole.warn("setEffectPosition not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getEffectCurrentPosition(e) { return s.AgoraConsole.warn("getEffectCurrentPosition not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableSoundPositionIndication(e) { return s.AgoraConsole.warn("enableSoundPositionIndication not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVoicePosition(e) { return s.AgoraConsole.warn("setRemoteVoicePosition not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableSpatialAudio(e) { return s.AgoraConsole.warn("enableSpatialAudio not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteUserSpatialAudioParams(e) { return s.AgoraConsole.warn("setRemoteUserSpatialAudioParams not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVoiceBeautifierPreset(e) { return s.AgoraConsole.warn("setVoiceBeautifierPreset not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioEffectPreset(e) { return s.AgoraConsole.warn("setAudioEffectPreset not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVoiceConversionPreset(e) { return s.AgoraConsole.warn("setVoiceConversionPreset not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioEffectParameters(e) { return s.AgoraConsole.warn("setAudioEffectParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVoiceBeautifierParameters(e) { return s.AgoraConsole.warn("setVoiceBeautifierParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVoiceConversionParameters(e) { return s.AgoraConsole.warn("setVoiceConversionParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalVoicePitch(e) { return s.AgoraConsole.warn("setLocalVoicePitch not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalVoiceFormant(e) { return s.AgoraConsole.warn("setLocalVoiceFormant not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalVoiceEqualization(e) { return s.AgoraConsole.warn("setLocalVoiceEqualization not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalVoiceReverb(e) { return s.AgoraConsole.warn("setLocalVoiceReverb not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setHeadphoneEQPreset(e) { return s.AgoraConsole.warn("setHeadphoneEQPreset not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setHeadphoneEQParameters(e) { return s.AgoraConsole.warn("setHeadphoneEQParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLogFile(e) { return s.AgoraConsole.warn("setLogFile not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLogFilter(e) { return s.AgoraConsole.warn("setLogFilter not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLogLevel(e) { let t = JSON.parse(e.data).level; if (void 0 === t) throw "level is undefined"; return this._impl.setLogLevel(t) } setLogFileSize(e) { return s.AgoraConsole.warn("setLogFileSize not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } uploadLogFile(e) { return s.AgoraConsole.warn("uploadLogFile not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalRenderMode(e) { return s.AgoraConsole.warn("setLocalRenderMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteRenderMode(e) { return s.AgoraConsole.warn("setRemoteRenderMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalRenderMode2(e) { return s.AgoraConsole.warn("setLocalRenderMode2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalVideoMirrorMode(e) { return s.AgoraConsole.warn("setLocalVideoMirrorMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableDualStreamMode(e) { return s.AgoraConsole.warn("enableDualStreamMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableDualStreamMode2(e) { return s.AgoraConsole.warn("enableDualStreamMode2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDualStreamMode(e) { return s.AgoraConsole.warn("setDualStreamMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDualStreamMode2(e) { return s.AgoraConsole.warn("setDualStreamMode2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableCustomAudioLocalPlayback(e) { return s.AgoraConsole.warn("enableCustomAudioLocalPlayback not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRecordingAudioFrameParameters(e) { return s.AgoraConsole.warn("setRecordingAudioFrameParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackAudioFrameParameters(e) { return s.AgoraConsole.warn("setPlaybackAudioFrameParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setMixedAudioFrameParameters(e) { return s.AgoraConsole.warn("setMixedAudioFrameParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEarMonitoringAudioFrameParameters(e) { return s.AgoraConsole.warn("setEarMonitoringAudioFrameParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackAudioFrameBeforeMixingParameters(e) { return s.AgoraConsole.warn("setPlaybackAudioFrameBeforeMixingParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAudioSpectrumMonitor(e) { return s.AgoraConsole.warn("enableAudioSpectrumMonitor not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } disableAudioSpectrumMonitor() { return s.AgoraConsole.warn("disableAudioSpectrumMonitor not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerAudioSpectrumObserver(e) { return s.AgoraConsole.warn("registerAudioSpectrumObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterAudioSpectrumObserver(e) { return s.AgoraConsole.warn("unregisterAudioSpectrumObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustRecordingSignalVolume(e) { return s.AgoraConsole.warn("adjustRecordingSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRecordingSignal(e) { return s.AgoraConsole.warn("muteRecordingSignal not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustPlaybackSignalVolume(e) { return s.AgoraConsole.warn("adjustPlaybackSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustUserPlaybackSignalVolume(e) { return s.AgoraConsole.warn("adjustUserPlaybackSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalPublishFallbackOption(e) { return s.AgoraConsole.warn("setLocalPublishFallbackOption not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteSubscribeFallbackOption(e) { return s.AgoraConsole.warn("setRemoteSubscribeFallbackOption not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setHighPriorityUserList(e) { return s.AgoraConsole.warn("setHighPriorityUserList not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableLoopbackRecording(e) { return s.AgoraConsole.warn("enableLoopbackRecording not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustLoopbackSignalVolume(e) { return s.AgoraConsole.warn("adjustLoopbackSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getLoopbackRecordingVolume() { return s.AgoraConsole.warn("getLoopbackRecordingVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableInEarMonitoring(e) { return s.AgoraConsole.warn("enableInEarMonitoring not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setInEarMonitoringVolume(e) { return s.AgoraConsole.warn("setInEarMonitoringVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } loadExtensionProvider(e) { return s.AgoraConsole.warn("loadExtensionProvider not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExtensionProviderProperty(e) { return s.AgoraConsole.warn("setExtensionProviderProperty not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerExtension(e) { return s.AgoraConsole.warn("registerExtension not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableExtension(e) { return s.AgoraConsole.warn("enableExtension not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableExtension2(e) { return s.AgoraConsole.warn("enableExtension2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExtensionProperty(e) { return s.AgoraConsole.warn("setExtensionProperty not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getExtensionProperty(e) { return s.AgoraConsole.warn("getExtensionProperty not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExtensionProperty2(e) { return s.AgoraConsole.warn("setExtensionProperty2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getExtensionProperty2(e) { return s.AgoraConsole.warn("getExtensionProperty2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraCapturerConfiguration(e) { return s.AgoraConsole.warn("setCameraCapturerConfiguration not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createCustomVideoTrack() { return s.AgoraConsole.warn("createCustomVideoTrack not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createCustomEncodedVideoTrack(e) { return s.AgoraConsole.warn("createCustomEncodedVideoTrack not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } destroyCustomVideoTrack(e) { return s.AgoraConsole.warn("destroyCustomVideoTrack not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } destroyCustomEncodedVideoTrack(e) { return s.AgoraConsole.warn("destroyCustomEncodedVideoTrack not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } switchCamera() { return s.AgoraConsole.warn("switchCamera not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraZoomSupported() { return s.AgoraConsole.warn("isCameraZoomSupported not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraFaceDetectSupported() { return s.AgoraConsole.warn("isCameraFaceDetectSupported not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraTorchSupported() { return s.AgoraConsole.warn("isCameraTorchSupported not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraFocusSupported() { return s.AgoraConsole.warn("isCameraFocusSupported not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraAutoFocusFaceModeSupported() { return s.AgoraConsole.warn("isCameraAutoFocusFaceModeSupported not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraZoomFactor(e) { return s.AgoraConsole.warn("setCameraZoomFactor not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableFaceDetection(e) { return s.AgoraConsole.warn("enableFaceDetection not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCameraMaxZoomFactor() { return s.AgoraConsole.warn("getCameraMaxZoomFactor not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraFocusPositionInPreview(e) { return s.AgoraConsole.warn("setCameraFocusPositionInPreview not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraTorchOn(e) { return s.AgoraConsole.warn("setCameraTorchOn not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraAutoFocusFaceModeEnabled(e) { return s.AgoraConsole.warn("setCameraAutoFocusFaceModeEnabled not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraExposurePositionSupported() { return s.AgoraConsole.warn("isCameraExposurePositionSupported not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraExposurePosition(e) { return s.AgoraConsole.warn("setCameraExposurePosition not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraExposureSupported() { return s.AgoraConsole.warn("isCameraExposureSupported not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraExposureFactor(e) { return s.AgoraConsole.warn("setCameraExposureFactor not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraAutoExposureFaceModeSupported() { return s.AgoraConsole.warn("isCameraAutoExposureFaceModeSupported not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraAutoExposureFaceModeEnabled(e) { return s.AgoraConsole.warn("setCameraAutoExposureFaceModeEnabled not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDefaultAudioRouteToSpeakerphone(e) { return s.AgoraConsole.warn("setDefaultAudioRouteToSpeakerphone not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEnableSpeakerphone(e) { return s.AgoraConsole.warn("setEnableSpeakerphone not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isSpeakerphoneEnabled() { return s.AgoraConsole.warn("isSpeakerphoneEnabled not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRouteInCommunicationMode(e) { return s.AgoraConsole.warn("setRouteInCommunicationMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getScreenCaptureSources(e) { return s.AgoraConsole.warn("getScreenCaptureSources not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioSessionOperationRestriction(e) { return s.AgoraConsole.warn("setAudioSessionOperationRestriction not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startScreenCaptureByDisplayId(e) { return s.AgoraConsole.warn("startScreenCaptureByDisplayId not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startScreenCaptureByScreenRect(e) { return s.AgoraConsole.warn("startScreenCaptureByScreenRect not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioDeviceInfo(e) { return s.AgoraConsole.warn("getAudioDeviceInfo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startScreenCaptureByWindowId(e) { return s.AgoraConsole.warn("startScreenCaptureByWindowId not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setScreenCaptureContentHint(e) { return s.AgoraConsole.warn("setScreenCaptureContentHint not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateScreenCaptureRegion(e) { return s.AgoraConsole.warn("updateScreenCaptureRegion not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateScreenCaptureParameters(e) { return s.AgoraConsole.warn("updateScreenCaptureParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startScreenCapture(e) { let t = JSON.parse(e.data).captureParams; if (void 0 === t) throw "captureParams is undefined"; return this._impl.startScreenCapture(t) } updateScreenCapture(e) { return s.AgoraConsole.warn("updateScreenCapture not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } queryScreenCaptureCapability() { return s.AgoraConsole.warn("queryScreenCaptureCapability not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setScreenCaptureScenario(e) { return s.AgoraConsole.warn("setScreenCaptureScenario not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopScreenCapture() { return this._impl.stopScreenCapture() } getCallId(e) { return s.AgoraConsole.warn("getCallId not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } rate(e) { return s.AgoraConsole.warn("rate not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } complain(e) { return s.AgoraConsole.warn("complain not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRtmpStreamWithoutTranscoding(e) { return s.AgoraConsole.warn("startRtmpStreamWithoutTranscoding not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRtmpStreamWithTranscoding(e) { return s.AgoraConsole.warn("startRtmpStreamWithTranscoding not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateRtmpTranscoding(e) { return s.AgoraConsole.warn("updateRtmpTranscoding not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopRtmpStream(e) { return s.AgoraConsole.warn("stopRtmpStream not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startLocalVideoTranscoder(e) { return s.AgoraConsole.warn("startLocalVideoTranscoder not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateLocalTranscoderConfiguration(e) { return s.AgoraConsole.warn("updateLocalTranscoderConfiguration not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopLocalVideoTranscoder() { return s.AgoraConsole.warn("stopLocalVideoTranscoder not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startCameraCapture(e) { return s.AgoraConsole.warn("startCameraCapture not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopCameraCapture(e) { return s.AgoraConsole.warn("stopCameraCapture not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraDeviceOrientation(e) { return s.AgoraConsole.warn("setCameraDeviceOrientation not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setScreenCaptureOrientation(e) { return s.AgoraConsole.warn("setScreenCaptureOrientation not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startScreenCapture2(e) { return s.AgoraConsole.warn("startScreenCapture2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopScreenCapture2(e) { let t = JSON.parse(e.data).sourceType; if (void 0 === t) throw "sourceType is undefined"; return this._impl.stopScreenCapture2(t) } getConnectionState() { return s.AgoraConsole.warn("getConnectionState not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerEventHandler(e) { let t = e.buffer[0]; if (void 0 === t) throw "eventHandler is undefined"; return this._impl.registerEventHandler(t) } unregisterEventHandler(e) { let t = e.buffer[0]; if (void 0 === t) throw "eventHandler is undefined"; return this._impl.unregisterEventHandler(t) } setRemoteUserPriority(e) { return s.AgoraConsole.warn("setRemoteUserPriority not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEncryptionMode(e) { return s.AgoraConsole.warn("setEncryptionMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEncryptionSecret(e) { return s.AgoraConsole.warn("setEncryptionSecret not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableEncryption(e) { return s.AgoraConsole.warn("enableEncryption not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createDataStream(e) { return s.AgoraConsole.warn("createDataStream not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createDataStream2(e) { return s.AgoraConsole.warn("createDataStream2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } sendStreamMessage(e) { return s.AgoraConsole.warn("sendStreamMessage not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } addVideoWatermark(e) { return s.AgoraConsole.warn("addVideoWatermark not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } addVideoWatermark2(e) { return s.AgoraConsole.warn("addVideoWatermark2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } clearVideoWatermarks() { return s.AgoraConsole.warn("clearVideoWatermarks not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseAudio() { return s.AgoraConsole.warn("pauseAudio not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeAudio() { return s.AgoraConsole.warn("resumeAudio not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableWebSdkInteroperability(e) { return s.AgoraConsole.warn("enableWebSdkInteroperability not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } sendCustomReportMessage(e) { return s.AgoraConsole.warn("sendCustomReportMessage not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerMediaMetadataObserver(e) { return s.AgoraConsole.warn("registerMediaMetadataObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterMediaMetadataObserver(e) { return s.AgoraConsole.warn("unregisterMediaMetadataObserver not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioFrameDump(e) { return s.AgoraConsole.warn("startAudioFrameDump not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopAudioFrameDump(e) { return s.AgoraConsole.warn("stopAudioFrameDump not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAINSMode(e) { return s.AgoraConsole.warn("setAINSMode not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerLocalUserAccount(e) { return s.AgoraConsole.warn("registerLocalUserAccount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } joinChannelWithUserAccount(e) { return s.AgoraConsole.warn("joinChannelWithUserAccount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } joinChannelWithUserAccount2(e) { return s.AgoraConsole.warn("joinChannelWithUserAccount2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } joinChannelWithUserAccountEx(e) { return s.AgoraConsole.warn("joinChannelWithUserAccountEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getUserInfoByUserAccount(e) { return s.AgoraConsole.warn("getUserInfoByUserAccount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getUserInfoByUid(e) { return s.AgoraConsole.warn("getUserInfoByUid not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startOrUpdateChannelMediaRelay(e) { return s.AgoraConsole.warn("startOrUpdateChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startChannelMediaRelay(e) { return s.AgoraConsole.warn("startChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateChannelMediaRelay(e) { return s.AgoraConsole.warn("updateChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopChannelMediaRelay() { return s.AgoraConsole.warn("stopChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseAllChannelMediaRelay() { return s.AgoraConsole.warn("pauseAllChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeAllChannelMediaRelay() { return s.AgoraConsole.warn("resumeAllChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDirectCdnStreamingAudioConfiguration(e) { return s.AgoraConsole.warn("setDirectCdnStreamingAudioConfiguration not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDirectCdnStreamingVideoConfiguration(e) { return s.AgoraConsole.warn("setDirectCdnStreamingVideoConfiguration not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startDirectCdnStreaming(e) { return s.AgoraConsole.warn("startDirectCdnStreaming not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopDirectCdnStreaming() { return s.AgoraConsole.warn("stopDirectCdnStreaming not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateDirectCdnStreamingMediaOptions(e) { return s.AgoraConsole.warn("updateDirectCdnStreamingMediaOptions not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRhythmPlayer(e) { return s.AgoraConsole.warn("startRhythmPlayer not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopRhythmPlayer() { return s.AgoraConsole.warn("stopRhythmPlayer not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } configRhythmPlayer(e) { return s.AgoraConsole.warn("configRhythmPlayer not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } takeSnapshot(e) { return s.AgoraConsole.warn("takeSnapshot not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableContentInspect(e) { return s.AgoraConsole.warn("enableContentInspect not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustCustomAudioPublishVolume(e) { return s.AgoraConsole.warn("adjustCustomAudioPublishVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustCustomAudioPlayoutVolume(e) { return s.AgoraConsole.warn("adjustCustomAudioPlayoutVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCloudProxy(e) { return s.AgoraConsole.warn("setCloudProxy not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalAccessPoint(e) { return s.AgoraConsole.warn("setLocalAccessPoint not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAdvancedAudioOptions(e) { return s.AgoraConsole.warn("setAdvancedAudioOptions not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAVSyncSource(e) { return s.AgoraConsole.warn("setAVSyncSource not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableVideoImageSource(e) { return s.AgoraConsole.warn("enableVideoImageSource not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCurrentMonotonicTimeInMs() { return s.AgoraConsole.warn("getCurrentMonotonicTimeInMs not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableWirelessAccelerate(e) { return s.AgoraConsole.warn("enableWirelessAccelerate not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getNetworkType() { return s.AgoraConsole.warn("getNetworkType not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setParameters(e) { return s.AgoraConsole.warn("setParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startMediaRenderingTracing() { return s.AgoraConsole.warn("startMediaRenderingTracing not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableInstantMediaRendering() { return s.AgoraConsole.warn("enableInstantMediaRendering not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getNtpWallTimeInMs() { return s.AgoraConsole.warn("getNtpWallTimeInMs not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isFeatureAvailableOnDevice(e) { return s.AgoraConsole.warn("isFeatureAvailableOnDevice not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 9113: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IRtcEngineExDispatch = t.IRtcEngineEventHandlerEx = void 0; const i = n(5844), r = n(7481), o = n(4856), s = n(4482), a = n(3386); class c extends a.IRtcEngineEventHandler { constructor(e) { super(e), this.classPrefix = "RtcEngineEventHandler_", this._engine = null, this._engine = e } eventKey(e) { return `${this.classPrefix}${e}` } notifyEvent(e) { this._engine.irisEventHandlerManager.notifyEvent("RtcEngine", e) } onJoinChannelSuccessEx(e, t) { let n = { connection: e, elapsed: t }, i = JSON.stringify(n), o = this.eventKey("onJoinChannelSuccessEx"), a = new r.IrisCore.EventParam(o, i, 0, "", [], [], 0); s.AgoraConsole.log(`onJoinChannelSuccessEx eventParam ${JSON.stringify(a)}`), this.notifyEvent(a) } onRejoinChannelSuccessEx(e, t) { s.AgoraConsole.warn("onRejoinChannelSuccessEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioQualityEx(e, t, n, r, o) { s.AgoraConsole.warn("onAudioQualityEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onAudioVolumeIndicationEx(e, t, n, i) { let o = { connection: e, speakers: t, speakerNumber: n, totalVolume: i }, a = JSON.stringify(o), c = this.eventKey("onAudioVolumeIndicationEx"), E = new r.IrisCore.EventParam(c, a, 0, "", [], [], 0); s.AgoraConsole.log(`onAudioVolumeIndicationEx eventParam ${JSON.stringify(E)}`), this.notifyEvent(E) } onLeaveChannelEx(e, t) { let n = { connection: e, stats: t }, i = JSON.stringify(n), o = this.eventKey("onLeaveChannelEx"), a = new r.IrisCore.EventParam(o, i, 0, "", [], [], 0); s.AgoraConsole.log(`onLeaveChannelEx eventParam ${JSON.stringify(a)}`), this.notifyEvent(a) } onRtcStatsEx(e, t) { s.AgoraConsole.warn("onRtcStatsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onNetworkQualityEx(e, t, n, i) { let o = { connection: e, remoteUid: t, txQuality: n, rxQuality: i }, a = JSON.stringify(o), c = this.eventKey("onNetworkQualityEx"), E = new r.IrisCore.EventParam(c, a, 0, "", [], [], 0); s.AgoraConsole.log(`onNetworkQualityEx eventParam ${JSON.stringify(E)}`), this.notifyEvent(E) } onIntraRequestReceivedEx(e) { s.AgoraConsole.warn("onIntraRequestReceivedEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onFirstRemoteVideoDecodedEx(e, t, n, i, o) { let a = { connection: e, remoteUid: t, width: n, height: i, elapsed: o }, c = JSON.stringify(a), E = this.eventKey("onFirstRemoteVideoDecodedEx"), _ = new r.IrisCore.EventParam(E, c, 0, "", [], [], 0); s.AgoraConsole.log(`onFirstRemoteVideoDecodedEx eventParam ${JSON.stringify(_)}`), this.notifyEvent(_) } onVideoSizeChangedEx(e, t, n, r, o, a) { s.AgoraConsole.warn("onVideoSizeChangedEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRemoteVideoStateChangedEx(e, t, n, r, o) { s.AgoraConsole.warn("onRemoteVideoStateChangedEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onFirstRemoteVideoFrameEx(e, t, n, i, o) { let a = { connection: e, remoteUid: t, width: n, height: i, elapsed: o }, c = JSON.stringify(a), E = this.eventKey("onFirstRemoteVideoFrameEx"), _ = new r.IrisCore.EventParam(E, c, 0, "", [], [], 0); s.AgoraConsole.log(`onFirstRemoteVideoFrameEx eventParam ${JSON.stringify(_)}`), this.notifyEvent(_) } onUserJoinedEx(e, t, n) { let i = { connection: e, remoteUid: t, elapsed: n }, o = JSON.stringify(i), a = this.eventKey("onUserJoinedEx"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onUserJoinedEx eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onUserOfflineEx(e, t, n) { let i = { connection: e, remoteUid: t, reason: n }, o = JSON.stringify(i), a = this.eventKey("onUserOfflineEx"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onUserOfflineEx eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onUserMuteAudioEx(e, t, n) { let i = { connection: e, remoteUid: t, muted: n }, o = JSON.stringify(i), a = this.eventKey("onUserMuteAudioEx"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onUserMuteAudioEx eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onUserMuteVideoEx(e, t, n) { let i = { connection: e, remoteUid: t, muted: n }, o = JSON.stringify(i), a = this.eventKey("onUserMuteVideoEx"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onUserMuteVideoEx eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onUserEnableVideoEx(e, t, n) { s.AgoraConsole.warn("onUserEnableVideoEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserEnableLocalVideoEx(e, t, n) { let i = { connection: e, remoteUid: t, enabled: n }, o = JSON.stringify(i), a = this.eventKey("onUserEnableLocalVideoEx"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onUserEnableLocalVideoEx eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onUserStateChangedEx(e, t, n) { let i = { connection: e, remoteUid: t, state: n }, o = JSON.stringify(i), a = this.eventKey("onUserStateChangedEx"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onUserStateChangedEx eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onLocalAudioStatsEx(e, t) { s.AgoraConsole.warn("onLocalAudioStatsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRemoteAudioStatsEx(e, t) { s.AgoraConsole.warn("onRemoteAudioStatsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRemoteVideoStatsEx(e, t) { s.AgoraConsole.warn("onRemoteVideoStatsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onConnectionLostEx(e) { let t = { connection: e }, n = JSON.stringify(t), i = this.eventKey("onConnectionLostEx"), o = new r.IrisCore.EventParam(i, n, 0, "", [], [], 0); s.AgoraConsole.log(`onConnectionLostEx eventParam ${JSON.stringify(o)}`), this.notifyEvent(o) } onConnectionInterruptedEx(e) { let t = { connection: e }, n = JSON.stringify(t), i = this.eventKey("onConnectionInterruptedEx"), o = new r.IrisCore.EventParam(i, n, 0, "", [], [], 0); s.AgoraConsole.log(`onConnectionInterruptedEx eventParam ${JSON.stringify(o)}`), this.notifyEvent(o) } onConnectionBannedEx(e) { let t = { connection: e }, n = JSON.stringify(t), i = this.eventKey("onConnectionBannedEx"), o = new r.IrisCore.EventParam(i, n, 0, "", [], [], 0); s.AgoraConsole.log(`onConnectionBannedEx eventParam ${JSON.stringify(o)}`), this.notifyEvent(o) } onStreamMessageEx(e, t, n, r, o, a) { s.AgoraConsole.warn("onStreamMessageEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onStreamMessageErrorEx(e, t, n, r, o, a) { s.AgoraConsole.warn("onStreamMessageErrorEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRequestTokenEx(e) { let t = { connection: e }, n = JSON.stringify(t), i = this.eventKey("onRequestTokenEx"), o = new r.IrisCore.EventParam(i, n, 0, "", [], [], 0); s.AgoraConsole.log(`onRequestTokenEx eventParam ${JSON.stringify(o)}`), this.notifyEvent(o) } onLicenseValidationFailureEx(e, t) { s.AgoraConsole.warn("onLicenseValidationFailureEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onTokenPrivilegeWillExpireEx(e, t) { let n = { connection: e, token: t }, i = JSON.stringify(n), o = this.eventKey("onTokenPrivilegeWillExpireEx"), a = new r.IrisCore.EventParam(o, i, 0, "", [], [], 0); s.AgoraConsole.log(`onTokenPrivilegeWillExpireEx eventParam ${JSON.stringify(a)}`), this.notifyEvent(a) } onFirstLocalAudioFramePublishedEx(e, t) { s.AgoraConsole.warn("onFirstLocalAudioFramePublishedEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onFirstRemoteAudioFrameEx(e, t, n) { let i = { connection: e, userId: t, elapsed: n }, o = JSON.stringify(i), a = this.eventKey("onFirstRemoteAudioFrameEx"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onFirstRemoteAudioFrameEx eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onFirstRemoteAudioDecodedEx(e, t, n) { let i = { connection: e, uid: t, elapsed: n }, o = JSON.stringify(i), a = this.eventKey("onFirstRemoteAudioDecodedEx"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onFirstRemoteAudioDecodedEx eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onLocalAudioStateChangedEx(e, t, n) { s.AgoraConsole.warn("onLocalAudioStateChangedEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRemoteAudioStateChangedEx(e, t, n, r, o) { s.AgoraConsole.warn("onRemoteAudioStateChangedEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onActiveSpeakerEx(e, t) { s.AgoraConsole.warn("onActiveSpeakerEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onClientRoleChangedEx(e, t, n, i) { let o = { connection: e, oldRole: t, newRole: n, newRoleOptions: i }, a = JSON.stringify(o), c = this.eventKey("onClientRoleChangedEx"), E = new r.IrisCore.EventParam(c, a, 0, "", [], [], 0); s.AgoraConsole.log(`onClientRoleChangedEx eventParam ${JSON.stringify(E)}`), this.notifyEvent(E) } onClientRoleChangeFailedEx(e, t, n) { s.AgoraConsole.warn("onClientRoleChangeFailedEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRemoteAudioTransportStatsEx(e, t, n, r, o) { s.AgoraConsole.warn("onRemoteAudioTransportStatsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onRemoteVideoTransportStatsEx(e, t, n, r, o) { s.AgoraConsole.warn("onRemoteVideoTransportStatsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onConnectionStateChangedEx(e, t, n) { let i = { connection: e, state: t, reason: n }, o = JSON.stringify(i), a = this.eventKey("onConnectionStateChangedEx"), c = new r.IrisCore.EventParam(a, o, 0, "", [], [], 0); s.AgoraConsole.log(`onConnectionStateChangedEx eventParam ${JSON.stringify(c)}`), this.notifyEvent(c) } onWlAccMessageEx(e, t, n, r) { s.AgoraConsole.warn("onWlAccMessageEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onWlAccStatsEx(e, t, n) { s.AgoraConsole.warn("onWlAccStatsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onNetworkTypeChangedEx(e, t) { s.AgoraConsole.warn("onNetworkTypeChangedEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onEncryptionErrorEx(e, t) { let n = { connection: e, errorType: t }, i = JSON.stringify(n), o = this.eventKey("onEncryptionErrorEx"), a = new r.IrisCore.EventParam(o, i, 0, "", [], [], 0); s.AgoraConsole.log(`onEncryptionErrorEx eventParam ${JSON.stringify(a)}`), this.notifyEvent(a) } onUploadLogResultEx(e, t, n, r) { s.AgoraConsole.warn("onUploadLogResultEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onUserAccountUpdatedEx(e, t, n) { s.AgoraConsole.warn("onUserAccountUpdatedEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onSnapshotTakenEx(e, t, n, r, o, a) { s.AgoraConsole.warn("onSnapshotTakenEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } onVideoRenderingTracingResultEx(e, t, n, r) { s.AgoraConsole.warn("onVideoRenderingTracingResultEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } t.IRtcEngineEventHandlerEx = c; t.IRtcEngineExDispatch = class { constructor(e) { this._engine = null, this._impl = new o.IRtcEngineExImpl(e), this._engine = e } joinChannelEx(e) { let t = JSON.parse(e.data), n = t.token; if (void 0 === n) throw "token is undefined"; let i = t.connection; if (void 0 === i) throw "connection is undefined"; let r = t.options; if (void 0 === r) throw "options is undefined"; return this._impl.joinChannelEx(n, i, r) } leaveChannelEx(e) { let t = JSON.parse(e.data).connection; if (void 0 === t) throw "connection is undefined"; return this._impl.leaveChannelEx(t) } leaveChannelEx2(e) { return s.AgoraConsole.warn("leaveChannelEx2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateChannelMediaOptionsEx(e) { let t = JSON.parse(e.data), n = t.options; if (void 0 === n) throw "options is undefined"; let i = t.connection; if (void 0 === i) throw "connection is undefined"; return this._impl.updateChannelMediaOptionsEx(n, i) } setVideoEncoderConfigurationEx(e) { return s.AgoraConsole.warn("setVideoEncoderConfigurationEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setupRemoteVideoEx(e) { let t = JSON.parse(e.data), n = t.canvas; if (void 0 === n) throw "canvas is undefined"; let i = t.connection; if (void 0 === i) throw "connection is undefined"; return this._impl.setupRemoteVideoEx(n, i) } muteRemoteAudioStreamEx(e) { return s.AgoraConsole.warn("muteRemoteAudioStreamEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRemoteVideoStreamEx(e) { return s.AgoraConsole.warn("muteRemoteVideoStreamEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVideoStreamTypeEx(e) { return s.AgoraConsole.warn("setRemoteVideoStreamTypeEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteLocalAudioStreamEx(e) { return s.AgoraConsole.warn("muteLocalAudioStreamEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteLocalVideoStreamEx(e) { return s.AgoraConsole.warn("muteLocalVideoStreamEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteAudioStreamsEx(e) { return s.AgoraConsole.warn("muteAllRemoteAudioStreamsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteVideoStreamsEx(e) { return s.AgoraConsole.warn("muteAllRemoteVideoStreamsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeAudioBlocklistEx(e) { return s.AgoraConsole.warn("setSubscribeAudioBlocklistEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeAudioAllowlistEx(e) { return s.AgoraConsole.warn("setSubscribeAudioAllowlistEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeVideoBlocklistEx(e) { return s.AgoraConsole.warn("setSubscribeVideoBlocklistEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeVideoAllowlistEx(e) { return s.AgoraConsole.warn("setSubscribeVideoAllowlistEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVideoSubscriptionOptionsEx(e) { return s.AgoraConsole.warn("setRemoteVideoSubscriptionOptionsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVoicePositionEx(e) { return s.AgoraConsole.warn("setRemoteVoicePositionEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteUserSpatialAudioParamsEx(e) { return s.AgoraConsole.warn("setRemoteUserSpatialAudioParamsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteRenderModeEx(e) { return s.AgoraConsole.warn("setRemoteRenderModeEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableLoopbackRecordingEx(e) { return s.AgoraConsole.warn("enableLoopbackRecordingEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustRecordingSignalVolumeEx(e) { return s.AgoraConsole.warn("adjustRecordingSignalVolumeEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRecordingSignalEx(e) { return s.AgoraConsole.warn("muteRecordingSignalEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustUserPlaybackSignalVolumeEx(e) { return s.AgoraConsole.warn("adjustUserPlaybackSignalVolumeEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getConnectionStateEx(e) { return s.AgoraConsole.warn("getConnectionStateEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableEncryptionEx(e) { return s.AgoraConsole.warn("enableEncryptionEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createDataStreamEx(e) { return s.AgoraConsole.warn("createDataStreamEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createDataStreamEx2(e) { return s.AgoraConsole.warn("createDataStreamEx2 not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } sendStreamMessageEx(e) { return s.AgoraConsole.warn("sendStreamMessageEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } addVideoWatermarkEx(e) { return s.AgoraConsole.warn("addVideoWatermarkEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } clearVideoWatermarkEx(e) { return s.AgoraConsole.warn("clearVideoWatermarkEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } sendCustomReportMessageEx(e) { return s.AgoraConsole.warn("sendCustomReportMessageEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAudioVolumeIndicationEx(e) { return s.AgoraConsole.warn("enableAudioVolumeIndicationEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRtmpStreamWithoutTranscodingEx(e) { return s.AgoraConsole.warn("startRtmpStreamWithoutTranscodingEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRtmpStreamWithTranscodingEx(e) { return s.AgoraConsole.warn("startRtmpStreamWithTranscodingEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateRtmpTranscodingEx(e) { return s.AgoraConsole.warn("updateRtmpTranscodingEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopRtmpStreamEx(e) { return s.AgoraConsole.warn("stopRtmpStreamEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startOrUpdateChannelMediaRelayEx(e) { return s.AgoraConsole.warn("startOrUpdateChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startChannelMediaRelayEx(e) { return s.AgoraConsole.warn("startChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateChannelMediaRelayEx(e) { return s.AgoraConsole.warn("updateChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopChannelMediaRelayEx(e) { return s.AgoraConsole.warn("stopChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseAllChannelMediaRelayEx(e) { return s.AgoraConsole.warn("pauseAllChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeAllChannelMediaRelayEx(e) { return s.AgoraConsole.warn("resumeAllChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getUserInfoByUserAccountEx(e) { return s.AgoraConsole.warn("getUserInfoByUserAccountEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getUserInfoByUidEx(e) { return s.AgoraConsole.warn("getUserInfoByUidEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableDualStreamModeEx(e) { return s.AgoraConsole.warn("enableDualStreamModeEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDualStreamModeEx(e) { return s.AgoraConsole.warn("setDualStreamModeEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setHighPriorityUserListEx(e) { return s.AgoraConsole.warn("setHighPriorityUserListEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } takeSnapshotEx(e) { return s.AgoraConsole.warn("takeSnapshotEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableContentInspectEx(e) { return s.AgoraConsole.warn("enableContentInspectEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startMediaRenderingTracingEx(e) { return s.AgoraConsole.warn("startMediaRenderingTracingEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 8389: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.ILocalSpatialAudioEngineDispatch = t.IBaseSpatialAudioEngineDispatch = void 0; const i = n(5844), r = n(2030), o = n(4482); t.IBaseSpatialAudioEngineDispatch = class { constructor(e) { this._engine = null, this._impl = new r.IBaseSpatialAudioEngineImpl(e), this._engine = e } release() { return o.AgoraConsole.warn("release not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setMaxAudioRecvCount(e) { return o.AgoraConsole.warn("setMaxAudioRecvCount not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioRecvRange(e) { return o.AgoraConsole.warn("setAudioRecvRange not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDistanceUnit(e) { return o.AgoraConsole.warn("setDistanceUnit not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateSelfPosition(e) { return o.AgoraConsole.warn("updateSelfPosition not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateSelfPositionEx(e) { return o.AgoraConsole.warn("updateSelfPositionEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updatePlayerPositionInfo(e) { return o.AgoraConsole.warn("updatePlayerPositionInfo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setParameters(e) { return o.AgoraConsole.warn("setParameters not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteLocalAudioStream(e) { return o.AgoraConsole.warn("muteLocalAudioStream not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteAudioStreams(e) { return o.AgoraConsole.warn("muteAllRemoteAudioStreams not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setZones(e) { return o.AgoraConsole.warn("setZones not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlayerAttenuation(e) { return o.AgoraConsole.warn("setPlayerAttenuation not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRemoteAudioStream(e) { return o.AgoraConsole.warn("muteRemoteAudioStream not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.ILocalSpatialAudioEngineDispatch = class { constructor(e) { this._engine = null, this._impl = new r.ILocalSpatialAudioEngineImpl(e), this._engine = e } initialize() { return o.AgoraConsole.warn("initialize not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateRemotePosition(e) { return o.AgoraConsole.warn("updateRemotePosition not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateRemotePositionEx(e) { return o.AgoraConsole.warn("updateRemotePositionEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeRemotePosition(e) { return o.AgoraConsole.warn("removeRemotePosition not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeRemotePositionEx(e) { return o.AgoraConsole.warn("removeRemotePositionEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } clearRemotePositions() { return o.AgoraConsole.warn("clearRemotePositions not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } clearRemotePositionsEx(e) { return o.AgoraConsole.warn("clearRemotePositionsEx not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteAudioAttenuation(e) { return o.AgoraConsole.warn("setRemoteAudioAttenuation not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 2513: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IAudioDeviceManagerDispatch = void 0; const i = n(5844), r = n(5795), o = n(4482); t.IAudioDeviceManagerDispatch = class { constructor(e) { this._engine = null, this._impl = new r.IAudioDeviceManagerImpl(e), this._engine = e } enumeratePlaybackDevices() { return o.AgoraConsole.warn("enumeratePlaybackDevices not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enumerateRecordingDevices() { return o.AgoraConsole.warn("enumerateRecordingDevices not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackDevice(e) { return o.AgoraConsole.warn("setPlaybackDevice not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlaybackDevice() { return o.AgoraConsole.warn("getPlaybackDevice not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlaybackDeviceInfo() { return o.AgoraConsole.warn("getPlaybackDeviceInfo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackDeviceVolume(e) { return o.AgoraConsole.warn("setPlaybackDeviceVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlaybackDeviceVolume() { return o.AgoraConsole.warn("getPlaybackDeviceVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRecordingDevice(e) { return o.AgoraConsole.warn("setRecordingDevice not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getRecordingDevice(e) { return o.AgoraConsole.warn("getRecordingDevice not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getRecordingDeviceInfo() { return o.AgoraConsole.warn("getRecordingDeviceInfo not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRecordingDeviceVolume(e) { return o.AgoraConsole.warn("setRecordingDeviceVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getRecordingDeviceVolume(e) { return o.AgoraConsole.warn("getRecordingDeviceVolume not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLoopbackDevice(e) { return o.AgoraConsole.warn("setLoopbackDevice not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getLoopbackDevice(e) { return o.AgoraConsole.warn("getLoopbackDevice not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackDeviceMute(e) { return o.AgoraConsole.warn("setPlaybackDeviceMute not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlaybackDeviceMute(e) { return o.AgoraConsole.warn("getPlaybackDeviceMute not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRecordingDeviceMute(e) { return o.AgoraConsole.warn("setRecordingDeviceMute not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getRecordingDeviceMute(e) { return o.AgoraConsole.warn("getRecordingDeviceMute not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startPlaybackDeviceTest(e) { return o.AgoraConsole.warn("startPlaybackDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopPlaybackDeviceTest() { return o.AgoraConsole.warn("stopPlaybackDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRecordingDeviceTest(e) { return o.AgoraConsole.warn("startRecordingDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopRecordingDeviceTest() { return o.AgoraConsole.warn("stopRecordingDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioDeviceLoopbackTest(e) { return o.AgoraConsole.warn("startAudioDeviceLoopbackTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopAudioDeviceLoopbackTest() { return o.AgoraConsole.warn("stopAudioDeviceLoopbackTest not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } followSystemPlaybackDevice(e) { return o.AgoraConsole.warn("followSystemPlaybackDevice not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } followSystemRecordingDevice(e) { return o.AgoraConsole.warn("followSystemRecordingDevice not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } followSystemLoopbackDevice(e) { return o.AgoraConsole.warn("followSystemLoopbackDevice not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } release() { return o.AgoraConsole.warn("release not supported in this platform!"), this._engine.returnResult(!1, -i.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 7170: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisClient = void 0; const a = o(n(5844)), c = n(4292), E = n(8973), _ = n(2223); t.IrisClient = class { constructor(e, t) { this.audioTrackPackages = new Array, this._engine = e, this.irisClientState = new E.IrisClientState(this._engine.globalState), t && (this.connection = t), this.id = `irisClient_${Math.floor(Math.random() * (new Date).getTime())}`, this._engine.irisClientManager.irisClientList.push(this) } setConnection(e) { this.connection = e } setClientConfig() { let e = this.irisClientState, t = { codec: null != e.videoEncoderConfiguration ? _.AgoraTranslate.NATIVE_RTCVIDEO_CODEC_TYPE2SDK_CODEC(e.videoEncoderConfiguration.codecType) : "vp8", mode: e.channelProfile ? _.AgoraTranslate.NATIVE_RTC_CHANNEL_PROFILE_TYPE2SDK_MODE(e.channelProfile) : "live" }; return null != e.clientRoleType && (t.role = _.AgoraTranslate.NATIVE_RTC_CLIENT_ROLE_TYPE2ClientRole(e.clientRoleType)), null != e.clientRoleOptions && (t.clientRoleOptions = _.AgoraTranslate.NATIVE_RTCClientRoleOptions2ClientRoleOptions(e.clientRoleOptions)), t } createClient(e) { var t; e && this.irisClientState.mergeChannelMediaOptions(e); let n, i = this.irisClientState, r = this._engine.globalState, o = this.setClientConfig(); this.agoraRTCClient = this._engine.globalState.AgoraRTC.createClient(o), null != i.remoteDefaultVideoStreamType && this.agoraRTCClient.setRemoteDefaultVideoStreamType(_.AgoraTranslate.NATIVE_RTCVIDEO_STREAM_TYPE2RemoteStreamType(i.remoteDefaultVideoStreamType)).then((() => { })).catch((() => { })).finally((() => { })); for (let s of i.remoteVideoStreamTypes) this.agoraRTCClient.setRemoteVideoStreamType(s[0], _.AgoraTranslate.NATIVE_RTCVIDEO_STREAM_TYPE2RemoteStreamType(s[1])).then((() => { })).catch((() => { })).finally((() => { })); if (1 == i.publishCameraTrack ? n = a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_PRIMARY : 1 == i.publishSecondaryCameraTrack ? n = a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_SECONDARY : 1 == i.publishScreenCaptureVideo && (n = a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_PRIMARY), i.enabledDualStreamModes.has(n)) { let e = i.enabledDualStreamModes.get(n); e.enabled ? (this.agoraRTCClient.enableDualStream().then((() => { })).catch((() => { })).finally((() => { })), null != e.streamConfig && this.agoraRTCClient.setLowStreamParameter(_.AgoraTranslate.NATIVE_RTCSimulcastStreamConfig2LowStreamParameter(e.streamConfig))) : this.agoraRTCClient.disableDualStream().then((() => { })).catch((() => { })).finally((() => { })) } else i.enabledDualStreamMode && this.agoraRTCClient.enableDualStream().then((() => { })).catch((() => { })).finally((() => { })); if (i.enabledAudioVolumeIndication && (this.agoraRTCClient.enableAudioVolumeIndicator(), i.enabledAudioVolumeIndication = null), null === (t = i.encryptionConfig) || void 0 === t ? void 0 : t.enabled) { let e = i.encryptionConfig.config, t = _.AgoraTranslate.NATIVE_RTCENCRYPTION_MODE2EncryptionMode(e.encryptionMode), n = new Uint8Array(e.encryptionKdfSalt); this.agoraRTCClient.setEncryptionConfig(t, e.encryptionKey, n), i.encryptionConfig.enabled = !1 } if (null != i.contentInspect && this.agoraRTCClient.enableContentInspect(_.AgoraTranslate.NATIVE_RTCContentInspectConfig2InspectConfiguration(i.contentInspect)).then((() => { })).catch((() => { })).finally((() => { })), null != r.cloudProxy) { let e = r.cloudProxy; e == a.CLOUD_PROXY_TYPE.UDP_PROXY ? this.agoraRTCClient.startProxyServer(3) : e == a.CLOUD_PROXY_TYPE.TCP_PROXY && this.agoraRTCClient.startProxyServer(5) } this.clientEventHandler = new c.IrisClientEventHandler(this, this._engine) } addLocalAudioTrack(e) { this.audioTrackPackages.push(e), e.setIrisClient(this) } removeLocalAudioTrack(e) { for (let t = 0; t < this.audioTrackPackages.length; t++) { if (this.audioTrackPackages[t].track == e.track) { this.audioTrackPackages.splice(t, 1), t--; break } } } setLocalVideoTrack(e) { this.videoTrackPackage = e, e.setIrisClient(this) } clearLocalVideoTrack() { this.videoTrackPackage = null } release() { var e, t, n, i, r, o; return s(this, void 0, void 0, (function* () { if (this.clientEventHandler && this.clientEventHandler.release(), null === (e = this.agoraRTCClient) || void 0 === e ? void 0 : e.channelName) try { yield this.agoraRTCClient.leave(), _.AgoraConsole.debug("client leave success") } catch (s) { throw s } this.audioTrackPackages = [], this.videoTrackPackage = null, this.agoraRTCClient = null; for (let e = 0; e < this._engine.irisClientManager.remoteUserPackages.length; e++) { let o = this._engine.irisClientManager.remoteUserPackages[e]; (null === (t = o.connection) || void 0 === t ? void 0 : t.channelId) == (null === (n = this.connection) || void 0 === n ? void 0 : n.channelId) && (null === (i = o.connection) || void 0 === i ? void 0 : i.localUid) == (null === (r = this.connection) || void 0 === r ? void 0 : r.localUid) && (this._engine.irisClientManager.removeRemoteUserPackage(o.uid), e--) } this.connection = null, (null === (o = this._engine.irisClientManager.irisClientList[0]) || void 0 === o ? void 0 : o.id) !== this.id && (this._engine.irisClientManager.irisClientList = this._engine.irisClientManager.irisClientList.filter((e => e.id != this.id))) })) } } }, 5873: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisClientManager = t.BufferSourceAudioTrackPackage = t.AudioTrackPackage = t.VideoTrackPackage = t.RemoteUserPackage = void 0; const a = o(n(5844)), c = n(4473), E = n(2223), _ = n(6545), d = n(7275); t.RemoteUserPackage = class { constructor(e, t, n, i, r) { this.connection = e, this.element = t, this.uid = n, this.videoSourceType = i, this.audioSourceType = r } update({ element: e = this.element, uid: t = this.uid, videoSourceType: n = this.videoSourceType, audioSourceType: i = this.audioSourceType }) { this.element = e, this.uid = t, this.videoSourceType = n, this.audioSourceType = i } dispose() { this.connection = null, this.element = null, this.uid = null, this.videoSourceType = null, this.audioSourceType = null } }; t.VideoTrackPackage = class { constructor(e, t, n) { this.isPreview = !1, this.element = e, this.type = t, this.track = n } setPreview(e) { this.isPreview = e } setIrisClient(e) { this.irisClient = e } update({ type: e = this.type, track: t = this.track, element: n = this.element }) { this.element = n, this.type = e, this.track = t } dispose() { this.element = null, this.type = null, this.isPreview = !1; try { this.track && (this.track.isPlaying && this.track.stop(), this.track.enabled && this.track.close()) } catch (e) { } this.track = null, this.irisClient = null } }; class u { constructor(e, t) { this.type = e, this.track = t } setIrisClient(e) { this.irisClient = e } update({ type: e = this.type, track: t = this.track }) { this.type = e, this.track = t } dispose() { this.type = null; try { this.track && (this.track.isPlaying && this.track.stop(), this.track.close()) } catch (e) { } this.irisClient = null, this.track = null } } t.AudioTrackPackage = u; t.BufferSourceAudioTrackPackage = class extends u { setIsPublished(e) { this.isPublished = e } constructor(e, t, n, i) { super(), this.type = e, this.track = t, this.soundId = n, this.needPublish = i } dispose() { super.dispose(), this.needPublish = !1 } }; t.IrisClientManager = class { constructor(e) { this._engine = null, this.irisClientList = [], this.localVideoTrackPackages = [], this.localAudioTrackPackages = [], this.trackEventHandlers = new Array, this.remoteUserPackages = new Array, this._engine = e, this.irisClientObserver = new _.IrisClientObserver(e) } addLocalVideoTrackPackage(e) { this.localVideoTrackPackages.push(e), this.irisClientObserver.addVideoTrackPackageObserver(e) } removeLocalVideoTrackPackage(e) { for (let t = 0; t < this.localVideoTrackPackages.length; t++) { let n = this.localVideoTrackPackages[t]; if (n.track == e.track && n.type == n.type) { this.localVideoTrackPackages.splice(t, 1), t--, this.irisClientObserver.removeVideoTrackPackageObserver(e), e.dispose(); break } } } getLocalVideoTrackPackageBySourceType(e) { return this.localVideoTrackPackages.filter((t => { if (!Array.isArray(e)) return t.type == e; for (let n of e) if (t.type == n) return !0 })) } addLocalAudioTrackPackage(e) { this.localAudioTrackPackages.push(e), this.irisClientObserver.addAudioTrackPackageObserver(e) } getLocalAudioTrackPackageBySourceType(e) { return this.localAudioTrackPackages.filter((t => { if (!Array.isArray(e)) return t.type == e; for (let n of e) if (t.type == n) return !0 })) } removeLocalAudioTrackPackage(e) { for (let t = 0; t < this.localAudioTrackPackages.length; t++) { let n = this.localAudioTrackPackages[t]; if (n.track == e.track && n.type == n.type) { this.localAudioTrackPackages.splice(t, 1), t--, this.irisClientObserver.removeAudioTrackPackageObserver(e), e.dispose(); break } } } getRemoteUserPackageByUid(e) { return this.remoteUserPackages.filter((t => t.uid == e))[0] } addRemoteUserPackage(e, t) { if (this.remoteUserPackages.push(e), this.irisClientObserver.addRemoteUserPackageObserver(e), t) { let n = setInterval((() => { var n, i; let r = t.getRemoteNetworkQuality(), o = { channelId: t.channelName, localUid: t.uid }; this._engine.rtcEngineEventHandler.onNetworkQualityEx(o, e.uid, null === (n = r[e.uid]) || void 0 === n ? void 0 : n.downlinkNetworkQuality, null === (i = r[e.uid]) || void 0 === i ? void 0 : i.uplinkNetworkQuality) }), this._engine.globalState.networkQualityInterval); this._engine.addIrisInterval(d.IrisIntervalType.networkQuality, n, e.uid) } } removeRemoteUserPackage(e) { for (let t = 0; t < this.remoteUserPackages.length; t++) { let n = this.remoteUserPackages[t]; if (n.uid == e) { this.remoteUserPackages.splice(t, 1), t--, this.irisClientObserver.removeRemoteUserPackageObserver(n), this._engine.removeIrisIntervalByUid(e), n.dispose(); break } } } getVideoFrame(e, t) { return this._engine.irisClientManager.irisClientList.map((n => { var i; if (n.agoraRTCClient.channelName == t && n.agoraRTCClient.uid == e) return { video_track: n.videoTrackPackage.track, is_new_frame: !0, process_err: c.IRIS_VIDEO_PROCESS_ERR.ERR_OK }; (null === (i = n.agoraRTCClient) || void 0 === i ? void 0 : i.channelName) == t && n.agoraRTCClient.remoteUsers.map((t => { if (t.uid == e && t.hasVideo && t.videoTrack) return { video_track: t.videoTrack, is_new_frame: !0, process_err: c.IRIS_VIDEO_PROCESS_ERR.ERR_OK } })) })), null } getVideoFrameByConfig(e) { let t = e.id, n = e.key, i = e.type; return this._engine.irisClientManager.irisClientList.map((e => { var r, o; if ((null === (r = e.videoTrackPackage) || void 0 === r ? void 0 : r.type) == i) return { video_track: e.videoTrackPackage.track, is_new_frame: !0, process_err: c.IRIS_VIDEO_PROCESS_ERR.ERR_OK }; (null === (o = e.agoraRTCClient) || void 0 === o ? void 0 : o.channelName) == n && e.agoraRTCClient.remoteUsers.map((e => { if (e.uid == t && e.hasVideo && e.videoTrack) return { video_track: e.videoTrack, is_new_frame: !0, process_err: c.IRIS_VIDEO_PROCESS_ERR.ERR_OK } })) })), null } getIrisClient() { if (0 != this.irisClientList.length) return this.irisClientList[0]; this._engine.irisRtcErrorHandler.notInitialized() } getIrisClientByConnection(e) { return e ? this.irisClientList.filter((t => { var n, i; if ((null === (n = t.connection) || void 0 === n ? void 0 : n.channelId) == e.channelId && (null === (i = t.connection) || void 0 === i ? void 0 : i.localUid) == e.localUid) return t }))[0] : this.getIrisClient() } getScreenCaptureStatus() { let e = !1; return this.getLocalVideoTrackPackageBySourceType([a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_PRIMARY, a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_SECONDARY, a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_THIRD, a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_FOURTH]).map((t => { t.track && (e = !0) })), e } addTrackEventHandler(e) { } removeTrackEventHandlerByTrack(e) { for (let t = 0; t < this.trackEventHandlers.length; t++) { let n = this.trackEventHandlers[t]; if (n.getTrack() == e) { n.release(), this.trackEventHandlers.splice(t, 1), t--; break } } } removetrackEventHandlerByRemoteUser(e, t) { this.trackEventHandlers = this.trackEventHandlers.filter((n => n.getRemoteUser() != e || ("all" == t || "audio" == t && "IRemoteTrack" == n.getTrackType() ? (n.release(), !1) : "video" != t || "IRemoteVideoTrack" != n.getTrackType() || (n.release(), !1)))) } processBufferSourceAudioTrackClose(e, t) { return s(this, void 0, void 0, (function* () { let n = e.track; if (t && t.localTracks && -1 != t.localTracks.indexOf(n)) try { yield t.unpublish(n), E.AgoraConsole.log("unpublish success") } catch (i) { throw this._engine.returnResult(!1), i } n.stopProcessAudioBuffer(), n.close(), this.removeTrackEventHandlerByTrack(n) })) } processAudioTrackClose(e, t) { return s(this, void 0, void 0, (function* () { let n = e.track; if (t && t.localTracks && -1 != t.localTracks.indexOf(n)) try { yield t.unpublish(n), E.AgoraConsole.log("unpublish success") } catch (i) { throw this._engine.returnResult(!1), i } n.isPlaying && this._engine.trackHelper.stop(n), n.muted || (yield this._engine.trackHelper.setEnabled(n, !1)), this.removeTrackEventHandlerByTrack(n) })) } processVideoTrackClose(e, t) { return s(this, void 0, void 0, (function* () { let n = e.track; if (t && t.localTracks && -1 != t.localTracks.indexOf(n)) try { yield t.unpublish(n), E.AgoraConsole.log("unpublish success") } catch (i) { throw this._engine.returnResult(!1), i } e.isPreview || (n.isPlaying && this._engine.trackHelper.stop(n), n.muted || (yield this._engine.trackHelper.setEnabled(n, !1))), this.removeTrackEventHandlerByTrack(n) })) } release() { return s(this, void 0, void 0, (function* () { this._engine.clearIrisInterval(), this._engine.irisElement.release(), this.localVideoTrackPackages.map((e => { e.dispose() })), this.localAudioTrackPackages.map((e => { e.dispose() })); for (let e of this.irisClientList) yield e.release(); this.trackEventHandlers.forEach((e => { e.release() })), this.irisClientList = [], this.localAudioTrackPackages = [], this.localVideoTrackPackages = [], this.trackEventHandlers = [], this.irisClientObserver.release() })) } } }, 6545: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisClientObserver = t.NotifyRemoteType = t.NotifyType = void 0; const a = o(n(5844)), c = n(4473), E = n(5783), _ = n(2223); var d, u; !function (e) { e[e.PUBLISH_TRACK = 0] = "PUBLISH_TRACK", e[e.UNPUBLISH_TRACK = 1] = "UNPUBLISH_TRACK", e[e.ENABLE_TRACK = 2] = "ENABLE_TRACK", e[e.UNABLE_TRACK = 3] = "UNABLE_TRACK", e[e.UPDATE_TRACK = 4] = "UPDATE_TRACK" }(d || (t.NotifyType = d = {})), function (e) { e[e.SUBSCRIBE_VIDEO_TRACK = 0] = "SUBSCRIBE_VIDEO_TRACK", e[e.SUBSCRIBE_AUDIO_TRACK = 1] = "SUBSCRIBE_AUDIO_TRACK", e[e.UNSUBSCRIBE_VIDEO_TRACK = 2] = "UNSUBSCRIBE_VIDEO_TRACK", e[e.UNSUBSCRIBE_AUDIO_TRACK = 3] = "UNSUBSCRIBE_AUDIO_TRACK" }(u || (t.NotifyRemoteType = u = {})); t.IrisClientObserver = class { constructor(e) { this.audioTrackPackageObservers = [], this.videoTrackPackageObservers = [], this.remoteUserPackageObservers = [], this._engine = e } addAudioTrackPackageObserver(e) { this.audioTrackPackageObservers.push(e) } addVideoTrackPackageObserver(e) { this.videoTrackPackageObservers.push(e) } addRemoteUserPackageObserver(e) { this.remoteUserPackageObservers.push(e) } removeRemoteUserPackageObserver(e) { this.remoteUserPackageObservers = this.remoteUserPackageObservers.filter((t => t !== e)) } removeAudioTrackPackageObserver(e) { this.audioTrackPackageObservers = this.audioTrackPackageObservers.filter((t => t !== e)) } removeVideoTrackPackageObserver(e) { this.videoTrackPackageObservers = this.videoTrackPackageObservers.filter((t => t !== e)) } publishTrack(e, t) { var n; return s(this, void 0, void 0, (function* () { let i, r = this._engine.globalState; for (let s of t) { let t = s.irisClientState; if (r.enabledAudio && r.enabledLocalAudio && (t.publishMicrophoneTrack && (!e.track || e.type !== c.IrisAudioSourceType.kAudioSourceTypeMicrophonePrimary && e.type !== c.IrisAudioSourceType.kAudioSourceTypeMicrophoneSecondary || (this._engine.trackHelper.setMuted(e.track, !1), i = e.track, s.addLocalAudioTrack(e))), t.publishScreenCaptureAudio && e.track && e.type === c.IrisAudioSourceType.kAudioSourceTypeScreenCapture && (i = e.track, s.addLocalAudioTrack(e)), e.track && e.type === c.IrisAudioSourceType.kAudioSourceTypeBufferSourceAudio && e.needPublish && !e.isPublished && (i = e.track, s.addLocalAudioTrack(e))), r.enabledVideo && r.enabledLocalVideo && (t.publishScreenCaptureVideo && (t.publishScreenTrack && e.track && e.type === a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_PRIMARY && (i = e.track, s.setLocalVideoTrack(e)), t.publishSecondaryScreenTrack && e.track && e.type === a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_SECONDARY && (i = e.track, s.setLocalVideoTrack(e)), t.publishThirdScreenTrack && e.track && e.type === a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_THIRD && (i = e.track, s.setLocalVideoTrack(e)), t.publishFourthScreenTrack && e.track && e.type === a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_FOURTH && (i = e.track, s.setLocalVideoTrack(e))), t.publishCameraTrack && e.track && e.type === a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_PRIMARY && (i = e.track, s.setLocalVideoTrack(e)), t.publishSecondaryCameraTrack && e.track && e.type === a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_SECONDARY && (i = e.track, s.setLocalVideoTrack(e)), t.publishThirdCameraTrack && e.track && e.type === a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_THIRD && (i = e.track, s.setLocalVideoTrack(e)), t.publishFourthCameraTrack && e.track && e.type === a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_FOURTH && (i = e.track, s.setLocalVideoTrack(e)), t.publishCustomVideoTrack && e.track && e.type === a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CUSTOM && (i = e.track, s.setLocalVideoTrack(e))), (null === (n = s.agoraRTCClient) || void 0 === n ? void 0 : n.channelName) && s.agoraRTCClient.localTracks) for (let e = 0; e < s.agoraRTCClient.localTracks.length; e++) { s.agoraRTCClient.localTracks[e] === i && (i = null) } else i = null; if (i) { i.enabled || (yield this._engine.trackHelper.setEnabled(i, !0)); try { _.AgoraConsole.debug(`publishTrack ${i}`), yield s.agoraRTCClient.publish(i) } catch (o) { _.AgoraConsole.error(o) } e.type === c.IrisAudioSourceType.kAudioSourceTypeBufferSourceAudio && e.setIsPublished(!0) } } })) } enableTrack(e) { return s(this, void 0, void 0, (function* () { let t = e.track; (null == t ? void 0 : t.enabled) || (yield this._engine.trackHelper.setEnabled(e.track, !0)) })) } unableTrack(e) { return s(this, void 0, void 0, (function* () { let t = e.track; (null == t ? void 0 : t.enabled) && (yield this._engine.trackHelper.setEnabled(e.track, !1)) })) } stopTrack(e) { return s(this, void 0, void 0, (function* () { let t = this._engine.irisClientManager; try { if (!e.track) return; _.AgoraConsole.debug(`stopTrack ${e.track}`); let n = e.irisClient; e.irisClient || (n = t.irisClientList[0]), this._engine.implHelper.isAudio(e.type) ? (yield t.processAudioTrackClose(e, n.agoraRTCClient), e.type === c.IrisAudioSourceType.kAudioSourceTypeScreenCapture && (this._engine.rtcEngineEventHandler.onLocalAudioStateChanged(a.LOCAL_AUDIO_STREAM_STATE.LOCAL_AUDIO_STREAM_STATE_STOPPED, 0), t.removeLocalAudioTrackPackage(e), n.removeLocalAudioTrack(e))) : c.IrisAudioSourceType.kAudioSourceTypeBufferSourceAudio === e.type ? (yield t.processBufferSourceAudioTrackClose(e, n.agoraRTCClient), n.removeLocalAudioTrack(e), t.removeLocalAudioTrackPackage(e)) : this._engine.implHelper.isVideoCamera(e.type) ? yield t.processVideoTrackClose(e, null == n ? void 0 : n.agoraRTCClient) : this._engine.implHelper.isScreenCapture(e.type) && (yield t.processVideoTrackClose(e, null == n ? void 0 : n.agoraRTCClient), this._engine.rtcEngineEventHandler.onLocalVideoStateChanged(e.type, a.LOCAL_VIDEO_STREAM_STATE.LOCAL_VIDEO_STREAM_STATE_STOPPED, 0), t.removeLocalVideoTrackPackage(e), n.clearLocalVideoTrack()) } catch (n) { throw _.AgoraConsole.error(n), n } })) } updateTrack(e) { return s(this, void 0, void 0, (function* () { })) } notifyLocal(e, t, n) { return s(this, void 0, void 0, (function* () { for (let i of t) switch (e) { case d.PUBLISH_TRACK: i && (yield this.publishTrack(i, n)); break; case d.ENABLE_TRACK: i && (yield this.enableTrack(i)); break; case d.UNABLE_TRACK: i && (yield this.unableTrack(i)); break; case d.UNPUBLISH_TRACK: i && (yield this.stopTrack(i)); break; case d.UPDATE_TRACK: i && (yield this.updateTrack(i)) } })) } subscribeVideoTrack(e) { let t = this._engine.irisClientManager.getIrisClientByConnection(e.connection); if (!t) return; let n = t.irisClientState.autoSubscribeVideo; if (this._engine.globalState.enabledVideo && n && t.agoraRTCClient) { let n = t.agoraRTCClient.remoteUsers.find((t => t.uid === e.uid)); if (!n || !n.hasVideo) return; t.agoraRTCClient.subscribe(n, "video").then((() => { _.AgoraConsole.debug("onEventUserPublished subscribe video success"), e.element && this._engine.trackHelper.play(n.videoTrack, e.element); let i = { channelName: t.agoraRTCClient.channelName, client: t.agoraRTCClient, remoteUser: n, track: n.videoTrack, trackType: "IRemoteVideoTrack" }, r = new E.IrisTrackEventHandler(i, this._engine); this._engine.irisClientManager.addTrackEventHandler(r) })) } } subscribeAudioTrack(e) { let t = this._engine.irisClientManager.getIrisClientByConnection(e.connection); if (!t) return; let n = t.irisClientState.autoSubscribeAudio; if (this._engine.globalState.enabledAudio && n && t.agoraRTCClient) { let n = t.agoraRTCClient.remoteUsers.find((t => t.uid === e.uid)); if (!n || !n.hasAudio) return; t.agoraRTCClient.subscribe(n, "audio").then((() => { _.AgoraConsole.debug("onEventUserPublished subscribe audio success"), this._engine.trackHelper.play(n.audioTrack); let e = { channelName: t.agoraRTCClient.channelName, client: t.agoraRTCClient, remoteUser: n, track: n.audioTrack, trackType: "IRemoteTrack" }, i = new E.IrisTrackEventHandler(e, this._engine); this._engine.irisClientManager.addTrackEventHandler(i) })) } } unsubscribeVideoTrack(e) { let t = this._engine.irisClientManager.getIrisClientByConnection(e.connection); if (null == t ? void 0 : t.agoraRTCClient) { let n = t.agoraRTCClient.remoteUsers.find((t => t.uid === e.uid)); if (!n || !n.videoTrack) return; t.agoraRTCClient.unsubscribe(n, "video").then((() => { _.AgoraConsole.debug("onEventUserPublished unsubscribe video success"), this._engine.irisClientManager.removetrackEventHandlerByRemoteUser(n, "video") })) } } unsubscribeAudioTrack(e) { let t = this._engine.irisClientManager.getIrisClientByConnection(e.connection); if (null == t ? void 0 : t.agoraRTCClient) { let n = t.agoraRTCClient.remoteUsers.find((t => t.uid === e.uid)); if (!n || !n.videoTrack) return; t.agoraRTCClient.unsubscribe(n, "audio").then((() => { _.AgoraConsole.debug("onEventUserPublished unsubscribe audio success"), this._engine.irisClientManager.removetrackEventHandlerByRemoteUser(n, "audio") })) } } notifyRemote(e, t) { for (let n of t) switch (e) { case u.SUBSCRIBE_VIDEO_TRACK: n && this.subscribeVideoTrack(n); break; case u.SUBSCRIBE_AUDIO_TRACK: n && this.subscribeAudioTrack(n); break; case u.UNSUBSCRIBE_AUDIO_TRACK: n && this.unsubscribeAudioTrack(n); break; case u.UNSUBSCRIBE_VIDEO_TRACK: n && this.unsubscribeVideoTrack(n) } } release() { this.audioTrackPackageObservers = [], this.videoTrackPackageObservers = [], this.remoteUserPackageObservers = [] } } }, 7275: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }, a = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisRtcEngine = t.IrisIntervalType = void 0; const c = o(n(5844)), E = n(7481), _ = n(9217), d = n(2343), u = n(1146), l = n(7513), R = n(3386), h = n(9113), p = n(8389), T = n(2513), O = n(6961), C = n(7986), A = n(2161), S = n(4366), g = n(9071), m = n(3501), I = n(8219), f = n(4482), P = a(n(4409)), N = n(5873); var D; !function (e) { e[e.enableAudioVolumeIndication = 0] = "enableAudioVolumeIndication", e[e.networkQuality = 1] = "networkQuality" }(D || (t.IrisIntervalType = D = {})); t.IrisRtcEngine = class { constructor(e, t) { this.implDispatchesMap = new Map, this.implHelper = new g.ImplHelper(this), this.trackHelper = new m.TrackHelper(this), this.clientHelper = new A.ClientHelper(this), this.irisClientManager = new N.IrisClientManager(this), this.rtcEngineEventHandler = null, this.globalState = null, this.agoraEventHandler = null, this.executor = null, this.irisEventHandlerManager = null, this.irisElement = null, this.irisIntervalList = [], this.irisRtcErrorHandler = new P.default(this);[["MediaPlayer", new d.IMediaPlayerDispatch(this)], ["MediaPlayerCacheManager", new d.IMediaPlayerCacheManagerDispatch(this)], ["MediaEngine", new _.IMediaEngineDispatch(this)], ["MediaRecorder", new u.IMediaRecorderDispatch(this)], ["MusicChartCollection", new l.MusicChartCollectionDispatch(this)], ["MusicCollection", new l.MusicCollectionDispatch(this)], ["MusicPlayer", new l.IMusicPlayerDispatch(this)], ["MusicContentCenter", new l.IMusicContentCenterDispatch(this)], ["AudioDeviceManager", new T.IAudioDeviceManagerDispatch(this)], ["VideoDeviceManager", new R.IVideoDeviceManagerDispatch(this)], ["RtcEngine", new C.RtcEngineDispatchExtensions(this)], ["RtcEngineEx", new h.IRtcEngineExDispatch(this)], ["BaseSpatialAudioEngine", new p.IBaseSpatialAudioEngineDispatch(this)], ["LocalSpatialAudioEngine", new p.ILocalSpatialAudioEngineDispatch(this)]].forEach((([e, t]) => this.implDispatchesMap.set(e, t))), this.rtcEngineEventHandler = new h.IRtcEngineEventHandlerEx(this), this.globalState = new I.IrisGlobalState, this.irisElement = new S.IrisElement, this.agoraEventHandler = new O.IrisAgoraEventHandler(this), this.executor = new E.CallApiExecutor(!0), this.irisEventHandlerManager = e, t && t.agoraRTC && (f.AgoraConsole.debug("use agoraRTC from initIrisRtc"), this.globalState.AgoraRTC = t.agoraRTC) } intercept(e) { return this.callIrisApiAsync(e) } callIrisApiAsync(e) { return s(this, void 0, void 0, (function* () { let t = e.event, n = t.split("_"), i = n[0], r = n[1]; f.AgoraConsole.log(`[callIrisApiAsync][start] ${(() => { let t = JSON.parse(JSON.stringify(e)); return null == t || delete t.buffer, JSON.stringify(t) })()}`); let o = this.implDispatchesMap.get(i); if (o) { let n = o[r]; if (n) { if ("RtcEngine_initialize" !== t && 0 == this.irisClientManager.irisClientList.length) return f.AgoraConsole.error("you have not initialize yet"), new E.CallIrisApiResult(-c.ERROR_CODE_TYPE.ERR_NOT_INITIALIZED, ""); let i = yield n.call(o, e); return f.AgoraConsole.log(`[callIrisApiAsync][result] ${t} ret ${i.code}`), i } return f.AgoraConsole.error(`[callIrisApiAsync][result] ${t} not found in ${i}Dispatch`), this.returnResult(!0, -c.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } return f.AgoraConsole.error(`[callIrisApiAsync][result] ${i} not found in DispatchsMap`), this.returnResult(!0, -c.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) })) } getVideoFrame(e, t) { return this.irisClientManager.getVideoFrame(e, t) } getVideoFrameByConfig(e) { return this.irisClientManager.getVideoFrameByConfig(e) } execute(e) { return this.executor.execute(e) } returnResult(e = !0, t, n = '{"result": 0}') { return e ? t = c.ERROR_CODE_TYPE.ERR_OK : "number" != typeof t && (t = -c.ERROR_CODE_TYPE.ERR_FAILED), Promise.resolve(new E.CallIrisApiResult(t, n)) } release() { return s(this, void 0, void 0, (function* () { this.agoraEventHandler.release(), yield this.irisClientManager.release() })) } addIrisInterval(e, t, n) { this.irisIntervalList.push({ type: e, interval: t, uid: n }) } getIrisIntervalByType(e) { this.irisIntervalList.filter((t => e == t.type)) } removeIrisIntervalByUid(e) { for (let t = 0; t < this.irisIntervalList.length; t++) { let n = this.irisIntervalList[t]; if (n.uid == e) { n.interval && clearInterval(n.interval), this.irisIntervalList.splice(t, 1); break } } } removeIrisIntervalByType(e) { for (let t = 0; t < this.irisIntervalList.length; t++) { let n = this.irisIntervalList[t]; n.type == e && (n.interval && clearInterval(n.interval), this.irisIntervalList.splice(t, 1), t--) } } clearIrisInterval() { this.irisIntervalList.map((e => { f.AgoraConsole.debug("clear interval"), e.interval && clearInterval(e.interval) })) } dispose() { return s(this, void 0, void 0, (function* () { return yield this.release(), Promise.resolve() })) } } }, 6961: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisAgoraEventHandler = void 0; const s = o(n(5844)), a = n(1215); t.IrisAgoraEventHandler = class { constructor(e) { this._engine = e } onAutoplayFailed() { this._engine.rtcEngineEventHandler.onError(s.ERROR_CODE_TYPE.ERR_NOT_READY, "auto play failed") } onCameraChanged(e) { let t = e.device.deviceId, n = s.MEDIA_DEVICE_TYPE.VIDEO_CAPTURE_DEVICE, i = a.AgoraTranslate.DeviceState2NATIVE_RTCMEDIA_DEVICE_STATE_TYPE(e.state); this._engine.rtcEngineEventHandler.onVideoDeviceStateChanged(t, n, i) } onMicrophoneChanged(e) { let t = e.device.deviceId, n = s.MEDIA_DEVICE_TYPE.AUDIO_RECORDING_DEVICE, i = a.AgoraTranslate.DeviceState2NATIVE_RTCMEDIA_DEVICE_STATE_TYPE(e.state); this._engine.rtcEngineEventHandler.onAudioDeviceStateChanged(t, n, i) } onPlaybackDeviceChanged(e) { let t = e.device.deviceId, n = s.MEDIA_DEVICE_TYPE.AUDIO_PLAYOUT_DEVICE, i = a.AgoraTranslate.DeviceState2NATIVE_RTCMEDIA_DEVICE_STATE_TYPE(e.state); this._engine.rtcEngineEventHandler.onAudioDeviceStateChanged(t, n, i) } release() { this._engine.globalState.AgoraRTC.onAutoplayFailed = void 0, this._engine.globalState.AgoraRTC.onCameraChanged = void 0, this._engine.globalState.AgoraRTC.onMicrophoneChanged = void 0, this._engine.globalState.AgoraRTC.onPlaybackDeviceChanged = void 0 } } }, 4292: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisClientEventHandler = void 0; const s = o(n(5844)), a = n(5957), c = n(4473), E = n(5873), _ = n(6545), d = n(1215); t.IrisClientEventHandler = class { constructor(e, t) { this._irisClient = e, this._engine = t, this.agoraRTCClient = e.agoraRTCClient, this.agoraRTCClient.on("connection-state-change", this.onEventConnectionStateChange.bind(this)), this.agoraRTCClient.on("user-joined", this.onEventUserJoined.bind(this)), this.agoraRTCClient.on("user-left", this.onEventUserLeft.bind(this)), this.agoraRTCClient.on("user-published", this.onEventUserPublished.bind(this)), this.agoraRTCClient.on("user-unpublished", this.onEventUserUnpublished.bind(this)), this.agoraRTCClient.on("user-info-updated", this.onEventUserInfoUpdated.bind(this)), this.agoraRTCClient.on("media-reconnect-start", this.onEventMediaReconnectStart.bind(this)), this.agoraRTCClient.on("media-reconnect-end", this.onEventMediaReconnectEnd.bind(this)), this.agoraRTCClient.on("stream-type-changed", this.onEventStreamTypeChanged.bind(this)), this.agoraRTCClient.on("stream-fallback", this.onEventStreamFallback.bind(this)), this.agoraRTCClient.on("channel-media-relay-state", this.onEventChannelMediaRelayState.bind(this)), this.agoraRTCClient.on("channel-media-relay-event", this.onEventChannelMediaRelayEvent.bind(this)), this.agoraRTCClient.on("volume-indicator", this.onEventVolumeIndicator.bind(this)), this.agoraRTCClient.on("crypt-error", this.onEventCryptError.bind(this)), this.agoraRTCClient.on("token-privilege-will-expire", this.onEventTokenPrivilegeWillExpire.bind(this)), this.agoraRTCClient.on("token-privilege-did-expire", this.onEventTokenPrivilegeDidExpire.bind(this)), this.agoraRTCClient.on("network-quality", this.onEventNetworkQuality.bind(this)), this.agoraRTCClient.on("live-streaming-error", this.onEventLiveStreamingError.bind(this)), this.agoraRTCClient.on("live-streaming-warning", this.onEventLiveStreamingWarning.bind(this)), this.agoraRTCClient.on("exception", this.onEventException.bind(this)), this.agoraRTCClient.on("is-using-cloud-proxy", this.onEventIsUsingCloudProxy.bind(this)), this.agoraRTCClient.on("join-fallback-to-proxy", this.onEventJoinFallbackToProxy.bind(this)), this.agoraRTCClient.on("published-user-list", this.onEventPublishedUserList.bind(this)), this.agoraRTCClient.on("content-inspect-error", this.onEventContentInspectError.bind(this)), this.agoraRTCClient.on("content_inspect_result", this.onEventContentInspectResult.bind(this)) } onEventConnectionStateChange(e, t, n) { if ("DISCONNECTED" == e ? this._engine.rtcEngineEventHandler.onConnectionLostEx(this._irisClient.connection) : n == a.ConnectionDisconnectedReason.CHANNEL_BANNED || n == a.ConnectionDisconnectedReason.IP_BANNED || n == a.ConnectionDisconnectedReason.UID_BANNED ? this._engine.rtcEngineEventHandler.onConnectionBannedEx(this._irisClient.connection) : n != a.ConnectionDisconnectedReason.NETWORK_ERROR && n != a.ConnectionDisconnectedReason.SERVER_ERROR || this._engine.rtcEngineEventHandler.onConnectionInterruptedEx(this._irisClient.connection), "DISCONNECTING" != e) { let t = d.AgoraTranslate.ConnectionState2NATIVE_RTCCONNECTION_STATE_TYPE(e), i = s.CONNECTION_CHANGED_REASON_TYPE.CONNECTION_CHANGED_INTERRUPTED; null != n && (i = d.AgoraTranslate.ConnectionDisconnectedReason2NATIVE_RTCCONNECTION_CHANGED_REASON_TYPE(n)), this._engine.rtcEngineEventHandler.onConnectionStateChangedEx(this._irisClient.connection, t, i) } } onEventUserJoined(e) { let t = { channelId: this.agoraRTCClient.channelName, localUid: this.agoraRTCClient.uid }, n = e.uid; this._engine.rtcEngineEventHandler.onUserJoinedEx(t, n, 0); let i = this._engine.irisClientManager.getRemoteUserPackageByUid(e.uid); i ? i.update({ uid: e.uid }) : (i = new E.RemoteUserPackage(t, null, e.uid, s.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_REMOTE, c.IrisAudioSourceType.kAudioSourceTypeRemote), this._engine.irisClientManager.addRemoteUserPackage(i, this.agoraRTCClient)) } onEventUserLeft(e, t) { let n = this._engine.irisClientManager.getRemoteUserPackageByUid(e.uid), i = d.AgoraTranslate.string2NATIVE_RTCUSER_OFFLINE_REASON_TYPE(t); this._engine.rtcEngineEventHandler.onUserOfflineEx(this._irisClient.connection, e.uid, i), this._engine.irisClientManager.irisClientObserver.notifyRemote(_.NotifyRemoteType.UNSUBSCRIBE_AUDIO_TRACK, [n]), this._engine.irisClientManager.irisClientObserver.notifyRemote(_.NotifyRemoteType.UNSUBSCRIBE_AUDIO_TRACK, [n]), this._engine.irisClientManager.removeRemoteUserPackage(e.uid), this._engine.irisClientManager.removetrackEventHandlerByRemoteUser(e, "all") } onEventUserPublished(e, t) { let n = this._engine.irisClientManager.getRemoteUserPackageByUid(e.uid); n && ("audio" == t ? this._engine.irisClientManager.irisClientObserver.notifyRemote(_.NotifyRemoteType.SUBSCRIBE_AUDIO_TRACK, [n]) : "video" == t && this._engine.irisClientManager.irisClientObserver.notifyRemote(_.NotifyRemoteType.SUBSCRIBE_VIDEO_TRACK, [n])) } onEventUserUnpublished(e, t) { let n = this._engine.irisClientManager.getRemoteUserPackageByUid(e.uid); n && ("audio" == t ? this._engine.irisClientManager.irisClientObserver.notifyRemote(_.NotifyRemoteType.UNSUBSCRIBE_AUDIO_TRACK, [n]) : "video" == t && this._engine.irisClientManager.irisClientObserver.notifyRemote(_.NotifyRemoteType.UNSUBSCRIBE_VIDEO_TRACK, [n])) } onEventUserInfoUpdated(e, t) { let n = e; switch (t) { case "mute-audio": this._engine.rtcEngineEventHandler.onUserMuteAudioEx(this._irisClient.connection, n, !0), this._engine.rtcEngineEventHandler.onUserStateChangedEx(this._irisClient.connection, n, s.REMOTE_USER_STATE.USER_STATE_MUTE_AUDIO); break; case "mute-video": this._engine.rtcEngineEventHandler.onUserMuteVideoEx(this._irisClient.connection, n, !0), this._engine.rtcEngineEventHandler.onUserStateChangedEx(this._irisClient.connection, n, s.REMOTE_USER_STATE.USER_STATE_MUTE_VIDEO); break; case "unmute-audio": this._engine.rtcEngineEventHandler.onUserMuteAudioEx(this._irisClient.connection, n, !1); break; case "unmute-video": this._engine.rtcEngineEventHandler.onUserMuteVideoEx(this._irisClient.connection, n, !1); break; case "enable-local-video": this._engine.rtcEngineEventHandler.onUserEnableLocalVideoEx(this._irisClient.connection, n, !0), this._engine.rtcEngineEventHandler.onUserStateChangedEx(this._irisClient.connection, n, s.REMOTE_USER_STATE.USER_STATE_ENABLE_LOCAL_VIDEO); break; case "disable-local-video": this._engine.rtcEngineEventHandler.onUserEnableLocalVideoEx(this._irisClient.connection, n, !1) } } onEventMediaReconnectStart(e) { } onEventMediaReconnectEnd(e) { } onEventStreamTypeChanged(e, t) { } onEventStreamFallback(e, t) { this._engine.rtcEngineEventHandler.onRemoteSubscribeFallbackToAudioOnly(e, "fallback" == t) } onEventChannelMediaRelayState(e, t) { let n = d.AgoraTranslate.ChannelMediaRelayState2NATIVE_RTCCHANNEL_MEDIA_RELAY_STATE(e), i = d.AgoraTranslate.ChannelMediaRelayError2NATIVE_RTCCHANNEL_MEDIA_RELAY_ERROR(t); this._engine.rtcEngineEventHandler.onChannelMediaRelayStateChanged(n, i) } onEventChannelMediaRelayEvent(e) { let t = d.AgoraTranslate.ChannelMediaRelayEvent2NATIVE_RTCCHANNEL_MEDIA_RELAY_EVENT(e); this._engine.rtcEngineEventHandler.onChannelMediaRelayEvent(t) } onEventVolumeIndicator(e) { let t = []; for (let i = 0; i < e.length; i++)t.push(d.AgoraTranslate.volumeIndicatorResult2NATIVE_RTCAudioVolumeInfo(e[i])); let n = e.length; this._engine.rtcEngineEventHandler.onAudioVolumeIndicationEx(this._irisClient.connection, t, n, 0) } onEventCryptError() { let e = s.ENCRYPTION_ERROR_TYPE.ENCRYPTION_ERROR_INTERNAL_FAILURE; this._engine.rtcEngineEventHandler.onEncryptionErrorEx(this._irisClient.connection, e) } onEventTokenPrivilegeWillExpire() { let e = this._irisClient.irisClientState.token; this._engine.rtcEngineEventHandler.onTokenPrivilegeWillExpireEx(this._irisClient.connection, e) } onEventTokenPrivilegeDidExpire() { this._engine.rtcEngineEventHandler.onRequestTokenEx(this._irisClient.connection) } onEventNetworkQuality(e) { let t = { channelId: this.agoraRTCClient.channelName, localUid: this.agoraRTCClient.uid }; this._engine.rtcEngineEventHandler.onNetworkQualityEx(t, 0, e.downlinkNetworkQuality, e.uplinkNetworkQuality) } onEventLiveStreamingError(e, t) { } onEventLiveStreamingWarning(e, t) { } onEventException(e) { } onEventIsUsingCloudProxy(e) { } onEventJoinFallbackToProxy(e) { } onEventPublishedUserList(e) { } onEventContentInspectError(e) { this._engine.rtcEngineEventHandler.onError(s.ERROR_CODE_TYPE.ERR_FAILED, (null == e ? void 0 : e.message) || "Content Inspect Error") } onEventContentInspectResult(e, t) { if (e) { let t = d.AgoraTranslate.data2NATIVE_RTC_CONNECT_INSPECT_RESULT(e); this._engine.rtcEngineEventHandler.onContentInspectResult(t) } } release() { this.agoraRTCClient.removeAllListeners() } } }, 5783: function (e, t, n) { "use strict"; var i = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisTrackEventHandler = void 0; const r = n(4473); t.IrisTrackEventHandler = class { constructor(e, t) { switch (this._client = null, this._remoteUser = null, this._track = null, this._trackType = "ILocalTrack", this.__onEventTrackEnded = null, this.__onEventBeautyEffectOverload = null, this.__onEventFirstFrameDecoded = null, this.__onEventVideoElementVisibleStatus = null, this.__onEventSourceStateChange = null, this._client = e.client, this._remoteUser = e.remoteUser, this._track = e.track, this._trackType = e.trackType, this._videoSourceType = e.videoSourceType, this._engine = t, this._trackType) { case "ILocalTrack": this.__onEventTrackEnded = this.onEventTrackEnded.bind(this), this._track.on("track-ended", this.__onEventTrackEnded); break; case "ILocalVideoTrack": this.__onEventTrackEnded = this.onEventTrackEnded.bind(this), this._track.on("track-ended", this.__onEventTrackEnded), this.__onEventBeautyEffectOverload = this.onEventBeautyEffectOverload.bind(this), this.__onEventVideoElementVisibleStatus = this.onEventVideoElementVisibleStatus.bind(this), this._track.on("video-element-visible-status", this.__onEventVideoElementVisibleStatus); break; case "IRemoteTrack": this.__onEventFirstFrameDecoded = this.onEventFirstFrameDecoded.bind(this), this._track.on("first-frame-decoded", this.__onEventFirstFrameDecoded); break; case "IRemoteVideoTrack": this.__onEventFirstFrameDecoded = this.onEventFirstFrameDecoded.bind(this), this._track.on("first-frame-decoded", this.__onEventFirstFrameDecoded), this.__onEventVideoElementVisibleStatus = this.onEventVideoElementVisibleStatus.bind(this), this._track.on("video-element-visible-status", this.__onEventVideoElementVisibleStatus); break; case "IBufferSourceAudioTrack": this.__onEventSourceStateChange = this.onEventSourceStateChange.bind(this), this._track.on("source-state-change", this.__onEventSourceStateChange) } } onEventTrackEnded() { return i(this, void 0, void 0, (function* () { if ("ILocalTrack" === this._trackType) this._engine.implHelper.isScreenCapture(this._videoSourceType) && this._engine.implDispatchesMap.get("RtcEngine")._impl.stopScreenCapture() })) } onEventSourceStateChange() { if ("IBufferSourceAudioTrack" === this._trackType) { let e = this._engine.irisClientManager.getLocalAudioTrackPackageBySourceType(r.IrisAudioSourceType.kAudioSourceTypeBufferSourceAudio)[0].soundId; this._engine.rtcEngineEventHandler.onAudioEffectFinished(e) } } onEventBeautyEffectOverload() { } onEventVideoElementVisibleStatus(e) { this._engine.rtcEngineEventHandler.onFirstLocalVideoFrame(this._videoSourceType, null, null, null) } onEventFirstFrameDecoded() { var e, t; if ("IRemoteTrack" == this._trackType) { let t = { channelId: this._client.channelName, localUid: this._client.uid }, n = (null === (e = this._remoteUser) || void 0 === e ? void 0 : e.uid) || -1, i = 0; this._engine.rtcEngineEventHandler.onFirstRemoteAudioDecodedEx(t, n, i), this._engine.rtcEngineEventHandler.onFirstRemoteAudioFrameEx(t, n, i) } else if ("IRemoteVideoTrack" == this._trackType) { let e = { channelId: this._client.channelName, localUid: this._client.uid }, n = (null === (t = this._remoteUser) || void 0 === t ? void 0 : t.uid) || -1, i = 0, r = -1, o = -1; if (this._remoteUser.hasVideo && this._remoteUser.videoTrack) { let e = this._remoteUser.videoTrack.getCurrentFrameData(); r = (null == e ? void 0 : e.width) || -1, o = (null == e ? void 0 : e.height) || -1 } this._engine.rtcEngineEventHandler.onFirstRemoteVideoDecodedEx(e, n, r, o, i), this._engine.rtcEngineEventHandler.onFirstRemoteVideoFrameEx(e, n, r, o, i) } } getTrack() { return this._track } getRemoteUser() { return this._remoteUser } getTrackType() { return this._trackType } release() { if ("ILocalTrack" == this._trackType) { this._track.off("track-ended", this.__onEventTrackEnded) } else if ("ILocalVideoTrack" == this._trackType) { let e = this._track; e.off("track-ended", this.__onEventTrackEnded), e.off("video-element-visible-status", this.__onEventVideoElementVisibleStatus) } else if ("IRemoteTrack" == this._trackType) { this._track.off("first-frame-decoded", this.__onEventFirstFrameDecoded) } else if ("IRemoteVideoTrack" == this._trackType) { let e = this._track; e.off("first-frame-decoded", this.__onEventFirstFrameDecoded), e.off("video-element-visible-status", this.__onEventVideoElementVisibleStatus) } } } }, 5762: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.callApiBufferExtension = void 0, t.callApiBufferExtension = function (e, t, n) { if ("MediaEngine_pushVideoFrame" === e) "object" == typeof (null == t ? void 0 : t.frame) && (t.frame.buffer = n); return t } }, 7986: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.RtcEngineDispatchExtensions = void 0; const i = n(3386), r = n(9209); class o extends i.IRtcEngineDispatch { constructor(e) { super(e), this._impl = new r.IRtcEngineImpl(e) } setAppType(e) { let t = JSON.parse(e.data).appType; if (void 0 === t) throw "appType is undefined"; return this._impl.setAppType(t) } } t.RtcEngineDispatchExtensions = o }, 2161: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.ClientHelper = void 0; const a = o(n(5844)), c = n(7481), E = n(4482), _ = n(1215); t.ClientHelper = class { constructor(e) { this._engine = e } setClientRole(e, t, n) { return s(this, void 0, void 0, (function* () { try { let i = _.AgoraTranslate.NATIVE_RTC_CLIENT_ROLE_TYPE2ClientRole(t); yield e.setClientRole(i, "audience" === i ? _.AgoraTranslate.NATIVE_RTC_AUDIENCE_LATENCY_LEVEL_TYPE2ClientRoleOptions(n) : null) } catch (i) { throw E.AgoraConsole.error(i), Promise.resolve(new c.CallIrisApiResult(-a.ERROR_CODE_TYPE.ERR_FAILED, i)), i } })) } } }, 4366: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisElement = void 0; t.IrisElement = class { constructor(e) { this.containerID = "IRIS-WEB-CONTAINER", this.containerDisplay = "none", e && (this.containerID = e) } createIrisElement() { const e = document.createElement("div"); return e.id = this.containerID, this.containerElement = e, e } getIrisElement() { return this.containerElement } remove() { var e; null === (e = this.containerElement) || void 0 === e || e.remove(), this.containerElement = null } release() { this.remove() } } }, 9071: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.ImplHelper = void 0; const a = o(n(5844)), c = n(4473), E = n(5873), _ = n(6545), d = n(5783), u = n(4482), l = n(1215); t.ImplHelper = class { constructor(e) { this._engine = e } createBufferSourceAudioTrack(e, t, n) { return s(this, void 0, void 0, (function* () { let i = null; try { i = yield this._engine.globalState.AgoraRTC.createBufferSourceAudioTrack(n) } catch (s) { u.AgoraConsole.error("createBufferSourceAudioTrack failed"), u.AgoraConsole.error(s) } yield this.processAudioTrack(i); let r = new E.BufferSourceAudioTrackPackage(c.IrisAudioSourceType.kAudioSourceTypeBufferSourceAudio, i, e, t); this._engine.irisClientManager.addLocalAudioTrackPackage(r); let o = new d.IrisTrackEventHandler({ track: i, trackType: "IBufferSourceAudioTrack" }, this._engine); return this._engine.irisClientManager.addTrackEventHandler(o), r })) } createCustomVideoTrack(e, t) { return s(this, void 0, void 0, (function* () { let n = this._engine.irisClientManager.getLocalVideoTrackPackageBySourceType(e)[0], i = null, r = { mediaStreamTrack: t }; if (null == n ? void 0 : n.track) return n; try { i = this._engine.globalState.AgoraRTC.createCustomVideoTrack(r) } catch (s) { u.AgoraConsole.error("createCustomVideoTrack failed"), u.AgoraConsole.error(s) } yield this.processVideoTrack(i), n ? n.update({ track: i }) : (n = new E.VideoTrackPackage(null, e, i), this._engine.irisClientManager.addLocalVideoTrackPackage(n)); let o = new d.IrisTrackEventHandler({ track: i, trackType: "ILocalVideoTrack" }, this._engine); return this._engine.irisClientManager.addTrackEventHandler(o), n })) } createScreenTrack(e, t) { return s(this, void 0, void 0, (function* () { let n = this._engine.irisClientManager.getLocalVideoTrackPackageBySourceType(t)[0]; if (null == n ? void 0 : n.track) return; let i = null, r = null, o = [null, null]; try { let s = this.generateScreenVideoTrackInitConfig(), a = yield this._engine.globalState.AgoraRTC.createScreenVideoTrack(s, e.captureAudio ? "auto" : "disable"); if (o = Array.isArray(a) ? a : [a, null], o) { if (i = o[1], i) { yield this.processScreenShareAudioTrack(i); let e = new E.AudioTrackPackage(c.IrisAudioSourceType.kAudioSourceTypeScreenCapture, i); this._engine.irisClientManager.addLocalAudioTrackPackage(e) } if (r = o[0], r) { yield this.processScreenShareVideoTrack(r), n ? n.update({ track: r }) : (n = new E.VideoTrackPackage(null, t, r), this._engine.irisClientManager.addLocalVideoTrackPackage(n)); let e = new d.IrisTrackEventHandler({ track: r, videoSourceType: t, trackType: "ILocalTrack" }, this._engine); this._engine.irisClientManager.addTrackEventHandler(e) } } } catch (s) { throw s } })) } createAudioTrack(e) { return s(this, void 0, void 0, (function* () { let t, n = null; try { n = yield this._engine.globalState.AgoraRTC.createMicrophoneAudioTrack(), yield this._engine.trackHelper.setEnabled(n, !1) } catch (i) { throw u.AgoraConsole.error("createMicrophoneAudioTrack failed"), i } return yield this.processAudioTrack(n), t = new E.AudioTrackPackage(e, n), this._engine.irisClientManager.addLocalAudioTrackPackage(t), t })) } createVideoCameraTrack() { return s(this, void 0, void 0, (function* () { let e = null; try { e = yield this._engine.globalState.AgoraRTC.createCameraVideoTrack(), yield this._engine.trackHelper.setEnabled(e, !1) } catch (t) { u.AgoraConsole.error("createCameraVideoTrack failed"), u.AgoraConsole.error(t) } return yield this.processVideoTrack(e), e })) } processScreenShareAudioTrack(e) { return s(this, void 0, void 0, (function* () { let t = this._engine.globalState; t.enabledAudio && this._engine.trackHelper.play(e), t.pausedAudio && (yield this._engine.trackHelper.setEnabled(e, !1)), t.mutedLocalAudioStream && (yield this._engine.trackHelper.setMuted(e, !0)) })) } processScreenShareVideoTrack(e) { return s(this, void 0, void 0, (function* () { let t = this._engine.globalState; t.pausedVideo && (yield this._engine.trackHelper.setEnabled(e, !1)), t.mutedLocalVideoStream && (yield this._engine.trackHelper.setMuted(e, !0)) })) } processAudioTrack(e) { return s(this, void 0, void 0, (function* () { let t = this._engine.globalState; t.pausedAudio && (yield this._engine.trackHelper.setEnabled(e, !1)), t.mutedLocalAudioStream && (yield this._engine.trackHelper.setMuted(e, !0)) })) } processVideoTrack(e) { return s(this, void 0, void 0, (function* () { let t = this._engine.globalState; t.pausedVideo && (yield this._engine.trackHelper.setEnabled(e, !1)), t.mutedLocalVideoStream && (yield this._engine.trackHelper.setMuted(e, !0)) })) } generateScreenVideoTrackInitConfig() { let e = {}, t = this._engine.globalState; return null != t.screenCaptureContentHint && t.screenCaptureContentHint != a.VIDEO_CONTENT_HINT.CONTENT_HINT_NONE && (e.optimizationMode = l.AgoraTranslate.NATIVE_RTCVIDEO_CONTENT_HINT2string(t.screenCaptureContentHint)), null != t.screenCaptureParameters2 && (e.encoderConfig = l.AgoraTranslate.NATIVE_RTCScreenCaptureParameters2VideoEncoderConfiguration(t.screenCaptureParameters2)), e } enumerateDevices() { return s(this, void 0, void 0, (function* () { let e = yield this._engine.globalState.AgoraRTC.getDevices(), t = [], n = [], i = []; for (let r of e) "audiooutput" == r.kind ? t.push({ deviceId: r.deviceId, deviceName: r.label }) : "audioinput" == r.kind ? n.push({ deviceId: r.deviceId, deviceName: r.label }) : "videoinput" == r.kind && i.push({ deviceId: r.deviceId, deviceName: r.label }); return this._engine.globalState.playbackDevices = t, this._engine.globalState.recordingDevices = n, this._engine.globalState.videoDevices = i, { playbackDevices: t, recordingDevices: n, videoDevices: i } })) } updateChannelMediaOptions(e, t) { return s(this, void 0, void 0, (function* () { const n = this._engine.irisClientManager, i = n.getIrisClientByConnection(t); let r = null == i ? void 0 : i.agoraRTCClient; if (!r) return this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_FAILED); let o = i.audioTrackPackages, s = i.videoTrackPackage, c = n.irisClientObserver; c.notifyLocal(_.NotifyType.UNPUBLISH_TRACK, [...o, s]); let E = i.irisClientState; if (E.mergeChannelMediaOptions(e), E.clientRoleType && (yield this._engine.clientHelper.setClientRole(r, E.clientRoleType, E.audienceLatencyLevel)), E.token) try { yield r.renewToken(E.token) } catch (d) { return this._engine.returnResult(!1) } c.notifyLocal(_.NotifyType.PUBLISH_TRACK, [...n.localAudioTrackPackages, ...n.localVideoTrackPackages], [i]) })) } isScreenCapture(e) { return e == a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_PRIMARY || e == a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_SECONDARY || e == a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_THIRD || e == a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_FOURTH } isVideoCamera(e) { return e == a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_PRIMARY || e == a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_SECONDARY || e == a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_THIRD || e == a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_FOURTH } isAudio(e) { return e === c.IrisAudioSourceType.kAudioSourceTypeMicrophonePrimary || e === c.IrisAudioSourceType.kAudioSourceTypeMicrophoneSecondary || e === c.IrisAudioSourceType.kAudioSourceTypeScreenCapture || e === c.IrisAudioSourceType.kAudioSourceTypeCustom || e === c.IrisAudioSourceType.kAudioSourceTypeUnknown } } }, 3501: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.TrackHelper = void 0; const a = o(n(5844)), c = n(7481), E = n(4482); t.TrackHelper = class { constructor(e) { this._engine = e } play(e, t) { try { null == e || e.play(t) } catch (n) { throw E.AgoraConsole.error(n), Promise.resolve(new c.CallIrisApiResult(-a.ERROR_CODE_TYPE.ERR_FAILED, n)), n } } stop(e) { try { null == e || e.stop() } catch (t) { throw E.AgoraConsole.error(t), Promise.resolve(new c.CallIrisApiResult(-a.ERROR_CODE_TYPE.ERR_FAILED, t)), t } } setEnabled(e, t) { return s(this, void 0, void 0, (function* () { try { yield null == e ? void 0 : e.setEnabled(t) } catch (n) { throw E.AgoraConsole.error(n), Promise.resolve(new c.CallIrisApiResult(-a.ERROR_CODE_TYPE.ERR_FAILED, n)), n } })) } setMuted(e, t) { return s(this, void 0, void 0, (function* () { try { (null == e ? void 0 : e.enabled) && (yield null == e ? void 0 : e.setMuted(t)) } catch (n) { throw E.AgoraConsole.error(n), Promise.resolve(new c.CallIrisApiResult(-a.ERROR_CODE_TYPE.ERR_FAILED, n)), n } })) } setDevice(e, t) { return s(this, void 0, void 0, (function* () { try { yield null == e ? void 0 : e.setDevice(t) } catch (n) { throw E.AgoraConsole.error(n), Promise.resolve(new c.CallIrisApiResult(-a.ERROR_CODE_TYPE.ERR_FAILED, n)), n } })) } } }, 1356: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IMediaEngineImpl = void 0; const a = o(n(5844)), c = n(6545), E = n(4482), _ = n(4144); t.IMediaEngineImpl = class { constructor(e) { this._engine = e } setExternalVideoSource(e, t, n, i) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return this._engine.globalState.pushVideoFrameEnabled = e, this._engine.globalState.pushVideoFrameUseTexture = t, this._engine.globalState.pushVideoFrameSourceType = n, this._engine.globalState.pushVideoFrameEncodedVideoOption = i, this._engine.returnResult() })))) } registerVideoEncodedFrameObserver(e) { return E.AgoraConsole.warn("registerVideoEncodedFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pushAudioFrame(e, t) { return E.AgoraConsole.warn("pushAudioFrame not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExternalAudioSource(e, t, n, i, r) { return E.AgoraConsole.warn("setExternalAudioSource not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createCustomAudioTrack(e, t) { return E.AgoraConsole.warn("createCustomAudioTrack not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } destroyCustomAudioTrack(e) { return E.AgoraConsole.warn("destroyCustomAudioTrack not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExternalAudioSink(e, t, n) { return E.AgoraConsole.warn("setExternalAudioSink not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableCustomAudioLocalPlayback(e, t) { return E.AgoraConsole.warn("enableCustomAudioLocalPlayback not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pushEncodedVideoImage(e, t, n, i) { return E.AgoraConsole.warn("pushEncodedVideoImage not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } release() { return E.AgoraConsole.warn("release not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerAudioFrameObserver(e) { return E.AgoraConsole.warn("registerAudioFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerVideoFrameObserver(e) { return E.AgoraConsole.warn("registerVideoFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pushCaptureAudioFrame(e) { return E.AgoraConsole.warn("pushCaptureAudioFrame not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pushReverseAudioFrame(e) { return E.AgoraConsole.warn("pushReverseAudioFrame not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pushDirectAudioFrame(e) { return E.AgoraConsole.warn("pushDirectAudioFrame not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pullAudioFrame(e) { return E.AgoraConsole.warn("pullAudioFrame not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDirectExternalAudioSource(e, t) { return E.AgoraConsole.warn("setDirectExternalAudioSource not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pushVideoFrame(e, t) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { if (0 == this._engine.globalState.enabledVideo) return E.AgoraConsole.error("call enableVideo(true) before startPreview"), this._engine.returnResult(); if (!this._engine.globalState.pushVideoFrameEnabled) return E.AgoraConsole.error("pushVideoFrameEnabled is disabled , call setExternalVideoSource first"), this._engine.returnResult(); let t = this._engine.irisElement.getIrisElement(); t || (t = this._engine.irisElement.createIrisElement()); let n = "MediaEngine_pushVideoFrame_CANVAS", i = document.querySelector(`#${n}`); if (i || (i = document.createElement("canvas"), i.id = n, i.style.display = "none"), e.format !== a.VIDEO_PIXEL_FORMAT.VIDEO_PIXEL_BGRA && e.format !== a.VIDEO_PIXEL_FORMAT.VIDEO_PIXEL_RGBA) return E.AgoraConsole.error(`format${e.format} not supported`), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED); (0, _.drawRGBABufferToCanvas)(e.stride, e.height, e.buffer, e.format, i), t.appendChild(i), document.body.appendChild(t); let r, o = i.captureStream().getVideoTracks()[0], s = a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CUSTOM; try { r = yield this._engine.implHelper.createCustomVideoTrack(s, o) } catch (u) { return u && E.AgoraConsole.error(u), this._engine.returnResult(!1) } let d = r.track; return d && (d.enabled || (yield this._engine.trackHelper.setEnabled(d, !0)), !d.isPlaying && r.element && this._engine.trackHelper.play(d, r.element), this._engine.irisClientManager.irisClientObserver.notifyLocal(c.NotifyType.PUBLISH_TRACK, [r], this._engine.irisClientManager.irisClientList)), this._engine.returnResult() })))) } } }, 619: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IMediaPlayerCacheManagerImpl = t.IMediaPlayerImpl = void 0; const s = o(n(5844)), a = n(4482); t.IMediaPlayerImpl = class { constructor(e) { this._engine = e } setPlayerOption2(e, t) { return a.AgoraConsole.warn("setPlayerOption2 not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerAudioFrameObserver2(e, t) { return a.AgoraConsole.warn("registerAudioFrameObserver2 not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterMediaPlayerAudioSpectrumObserver(e) { return a.AgoraConsole.warn("unregisterMediaPlayerAudioSpectrumObserver not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMediaPlayerId() { return a.AgoraConsole.warn("getMediaPlayerId not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } open(e, t) { return a.AgoraConsole.warn("open not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } openWithMediaSource(e) { return a.AgoraConsole.warn("openWithMediaSource not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } play() { return a.AgoraConsole.warn("play not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pause() { return a.AgoraConsole.warn("pause not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stop() { return a.AgoraConsole.warn("stop not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resume() { return a.AgoraConsole.warn("resume not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } seek(e) { return a.AgoraConsole.warn("seek not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioPitch(e) { return a.AgoraConsole.warn("setAudioPitch not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getDuration(e) { return a.AgoraConsole.warn("getDuration not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlayPosition(e) { return a.AgoraConsole.warn("getPlayPosition not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getStreamCount(e) { return a.AgoraConsole.warn("getStreamCount not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getStreamInfo(e, t) { return a.AgoraConsole.warn("getStreamInfo not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLoopCount(e) { return a.AgoraConsole.warn("setLoopCount not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackSpeed(e) { return a.AgoraConsole.warn("setPlaybackSpeed not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } selectAudioTrack(e) { return a.AgoraConsole.warn("selectAudioTrack not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlayerOption(e, t) { return a.AgoraConsole.warn("setPlayerOption not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } takeScreenshot(e) { return a.AgoraConsole.warn("takeScreenshot not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } selectInternalSubtitle(e) { return a.AgoraConsole.warn("selectInternalSubtitle not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExternalSubtitle(e) { return a.AgoraConsole.warn("setExternalSubtitle not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getState() { return a.AgoraConsole.warn("getState not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } mute(e) { return a.AgoraConsole.warn("mute not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMute(e) { return a.AgoraConsole.warn("getMute not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustPlayoutVolume(e) { return a.AgoraConsole.warn("adjustPlayoutVolume not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlayoutVolume(e) { return a.AgoraConsole.warn("getPlayoutVolume not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustPublishSignalVolume(e) { return a.AgoraConsole.warn("adjustPublishSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPublishSignalVolume(e) { return a.AgoraConsole.warn("getPublishSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setView(e) { return a.AgoraConsole.warn("setView not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRenderMode(e) { return a.AgoraConsole.warn("setRenderMode not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerPlayerSourceObserver(e) { return a.AgoraConsole.warn("registerPlayerSourceObserver not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterPlayerSourceObserver(e) { return a.AgoraConsole.warn("unregisterPlayerSourceObserver not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerAudioFrameObserver(e) { return a.AgoraConsole.warn("registerAudioFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterAudioFrameObserver(e) { return a.AgoraConsole.warn("unregisterAudioFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerVideoFrameObserver(e) { return a.AgoraConsole.warn("registerVideoFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterVideoFrameObserver(e) { return a.AgoraConsole.warn("unregisterVideoFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerMediaPlayerAudioSpectrumObserver(e, t) { return a.AgoraConsole.warn("registerMediaPlayerAudioSpectrumObserver not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioDualMonoMode(e) { return a.AgoraConsole.warn("setAudioDualMonoMode not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlayerSdkVersion() { return a.AgoraConsole.warn("getPlayerSdkVersion not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlaySrc() { return a.AgoraConsole.warn("getPlaySrc not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } openWithAgoraCDNSrc(e, t) { return a.AgoraConsole.warn("openWithAgoraCDNSrc not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAgoraCDNLineCount() { return a.AgoraConsole.warn("getAgoraCDNLineCount not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } switchAgoraCDNLineByIndex(e) { return a.AgoraConsole.warn("switchAgoraCDNLineByIndex not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCurrentAgoraCDNIndex() { return a.AgoraConsole.warn("getCurrentAgoraCDNIndex not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAutoSwitchAgoraCDN(e) { return a.AgoraConsole.warn("enableAutoSwitchAgoraCDN not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } renewAgoraCDNSrcToken(e, t) { return a.AgoraConsole.warn("renewAgoraCDNSrcToken not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } switchAgoraCDNSrc(e, t) { return a.AgoraConsole.warn("switchAgoraCDNSrc not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } switchSrc(e, t) { return a.AgoraConsole.warn("switchSrc not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preloadSrc(e, t) { return a.AgoraConsole.warn("preloadSrc not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } playPreloadedSrc(e) { return a.AgoraConsole.warn("playPreloadedSrc not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unloadSrc(e) { return a.AgoraConsole.warn("unloadSrc not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSpatialAudioParams(e) { return a.AgoraConsole.warn("setSpatialAudioParams not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSoundPositionParams(e, t) { return a.AgoraConsole.warn("setSoundPositionParams not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.IMediaPlayerCacheManagerImpl = class { constructor(e) { this._engine = e } removeAllCaches() { return a.AgoraConsole.warn("removeAllCaches not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeOldCache() { return a.AgoraConsole.warn("removeOldCache not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeCacheByUri(e) { return a.AgoraConsole.warn("removeCacheByUri not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCacheDir(e) { return a.AgoraConsole.warn("setCacheDir not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setMaxCacheFileCount(e) { return a.AgoraConsole.warn("setMaxCacheFileCount not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setMaxCacheFileSize(e) { return a.AgoraConsole.warn("setMaxCacheFileSize not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAutoRemoveCache(e) { return a.AgoraConsole.warn("enableAutoRemoveCache not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCacheDir(e, t) { return a.AgoraConsole.warn("getCacheDir not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMaxCacheFileCount() { return a.AgoraConsole.warn("getMaxCacheFileCount not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMaxCacheFileSize() { return a.AgoraConsole.warn("getMaxCacheFileSize not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCacheFileCount() { return a.AgoraConsole.warn("getCacheFileCount not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 8767: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IMediaRecorderImpl = void 0; const s = o(n(5844)), a = n(4482); t.IMediaRecorderImpl = class { constructor(e) { this._engine = e } setMediaRecorderObserver(e) { return a.AgoraConsole.warn("setMediaRecorderObserver not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRecording(e) { return a.AgoraConsole.warn("startRecording not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopRecording() { return a.AgoraConsole.warn("stopRecording not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 2215: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.MusicCollectionImpl = t.IMusicPlayerImpl = t.MusicChartCollectionImpl = t.IMusicContentCenterImpl = void 0; const s = o(n(5844)), a = n(4482); t.IMusicContentCenterImpl = class { constructor(e) { this._engine = e } initialize(e) { return a.AgoraConsole.warn("initialize not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } renewToken(e) { return a.AgoraConsole.warn("renewToken not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } release() { return a.AgoraConsole.warn("release not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerEventHandler(e) { return a.AgoraConsole.warn("registerEventHandler not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterEventHandler() { return a.AgoraConsole.warn("unregisterEventHandler not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createMusicPlayer() { return a.AgoraConsole.warn("createMusicPlayer not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMusicCharts(e) { return a.AgoraConsole.warn("getMusicCharts not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMusicCollectionByMusicChartId(e, t, n, i, r) { return a.AgoraConsole.warn("getMusicCollectionByMusicChartId not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } searchMusic(e, t, n, i, r) { return a.AgoraConsole.warn("searchMusic not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preload(e, t) { return a.AgoraConsole.warn("preload not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preload2(e, t) { return a.AgoraConsole.warn("preload2 not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeCache(e) { return a.AgoraConsole.warn("removeCache not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCaches(e, t) { return a.AgoraConsole.warn("getCaches not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isPreloaded(e) { return a.AgoraConsole.warn("isPreloaded not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getLyric(e, t, n) { return a.AgoraConsole.warn("getLyric not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getSongSimpleInfo(e, t) { return a.AgoraConsole.warn("getSongSimpleInfo not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getInternalSongCode(e, t, n) { return a.AgoraConsole.warn("getInternalSongCode not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.MusicChartCollectionImpl = class { constructor(e) { this._engine = e } getCount() { return a.AgoraConsole.warn("getCount not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } get(e) { return a.AgoraConsole.warn("get not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.IMusicPlayerImpl = class { constructor(e) { this._engine = e } }; t.MusicCollectionImpl = class { constructor(e) { this._engine = e } getCount() { return a.AgoraConsole.warn("getCount not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getTotal() { return a.AgoraConsole.warn("getTotal not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPage() { return a.AgoraConsole.warn("getPage not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPageSize() { return a.AgoraConsole.warn("getPageSize not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getMusic(e) { return a.AgoraConsole.warn("getMusic not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 4856: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IRtcEngineExImpl = void 0; const a = o(n(5844)), c = n(7170), E = n(5873), _ = n(6545), d = n(4482); t.IRtcEngineExImpl = class { constructor(e) { this._engine = e } enableContentInspectEx(e, t, n) { return d.AgoraConsole.warn("enableContentInspectEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } joinChannelEx(e, t, n) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { let i = new c.IrisClient(this._engine, t); i.createClient(n), i.irisClientState.token = e; let r = i.agoraRTCClient; try { yield r.join(this._engine.globalState.rtcEngineContext.appId, t.channelId, e || null, t.localUid) } catch (o) { return d.AgoraConsole.error(o), this._engine.rtcEngineEventHandler.onError(a.ERROR_CODE_TYPE.ERR_JOIN_CHANNEL_REJECTED, ""), i.release(), this._engine.returnResult(!1) } return this._engine.rtcEngineEventHandler.onJoinChannelSuccessEx(t, 0), yield this._engine.irisClientManager.irisClientObserver.notifyLocal(_.NotifyType.PUBLISH_TRACK, [...this._engine.irisClientManager.localAudioTrackPackages, ...this._engine.irisClientManager.localVideoTrackPackages], [i]), this._engine.returnResult() })))) } leaveChannelEx(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { if (0 === this._engine.irisClientManager.irisClientList.length) return this._engine.returnResult(); let t = this._engine.irisClientManager.getIrisClientByConnection(e); yield this._engine.irisClientManager.irisClientObserver.notifyLocal(_.NotifyType.UNPUBLISH_TRACK, [...this._engine.irisClientManager.localAudioTrackPackages, ...this._engine.irisClientManager.localVideoTrackPackages]); let n = null == t ? void 0 : t.agoraRTCClient; if (n) { try { yield n.leave() } catch (i) { d.AgoraConsole.error(i), this._engine.returnResult(!1), this._engine.rtcEngineEventHandler.onError(a.ERROR_CODE_TYPE.ERR_LEAVE_CHANNEL_REJECTED, "") } this._engine.rtcEngineEventHandler.onLeaveChannelEx(e, new a.RtcStats), t.release() } return this._engine.returnResult() })))) } leaveChannelEx2(e, t) { return d.AgoraConsole.warn("leaveChannelEx2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateChannelMediaOptionsEx(e, t) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return yield this._engine.implHelper.updateChannelMediaOptions(e, t), this._engine.returnResult() })))) } setVideoEncoderConfigurationEx(e, t) { return d.AgoraConsole.warn("setVideoEncoderConfigurationEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setupRemoteVideoEx(e, t) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { let n = this._engine.irisClientManager.getRemoteUserPackageByUid(e.uid); if (n) n.update({ element: e.view }), this._engine.irisClientManager.irisClientObserver.notifyRemote(_.NotifyRemoteType.SUBSCRIBE_VIDEO_TRACK, [n]); else { let n = new E.RemoteUserPackage(t, e.view, e.uid, a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_REMOTE), i = this._engine.irisClientManager.getIrisClientByConnection(t); this._engine.irisClientManager.addRemoteUserPackage(n, null == i ? void 0 : i.agoraRTCClient) } return this._engine.returnResult() })))) } muteRemoteAudioStreamEx(e, t, n) { return d.AgoraConsole.warn("muteRemoteAudioStreamEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRemoteVideoStreamEx(e, t, n) { return d.AgoraConsole.warn("muteRemoteVideoStreamEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVideoStreamTypeEx(e, t, n) { return d.AgoraConsole.warn("setRemoteVideoStreamTypeEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteLocalAudioStreamEx(e, t) { return d.AgoraConsole.warn("muteLocalAudioStreamEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteLocalVideoStreamEx(e, t) { return d.AgoraConsole.warn("muteLocalVideoStreamEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteAudioStreamsEx(e, t) { return d.AgoraConsole.warn("muteAllRemoteAudioStreamsEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteVideoStreamsEx(e, t) { return d.AgoraConsole.warn("muteAllRemoteVideoStreamsEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeAudioBlocklistEx(e, t, n) { return d.AgoraConsole.warn("setSubscribeAudioBlocklistEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeAudioAllowlistEx(e, t, n) { return d.AgoraConsole.warn("setSubscribeAudioAllowlistEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeVideoBlocklistEx(e, t, n) { return d.AgoraConsole.warn("setSubscribeVideoBlocklistEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeVideoAllowlistEx(e, t, n) { return d.AgoraConsole.warn("setSubscribeVideoAllowlistEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVideoSubscriptionOptionsEx(e, t, n) { return d.AgoraConsole.warn("setRemoteVideoSubscriptionOptionsEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVoicePositionEx(e, t, n, i) { return d.AgoraConsole.warn("setRemoteVoicePositionEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteUserSpatialAudioParamsEx(e, t, n) { return d.AgoraConsole.warn("setRemoteUserSpatialAudioParamsEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteRenderModeEx(e, t, n, i) { return d.AgoraConsole.warn("setRemoteRenderModeEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableLoopbackRecordingEx(e, t, n) { return d.AgoraConsole.warn("enableLoopbackRecordingEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustRecordingSignalVolumeEx(e, t) { return d.AgoraConsole.warn("adjustRecordingSignalVolumeEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRecordingSignalEx(e, t) { return d.AgoraConsole.warn("muteRecordingSignalEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustUserPlaybackSignalVolumeEx(e, t, n) { return d.AgoraConsole.warn("adjustUserPlaybackSignalVolumeEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getConnectionStateEx(e) { return d.AgoraConsole.warn("getConnectionStateEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableEncryptionEx(e, t, n) { return d.AgoraConsole.warn("enableEncryptionEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createDataStreamEx(e, t, n, i) { return d.AgoraConsole.warn("createDataStreamEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createDataStreamEx2(e, t, n) { return d.AgoraConsole.warn("createDataStreamEx2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } sendStreamMessageEx(e, t, n, i) { return d.AgoraConsole.warn("sendStreamMessageEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } addVideoWatermarkEx(e, t, n) { return d.AgoraConsole.warn("addVideoWatermarkEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } clearVideoWatermarkEx(e) { return d.AgoraConsole.warn("clearVideoWatermarkEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } sendCustomReportMessageEx(e, t, n, i, r, o) { return d.AgoraConsole.warn("sendCustomReportMessageEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAudioVolumeIndicationEx(e, t, n, i) { return d.AgoraConsole.warn("enableAudioVolumeIndicationEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRtmpStreamWithoutTranscodingEx(e, t) { return d.AgoraConsole.warn("startRtmpStreamWithoutTranscodingEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRtmpStreamWithTranscodingEx(e, t, n) { return d.AgoraConsole.warn("startRtmpStreamWithTranscodingEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateRtmpTranscodingEx(e, t) { return d.AgoraConsole.warn("updateRtmpTranscodingEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopRtmpStreamEx(e, t) { return d.AgoraConsole.warn("stopRtmpStreamEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startOrUpdateChannelMediaRelayEx(e, t) { return d.AgoraConsole.warn("startOrUpdateChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startChannelMediaRelayEx(e, t) { return d.AgoraConsole.warn("startChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateChannelMediaRelayEx(e, t) { return d.AgoraConsole.warn("updateChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopChannelMediaRelayEx(e) { return d.AgoraConsole.warn("stopChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseAllChannelMediaRelayEx(e) { return d.AgoraConsole.warn("pauseAllChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeAllChannelMediaRelayEx(e) { return d.AgoraConsole.warn("resumeAllChannelMediaRelayEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getUserInfoByUserAccountEx(e, t, n) { return d.AgoraConsole.warn("getUserInfoByUserAccountEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getUserInfoByUidEx(e, t, n) { return d.AgoraConsole.warn("getUserInfoByUidEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableDualStreamModeEx(e, t, n) { return d.AgoraConsole.warn("enableDualStreamModeEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDualStreamModeEx(e, t, n) { return d.AgoraConsole.warn("setDualStreamModeEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setHighPriorityUserListEx(e, t, n, i) { return d.AgoraConsole.warn("setHighPriorityUserListEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } takeSnapshotEx(e, t, n) { return d.AgoraConsole.warn("takeSnapshotEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startMediaRenderingTracingEx(e) { return d.AgoraConsole.warn("startMediaRenderingTracingEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 9209: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__awaiter || function (e, t, n, i) { return new (n || (n = Promise))((function (r, o) { function s(e) { try { c(i.next(e)) } catch (t) { o(t) } } function a(e) { try { c(i.throw(e)) } catch (t) { o(t) } } function c(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } c((i = i.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IVideoDeviceManagerImpl = t.IRtcEngineImpl = t.RTCENGINE_KEY = void 0; const a = o(n(5844)), c = n(4473), E = n(7170), _ = n(5873), d = n(6545), u = n(7275), l = n(4482), R = n(1215); t.RTCENGINE_KEY = "RtcEngine"; t.IRtcEngineImpl = class { constructor(e) { this._engine = null, this._engine = e } isFeatureAvailableOnDevice(e) { return l.AgoraConsole.warn("isFeatureAvailableOnDevice not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } release(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return yield this._engine.irisClientManager.release(), this._engine.returnResult() })))) } setAppType(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return this._engine.globalState.AgoraRTC.setAppType(e), this._engine.returnResult() })))) } initialize(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { var t, n; if (this._engine.irisClientManager.irisClientList.length > 0) return this._engine.returnResult(!0, a.ERROR_CODE_TYPE.ERR_OK); new E.IrisClient(this._engine), this._engine.globalState.rtcEngineContext = e, this._engine.globalState.AgoraRTC.setArea([R.AgoraTranslate.NATIVE_RTCAREA_CODE2AREAS(e.areaCode)]), (null === (t = null == e ? void 0 : e.logConfig) || void 0 === t ? void 0 : t.level) && this._engine.globalState.AgoraRTC.setLogLevel(R.AgoraTranslate.NATIVE_RTCLOG_LEVEL2Number(null === (n = null == e ? void 0 : e.logConfig) || void 0 === n ? void 0 : n.level)); try { yield this._engine.implHelper.createAudioTrack(c.IrisAudioSourceType.kAudioSourceTypeMicrophonePrimary) } catch (r) { l.AgoraConsole.warn(`createAudioTrack error: ${r}`) } let i = this._engine.globalState.AgoraRTC.checkSystemRequirements(); return this._engine.returnResult(i) })))) } getVersion() { return this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getErrorDescription(e) { return l.AgoraConsole.warn("getErrorDescription not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } queryCodecCapability(e, t) { return l.AgoraConsole.warn("queryCodecCapability not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preloadChannel(e, t, n) { return l.AgoraConsole.warn("preloadChannel not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preloadChannel2(e, t, n) { return l.AgoraConsole.warn("preloadChannel2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updatePreloadChannelToken(e) { return l.AgoraConsole.warn("updatePreloadChannelToken not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } joinChannel(e, t, n, i) { let r = this._engine.irisClientManager.getIrisClient(); return this.joinChannel2(e, t, i, r.irisClientState) } joinChannel2(e, t, n, i) { let r = this._engine.globalState; return this._engine.execute((() => s(this, void 0, void 0, (function* () { let o = this._engine.irisClientManager.getIrisClient(); o.createClient(i), i = o.irisClientState, o.irisClientState.token = e; let s = o.agoraRTCClient; try { yield s.join(r.rtcEngineContext.appId, t, e || null, n) } catch (E) { return l.AgoraConsole.error(E), this._engine.rtcEngineEventHandler.onError(a.ERROR_CODE_TYPE.ERR_JOIN_CHANNEL_REJECTED, ""), o.release(), this._engine.returnResult(!1) } let c = { channelId: t, localUid: s.uid }; return o.setConnection(c), this._engine.rtcEngineEventHandler.onJoinChannelSuccessEx(c, 0), yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.PUBLISH_TRACK, [...this._engine.irisClientManager.localAudioTrackPackages, ...this._engine.irisClientManager.localVideoTrackPackages], [o]), this._engine.returnResult() })))) } updateChannelMediaOptions(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return yield this._engine.implHelper.updateChannelMediaOptions(e), this._engine.returnResult() })))) } leaveChannel() { return this.leaveChannel2({ stopAudioMixing: !0, stopAllEffect: !0, stopMicrophoneRecording: !0 }) } leaveChannel2(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { var t; if (0 === this._engine.irisClientManager.irisClientList.length) return this._engine.returnResult(); yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.UNPUBLISH_TRACK, [...this._engine.irisClientManager.localAudioTrackPackages, ...this._engine.irisClientManager.localVideoTrackPackages]); for (let i of this._engine.irisClientManager.irisClientList) { i.irisClientState.mergeChannelMediaOptions(e); let r = i.agoraRTCClient; if (e = i.irisClientState, r) { for (let t of i.audioTrackPackages) if (t.track) { let n = t.track; e.stopMicrophoneRecording && (yield this._engine.trackHelper.setMuted(n, !0)), e.stopAllEffect && this.stopAllEffects(), e.stopAudioMixing } let o = { channelId: r.channelName, localUid: r.uid }; r.remoteUsers.map((e => { var t; this._engine.rtcEngineEventHandler.onUserOfflineEx(null !== (t = i.connection) && void 0 !== t ? t : o, e.uid, a.USER_OFFLINE_REASON_TYPE.USER_OFFLINE_DROPPED) })); try { yield r.leave(), l.AgoraConsole.log("leaveChannel success") } catch (n) { l.AgoraConsole.error(`leaveChannel failed:${n}`), this._engine.rtcEngineEventHandler.onError(a.ERROR_CODE_TYPE.ERR_LEAVE_CHANNEL_REJECTED, "") } this._engine.rtcEngineEventHandler.onLeaveChannelEx(null !== (t = i.connection) && void 0 !== t ? t : o, new a.RtcStats), i.release() } } return this._engine.returnResult() })))) } renewToken(e) { return l.AgoraConsole.warn("renewToken not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setChannelProfile(e) { return l.AgoraConsole.warn("setChannelProfile not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setClientRole(e) { let t = { audienceLatencyLevel: a.AUDIENCE_LATENCY_LEVEL_TYPE.AUDIENCE_LATENCY_LEVEL_ULTRA_LOW_LATENCY }; return this.setClientRole2(e, t) } setClientRole2(e, t) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { let n = this._engine.irisClientManager.getIrisClient(), i = n.irisClientState.clientRoleType; n.irisClientState.clientRoleType = e; let r = null == n ? void 0 : n.agoraRTCClient; return r && (yield this._engine.clientHelper.setClientRole(r, e, t.audienceLatencyLevel)), (null == r ? void 0 : r.channelName) && this._engine.rtcEngineEventHandler.onClientRoleChangedEx(n.connection, i, e, t), this._engine.returnResult() })))) } startEchoTest() { return l.AgoraConsole.warn("startEchoTest not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startEchoTest2(e) { return l.AgoraConsole.warn("startEchoTest2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startEchoTest3(e) { return l.AgoraConsole.warn("startEchoTest3 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopEchoTest() { return l.AgoraConsole.warn("stopEchoTest not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableMultiCamera(e, t) { return l.AgoraConsole.warn("enableMultiCamera not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableVideo() { return this._engine.execute((() => s(this, void 0, void 0, (function* () { this._engine.globalState.enabledVideo = !0, this._engine.globalState.autoSubscribeVideo = !0, yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.ENABLE_TRACK, [...this._engine.irisClientManager.localVideoTrackPackages]); for (let e of this._engine.irisClientManager.irisClientList) e.irisClientState.autoSubscribeVideo = !0, yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.PUBLISH_TRACK, [...this._engine.irisClientManager.localVideoTrackPackages], [e]); return this._engine.irisClientManager.irisClientObserver.notifyRemote(d.NotifyRemoteType.SUBSCRIBE_VIDEO_TRACK, this._engine.irisClientManager.remoteUserPackages), this._engine.returnResult() })))) } disableVideo() { return this._engine.execute((() => s(this, void 0, void 0, (function* () { this._engine.globalState.enabledVideo = !1, this._engine.globalState.autoSubscribeVideo = !1, yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.UNABLE_TRACK, [...this._engine.irisClientManager.localVideoTrackPackages]); for (let e of this._engine.irisClientManager.irisClientList) e.irisClientState.autoSubscribeVideo = !1, yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.UNPUBLISH_TRACK, [...this._engine.irisClientManager.localVideoTrackPackages], [e]); return this._engine.irisClientManager.irisClientObserver.notifyRemote(d.NotifyRemoteType.UNSUBSCRIBE_VIDEO_TRACK, this._engine.irisClientManager.remoteUserPackages), this._engine.returnResult() })))) } startPreview() { return this.startPreview2(a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA) } startPreview2(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { if (0 == this._engine.globalState.enabledVideo) return l.AgoraConsole.error("call enableVideo(true) before startPreview"), this._engine.returnResult(); if (e >= 5) return l.AgoraConsole.error("Invalid source type"), this._engine.returnResult(!1); let t; if (l.AgoraConsole.debug(`startPreview2 videoSource: ${e}`), null == e && a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_PRIMARY, t = this._engine.irisClientManager.getLocalVideoTrackPackageBySourceType(e)[0], !t && (t = new _.VideoTrackPackage(null, e, null), this._engine.irisClientManager.addLocalVideoTrackPackage(t), this._engine.implHelper.isVideoCamera(e))) { let e = null; e = yield this._engine.implHelper.createVideoCameraTrack(), t.update({ track: e }) } t.setPreview(!0); try { let e = null == t ? void 0 : t.track; e && (yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.ENABLE_TRACK, [t]), t.element && this._engine.trackHelper.play(e, t.element)) } catch (n) { return l.AgoraConsole.error(n), this._engine.returnResult(!1) } return this._engine.rtcEngineEventHandler.onLocalVideoStateChanged(e, a.LOCAL_VIDEO_STREAM_STATE.LOCAL_VIDEO_STREAM_STATE_ENCODING, 0), this._engine.returnResult() })))) } stopPreview() { return this.stopPreview2(a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA) } stopPreview2(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { if (e >= 5) return l.AgoraConsole.error("Invalid source type"), this._engine.returnResult(!1); let t; l.AgoraConsole.debug(`stopPreview2 videoSource: ${e}`), null == e && a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_PRIMARY, t = this._engine.irisClientManager.getLocalVideoTrackPackageBySourceType(e)[0], null == t || t.setPreview(!1); try { (null == t ? void 0 : t.track) && (yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.UNABLE_TRACK, [t]), t.element && this._engine.trackHelper.play(t.track, t.element)) } catch (n) { return l.AgoraConsole.error(n), this._engine.returnResult(!1) } return this._engine.rtcEngineEventHandler.onLocalVideoStateChanged(e, a.LOCAL_VIDEO_STREAM_STATE.LOCAL_VIDEO_STREAM_STATE_STOPPED, 0), this._engine.returnResult() })))) } startLastmileProbeTest(e) { return l.AgoraConsole.warn("startLastmileProbeTest not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopLastmileProbeTest() { return l.AgoraConsole.warn("stopLastmileProbeTest not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVideoEncoderConfiguration(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { this._engine.globalState.videoEncoderConfiguration = e; for (let t of this._engine.irisClientManager.localVideoTrackPackages) if (t.track) { let n = t.track; yield n.setEncoderConfiguration(R.AgoraTranslate.NATIVE_RTCVideoEncoderConfiguration2VideoEncoderConfiguration(e)) } return this._engine.returnResult() })))) } setBeautyEffectOptions(e, t, n) { return l.AgoraConsole.warn("setBeautyEffectOptions not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLowlightEnhanceOptions(e, t, n) { return l.AgoraConsole.warn("setLowlightEnhanceOptions not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVideoDenoiserOptions(e, t, n) { return l.AgoraConsole.warn("setVideoDenoiserOptions not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setColorEnhanceOptions(e, t, n) { return l.AgoraConsole.warn("setColorEnhanceOptions not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableVirtualBackground(e, t, n, i) { return l.AgoraConsole.warn("enableVirtualBackground not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setupRemoteVideo(e) { return l.AgoraConsole.warn("setupRemoteVideo not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setupLocalVideo(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { let t = e.sourceType || a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_PRIMARY, n = this._engine.irisClientManager.getLocalVideoTrackPackageBySourceType(t)[0]; if (!n && (n = new _.VideoTrackPackage(e.view, t, null), this._engine.irisClientManager.addLocalVideoTrackPackage(n), this._engine.implHelper.isVideoCamera(t))) { let e = null; e = yield this._engine.implHelper.createVideoCameraTrack(), n.update({ track: e }) } n.update({ type: t, element: e.view }); let i = n.track; return i && (yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.ENABLE_TRACK, [n]), n.element && n.isPreview && this._engine.trackHelper.play(i, n.element)), this._engine.returnResult() })))) } setVideoScenario(e) { return l.AgoraConsole.warn("setVideoScenario not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAudio() { return this._engine.execute((() => s(this, void 0, void 0, (function* () { this._engine.globalState.enabledAudio = !0, yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.ENABLE_TRACK, this._engine.irisClientManager.localAudioTrackPackages); for (let e of this._engine.irisClientManager.irisClientList) e.irisClientState.autoSubscribeAudio = !0, yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.PUBLISH_TRACK, [...this._engine.irisClientManager.localAudioTrackPackages], [e]); return this._engine.irisClientManager.irisClientObserver.notifyRemote(d.NotifyRemoteType.SUBSCRIBE_AUDIO_TRACK, this._engine.irisClientManager.remoteUserPackages), this._engine.returnResult() })))) } disableAudio() { return this._engine.execute((() => s(this, void 0, void 0, (function* () { this._engine.globalState.enabledAudio = !1, yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.UNABLE_TRACK, this._engine.irisClientManager.localAudioTrackPackages); for (let e of this._engine.irisClientManager.irisClientList) e.irisClientState.autoSubscribeAudio = !1, yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.UNPUBLISH_TRACK, [...this._engine.irisClientManager.localAudioTrackPackages], [e]); return this._engine.irisClientManager.irisClientObserver.notifyRemote(d.NotifyRemoteType.UNSUBSCRIBE_AUDIO_TRACK, this._engine.irisClientManager.remoteUserPackages), this._engine.returnResult() })))) } setAudioProfile(e, t) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return this._engine.globalState.audioProfile = e, this._engine.globalState.rtcEngineContext.audioScenario = t, this._engine.returnResult() })))) } setAudioProfile2(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return this._engine.globalState.audioProfile = e, this._engine.returnResult() })))) } setAudioScenario(e) { return l.AgoraConsole.warn("setAudioScenario not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableLocalAudio(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return this._engine.globalState.enabledLocalAudio = e, yield this._engine.irisClientManager.irisClientObserver.notifyLocal(e ? d.NotifyType.ENABLE_TRACK : d.NotifyType.UNABLE_TRACK, this._engine.irisClientManager.localAudioTrackPackages), yield this._engine.irisClientManager.irisClientObserver.notifyLocal(e ? d.NotifyType.PUBLISH_TRACK : d.NotifyType.UNPUBLISH_TRACK, this._engine.irisClientManager.localAudioTrackPackages, this._engine.irisClientManager.irisClientList), this._engine.returnResult() })))) } muteLocalAudioStream(e) { return this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteAudioStreams(e) { return l.AgoraConsole.warn("muteAllRemoteAudioStreams not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDefaultMuteAllRemoteAudioStreams(e) { return l.AgoraConsole.warn("setDefaultMuteAllRemoteAudioStreams not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRemoteAudioStream(e, t) { return l.AgoraConsole.warn("muteRemoteAudioStream not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteLocalVideoStream(e) { return l.AgoraConsole.warn("muteLocalVideoStream not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableLocalVideo(e) { return l.AgoraConsole.warn("enableLocalVideo not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteVideoStreams(e) { return l.AgoraConsole.warn("muteAllRemoteVideoStreams not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDefaultMuteAllRemoteVideoStreams(e) { return l.AgoraConsole.warn("setDefaultMuteAllRemoteVideoStreams not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRemoteVideoStream(e, t) { return l.AgoraConsole.warn("muteRemoteVideoStream not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVideoStreamType(e, t) { return l.AgoraConsole.warn("setRemoteVideoStreamType not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVideoSubscriptionOptions(e, t) { return l.AgoraConsole.warn("setRemoteVideoSubscriptionOptions not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteDefaultVideoStreamType(e) { return l.AgoraConsole.warn("setRemoteDefaultVideoStreamType not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeAudioBlocklist(e, t) { return l.AgoraConsole.warn("setSubscribeAudioBlocklist not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeAudioAllowlist(e, t) { return l.AgoraConsole.warn("setSubscribeAudioAllowlist not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeVideoBlocklist(e, t) { return l.AgoraConsole.warn("setSubscribeVideoBlocklist not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setSubscribeVideoAllowlist(e, t) { return l.AgoraConsole.warn("setSubscribeVideoAllowlist not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAudioVolumeIndication(e, t, n) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { var i; this._engine.globalState.enableAudioVolumeIndicationConfig = Object.assign(Object.assign(Object.assign(Object.assign({}, this._engine.globalState.enableAudioVolumeIndicationConfig), e && { interval: e }), t && { smooth: t }), n && { reportVad: n }); let r = null === (i = this._engine.irisClientManager.getIrisClient()) || void 0 === i ? void 0 : i.agoraRTCClient; if (!this._engine.globalState.enableAudioVolumeIndication) { let t = setInterval((() => { var e; if (r) { const t = r.getLocalAudioStats(); let i = { channelId: r.channelName, localUid: r.uid }; n && this._engine.rtcEngineEventHandler.onAudioVolumeIndicationEx(i, [{ uid: r.uid, volume: null == t ? void 0 : t.sendVolumeLevel, vad: (null == t ? void 0 : t.sendVolumeLevel) > 0 ? 1 : 0 }], 1, null == t ? void 0 : t.sendVolumeLevel); const o = r.getRemoteAudioStats(); let s = []; for (let e in o) s.push({ uid: e, volume: o[e].receiveLevel, vad: 1 }); let a = null !== (e = s.length > 0) && void 0 !== e ? e : s.reduce(((e, t) => t.receiveLevel > e.receiveLevel ? t : e)); this._engine.rtcEngineEventHandler.onAudioVolumeIndicationEx(i, s, s.length, a) } }), e); this._engine.addIrisInterval(u.IrisIntervalType.enableAudioVolumeIndication, t, 0) } return this._engine.globalState.enableAudioVolumeIndication = !0, this._engine.returnResult() })))) } startAudioRecording(e, t) { return l.AgoraConsole.warn("startAudioRecording not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioRecording2(e, t, n) { return l.AgoraConsole.warn("startAudioRecording2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioRecording3(e) { return l.AgoraConsole.warn("startAudioRecording3 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerAudioEncodedFrameObserver(e, t) { return l.AgoraConsole.warn("registerAudioEncodedFrameObserver not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopAudioRecording() { return l.AgoraConsole.warn("stopAudioRecording not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createMediaPlayer() { return l.AgoraConsole.warn("createMediaPlayer not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } destroyMediaPlayer(e) { return l.AgoraConsole.warn("destroyMediaPlayer not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createMediaRecorder(e) { return l.AgoraConsole.warn("createMediaRecorder not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } destroyMediaRecorder(e) { return l.AgoraConsole.warn("destroyMediaRecorder not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioMixing(e, t, n) { return l.AgoraConsole.warn("startAudioMixing not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioMixing2(e, t, n, i) { return l.AgoraConsole.warn("startAudioMixing2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopAudioMixing() { return l.AgoraConsole.warn("stopAudioMixing not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseAudioMixing() { return l.AgoraConsole.warn("pauseAudioMixing not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeAudioMixing() { return l.AgoraConsole.warn("resumeAudioMixing not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } selectAudioTrack(e) { return l.AgoraConsole.warn("selectAudioTrack not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioTrackCount() { return l.AgoraConsole.warn("getAudioTrackCount not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustAudioMixingVolume(e) { return l.AgoraConsole.warn("adjustAudioMixingVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustAudioMixingPublishVolume(e) { return l.AgoraConsole.warn("adjustAudioMixingPublishVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioMixingPublishVolume() { return l.AgoraConsole.warn("getAudioMixingPublishVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustAudioMixingPlayoutVolume(e) { return l.AgoraConsole.warn("adjustAudioMixingPlayoutVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioMixingPlayoutVolume() { return l.AgoraConsole.warn("getAudioMixingPlayoutVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioMixingDuration() { return l.AgoraConsole.warn("getAudioMixingDuration not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioMixingCurrentPosition() { return l.AgoraConsole.warn("getAudioMixingCurrentPosition not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioMixingPosition(e) { return l.AgoraConsole.warn("setAudioMixingPosition not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioMixingDualMonoMode(e) { return l.AgoraConsole.warn("setAudioMixingDualMonoMode not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioMixingPitch(e) { return l.AgoraConsole.warn("setAudioMixingPitch not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getEffectsVolume() { return l.AgoraConsole.warn("getEffectsVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEffectsVolume(e) { return l.AgoraConsole.warn("setEffectsVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } preloadEffect(e, t, n) { return l.AgoraConsole.warn("preloadEffect not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } playEffect(e, t, n, i, r, o, a, c) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { if (!this._engine.globalState.enabledAudio || !this._engine.globalState.enabledLocalAudio) return l.AgoraConsole.error("please enableAudio first"), this._engine.returnResult(!1); let i = this._engine.irisClientManager.getIrisClient(), r = null, s = { source: null }; t.startsWith("https://") || t.startsWith("http://") ? s.source = t : s.source = `${location.origin}/${t}`; try { r = yield this._engine.implHelper.createBufferSourceAudioTrack(e, a, s), l.AgoraConsole.log("createBufferSourceAudioTrack success") } catch (E) { return E && l.AgoraConsole.error(E), this._engine.returnResult(!1) } if (r.track) { o && r.track.setVolume(o); try { let e = { loop: !1 }; "number" == typeof n && n >= 0 && (e.cycle = n, -1 === n && (e.loop = !0)), c && (e.startPlayTime = Math.floor(c / 1e3)), r.track.startProcessAudioBuffer(e), r.track.play() } catch (_) { l.AgoraConsole.error(_) } } return a && (yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.PUBLISH_TRACK, [r], [i])), this._engine.returnResult() })))) } playAllEffects(e, t, n, i, r) { return l.AgoraConsole.warn("playAllEffects not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getVolumeOfEffect(e) { return l.AgoraConsole.warn("getVolumeOfEffect not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVolumeOfEffect(e, t) { return l.AgoraConsole.warn("setVolumeOfEffect not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseEffect(e) { return l.AgoraConsole.warn("pauseEffect not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseAllEffects() { return l.AgoraConsole.warn("pauseAllEffects not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeEffect(e) { return l.AgoraConsole.warn("resumeEffect not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeAllEffects() { return l.AgoraConsole.warn("resumeAllEffects not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopEffect(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { let t = this._engine.irisClientManager.getLocalAudioTrackPackageBySourceType(c.IrisAudioSourceType.kAudioSourceTypeBufferSourceAudio)[0]; return (null == t ? void 0 : t.track) ? (yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.UNPUBLISH_TRACK, [t]), this._engine.returnResult()) : (l.AgoraConsole.error(`soundId:${e} not found`), this._engine.rtcEngineEventHandler.onError(a.ERROR_CODE_TYPE.ERR_FAILED, `soundId:${e} not found`), this._engine.returnResult()) })))) } stopAllEffects() { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return this._engine.irisClientManager.getLocalAudioTrackPackageBySourceType(c.IrisAudioSourceType.kAudioSourceTypeBufferSourceAudio).map((e => { e.track && e.soundId && this.stopEffect(e.soundId) })), this._engine.returnResult() })))) } unloadEffect(e) { return l.AgoraConsole.warn("unloadEffect not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unloadAllEffects() { return l.AgoraConsole.warn("unloadAllEffects not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getEffectDuration(e) { return l.AgoraConsole.warn("getEffectDuration not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEffectPosition(e, t) { return l.AgoraConsole.warn("setEffectPosition not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getEffectCurrentPosition(e) { return l.AgoraConsole.warn("getEffectCurrentPosition not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableSoundPositionIndication(e) { return l.AgoraConsole.warn("enableSoundPositionIndication not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteVoicePosition(e, t, n) { return l.AgoraConsole.warn("setRemoteVoicePosition not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableSpatialAudio(e) { return l.AgoraConsole.warn("enableSpatialAudio not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteUserSpatialAudioParams(e, t) { return l.AgoraConsole.warn("setRemoteUserSpatialAudioParams not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVoiceBeautifierPreset(e) { return l.AgoraConsole.warn("setVoiceBeautifierPreset not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioEffectPreset(e) { return l.AgoraConsole.warn("setAudioEffectPreset not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVoiceConversionPreset(e) { return l.AgoraConsole.warn("setVoiceConversionPreset not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioEffectParameters(e, t, n) { return l.AgoraConsole.warn("setAudioEffectParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVoiceBeautifierParameters(e, t, n) { return l.AgoraConsole.warn("setVoiceBeautifierParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setVoiceConversionParameters(e, t, n) { return l.AgoraConsole.warn("setVoiceConversionParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalVoicePitch(e) { return l.AgoraConsole.warn("setLocalVoicePitch not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalVoiceFormant(e) { return l.AgoraConsole.warn("setLocalVoiceFormant not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalVoiceEqualization(e, t) { return l.AgoraConsole.warn("setLocalVoiceEqualization not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalVoiceReverb(e, t) { return l.AgoraConsole.warn("setLocalVoiceReverb not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setHeadphoneEQPreset(e) { return l.AgoraConsole.warn("setHeadphoneEQPreset not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setHeadphoneEQParameters(e, t) { return l.AgoraConsole.warn("setHeadphoneEQParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLogFile(e) { return l.AgoraConsole.warn("setLogFile not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLogFilter(e) { return this._engine.execute((() => (l.AgoraConsole.warn("setLogFilter not supported in this platform!"), this._engine.returnResult()))) } setLogLevel(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { l.AgoraConsole.logLevel = e; let t = R.AgoraTranslate.NATIVE_RTCLOG_LEVEL2Number(e); return this._engine.globalState.AgoraRTC.setLogLevel(t), this._engine.returnResult() })))) } setLogFileSize(e) { return l.AgoraConsole.warn("setLogFileSize not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } uploadLogFile(e) { return l.AgoraConsole.warn("uploadLogFile not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalRenderMode(e, t) { return l.AgoraConsole.warn("setLocalRenderMode not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteRenderMode(e, t, n) { return l.AgoraConsole.warn("setRemoteRenderMode not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalRenderMode2(e) { return l.AgoraConsole.warn("setLocalRenderMode2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalVideoMirrorMode(e) { return l.AgoraConsole.warn("setLocalVideoMirrorMode not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableDualStreamMode(e) { return l.AgoraConsole.warn("enableDualStreamMode not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableDualStreamMode2(e, t) { return l.AgoraConsole.warn("enableDualStreamMode2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDualStreamMode(e) { return l.AgoraConsole.warn("setDualStreamMode not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDualStreamMode2(e, t) { return l.AgoraConsole.warn("setDualStreamMode2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableCustomAudioLocalPlayback(e, t) { return l.AgoraConsole.warn("enableCustomAudioLocalPlayback not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRecordingAudioFrameParameters(e, t, n, i) { return l.AgoraConsole.warn("setRecordingAudioFrameParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackAudioFrameParameters(e, t, n, i) { return l.AgoraConsole.warn("setPlaybackAudioFrameParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setMixedAudioFrameParameters(e, t, n) { return l.AgoraConsole.warn("setMixedAudioFrameParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEarMonitoringAudioFrameParameters(e, t, n, i) { return l.AgoraConsole.warn("setEarMonitoringAudioFrameParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackAudioFrameBeforeMixingParameters(e, t) { return l.AgoraConsole.warn("setPlaybackAudioFrameBeforeMixingParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableAudioSpectrumMonitor(e) { return l.AgoraConsole.warn("enableAudioSpectrumMonitor not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } disableAudioSpectrumMonitor() { return l.AgoraConsole.warn("disableAudioSpectrumMonitor not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerAudioSpectrumObserver(e) { return l.AgoraConsole.warn("registerAudioSpectrumObserver not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterAudioSpectrumObserver(e) { return l.AgoraConsole.warn("unregisterAudioSpectrumObserver not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustRecordingSignalVolume(e) { return l.AgoraConsole.warn("adjustRecordingSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRecordingSignal(e) { return l.AgoraConsole.warn("muteRecordingSignal not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustPlaybackSignalVolume(e) { return l.AgoraConsole.warn("adjustPlaybackSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustUserPlaybackSignalVolume(e, t) { return l.AgoraConsole.warn("adjustUserPlaybackSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalPublishFallbackOption(e) { return l.AgoraConsole.warn("setLocalPublishFallbackOption not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteSubscribeFallbackOption(e) { return l.AgoraConsole.warn("setRemoteSubscribeFallbackOption not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setHighPriorityUserList(e, t, n) { return l.AgoraConsole.warn("setHighPriorityUserList not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableLoopbackRecording(e, t) { return l.AgoraConsole.warn("enableLoopbackRecording not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustLoopbackSignalVolume(e) { return l.AgoraConsole.warn("adjustLoopbackSignalVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getLoopbackRecordingVolume() { return l.AgoraConsole.warn("getLoopbackRecordingVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableInEarMonitoring(e, t) { return l.AgoraConsole.warn("enableInEarMonitoring not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setInEarMonitoringVolume(e) { return l.AgoraConsole.warn("setInEarMonitoringVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } loadExtensionProvider(e, t) { return l.AgoraConsole.warn("loadExtensionProvider not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExtensionProviderProperty(e, t, n) { return l.AgoraConsole.warn("setExtensionProviderProperty not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerExtension(e, t, n) { return l.AgoraConsole.warn("registerExtension not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableExtension(e, t, n, i) { return l.AgoraConsole.warn("enableExtension not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableExtension2(e, t, n, i) { return l.AgoraConsole.warn("enableExtension2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExtensionProperty(e, t, n, i, r) { return l.AgoraConsole.warn("setExtensionProperty not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getExtensionProperty(e, t, n, i, r, o) { return l.AgoraConsole.warn("getExtensionProperty not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setExtensionProperty2(e, t, n, i, r) { return l.AgoraConsole.warn("setExtensionProperty2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getExtensionProperty2(e, t, n, i, r, o) { return l.AgoraConsole.warn("getExtensionProperty2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraCapturerConfiguration(e) { return l.AgoraConsole.warn("setCameraCapturerConfiguration not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createCustomVideoTrack() { return l.AgoraConsole.warn("createCustomVideoTrack not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createCustomEncodedVideoTrack(e) { return l.AgoraConsole.warn("createCustomEncodedVideoTrack not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } destroyCustomVideoTrack(e) { return l.AgoraConsole.warn("destroyCustomVideoTrack not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } destroyCustomEncodedVideoTrack(e) { return l.AgoraConsole.warn("destroyCustomEncodedVideoTrack not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } switchCamera() { return l.AgoraConsole.warn("switchCamera not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraZoomSupported() { return l.AgoraConsole.warn("isCameraZoomSupported not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraFaceDetectSupported() { return l.AgoraConsole.warn("isCameraFaceDetectSupported not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraTorchSupported() { return l.AgoraConsole.warn("isCameraTorchSupported not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraFocusSupported() { return l.AgoraConsole.warn("isCameraFocusSupported not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraAutoFocusFaceModeSupported() { return l.AgoraConsole.warn("isCameraAutoFocusFaceModeSupported not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraZoomFactor(e) { return l.AgoraConsole.warn("setCameraZoomFactor not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableFaceDetection(e) { return l.AgoraConsole.warn("enableFaceDetection not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCameraMaxZoomFactor() { return l.AgoraConsole.warn("getCameraMaxZoomFactor not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraFocusPositionInPreview(e, t) { return l.AgoraConsole.warn("setCameraFocusPositionInPreview not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraTorchOn(e) { return l.AgoraConsole.warn("setCameraTorchOn not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraAutoFocusFaceModeEnabled(e) { return l.AgoraConsole.warn("setCameraAutoFocusFaceModeEnabled not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraExposurePositionSupported() { return l.AgoraConsole.warn("isCameraExposurePositionSupported not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraExposurePosition(e, t) { return l.AgoraConsole.warn("setCameraExposurePosition not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraExposureSupported() { return l.AgoraConsole.warn("isCameraExposureSupported not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraExposureFactor(e) { return l.AgoraConsole.warn("setCameraExposureFactor not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isCameraAutoExposureFaceModeSupported() { return l.AgoraConsole.warn("isCameraAutoExposureFaceModeSupported not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraAutoExposureFaceModeEnabled(e) { return l.AgoraConsole.warn("setCameraAutoExposureFaceModeEnabled not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDefaultAudioRouteToSpeakerphone(e) { return l.AgoraConsole.warn("setDefaultAudioRouteToSpeakerphone not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEnableSpeakerphone(e) { return l.AgoraConsole.warn("setEnableSpeakerphone not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } isSpeakerphoneEnabled() { return l.AgoraConsole.warn("isSpeakerphoneEnabled not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRouteInCommunicationMode(e) { return l.AgoraConsole.warn("setRouteInCommunicationMode not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getScreenCaptureSources(e, t, n) { return l.AgoraConsole.warn("getScreenCaptureSources not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioSessionOperationRestriction(e) { return l.AgoraConsole.warn("setAudioSessionOperationRestriction not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startScreenCaptureByDisplayId(e, t, n) { return l.AgoraConsole.warn("startScreenCaptureByDisplayId not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startScreenCaptureByScreenRect(e, t, n) { return l.AgoraConsole.warn("startScreenCaptureByScreenRect not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getAudioDeviceInfo(e) { return l.AgoraConsole.warn("getAudioDeviceInfo not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startScreenCaptureByWindowId(e, t, n) { return l.AgoraConsole.warn("startScreenCaptureByWindowId not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setScreenCaptureContentHint(e) { return l.AgoraConsole.warn("setScreenCaptureContentHint not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateScreenCaptureRegion(e) { return l.AgoraConsole.warn("updateScreenCaptureRegion not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateScreenCaptureParameters(e) { return l.AgoraConsole.warn("updateScreenCaptureParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startScreenCapture(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { if (this._engine.irisClientManager.getScreenCaptureStatus()) return l.AgoraConsole.error("you have already startScreenCapture"), this._engine.returnResult(!1); if (!e.captureVideo) return l.AgoraConsole.log("captureVideo is false, do nothing"), this._engine.returnResult(); let t = a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_PRIMARY; try { yield this._engine.implHelper.createScreenTrack(e, t), l.AgoraConsole.log("ScreenShare track create success") } catch (n) { return n && l.AgoraConsole.error(n), this._engine.returnResult(!1) } return this._engine.returnResult() })))) } updateScreenCapture(e) { return l.AgoraConsole.warn("updateScreenCapture not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } queryScreenCaptureCapability() { return l.AgoraConsole.warn("queryScreenCaptureCapability not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setScreenCaptureScenario(e) { return l.AgoraConsole.warn("setScreenCaptureScenario not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopScreenCapture() { return this.stopScreenCapture2(a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_SCREEN_PRIMARY) } stopScreenCapture2(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { let t = this._engine.irisClientManager; if (!this._engine.irisClientManager.getScreenCaptureStatus()) return l.AgoraConsole.warn("screenCapture is not start"), this._engine.returnResult(); let n = t.getLocalVideoTrackPackageBySourceType(e), i = t.getLocalAudioTrackPackageBySourceType(c.IrisAudioSourceType.kAudioSourceTypeScreenCapture); return 0 == n.length ? (l.AgoraConsole.error(`sourceType:${e} is not start`), this._engine.returnResult(!1)) : (yield this._engine.irisClientManager.irisClientObserver.notifyLocal(d.NotifyType.UNPUBLISH_TRACK, [...n, ...i]), this._engine.returnResult()) })))) } getCallId(e) { return l.AgoraConsole.warn("getCallId not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } rate(e, t, n) { return l.AgoraConsole.warn("rate not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } complain(e, t) { return l.AgoraConsole.warn("complain not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRtmpStreamWithoutTranscoding(e) { return l.AgoraConsole.warn("startRtmpStreamWithoutTranscoding not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRtmpStreamWithTranscoding(e, t) { return l.AgoraConsole.warn("startRtmpStreamWithTranscoding not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateRtmpTranscoding(e) { return l.AgoraConsole.warn("updateRtmpTranscoding not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopRtmpStream(e) { return l.AgoraConsole.warn("stopRtmpStream not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startLocalVideoTranscoder(e) { return l.AgoraConsole.warn("startLocalVideoTranscoder not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateLocalTranscoderConfiguration(e) { return l.AgoraConsole.warn("updateLocalTranscoderConfiguration not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopLocalVideoTranscoder() { return l.AgoraConsole.warn("stopLocalVideoTranscoder not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startCameraCapture(e, t) { return l.AgoraConsole.warn("startCameraCapture not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopCameraCapture(e) { return l.AgoraConsole.warn("stopCameraCapture not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCameraDeviceOrientation(e, t) { return l.AgoraConsole.warn("setCameraDeviceOrientation not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setScreenCaptureOrientation(e, t) { return l.AgoraConsole.warn("setScreenCaptureOrientation not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startScreenCapture2(e, t) { return l.AgoraConsole.warn("startScreenCapture2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getConnectionState() { return l.AgoraConsole.warn("getConnectionState not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerEventHandler(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return this._engine.irisEventHandlerManager.addEventHandler(t.RTCENGINE_KEY, e), this._engine.returnResult() })))) } unregisterEventHandler(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { return this._engine.irisEventHandlerManager.removeEventHandler(t.RTCENGINE_KEY, e), this._engine.returnResult() })))) } setRemoteUserPriority(e, t) { return l.AgoraConsole.warn("setRemoteUserPriority not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEncryptionMode(e) { return l.AgoraConsole.warn("setEncryptionMode not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setEncryptionSecret(e) { return l.AgoraConsole.warn("setEncryptionSecret not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableEncryption(e, t) { return l.AgoraConsole.warn("enableEncryption not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createDataStream(e, t, n) { return l.AgoraConsole.warn("createDataStream not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } createDataStream2(e, t) { return l.AgoraConsole.warn("createDataStream2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } sendStreamMessage(e, t, n) { return l.AgoraConsole.warn("sendStreamMessage not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } addVideoWatermark(e) { return l.AgoraConsole.warn("addVideoWatermark not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } addVideoWatermark2(e, t) { return l.AgoraConsole.warn("addVideoWatermark2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } clearVideoWatermarks() { return l.AgoraConsole.warn("clearVideoWatermarks not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseAudio() { return l.AgoraConsole.warn("pauseAudio not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeAudio() { return l.AgoraConsole.warn("resumeAudio not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableWebSdkInteroperability(e) { return l.AgoraConsole.warn("enableWebSdkInteroperability not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } sendCustomReportMessage(e, t, n, i, r) { return l.AgoraConsole.warn("sendCustomReportMessage not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerMediaMetadataObserver(e, t) { return l.AgoraConsole.warn("registerMediaMetadataObserver not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } unregisterMediaMetadataObserver(e, t) { return l.AgoraConsole.warn("unregisterMediaMetadataObserver not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioFrameDump(e, t, n, i, r, o, s) { return l.AgoraConsole.warn("startAudioFrameDump not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopAudioFrameDump(e, t, n) { return l.AgoraConsole.warn("stopAudioFrameDump not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAINSMode(e, t) { return l.AgoraConsole.warn("setAINSMode not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } registerLocalUserAccount(e, t) { return l.AgoraConsole.warn("registerLocalUserAccount not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } joinChannelWithUserAccount(e, t, n) { return l.AgoraConsole.warn("joinChannelWithUserAccount not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } joinChannelWithUserAccount2(e, t, n, i) { return l.AgoraConsole.warn("joinChannelWithUserAccount2 not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } joinChannelWithUserAccountEx(e, t, n, i) { return l.AgoraConsole.warn("joinChannelWithUserAccountEx not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getUserInfoByUserAccount(e, t) { return l.AgoraConsole.warn("getUserInfoByUserAccount not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getUserInfoByUid(e, t) { return l.AgoraConsole.warn("getUserInfoByUid not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startOrUpdateChannelMediaRelay(e) { return l.AgoraConsole.warn("startOrUpdateChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startChannelMediaRelay(e) { return l.AgoraConsole.warn("startChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateChannelMediaRelay(e) { return l.AgoraConsole.warn("updateChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopChannelMediaRelay() { return l.AgoraConsole.warn("stopChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } pauseAllChannelMediaRelay() { return l.AgoraConsole.warn("pauseAllChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } resumeAllChannelMediaRelay() { return l.AgoraConsole.warn("resumeAllChannelMediaRelay not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDirectCdnStreamingAudioConfiguration(e) { return l.AgoraConsole.warn("setDirectCdnStreamingAudioConfiguration not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDirectCdnStreamingVideoConfiguration(e) { return l.AgoraConsole.warn("setDirectCdnStreamingVideoConfiguration not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startDirectCdnStreaming(e, t, n) { return l.AgoraConsole.warn("startDirectCdnStreaming not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopDirectCdnStreaming() { return l.AgoraConsole.warn("stopDirectCdnStreaming not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateDirectCdnStreamingMediaOptions(e) { return l.AgoraConsole.warn("updateDirectCdnStreamingMediaOptions not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRhythmPlayer(e, t, n) { return l.AgoraConsole.warn("startRhythmPlayer not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopRhythmPlayer() { return l.AgoraConsole.warn("stopRhythmPlayer not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } configRhythmPlayer(e) { return l.AgoraConsole.warn("configRhythmPlayer not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } takeSnapshot(e, t) { return l.AgoraConsole.warn("takeSnapshot not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableContentInspect(e, t) { return l.AgoraConsole.warn("enableContentInspect not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustCustomAudioPublishVolume(e, t) { return l.AgoraConsole.warn("adjustCustomAudioPublishVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } adjustCustomAudioPlayoutVolume(e, t) { return l.AgoraConsole.warn("adjustCustomAudioPlayoutVolume not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setCloudProxy(e) { return l.AgoraConsole.warn("setCloudProxy not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLocalAccessPoint(e) { return l.AgoraConsole.warn("setLocalAccessPoint not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAdvancedAudioOptions(e, t) { return l.AgoraConsole.warn("setAdvancedAudioOptions not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAVSyncSource(e, t) { return l.AgoraConsole.warn("setAVSyncSource not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableVideoImageSource(e, t) { return l.AgoraConsole.warn("enableVideoImageSource not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCurrentMonotonicTimeInMs() { return l.AgoraConsole.warn("getCurrentMonotonicTimeInMs not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableWirelessAccelerate(e) { return l.AgoraConsole.warn("enableWirelessAccelerate not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getNetworkType() { return l.AgoraConsole.warn("getNetworkType not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setParameters(e) { return l.AgoraConsole.warn("setParameters not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startMediaRenderingTracing() { return l.AgoraConsole.warn("startMediaRenderingTracing not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enableInstantMediaRendering() { return l.AgoraConsole.warn("enableInstantMediaRendering not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getNtpWallTimeInMs() { return l.AgoraConsole.warn("getNtpWallTimeInMs not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.IVideoDeviceManagerImpl = class { constructor(e) { this._engine = e } enumerateVideoDevices() { let e = []; return this._engine.execute((() => s(this, void 0, void 0, (function* () { var t; try { e = null === (t = yield this._engine.implHelper.enumerateDevices()) || void 0 === t ? void 0 : t.videoDevices } catch (n) { return l.AgoraConsole.log(n), this._engine.returnResult(!1) } return this._engine.returnResult(!0, 0, JSON.stringify({ result: e })) })))) } setDevice(e) { return this._engine.execute((() => s(this, void 0, void 0, (function* () { this._engine.globalState.videoDeviceId = e; for (let t of this._engine.irisClientManager.localVideoTrackPackages) t.track && (t.type != a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_PRIMARY && t.type != a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_SECONDARY && t.type != a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_THIRD && t.type != a.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA_FOURTH || (yield this._engine.trackHelper.setDevice(t.track, e))); return this._engine.returnResult() })))) } getDevice() { return this._engine.execute((() => s(this, void 0, void 0, (function* () { let e = [], t = ""; if (this._engine.globalState.videoDeviceId) t = this._engine.globalState.videoDeviceId; else { try { e = yield this._engine.globalState.AgoraRTC.getCameras() } catch (n) { return this._engine.returnResult(!1) } e && e.length > 0 && (t = e[0].deviceId) } return this._engine.returnResult(!0, 0, JSON.stringify({ result: a.ERROR_CODE_TYPE.ERR_OK, deviceIdUTF8: t })) })))) } numberOfCapabilities(e) { return l.AgoraConsole.warn("numberOfCapabilities not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getCapability(e, t, n) { return l.AgoraConsole.warn("getCapability not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startDeviceTest(e) { return l.AgoraConsole.warn("startDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopDeviceTest() { return l.AgoraConsole.warn("stopDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -a.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } release() { return this._engine.execute((() => s(this, void 0, void 0, (function* () { let e = this._engine; return e.globalState.playbackDevices = new Array, e.globalState.recordingDevices = new Array, e.globalState.videoDevices = new Array, this._engine.returnResult() })))) } } }, 2030: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IBaseSpatialAudioEngineImpl = t.ILocalSpatialAudioEngineImpl = void 0; const s = o(n(5844)), a = n(4482); t.ILocalSpatialAudioEngineImpl = class { constructor(e) { this._engine = e } initialize() { return a.AgoraConsole.warn("initialize not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteAudioAttenuation(e, t, n) { return a.AgoraConsole.warn("setRemoteAudioAttenuation not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setMaxAudioRecvCount(e) { return a.AgoraConsole.warn("setMaxAudioRecvCount not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioRecvRange(e) { return a.AgoraConsole.warn("setAudioRecvRange not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDistanceUnit(e) { return a.AgoraConsole.warn("setDistanceUnit not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateSelfPosition(e, t, n, i) { return a.AgoraConsole.warn("updateSelfPosition not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateSelfPositionEx(e, t, n, i, r) { return a.AgoraConsole.warn("updateSelfPositionEx not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updatePlayerPositionInfo(e, t) { return a.AgoraConsole.warn("updatePlayerPositionInfo not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setParameters(e) { return a.AgoraConsole.warn("setParameters not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteLocalAudioStream(e) { return a.AgoraConsole.warn("muteLocalAudioStream not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteAudioStreams(e) { return a.AgoraConsole.warn("muteAllRemoteAudioStreams not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateRemotePosition(e, t) { return a.AgoraConsole.warn("updateRemotePosition not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateRemotePositionEx(e, t, n) { return a.AgoraConsole.warn("updateRemotePositionEx not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeRemotePosition(e) { return a.AgoraConsole.warn("removeRemotePosition not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeRemotePositionEx(e, t) { return a.AgoraConsole.warn("removeRemotePositionEx not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } clearRemotePositions() { return a.AgoraConsole.warn("clearRemotePositions not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } clearRemotePositionsEx(e) { return a.AgoraConsole.warn("clearRemotePositionsEx not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } }; t.IBaseSpatialAudioEngineImpl = class { constructor(e) { this._engine = e } release() { return a.AgoraConsole.warn("release not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setZones(e, t) { return a.AgoraConsole.warn("setZones not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlayerAttenuation(e, t, n) { return a.AgoraConsole.warn("setPlayerAttenuation not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteRemoteAudioStream(e, t) { return a.AgoraConsole.warn("muteRemoteAudioStream not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } initialize() { return a.AgoraConsole.warn("initialize not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRemoteAudioAttenuation(e, t, n) { return a.AgoraConsole.warn("setRemoteAudioAttenuation not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setMaxAudioRecvCount(e) { return a.AgoraConsole.warn("setMaxAudioRecvCount not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setAudioRecvRange(e) { return a.AgoraConsole.warn("setAudioRecvRange not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setDistanceUnit(e) { return a.AgoraConsole.warn("setDistanceUnit not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateSelfPosition(e, t, n, i) { return a.AgoraConsole.warn("updateSelfPosition not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateSelfPositionEx(e, t, n, i, r) { return a.AgoraConsole.warn("updateSelfPositionEx not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updatePlayerPositionInfo(e, t) { return a.AgoraConsole.warn("updatePlayerPositionInfo not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setParameters(e) { return a.AgoraConsole.warn("setParameters not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteLocalAudioStream(e) { return a.AgoraConsole.warn("muteLocalAudioStream not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } muteAllRemoteAudioStreams(e) { return a.AgoraConsole.warn("muteAllRemoteAudioStreams not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateRemotePosition(e, t) { return a.AgoraConsole.warn("updateRemotePosition not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } updateRemotePositionEx(e, t, n) { return a.AgoraConsole.warn("updateRemotePositionEx not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeRemotePosition(e) { return a.AgoraConsole.warn("removeRemotePosition not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } removeRemotePositionEx(e, t) { return a.AgoraConsole.warn("removeRemotePositionEx not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } clearRemotePositions() { return a.AgoraConsole.warn("clearRemotePositions not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } clearRemotePositionsEx(e) { return a.AgoraConsole.warn("clearRemotePositionsEx not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 5795: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IAudioDeviceManagerImpl = void 0; const s = o(n(5844)), a = n(2223); t.IAudioDeviceManagerImpl = class { constructor(e) { this._engine = e } enumeratePlaybackDevices() { return a.AgoraConsole.warn("enumeratePlaybackDevices not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } enumerateRecordingDevices() { return a.AgoraConsole.warn("enumerateRecordingDevices not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackDevice(e) { return a.AgoraConsole.warn("setPlaybackDevice not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlaybackDevice() { return a.AgoraConsole.warn("getPlaybackDevice not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlaybackDeviceInfo() { return a.AgoraConsole.warn("getPlaybackDeviceInfo not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackDeviceVolume(e) { return a.AgoraConsole.warn("setPlaybackDeviceVolume not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlaybackDeviceVolume() { return a.AgoraConsole.warn("getPlaybackDeviceVolume not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRecordingDevice(e) { return a.AgoraConsole.warn("setRecordingDevice not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getRecordingDevice(e) { return a.AgoraConsole.warn("getRecordingDevice not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getRecordingDeviceInfo() { return a.AgoraConsole.warn("getRecordingDeviceInfo not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRecordingDeviceVolume(e) { return a.AgoraConsole.warn("setRecordingDeviceVolume not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getRecordingDeviceVolume(e) { return a.AgoraConsole.warn("getRecordingDeviceVolume not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setLoopbackDevice(e) { return a.AgoraConsole.warn("setLoopbackDevice not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getLoopbackDevice(e) { return a.AgoraConsole.warn("getLoopbackDevice not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setPlaybackDeviceMute(e) { return a.AgoraConsole.warn("setPlaybackDeviceMute not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getPlaybackDeviceMute(e) { return a.AgoraConsole.warn("getPlaybackDeviceMute not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } setRecordingDeviceMute(e) { return a.AgoraConsole.warn("setRecordingDeviceMute not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } getRecordingDeviceMute(e) { return a.AgoraConsole.warn("getRecordingDeviceMute not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startPlaybackDeviceTest(e) { return a.AgoraConsole.warn("startPlaybackDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopPlaybackDeviceTest() { return a.AgoraConsole.warn("stopPlaybackDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startRecordingDeviceTest(e) { return a.AgoraConsole.warn("startRecordingDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopRecordingDeviceTest() { return a.AgoraConsole.warn("stopRecordingDeviceTest not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } startAudioDeviceLoopbackTest(e) { return a.AgoraConsole.warn("startAudioDeviceLoopbackTest not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } stopAudioDeviceLoopbackTest() { return a.AgoraConsole.warn("stopAudioDeviceLoopbackTest not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } followSystemPlaybackDevice(e) { return a.AgoraConsole.warn("followSystemPlaybackDevice not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } followSystemRecordingDevice(e) { return a.AgoraConsole.warn("followSystemRecordingDevice not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } followSystemLoopbackDevice(e) { return a.AgoraConsole.warn("followSystemLoopbackDevice not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } release() { return a.AgoraConsole.warn("release not supported in this platform!"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED) } } }, 5352: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__exportStar || function (e, t) { for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || i(t, e, n) }; Object.defineProperty(t, "__esModule", { value: !0 }), r(n(7481), t), r(n(2223), t), r(n(2100), t), r(n(7275), t) }, 8973: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisClientState = void 0; const s = o(n(5844)); t.IrisClientState = class { constructor(e) { var t; this._globalState = null, this.stopAudioMixing = !0, this.stopAllEffect = !0, this.stopMicrophoneRecording = !0, this.publishCameraTrack = !0, this.publishSecondaryCameraTrack = !1, this.publishMicrophoneTrack = !0, this.autoSubscribeAudio = !0, this.clientRoleType = s.CLIENT_ROLE_TYPE.CLIENT_ROLE_BROADCASTER, this.defaultVideoStreamType = s.VIDEO_STREAM_TYPE.VIDEO_STREAM_HIGH, this.channelProfile = s.CHANNEL_PROFILE_TYPE.CHANNEL_PROFILE_COMMUNICATION, this.clientRoleOptions = null, this.mutedRemoteAudioStreams = new Map, this.mutedRemoteVideoStreams = new Map, this.videoSourceType = s.VIDEO_SOURCE_TYPE.VIDEO_SOURCE_CAMERA, this.videoEncoderConfiguration = null, this.enabledDualStreamMode = !1, this.enabledDualStreamModes = new Map, this.remoteVideoStreamTypes = new Map, this.remoteDefaultVideoStreamType = null, this.encryptionConfig = { enabled: !1, config: new s.EncryptionConfig }, this.enabledAudioVolumeIndication = null, this.playbackDeviceId = null, this.recordingDeviceId = null, this.contentInspect = null, this.currChannelMediaRelayconfiguration = null, this._globalState = e, (null === (t = e.rtcEngineContext) || void 0 === t ? void 0 : t.channelProfile) && (this.channelProfile = e.rtcEngineContext.channelProfile), e.autoSubscribeVideo && (this.autoSubscribeVideo = e.autoSubscribeVideo) } mergeChannelMediaOptions(e) { for (let t in e) this[t] = e[t]; this.publishCustomVideoTrack && this._globalState.pushVideoFrameEnabled && (this.publishCameraTrack = !1, this.publishEncodedVideoTrack = !1, this.publishSecondaryCameraTrack = !1, this.publishThirdCameraTrack = !1, this.publishFourthCameraTrack = !1, this.publishScreenTrack = !1, this.publishSecondaryScreenTrack = !1, this.publishThirdScreenTrack = !1, this.publishFourthScreenTrack = !1, this.publishMediaPlayerVideoTrack = !1) } } }, 8219: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }, s = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.IrisGlobalState = void 0; const a = o(n(5844)), c = s(n(5957)); t.IrisGlobalState = class { constructor() { this.networkQualityInterval = 2e3, this.enabledAudio = !0, this.pausedAudio = !1, this.pushVideoFrameEnabled = !1, this.pushVideoFrameUseTexture = !1, this.pushVideoFrameSourceType = a.EXTERNAL_VIDEO_SOURCE_TYPE.ENCODED_VIDEO_FRAME, this.enabledLocalAudio = !0, this.mutedLocalAudioStream = !1, this.enabledLocalVideo = !0, this.mutedLocalVideoStream = !1, this.enabledVideo = !1, this.pausedVideo = !1, this.recordingSignalVolume = 100, this.mutedRecordingSignal = !1, this.defaultMutedAllRemoteAudioStreams = !1, this.defaultMutedAllRemoteVideoStreams = !1, this.mirrorMode = a.VIDEO_MIRROR_MODE_TYPE.VIDEO_MIRROR_MODE_ENABLED, this.videoEncoderConfiguration = null, this.fallbackOption = null, this.screenCaptureContentHint = null, this.screenCaptureParameters2 = null, this.cloudProxy = null, this.playbackDevices = new Array, this.recordingDevices = new Array, this.videoDevices = new Array, this.videoDeviceId = null, this.enableAudioVolumeIndication = !1, this.enableAudioVolumeIndicationConfig = { interval: 50, smooth: 3, reportVad: !1 }, this.autoSubscribeVideo = !1, this.AgoraRTC = c.default } reset() { this.enabledAudio = !0, this.pausedAudio = !1, this.enabledLocalAudio = !0, this.mutedLocalAudioStream = !1 } } }, 4482: function (e, t, n) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.AgoraConsole = void 0; const i = n(5844); class r { static getDate() { const e = new Date; return `${e.toLocaleTimeString()}:${("00" + e.getMilliseconds()).slice(-3)}` } static debug(e) { r.logLevel > i.LOG_LEVEL.LOG_LEVEL_NONE && console.log(`[${this.getDate()}][Iris debug]:${e}`) } static log(e) { r.logLevel > i.LOG_LEVEL.LOG_LEVEL_NONE && r.logLevel <= i.LOG_LEVEL.LOG_LEVEL_INFO && console.log(`[${this.getDate()}][Iris log]:${e}`) } static warn(e) { r.logLevel > i.LOG_LEVEL.LOG_LEVEL_NONE && r.logLevel <= i.LOG_LEVEL.LOG_LEVEL_WARN && console.log(`[${this.getDate()}][Iris warning]:${e}`) } static error(e) { r.logLevel > i.LOG_LEVEL.LOG_LEVEL_NONE && r.logLevel <= i.LOG_LEVEL.LOG_LEVEL_ERROR && console.error(`[${this.getDate()}][Iris error]:${e}`) } } t.AgoraConsole = r, r.logLevel = i.LOG_LEVEL.LOG_LEVEL_INFO }, 9261: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.AgoraTool = void 0; t.AgoraTool = class { static mergeArray(e, t) { for (let n = 0; n < t.length; n++)e.push(t[n]) } static spliceFileName(e) { let t = 0; t = e.lastIndexOf("/"), -1 == t && (t = e.lastIndexOf("\\")); let n = null; return n = -1 == t ? e : e.substring(t + 1), n } static downloadCanvasAsImage(e, t) { let n = e.toDataURL("image/jpeg", 1), i = document.createElement("a"); i.href = n, i.download = t, i.click() } } }, 1215: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.AgoraTranslate = void 0; const s = o(n(5844)), a = n(5957), c = n(4482); class E { static NATIVE_RTCLOG_LEVEL2Number(e) { switch (e) { case s.LOG_LEVEL.LOG_LEVEL_NONE: return 4; case s.LOG_LEVEL.LOG_LEVEL_INFO: return 1; case s.LOG_LEVEL.LOG_LEVEL_WARN: return 2; case s.LOG_LEVEL.LOG_LEVEL_ERROR: case s.LOG_LEVEL.LOG_LEVEL_FATAL: return 3; case s.LOG_LEVEL.LOG_LEVEL_API_CALL: return 0; default: return c.AgoraConsole.log("SDK logLevel is not specified, will output webSDK log."), 0 } } static NATIVE_RTCAREA_CODE2AREAS(e) { switch (e) { case s.AREA_CODE.AREA_CODE_CN: return a.AREAS.CHINA; case s.AREA_CODE.AREA_CODE_NA: return a.AREAS.NORTH_AMERICA; case s.AREA_CODE.AREA_CODE_EU: return a.AREAS.EUROPE; case s.AREA_CODE.AREA_CODE_AS: return a.AREAS.ASIA; case s.AREA_CODE.AREA_CODE_JP: return a.AREAS.JAPAN; case s.AREA_CODE.AREA_CODE_IN: return a.AREAS.INDIA; case s.AREA_CODE.AREA_CODE_GLOB: return a.AREAS.GLOBAL; case s.AREA_CODE_EX.AREA_CODE_SA: return a.AREAS.SOUTH_AMERICA; case s.AREA_CODE_EX.AREA_CODE_AF: return a.AREAS.AFRICA; case s.AREA_CODE_EX.AREA_CODE_KR: return a.AREAS.KOREA; case s.AREA_CODE_EX.AREA_CODE_OC: return a.AREAS.OCEANIA; case s.AREA_CODE_EX.AREA_CODE_HKMC: return a.AREAS.HKMC; case s.AREA_CODE_EX.AREA_CODE_US: return a.AREAS.US; case s.AREA_CODE_EX.AREA_CODE_OVS: return a.AREAS.OVERSEA; default: return c.AgoraConsole.warn("input Unknown areaCode"), a.AREAS.GLOBAL } } static NATIVE_RTC_CLIENT_ROLE_TYPE2ClientRole(e) { switch (e) { case s.CLIENT_ROLE_TYPE.CLIENT_ROLE_BROADCASTER: return "host"; case s.CLIENT_ROLE_TYPE.CLIENT_ROLE_AUDIENCE: return "audience" } } static NATIVE_RTC_CHANNEL_PROFILE_TYPE2SDK_MODE(e) { return e === s.CHANNEL_PROFILE_TYPE.CHANNEL_PROFILE_LIVE_BROADCASTING ? "live" : "rtc" } static NATIVE_RTCClientRoleOptions2ClientRoleOptions(e) { switch (e.audienceLatencyLevel) { case s.AUDIENCE_LATENCY_LEVEL_TYPE.AUDIENCE_LATENCY_LEVEL_LOW_LATENCY: return { level: a.AudienceLatencyLevelType.AUDIENCE_LEVEL_LOW_LATENCY }; case s.AUDIENCE_LATENCY_LEVEL_TYPE.AUDIENCE_LATENCY_LEVEL_ULTRA_LOW_LATENCY: return { level: a.AudienceLatencyLevelType.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY } } } static NATIVE_RTC_AUDIENCE_LATENCY_LEVEL_TYPE2ClientRoleOptions(e) { switch (e) { case s.AUDIENCE_LATENCY_LEVEL_TYPE.AUDIENCE_LATENCY_LEVEL_LOW_LATENCY: return { level: a.AudienceLatencyLevelType.AUDIENCE_LEVEL_LOW_LATENCY }; case s.AUDIENCE_LATENCY_LEVEL_TYPE.AUDIENCE_LATENCY_LEVEL_ULTRA_LOW_LATENCY: return { level: a.AudienceLatencyLevelType.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY } } } static NATIVE_RTCVideoEncoderConfiguration2VideoEncoderConfiguration(e) { return { width: e.dimensions.width, height: e.dimensions.height, frameRate: e.frameRate, bitrateMax: e.bitrate, bitrateMin: e.minBitrate } } static NATIVE_RTCVideoFormat2VideoEncoderConfiguration(e) { return { width: e.width, height: e.height, frameRate: e.fps } } static NATIVE_RTCScreenCaptureParameters2VideoEncoderConfiguration(e) { var t, n; return { frameRate: null === (t = e.videoParams) || void 0 === t ? void 0 : t.frameRate, bitrateMax: null === (n = e.videoParams) || void 0 === n ? void 0 : n.bitrate } } static NATIVE_RTCSimulcastStreamConfig2LowStreamParameter(e) { return { width: e.dimensions.width, height: e.dimensions.height, framerate: { ideal: e.framerate }, bitrate: e.framerate } } static NATIVE_RTCCONNECTION_STATE_TYPE2ConnectionState(e) { switch (e) { case s.CONNECTION_STATE_TYPE.CONNECTION_STATE_DISCONNECTED: return "DISCONNECTED"; case s.CONNECTION_STATE_TYPE.CONNECTION_STATE_CONNECTING: return "CONNECTING"; case s.CONNECTION_STATE_TYPE.CONNECTION_STATE_CONNECTED: return "CONNECTED"; case s.CONNECTION_STATE_TYPE.CONNECTION_STATE_RECONNECTING: return "RECONNECTING"; case s.CONNECTION_STATE_TYPE.CONNECTION_STATE_FAILED: return "DISCONNECTED" } } static NATIVE_RTCENCRYPTION_MODE2EncryptionMode(e) { switch (e) { case s.ENCRYPTION_MODE.AES_128_XTS: return "aes-128-xts"; case s.ENCRYPTION_MODE.AES_128_ECB: return "aes-128-ecb"; case s.ENCRYPTION_MODE.AES_256_XTS: return "aes-256-xts"; case s.ENCRYPTION_MODE.SM4_128_ECB: return "sm4-128-ecb"; case s.ENCRYPTION_MODE.AES_128_GCM: return "aes-128-gcm"; case s.ENCRYPTION_MODE.AES_256_GCM: return "aes-256-gcm"; case s.ENCRYPTION_MODE.AES_128_GCM2: return "aes-128-gcm2"; case s.ENCRYPTION_MODE.AES_256_GCM2: return "aes-256-gcm2" } } static NATIVE_RTCInjectStreamConfig2InjectStreamConfig(e) { return { audioBitrate: e.audioBitrate, audioChannels: e.audioChannels, audioSampleRate: e.audioSampleRate, height: e.width, width: e.height, videoBitrate: e.videoBitrate, videoFramerate: e.videoFramerate, videoGop: e.videoGop } } static NATIVE_RTCChannelMediaRelayConfiguration2IChannelMediaRelayConfiguration(e, t) { let n = t.globalState.AgoraRTC.createChannelMediaRelayConfiguration(); for (let i = 0; i < e.srcInfo.length; i++)n.addDestChannelInfo(E.NATIVE_RTCChannelMediaInfo2ChannelMediaRelayInfo(e.srcInfo[i])); for (let i = 0; i < e.destInfos.length; i++)n.addDestChannelInfo(E.NATIVE_RTCChannelMediaInfo2ChannelMediaRelayInfo(e.destInfos[i])); return n } static NATIVE_RTCChannelMediaInfo2ChannelMediaRelayInfo(e) { return { channelName: e.channelName, token: e.token, uid: e.uid } } static NATIVE_RTCContentInspectConfig2InspectConfiguration(e) { let t = { interval: 1, extraInfo: e.extraInfo, inspectType: [] }, n = e.modules; switch (t.interval = n.interval, n.type) { case s.CONTENT_INSPECT_TYPE.CONTENT_INSPECT_INVALID: break; case s.CONTENT_INSPECT_TYPE.CONTENT_INSPECT_MODERATION: t.inspectType.push("moderation"); break; case s.CONTENT_INSPECT_TYPE.CONTENT_INSPECT_SUPERVISION: t.inspectType.push("supervise") }return t.interval = 1e3 * n.interval, t } static NATIVE_RTCVIDEO_CONTENT_HINT2string(e) { switch (e) { case s.VIDEO_CONTENT_HINT.CONTENT_HINT_MOTION: return "motion"; case s.VIDEO_CONTENT_HINT.CONTENT_HINT_DETAILS: default: return "detail" } } static NATIVE_RTCCAMERA_DIRECTION2string(e) { switch (e) { case s.CAMERA_DIRECTION.CAMERA_FRONT: return "user"; case s.CAMERA_DIRECTION.CAMERA_REAR: return "environment" } } static NATIVE_RTCVIDEO_MIRROR_MODE_TYPE2boolean(e) { switch (e) { case s.VIDEO_MIRROR_MODE_TYPE.VIDEO_MIRROR_MODE_AUTO: return !0; case s.VIDEO_MIRROR_MODE_TYPE.VIDEO_MIRROR_MODE_DISABLED: return !1; case s.VIDEO_MIRROR_MODE_TYPE.VIDEO_MIRROR_MODE_ENABLED: return !0 } } static NATIVE_RTCVIDEO_CODEC_TYPE2SDK_CODEC(e) { switch (e) { case s.VIDEO_CODEC_TYPE.VIDEO_CODEC_H264: return "h264"; case s.VIDEO_CODEC_TYPE.VIDEO_CODEC_AV1: return "av1"; case s.VIDEO_CODEC_TYPE.VIDEO_CODEC_VP8: return "vp8"; case s.VIDEO_CODEC_TYPE.VIDEO_CODEC_VP9: return "vp9"; default: return "vp8" } } static NATIVE_RTCVIDEO_STREAM_TYPE2RemoteStreamType(e) { switch (e) { case s.VIDEO_STREAM_TYPE.VIDEO_STREAM_HIGH: return a.RemoteStreamType.HIGH_STREAM; case s.VIDEO_STREAM_TYPE.VIDEO_STREAM_LOW: return a.RemoteStreamType.LOW_STREAM } } static NATIVE_RTCSTREAM_FALLBACK_OPTIONS2RemoteStreamFallbackType(e) { switch (e) { case s.STREAM_FALLBACK_OPTIONS.STREAM_FALLBACK_OPTION_DISABLED: return a.RemoteStreamFallbackType.DISABLE; case s.STREAM_FALLBACK_OPTIONS.STREAM_FALLBACK_OPTION_VIDEO_STREAM_LOW: return a.RemoteStreamFallbackType.LOW_STREAM; case s.STREAM_FALLBACK_OPTIONS.STREAM_FALLBACK_OPTION_AUDIO_ONLY: return a.RemoteStreamFallbackType.AUDIO_ONLY } } static NATIVE_RTCRtcImage2LiveStreamingTranscodingImage(e) { return { url: e.url, x: e.x, y: e.y, width: e.width, height: e.height, alpha: e.alpha } } static NATIVE_RTCTranscodingUser2LiveStreamingTranscodingUser(e) { return { alpha: e.alpha, height: e.height, uid: e.uid, width: e.width, x: e.x, y: e.y, zOrder: e.zOrder, audioChannel: e.audioChannel } } static NATIVE_RTCLiveTranscoding2LiveStreamingTranscodingConfig(e) { let t = { audioBitrate: e.audioBitrate, audioChannels: e.audioChannels, audioSampleRate: e.audioSampleRate, backgroundColor: e.backgroundColor, height: e.height, width: e.width, lowLatency: e.lowLatency, videoBitrate: e.videoBitrate, videoCodecProfile: e.videoCodecProfile, videoFrameRate: e.videoFramerate, videoGop: e.videoGop, userConfigExtraInfo: e.transcodingExtraInfo }; if (e.watermarkCount >= 1 && (t.watermark = E.NATIVE_RTCRtcImage2LiveStreamingTranscodingImage(e.watermark[0])), e.backgroundImageCount >= 1 && (t.backgroundImage = E.NATIVE_RTCRtcImage2LiveStreamingTranscodingImage(e.backgroundImage[0])), t.transcodingUsers = [], e.userCount > 0) for (let n = 0; n < e.userCount; n++)t.transcodingUsers.push(E.NATIVE_RTCTranscodingUser2LiveStreamingTranscodingUser(e.transcodingUsers[n])); return t } static DeviceState2NATIVE_RTCMEDIA_DEVICE_STATE_TYPE(e) { switch (e) { case "ACTIVE": return s.MEDIA_DEVICE_STATE_TYPE.MEDIA_DEVICE_STATE_ACTIVE; case "INACTIVE": return s.MEDIA_DEVICE_STATE_TYPE.MEDIA_DEVICE_STATE_DISABLED } } static ConnectionState2NATIVE_RTCCONNECTION_STATE_TYPE(e) { switch (e) { case "DISCONNECTED": case "DISCONNECTING": return s.CONNECTION_STATE_TYPE.CONNECTION_STATE_DISCONNECTED; case "CONNECTING": return s.CONNECTION_STATE_TYPE.CONNECTION_STATE_CONNECTING; case "CONNECTED": return s.CONNECTION_STATE_TYPE.CONNECTION_STATE_CONNECTED; case "RECONNECTING": return s.CONNECTION_STATE_TYPE.CONNECTION_STATE_RECONNECTING } } static string2NATIVE_RTCENCRYPTION_MODE(e) { switch (e) { case "aes-128-xts": return s.ENCRYPTION_MODE.AES_128_XTS; case "aes-128-ecb": return s.ENCRYPTION_MODE.AES_128_ECB; case "aes-256-xts": return s.ENCRYPTION_MODE.AES_256_XTS; case "sm4-128-ecb": return s.ENCRYPTION_MODE.SM4_128_ECB; case "aes-128-gcm": return s.ENCRYPTION_MODE.AES_128_GCM; case "aes-256-gcm": return s.ENCRYPTION_MODE.AES_256_GCM; case "aes-128-gcm2": return s.ENCRYPTION_MODE.AES_128_GCM2; case "aes-256-gcm2": return s.ENCRYPTION_MODE.AES_256_GCM2; default: return c.AgoraConsole.warn("invalid mode: " + e), s.ENCRYPTION_MODE.AES_128_GCM } } static ConnectionDisconnectedReason2NATIVE_RTCCONNECTION_CHANGED_REASON_TYPE(e) { switch (e) { case a.ConnectionDisconnectedReason.LEAVE: return s.CONNECTION_CHANGED_REASON_TYPE.CONNECTION_CHANGED_LEAVE_CHANNEL; case a.ConnectionDisconnectedReason.NETWORK_ERROR: case a.ConnectionDisconnectedReason.SERVER_ERROR: return s.CONNECTION_CHANGED_REASON_TYPE.CONNECTION_CHANGED_INTERRUPTED; case a.ConnectionDisconnectedReason.UID_BANNED: case a.ConnectionDisconnectedReason.IP_BANNED: return s.CONNECTION_CHANGED_REASON_TYPE.CONNECTION_CHANGED_BANNED_BY_SERVER; case a.ConnectionDisconnectedReason.CHANNEL_BANNED: return s.CONNECTION_CHANGED_REASON_TYPE.CONNECTION_CHANGED_INVALID_CHANNEL_NAME; case a.ConnectionDisconnectedReason.FALLBACK: return s.CONNECTION_CHANGED_REASON_TYPE.CONNECTION_CHANGED_INTERRUPTED } } static string2NATIVE_RTCUSER_OFFLINE_REASON_TYPE(e) { switch (e) { case "Quit": default: return s.USER_OFFLINE_REASON_TYPE.USER_OFFLINE_QUIT; case "ServerTimeOut": return s.USER_OFFLINE_REASON_TYPE.USER_OFFLINE_DROPPED; case "BecomeAudience": return s.USER_OFFLINE_REASON_TYPE.USER_OFFLINE_BECOME_AUDIENCE } } static ChannelMediaRelayState2NATIVE_RTCCHANNEL_MEDIA_RELAY_STATE(e) { switch (e) { case a.ChannelMediaRelayState.RELAY_STATE_IDLE: return s.CHANNEL_MEDIA_RELAY_STATE.RELAY_STATE_IDLE; case a.ChannelMediaRelayState.RELAY_STATE_CONNECTING: return s.CHANNEL_MEDIA_RELAY_STATE.RELAY_STATE_CONNECTING; case a.ChannelMediaRelayState.RELAY_STATE_RUNNING: return s.CHANNEL_MEDIA_RELAY_STATE.RELAY_STATE_RUNNING; case a.ChannelMediaRelayState.RELAY_STATE_FAILURE: return s.CHANNEL_MEDIA_RELAY_STATE.RELAY_STATE_FAILURE } } static ChannelMediaRelayError2NATIVE_RTCCHANNEL_MEDIA_RELAY_ERROR(e) { switch (e) { case a.ChannelMediaRelayError.RELAY_OK: return s.CHANNEL_MEDIA_RELAY_ERROR.RELAY_OK; case a.ChannelMediaRelayError.SERVER_CONNECTION_LOST: return s.CHANNEL_MEDIA_RELAY_ERROR.RELAY_ERROR_SERVER_CONNECTION_LOST; case a.ChannelMediaRelayError.SRC_TOKEN_EXPIRED: return s.CHANNEL_MEDIA_RELAY_ERROR.RELAY_ERROR_SRC_TOKEN_EXPIRED; case a.ChannelMediaRelayError.DEST_TOKEN_EXPIRED: return s.CHANNEL_MEDIA_RELAY_ERROR.RELAY_ERROR_DEST_TOKEN_EXPIRED } } static ChannelMediaRelayEvent2NATIVE_RTCCHANNEL_MEDIA_RELAY_EVENT(e) { switch (e) { case a.ChannelMediaRelayEvent.NETWORK_DISCONNECTED: return s.CHANNEL_MEDIA_RELAY_EVENT.RELAY_EVENT_NETWORK_DISCONNECTED; case a.ChannelMediaRelayEvent.NETWORK_CONNECTED: return s.CHANNEL_MEDIA_RELAY_EVENT.RELAY_EVENT_NETWORK_CONNECTED; case a.ChannelMediaRelayEvent.PACKET_JOINED_SRC_CHANNEL: return s.CHANNEL_MEDIA_RELAY_EVENT.RELAY_EVENT_PACKET_JOINED_SRC_CHANNEL; case a.ChannelMediaRelayEvent.PACKET_JOINED_DEST_CHANNEL: return s.CHANNEL_MEDIA_RELAY_EVENT.RELAY_EVENT_PACKET_JOINED_DEST_CHANNEL; case a.ChannelMediaRelayEvent.PACKET_SENT_TO_DEST_CHANNEL: return s.CHANNEL_MEDIA_RELAY_EVENT.RELAY_EVENT_PACKET_SENT_TO_DEST_CHANNEL; case a.ChannelMediaRelayEvent.PACKET_RECEIVED_VIDEO_FROM_SRC: return s.CHANNEL_MEDIA_RELAY_EVENT.RELAY_EVENT_PACKET_RECEIVED_VIDEO_FROM_SRC; case a.ChannelMediaRelayEvent.PACKET_RECEIVED_AUDIO_FROM_SRC: return s.CHANNEL_MEDIA_RELAY_EVENT.RELAY_EVENT_PACKET_RECEIVED_AUDIO_FROM_SRC; case a.ChannelMediaRelayEvent.PACKET_UPDATE_DEST_CHANNEL: return s.CHANNEL_MEDIA_RELAY_EVENT.RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL; case a.ChannelMediaRelayEvent.PACKET_UPDATE_DEST_CHANNEL_REFUSED: return s.CHANNEL_MEDIA_RELAY_EVENT.RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_REFUSED; case a.ChannelMediaRelayEvent.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE: return s.CHANNEL_MEDIA_RELAY_EVENT.RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE } } static volumeIndicatorResult2NATIVE_RTCAudioVolumeInfo(e) { return { uid: e.uid, volume: Math.floor(2.55 * e.level), vad: 0, voicePitch: 0 } } static webQuality2NATIVE_RTCQuality(e) { return 6 - e } static data2NATIVE_RTC_CONNECT_INSPECT_RESULT(e) { switch (e) { case "porn": return s.CONTENT_INSPECT_RESULT.CONTENT_INSPECT_PORN; case "sexy": return s.CONTENT_INSPECT_RESULT.CONTENT_INSPECT_SEXY; case "neutral": return s.CONTENT_INSPECT_RESULT.CONTENT_INSPECT_NEUTRAL } } } t.AgoraTranslate = E }, 4144: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }), t.drawRGBABufferToCanvas = void 0; const s = o(n(5844)); t.drawRGBABufferToCanvas = (e, t, n, i, r) => { const o = r.getContext("2d"); if (r.width = e, r.height = t, i == s.VIDEO_PIXEL_FORMAT.VIDEO_PIXEL_BGRA) { for (var a = new Uint8ClampedArray(e * t * 4), c = 0; c < n[0].length; c += 4)a[c] = n[0][c + 2], a[c + 1] = n[0][c + 1], a[c + 2] = n[0][c], a[c + 3] = n[0][c + 3]; var E = new ImageData(a, e, t); o.putImageData(E, 0, 0) } else if (i == s.VIDEO_PIXEL_FORMAT.VIDEO_PIXEL_RGBA) { for (E = o.createImageData(e, t), c = 0; c < n[0].length; c++)E.data[c] = n[0][c]; o.putImageData(E, 0, 0) } } }, 4409: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i(t, e, n); return r(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }); const s = o(n(5844)), a = n(4482); t.default = class { constructor(e) { this._engine = e } notInitialized() { return a.AgoraConsole.error("not initialized"), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_NOT_INITIALIZED) } failed(e) { return a.AgoraConsole.error(e), this._engine.returnResult(!1, -s.ERROR_CODE_TYPE.ERR_FAILED) } } }, 2223: function (e, t, n) { "use strict"; var i = this && this.__createBinding || (Object.create ? function (e, t, n, i) { void 0 === i && (i = n); var r = Object.getOwnPropertyDescriptor(t, n); r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = { enumerable: !0, get: function () { return t[n] } }), Object.defineProperty(e, i, r) } : function (e, t, n, i) { void 0 === i && (i = n), e[i] = t[n] }), r = this && this.__exportStar || function (e, t) { for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || i(t, e, n) }; Object.defineProperty(t, "__esModule", { value: !0 }), r(n(4482), t), r(n(9261), t), r(n(1215), t) }
        }, t = {}; function n(i) { var r = t[i]; if (void 0 !== r) return r.exports; var o = t[i] = { exports: {} }; return e[i].call(o.exports, o, o.exports, n), o.exports } return n.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" == typeof window) return window } }(), n(5352)
    }()
}));